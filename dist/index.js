require('./sourcemap-register.js');/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 7657:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkLayouts = exports.STORAGE_WORD_SIZE = void 0;
const isEqual_1 = __importDefault(__nccwpck_require__(52));
const range_1 = __importDefault(__nccwpck_require__(9826));
const sortBy_1 = __importDefault(__nccwpck_require__(9774));
const uniqWith_1 = __importDefault(__nccwpck_require__(2854));
const solidity_1 = __nccwpck_require__(4516);
const types_1 = __nccwpck_require__(8164);
exports.STORAGE_WORD_SIZE = 32n;
const getStorageVariableBytesMapping = (layout, variable, startByte) => {
    const varType = layout.types[variable.type];
    let slot = 0n;
    let example = {};
    switch (varType.encoding) {
        case "dynamic_array":
            slot = BigInt((0, solidity_1.keccak256)(["uint256"], [variable.slot])); // slot of the element at index 0
            example = getStorageVariableBytesMapping(layout, {
                ...variable,
                slot,
                offset: 0n,
                type: varType.base,
                label: variable.label.replace("[]", "[0]"),
            }, slot * exports.STORAGE_WORD_SIZE);
            break;
        case "mapping":
            slot = BigInt((0, solidity_1.keccak256)(["uint256", "uint256"], [0, variable.slot])); // slot of the element at key 0
            example = getStorageVariableBytesMapping(layout, {
                ...variable,
                slot,
                offset: 0n,
                type: varType.value,
                label: `${variable.label}[0]`,
            }, slot * exports.STORAGE_WORD_SIZE);
            break;
        default:
            break;
    }
    const details = {
        ...variable,
        fullLabel: variable.parent
            ? `(${variable.parent.typeLabel} ${variable.parent.label}).${variable.label}`
            : variable.label,
        typeLabel: varType.label.replace(/struct /, ""),
        startByte,
    };
    if (!varType.members)
        return {
            ...example,
            ...Object.fromEntries((0, range_1.default)(Number(varType.numberOfBytes.toString())).map((byteIndex) => [
                startByte + BigInt(byteIndex),
                details,
            ])),
        };
    return varType.members.reduce((acc, member) => ({
        ...acc,
        ...getStorageVariableBytesMapping(layout, {
            ...member,
            parent: details,
            slot: details.slot + member.slot,
        }, startByte + member.slot * exports.STORAGE_WORD_SIZE + member.offset),
    }), {});
};
const getStorageBytesMapping = (layout) => layout.storage.reduce((acc, variable) => ({
    ...acc,
    ...getStorageVariableBytesMapping(layout, variable, variable.slot * exports.STORAGE_WORD_SIZE + variable.offset),
}), {});
const checkLayouts = async (srcLayout, cmpLayout, { address, provider, checkRemovals, } = {}) => {
    const diffs = [];
    const added = [];
    const srcMapping = getStorageBytesMapping(srcLayout);
    const cmpMapping = getStorageBytesMapping(cmpLayout);
    for (const byte of Object.keys(cmpMapping)) {
        const srcSlotVar = srcMapping[byte];
        const cmpSlotVar = cmpMapping[byte];
        const byteIndex = BigInt(byte);
        const location = {
            slot: byteIndex / exports.STORAGE_WORD_SIZE,
            offset: byteIndex % exports.STORAGE_WORD_SIZE,
        };
        if (!srcSlotVar) {
            added.push({
                location,
                cmp: cmpSlotVar,
            });
            continue; // source byte was unused
        }
        if (cmpSlotVar.type === srcSlotVar.type &&
            cmpSlotVar.fullLabel === srcSlotVar.fullLabel &&
            cmpSlotVar.slot === srcSlotVar.slot &&
            cmpSlotVar.offset === srcSlotVar.offset &&
            cmpSlotVar.startByte === srcSlotVar.startByte)
            continue; // variable did not change
        if (srcSlotVar.label === "__gap" || cmpSlotVar.label === "__gap") {
            added.push({
                location,
                cmp: cmpSlotVar,
            });
            continue; // source byte was part of a gap slot or is replaced with a gap slot
        }
        if (cmpSlotVar.fullLabel !== srcSlotVar.fullLabel) {
            if (cmpSlotVar.fullLabel.startsWith(`(${srcSlotVar.typeLabel} ${srcSlotVar.label})`)) {
                added.push({
                    location,
                    cmp: cmpSlotVar,
                });
                continue; // variable is a member of source struct, in empty bytes
            }
            if (cmpSlotVar.type === srcSlotVar.type) {
                if (cmpSlotVar.label !== srcSlotVar.label)
                    diffs.push({
                        location,
                        type: types_1.StorageLayoutDiffType.LABEL,
                        src: srcSlotVar,
                        cmp: cmpSlotVar,
                    });
                continue;
            }
            diffs.push({
                location,
                type: types_1.StorageLayoutDiffType.VARIABLE,
                src: srcSlotVar,
                cmp: cmpSlotVar,
            });
            continue;
        }
        if (cmpSlotVar.type !== srcSlotVar.type) {
            const cmpVarType = cmpLayout.types[cmpSlotVar.type];
            if ((cmpVarType.members?.length ?? 0) > 0)
                continue; // if the type has members, their corresponding bytes will be checked
            const srcVarType = srcLayout.types[srcSlotVar.type];
            if (cmpVarType.encoding === srcVarType.encoding) {
                if (cmpVarType.encoding === "mapping" && cmpVarType.key === srcVarType.key) {
                    const srcValueType = srcLayout.types[srcVarType.value];
                    const cmpValueType = cmpLayout.types[cmpVarType.value];
                    if (
                    // if the value isn't encoded "inplace", the canonic value bytes will be checked
                    (cmpValueType.encoding === srcValueType.encoding &&
                        cmpValueType.encoding !== "inplace") ||
                        (cmpValueType.members?.length ?? 0) > 0 // if the value has members, their corresponding bytes will be checked
                    )
                        continue;
                }
                else if (cmpVarType.encoding === "dynamic_array") {
                    const srcBaseType = srcLayout.types[srcVarType.base];
                    const cmpBaseType = cmpLayout.types[cmpVarType.base];
                    if (
                    // if the value isn't encoded "inplace", the canonic value bytes will be checked
                    (cmpBaseType.encoding === srcBaseType.encoding && cmpBaseType.encoding !== "inplace") ||
                        (cmpBaseType.members?.length ?? 0) > 0 // if the value has members, their corresponding bytes will be checked
                    )
                        continue;
                }
                else if ((srcSlotVar.type.startsWith("t_contract") || srcSlotVar.type === "t_address") &&
                    (cmpSlotVar.type.startsWith("t_contract") || cmpSlotVar.type === "t_address"))
                    continue; // source & target bytes are part of an address variable disguised as an interface
            }
            diffs.push({
                location,
                type: types_1.StorageLayoutDiffType.VARIABLE_TYPE,
                src: srcSlotVar,
                cmp: cmpSlotVar,
            });
            continue;
        }
    }
    if (checkRemovals) {
        for (const byte of Object.keys(srcMapping)) {
            const srcSlotVar = srcMapping[byte];
            const cmpSlotVar = cmpMapping[byte];
            const byteIndex = BigInt(byte);
            const location = {
                slot: byteIndex / exports.STORAGE_WORD_SIZE,
                offset: byteIndex % exports.STORAGE_WORD_SIZE,
            };
            if (!cmpSlotVar)
                diffs.push({
                    location,
                    type: types_1.StorageLayoutDiffType.VARIABLE_REMOVED,
                    src: srcSlotVar,
                });
        }
    }
    return (0, uniqWith_1.default)((0, sortBy_1.default)(diffs, ["location.slot", "location.offset"]), // make sure it's ordered by storage byte order
    ({ location: location1, ...diff1 }, { location: location2, ...diff2 }) => (0, isEqual_1.default)(diff1, diff2) // only keep first byte diff of a variable, which corresponds to the start byte
    ).concat(address && provider ? await checkAddedStorageSlots(added, address, provider) : []);
};
exports.checkLayouts = checkLayouts;
const checkAddedStorageSlots = async (added, address, provider) => {
    const storage = {};
    const diffs = [];
    for (const diff of (0, sortBy_1.default)(added, ["location.slot", "location.offset"])) {
        const slot = diff.location.slot.toString();
        const memoized = storage[slot];
        let value = memoized ?? (await provider.getStorageAt(address, slot));
        if (!memoized)
            storage[slot] = value;
        const byteIndex = value.length - Number((diff.location.offset + 1n) * 2n);
        value = value.substring(byteIndex, byteIndex + 2);
        if (value === "00")
            continue;
        diffs.push({
            ...diff,
            type: types_1.StorageLayoutDiffType.NON_ZERO_ADDED_SLOT,
            value,
        });
    }
    return (0, uniqWith_1.default)(diffs, ({ location: location1, value: value1, ...diff1 }, { location: location2, value: value2, ...diff2 }) => (0, isEqual_1.default)(diff1, diff2) // only keep first byte diff of a variable, which corresponds to the start byte
    );
};


/***/ }),

/***/ 6610:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatDiff = exports.diffTitles = exports.diffLevels = void 0;
const types_1 = __nccwpck_require__(8164);
exports.diffLevels = {
    [types_1.StorageLayoutDiffType.LABEL]: "warning",
    [types_1.StorageLayoutDiffType.VARIABLE_TYPE]: "error",
    [types_1.StorageLayoutDiffType.TYPE_REMOVED]: "warning",
    [types_1.StorageLayoutDiffType.TYPE_CHANGED]: "error",
    [types_1.StorageLayoutDiffType.VARIABLE]: "error",
};
exports.diffTitles = {
    [types_1.StorageLayoutDiffType.LABEL]: "Label diff",
    [types_1.StorageLayoutDiffType.VARIABLE_TYPE]: "Variable type diff",
    [types_1.StorageLayoutDiffType.TYPE_REMOVED]: "Type removal",
    [types_1.StorageLayoutDiffType.TYPE_CHANGED]: "Type diff",
    [types_1.StorageLayoutDiffType.VARIABLE]: "Variable diff",
};
const formatDiff = (cmpDef, diff) => {
    const location = (diff.parent
        ? `${diff.parent} slot #${diff.location.slot.toString(10)}`
        : `storage slot 0x${diff.location.slot.toString(16).padStart(64, "0")}`) +
        `, byte #${diff.location.offset.toString()}`;
    const loc = cmpDef.tokens.find((token) => token.type === "Identifier" && "cmp" in diff && token.value === diff.cmp.label)?.loc ?? {
        start: {
            line: 0,
            column: 0,
        },
        end: {
            line: 0,
            column: 0,
        },
    };
    const { type } = diff;
    switch (type) {
        case types_1.StorageLayoutDiffType.LABEL:
            return {
                loc,
                type,
                message: `variable "${diff.src.fullLabel}" was renamed to "${diff.cmp.fullLabel}". Is it intentional? (${location})`,
            };
        case types_1.StorageLayoutDiffType.VARIABLE_TYPE:
            return {
                loc,
                type,
                message: `variable "${diff.src.fullLabel}" was of type "${diff.src.typeLabel}" but is now "${diff.cmp.typeLabel}" (${location})`,
            };
        case types_1.StorageLayoutDiffType.VARIABLE_REMOVED:
            return {
                loc,
                type,
                message: `variable "${diff.src.fullLabel}" of type "${diff.src.typeLabel}" was removed (${location})`,
            };
        case types_1.StorageLayoutDiffType.TYPE_REMOVED:
            return {
                loc,
                type,
                message: `type "${diff.src.fullLabel}" was removed.`,
            };
        case types_1.StorageLayoutDiffType.TYPE_CHANGED:
            return {
                loc,
                type,
                message: `type "${diff.src.fullLabel}" was changed.`,
            };
        case types_1.StorageLayoutDiffType.VARIABLE:
            return {
                loc,
                type,
                message: `variable "${diff.src.fullLabel}" of type "${diff.src.typeLabel}" was replaced by variable "${diff.cmp.fullLabel}" of type "${diff.cmp.typeLabel}" (${location})`,
            };
        case types_1.StorageLayoutDiffType.NON_ZERO_ADDED_SLOT:
            return {
                loc,
                type,
                message: `variable "${diff.cmp.fullLabel}" of type "${diff.cmp.typeLabel}" was added at a non-zero storage byte (${location}: 0x${diff.value})`,
            };
        default:
            return {
                loc,
                type,
                message: `Storage layout diff`,
            };
    }
};
exports.formatDiff = formatDiff;


/***/ }),

/***/ 4822:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const adm_zip_1 = __importDefault(__nccwpck_require__(6761));
const fs = __importStar(__nccwpck_require__(7147));
const path_1 = __nccwpck_require__(1017);
const artifact = __importStar(__nccwpck_require__(2605));
const core = __importStar(__nccwpck_require__(2186));
const github_1 = __nccwpck_require__(5438);
const providers_1 = __nccwpck_require__(529);
const check_1 = __nccwpck_require__(7657);
const format_1 = __nccwpck_require__(6610);
const input_1 = __nccwpck_require__(8657);
const types_1 = __nccwpck_require__(8164);
const token = process.env.GITHUB_TOKEN || core.getInput("token");
const baseBranch = core.getInput("base");
const headBranch = core.getInput("head");
const contract = core.getInput("contract");
const address = core.getInput("address");
const rpcUrl = core.getInput("rpcUrl");
const failOnRemoval = core.getInput("failOnRemoval") === "true";
const workingDirectory = core.getInput("workingDirectory");
const contractEscaped = contract.replace(/\//g, "_").replace(/:/g, "-");
const getReportPath = (branch, baseName) => `${branch.replace(/[/\\]/g, "-")}.${baseName}.json`;
const baseReport = getReportPath(baseBranch, contractEscaped);
const outReport = getReportPath(headBranch, contractEscaped);
const octokit = (0, github_1.getOctokit)(token);
const artifactClient = artifact.create();
const { owner, repo } = github_1.context.repo;
const repository = owner + "/" + repo;
const provider = rpcUrl ? (0, providers_1.getDefaultProvider)(rpcUrl) : undefined;
let srcContent;
let refCommitHash;
async function run() {
    core.startGroup(`Generate storage layout of contract "${contract}" using foundry forge`);
    core.info(`Start forge process`);
    const cmpContent = (0, input_1.createLayout)(contract, workingDirectory);
    core.info(`Parse generated layout`);
    const cmpLayout = (0, input_1.parseLayout)(cmpContent);
    core.endGroup();
    try {
        const localReportPath = (0, path_1.resolve)(outReport);
        fs.writeFileSync(localReportPath, cmpContent);
        core.startGroup(`Upload new report from "${localReportPath}" as artifact named "${outReport}"`);
        const uploadResponse = await artifactClient.uploadArtifact(outReport, [localReportPath], (0, path_1.dirname)(localReportPath), { continueOnError: false });
        if (uploadResponse.failedItems.length > 0)
            throw Error("Failed to upload storage layout report.");
        core.info(`Artifact ${uploadResponse.artifactName} has been successfully uploaded!`);
    }
    catch (error) {
        return core.setFailed(error.message);
    }
    core.endGroup();
    // cannot use artifactClient because downloads are limited to uploads in the same workflow run
    // cf. https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts#downloading-or-deleting-artifacts
    let artifactId = null;
    if (github_1.context.eventName === "pull_request") {
        try {
            core.startGroup(`Searching artifact "${baseReport}" on repository "${repository}", on branch "${baseBranch}"`);
            // Note that the artifacts are returned in most recent first order.
            for await (const res of octokit.paginate.iterator(octokit.rest.actions.listArtifactsForRepo, {
                owner,
                repo,
            })) {
                const artifact = res.data.find((artifact) => !artifact.expired && artifact.name === baseReport);
                if (!artifact) {
                    await new Promise((resolve) => setTimeout(resolve, 800)); // avoid reaching the API rate limit
                    continue;
                }
                artifactId = artifact.id;
                refCommitHash = artifact.workflow_run?.head_sha;
                core.info(`Found artifact named "${baseReport}" with ID "${artifactId}" from commit "${refCommitHash}"`);
                break;
            }
            core.endGroup();
            if (artifactId) {
                core.startGroup(`Downloading artifact "${baseReport}" of repository "${repository}" with ID "${artifactId}"`);
                const res = await octokit.rest.actions.downloadArtifact({
                    owner,
                    repo,
                    artifact_id: artifactId,
                    archive_format: "zip",
                });
                // @ts-ignore data is unknown
                const zip = new adm_zip_1.default(Buffer.from(res.data));
                for (const entry of zip.getEntries()) {
                    core.info(`Loading storage layout report from "${entry.entryName}"`);
                    srcContent = zip.readAsText(entry);
                }
                core.endGroup();
            }
            else
                core.error(`No workflow run found with an artifact named "${baseReport}"`);
        }
        catch (error) {
            return core.setFailed(error.message);
        }
    }
    try {
        core.startGroup("Load storage layout reports");
        srcContent ??= cmpContent; // if no source storage layout report were loaded, defaults to the current storage layout report
        core.info(`Mapping reference storage layout report`);
        const srcLayout = (0, input_1.parseLayout)(srcContent);
        core.endGroup();
        core.startGroup("Check storage layout");
        const diffs = await (0, check_1.checkLayouts)(srcLayout, cmpLayout, {
            address,
            provider,
            checkRemovals: failOnRemoval,
        });
        if (diffs.length > 0) {
            core.info(`Parse source code`);
            const cmpDef = (0, input_1.parseSource)(contract);
            const formattedDiffs = diffs.map((diff) => {
                const formattedDiff = (0, format_1.formatDiff)(cmpDef, diff);
                const title = format_1.diffTitles[formattedDiff.type];
                const level = format_1.diffLevels[formattedDiff.type] || "error";
                core[level](formattedDiff.message, {
                    title,
                    file: cmpDef.path,
                    startLine: formattedDiff.loc.start.line,
                    endLine: formattedDiff.loc.end.line,
                    startColumn: formattedDiff.loc.start.column,
                    endColumn: formattedDiff.loc.end.column,
                });
                return formattedDiff;
            });
            if (formattedDiffs.filter((diff) => format_1.diffLevels[diff.type] === "error").length > 0 ||
                (failOnRemoval &&
                    formattedDiffs.filter((diff) => diff.type === types_1.StorageLayoutDiffType.VARIABLE_REMOVED)
                        .length > 0))
                return core.setFailed("Unsafe storage layout changes detected. Please see above for details.");
        }
        core.endGroup();
    }
    catch (error) {
        core.setFailed(error.message);
    }
}
run();


/***/ }),

/***/ 8657:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseSource = exports.parseLayout = exports.createLayout = void 0;
const child_process_1 = __nccwpck_require__(2081);
const fs_1 = __importDefault(__nccwpck_require__(7147));
const parser = __importStar(__nccwpck_require__(4834));
const exactify = (variable) => ({
    ...variable,
    slot: BigInt(variable.slot),
    offset: BigInt(variable.offset),
});
const createLayout = (contract, cwd) => {
    return (0, child_process_1.execSync)(`forge inspect ${contract} storage-layout`, {
        encoding: "utf-8",
        cwd,
    });
};
exports.createLayout = createLayout;
const parseLayout = (content) => {
    try {
        const layout = JSON.parse(content);
        return {
            storage: layout.storage.map(exactify),
            types: Object.fromEntries(Object.entries(layout.types).map(([name, type]) => [
                name,
                {
                    ...type,
                    members: type.members?.map(exactify),
                    numberOfBytes: BigInt(type.numberOfBytes),
                },
            ])),
        };
    }
    catch (error) {
        console.error("Error while parsing storage layout:", content);
        throw error;
    }
};
exports.parseLayout = parseLayout;
const parseSource = (contract) => {
    const [path, contractName] = contract.split(":");
    const { children, tokens = [] } = parser.parse(fs_1.default.readFileSync(path, { encoding: "utf-8" }), {
        tolerant: true,
        tokens: true,
        loc: true,
    });
    const def = children.find((child) => child.type === "ContractDefinition" && child.name === contractName);
    if (!def)
        throw Error(`Contract definition not found: ${contractName}`);
    return { path, def, tokens };
};
exports.parseSource = parseSource;


/***/ }),

/***/ 8164:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StorageLayoutDiffType = void 0;
var StorageLayoutDiffType;
(function (StorageLayoutDiffType) {
    StorageLayoutDiffType["LABEL"] = "LABEL";
    StorageLayoutDiffType["TYPE_REMOVED"] = "TYPE_REMOVED";
    StorageLayoutDiffType["TYPE_CHANGED"] = "TYPE_CHANGED";
    StorageLayoutDiffType["VARIABLE"] = "VARIABLE";
    StorageLayoutDiffType["VARIABLE_TYPE"] = "VARIABLE_TYPE";
    StorageLayoutDiffType["VARIABLE_REMOVED"] = "VARIABLE_REMOVED";
    StorageLayoutDiffType["NON_ZERO_ADDED_SLOT"] = "NON_ZERO_ADDED_SLOT";
})(StorageLayoutDiffType = exports.StorageLayoutDiffType || (exports.StorageLayoutDiffType = {}));


/***/ }),

/***/ 2605:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.create = void 0;
const artifact_client_1 = __nccwpck_require__(8802);
/**
 * Constructs an ArtifactClient
 */
function create() {
    return artifact_client_1.DefaultArtifactClient.create();
}
exports.create = create;
//# sourceMappingURL=artifact-client.js.map

/***/ }),

/***/ 8802:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultArtifactClient = void 0;
const core = __importStar(__nccwpck_require__(2186));
const upload_specification_1 = __nccwpck_require__(183);
const upload_http_client_1 = __nccwpck_require__(4354);
const utils_1 = __nccwpck_require__(6327);
const path_and_artifact_name_validation_1 = __nccwpck_require__(7398);
const download_http_client_1 = __nccwpck_require__(8538);
const download_specification_1 = __nccwpck_require__(5686);
const config_variables_1 = __nccwpck_require__(2222);
const path_1 = __nccwpck_require__(1017);
class DefaultArtifactClient {
    /**
     * Constructs a DefaultArtifactClient
     */
    static create() {
        return new DefaultArtifactClient();
    }
    /**
     * Uploads an artifact
     */
    uploadArtifact(name, files, rootDirectory, options) {
        return __awaiter(this, void 0, void 0, function* () {
            core.info(`Starting artifact upload
For more detailed logs during the artifact upload process, enable step-debugging: https://docs.github.com/actions/monitoring-and-troubleshooting-workflows/enabling-debug-logging#enabling-step-debug-logging`);
            path_and_artifact_name_validation_1.checkArtifactName(name);
            // Get specification for the files being uploaded
            const uploadSpecification = upload_specification_1.getUploadSpecification(name, rootDirectory, files);
            const uploadResponse = {
                artifactName: name,
                artifactItems: [],
                size: 0,
                failedItems: []
            };
            const uploadHttpClient = new upload_http_client_1.UploadHttpClient();
            if (uploadSpecification.length === 0) {
                core.warning(`No files found that can be uploaded`);
            }
            else {
                // Create an entry for the artifact in the file container
                const response = yield uploadHttpClient.createArtifactInFileContainer(name, options);
                if (!response.fileContainerResourceUrl) {
                    core.debug(response.toString());
                    throw new Error('No URL provided by the Artifact Service to upload an artifact to');
                }
                core.debug(`Upload Resource URL: ${response.fileContainerResourceUrl}`);
                core.info(`Container for artifact "${name}" successfully created. Starting upload of file(s)`);
                // Upload each of the files that were found concurrently
                const uploadResult = yield uploadHttpClient.uploadArtifactToFileContainer(response.fileContainerResourceUrl, uploadSpecification, options);
                // Update the size of the artifact to indicate we are done uploading
                // The uncompressed size is used for display when downloading a zip of the artifact from the UI
                core.info(`File upload process has finished. Finalizing the artifact upload`);
                yield uploadHttpClient.patchArtifactSize(uploadResult.totalSize, name);
                if (uploadResult.failedItems.length > 0) {
                    core.info(`Upload finished. There were ${uploadResult.failedItems.length} items that failed to upload`);
                }
                else {
                    core.info(`Artifact has been finalized. All files have been successfully uploaded!`);
                }
                core.info(`
The raw size of all the files that were specified for upload is ${uploadResult.totalSize} bytes
The size of all the files that were uploaded is ${uploadResult.uploadSize} bytes. This takes into account any gzip compression used to reduce the upload size, time and storage

Note: The size of downloaded zips can differ significantly from the reported size. For more information see: https://github.com/actions/upload-artifact#zipped-artifact-downloads \r\n`);
                uploadResponse.artifactItems = uploadSpecification.map(item => item.absoluteFilePath);
                uploadResponse.size = uploadResult.uploadSize;
                uploadResponse.failedItems = uploadResult.failedItems;
            }
            return uploadResponse;
        });
    }
    downloadArtifact(name, path, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const downloadHttpClient = new download_http_client_1.DownloadHttpClient();
            const artifacts = yield downloadHttpClient.listArtifacts();
            if (artifacts.count === 0) {
                throw new Error(`Unable to find any artifacts for the associated workflow`);
            }
            const artifactToDownload = artifacts.value.find(artifact => {
                return artifact.name === name;
            });
            if (!artifactToDownload) {
                throw new Error(`Unable to find an artifact with the name: ${name}`);
            }
            const items = yield downloadHttpClient.getContainerItems(artifactToDownload.name, artifactToDownload.fileContainerResourceUrl);
            if (!path) {
                path = config_variables_1.getWorkSpaceDirectory();
            }
            path = path_1.normalize(path);
            path = path_1.resolve(path);
            // During upload, empty directories are rejected by the remote server so there should be no artifacts that consist of only empty directories
            const downloadSpecification = download_specification_1.getDownloadSpecification(name, items.value, path, (options === null || options === void 0 ? void 0 : options.createArtifactFolder) || false);
            if (downloadSpecification.filesToDownload.length === 0) {
                core.info(`No downloadable files were found for the artifact: ${artifactToDownload.name}`);
            }
            else {
                // Create all necessary directories recursively before starting any download
                yield utils_1.createDirectoriesForArtifact(downloadSpecification.directoryStructure);
                core.info('Directory structure has been setup for the artifact');
                yield utils_1.createEmptyFilesForArtifact(downloadSpecification.emptyFilesToCreate);
                yield downloadHttpClient.downloadSingleArtifact(downloadSpecification.filesToDownload);
            }
            return {
                artifactName: name,
                downloadPath: downloadSpecification.rootDownloadLocation
            };
        });
    }
    downloadAllArtifacts(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const downloadHttpClient = new download_http_client_1.DownloadHttpClient();
            const response = [];
            const artifacts = yield downloadHttpClient.listArtifacts();
            if (artifacts.count === 0) {
                core.info('Unable to find any artifacts for the associated workflow');
                return response;
            }
            if (!path) {
                path = config_variables_1.getWorkSpaceDirectory();
            }
            path = path_1.normalize(path);
            path = path_1.resolve(path);
            let downloadedArtifacts = 0;
            while (downloadedArtifacts < artifacts.count) {
                const currentArtifactToDownload = artifacts.value[downloadedArtifacts];
                downloadedArtifacts += 1;
                core.info(`starting download of artifact ${currentArtifactToDownload.name} : ${downloadedArtifacts}/${artifacts.count}`);
                // Get container entries for the specific artifact
                const items = yield downloadHttpClient.getContainerItems(currentArtifactToDownload.name, currentArtifactToDownload.fileContainerResourceUrl);
                const downloadSpecification = download_specification_1.getDownloadSpecification(currentArtifactToDownload.name, items.value, path, true);
                if (downloadSpecification.filesToDownload.length === 0) {
                    core.info(`No downloadable files were found for any artifact ${currentArtifactToDownload.name}`);
                }
                else {
                    yield utils_1.createDirectoriesForArtifact(downloadSpecification.directoryStructure);
                    yield utils_1.createEmptyFilesForArtifact(downloadSpecification.emptyFilesToCreate);
                    yield downloadHttpClient.downloadSingleArtifact(downloadSpecification.filesToDownload);
                }
                response.push({
                    artifactName: currentArtifactToDownload.name,
                    downloadPath: downloadSpecification.rootDownloadLocation
                });
            }
            return response;
        });
    }
}
exports.DefaultArtifactClient = DefaultArtifactClient;
//# sourceMappingURL=artifact-client.js.map

/***/ }),

/***/ 2222:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRetentionDays = exports.getWorkSpaceDirectory = exports.getWorkFlowRunId = exports.getRuntimeUrl = exports.getRuntimeToken = exports.getDownloadFileConcurrency = exports.getInitialRetryIntervalInMilliseconds = exports.getRetryMultiplier = exports.getRetryLimit = exports.getUploadChunkSize = exports.getUploadFileConcurrency = void 0;
// The number of concurrent uploads that happens at the same time
function getUploadFileConcurrency() {
    return 2;
}
exports.getUploadFileConcurrency = getUploadFileConcurrency;
// When uploading large files that can't be uploaded with a single http call, this controls
// the chunk size that is used during upload
function getUploadChunkSize() {
    return 8 * 1024 * 1024; // 8 MB Chunks
}
exports.getUploadChunkSize = getUploadChunkSize;
// The maximum number of retries that can be attempted before an upload or download fails
function getRetryLimit() {
    return 5;
}
exports.getRetryLimit = getRetryLimit;
// With exponential backoff, the larger the retry count, the larger the wait time before another attempt
// The retry multiplier controls by how much the backOff time increases depending on the number of retries
function getRetryMultiplier() {
    return 1.5;
}
exports.getRetryMultiplier = getRetryMultiplier;
// The initial wait time if an upload or download fails and a retry is being attempted for the first time
function getInitialRetryIntervalInMilliseconds() {
    return 3000;
}
exports.getInitialRetryIntervalInMilliseconds = getInitialRetryIntervalInMilliseconds;
// The number of concurrent downloads that happens at the same time
function getDownloadFileConcurrency() {
    return 2;
}
exports.getDownloadFileConcurrency = getDownloadFileConcurrency;
function getRuntimeToken() {
    const token = process.env['ACTIONS_RUNTIME_TOKEN'];
    if (!token) {
        throw new Error('Unable to get ACTIONS_RUNTIME_TOKEN env variable');
    }
    return token;
}
exports.getRuntimeToken = getRuntimeToken;
function getRuntimeUrl() {
    const runtimeUrl = process.env['ACTIONS_RUNTIME_URL'];
    if (!runtimeUrl) {
        throw new Error('Unable to get ACTIONS_RUNTIME_URL env variable');
    }
    return runtimeUrl;
}
exports.getRuntimeUrl = getRuntimeUrl;
function getWorkFlowRunId() {
    const workFlowRunId = process.env['GITHUB_RUN_ID'];
    if (!workFlowRunId) {
        throw new Error('Unable to get GITHUB_RUN_ID env variable');
    }
    return workFlowRunId;
}
exports.getWorkFlowRunId = getWorkFlowRunId;
function getWorkSpaceDirectory() {
    const workspaceDirectory = process.env['GITHUB_WORKSPACE'];
    if (!workspaceDirectory) {
        throw new Error('Unable to get GITHUB_WORKSPACE env variable');
    }
    return workspaceDirectory;
}
exports.getWorkSpaceDirectory = getWorkSpaceDirectory;
function getRetentionDays() {
    return process.env['GITHUB_RETENTION_DAYS'];
}
exports.getRetentionDays = getRetentionDays;
//# sourceMappingURL=config-variables.js.map

/***/ }),

/***/ 3549:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * CRC64: cyclic redundancy check, 64-bits
 *
 * In order to validate that artifacts are not being corrupted over the wire, this redundancy check allows us to
 * validate that there was no corruption during transmission. The implementation here is based on Go's hash/crc64 pkg,
 * but without the slicing-by-8 optimization: https://cs.opensource.google/go/go/+/master:src/hash/crc64/crc64.go
 *
 * This implementation uses a pregenerated table based on 0x9A6C9329AC4BC9B5 as the polynomial, the same polynomial that
 * is used for Azure Storage: https://github.com/Azure/azure-storage-net/blob/cbe605f9faa01bfc3003d75fc5a16b2eaccfe102/Lib/Common/Core/Util/Crc64.cs#L27
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
// when transpile target is >= ES2020 (after dropping node 12) these can be changed to bigint literals - ts(2737)
const PREGEN_POLY_TABLE = [
    BigInt('0x0000000000000000'),
    BigInt('0x7F6EF0C830358979'),
    BigInt('0xFEDDE190606B12F2'),
    BigInt('0x81B31158505E9B8B'),
    BigInt('0xC962E5739841B68F'),
    BigInt('0xB60C15BBA8743FF6'),
    BigInt('0x37BF04E3F82AA47D'),
    BigInt('0x48D1F42BC81F2D04'),
    BigInt('0xA61CECB46814FE75'),
    BigInt('0xD9721C7C5821770C'),
    BigInt('0x58C10D24087FEC87'),
    BigInt('0x27AFFDEC384A65FE'),
    BigInt('0x6F7E09C7F05548FA'),
    BigInt('0x1010F90FC060C183'),
    BigInt('0x91A3E857903E5A08'),
    BigInt('0xEECD189FA00BD371'),
    BigInt('0x78E0FF3B88BE6F81'),
    BigInt('0x078E0FF3B88BE6F8'),
    BigInt('0x863D1EABE8D57D73'),
    BigInt('0xF953EE63D8E0F40A'),
    BigInt('0xB1821A4810FFD90E'),
    BigInt('0xCEECEA8020CA5077'),
    BigInt('0x4F5FFBD87094CBFC'),
    BigInt('0x30310B1040A14285'),
    BigInt('0xDEFC138FE0AA91F4'),
    BigInt('0xA192E347D09F188D'),
    BigInt('0x2021F21F80C18306'),
    BigInt('0x5F4F02D7B0F40A7F'),
    BigInt('0x179EF6FC78EB277B'),
    BigInt('0x68F0063448DEAE02'),
    BigInt('0xE943176C18803589'),
    BigInt('0x962DE7A428B5BCF0'),
    BigInt('0xF1C1FE77117CDF02'),
    BigInt('0x8EAF0EBF2149567B'),
    BigInt('0x0F1C1FE77117CDF0'),
    BigInt('0x7072EF2F41224489'),
    BigInt('0x38A31B04893D698D'),
    BigInt('0x47CDEBCCB908E0F4'),
    BigInt('0xC67EFA94E9567B7F'),
    BigInt('0xB9100A5CD963F206'),
    BigInt('0x57DD12C379682177'),
    BigInt('0x28B3E20B495DA80E'),
    BigInt('0xA900F35319033385'),
    BigInt('0xD66E039B2936BAFC'),
    BigInt('0x9EBFF7B0E12997F8'),
    BigInt('0xE1D10778D11C1E81'),
    BigInt('0x606216208142850A'),
    BigInt('0x1F0CE6E8B1770C73'),
    BigInt('0x8921014C99C2B083'),
    BigInt('0xF64FF184A9F739FA'),
    BigInt('0x77FCE0DCF9A9A271'),
    BigInt('0x08921014C99C2B08'),
    BigInt('0x4043E43F0183060C'),
    BigInt('0x3F2D14F731B68F75'),
    BigInt('0xBE9E05AF61E814FE'),
    BigInt('0xC1F0F56751DD9D87'),
    BigInt('0x2F3DEDF8F1D64EF6'),
    BigInt('0x50531D30C1E3C78F'),
    BigInt('0xD1E00C6891BD5C04'),
    BigInt('0xAE8EFCA0A188D57D'),
    BigInt('0xE65F088B6997F879'),
    BigInt('0x9931F84359A27100'),
    BigInt('0x1882E91B09FCEA8B'),
    BigInt('0x67EC19D339C963F2'),
    BigInt('0xD75ADABD7A6E2D6F'),
    BigInt('0xA8342A754A5BA416'),
    BigInt('0x29873B2D1A053F9D'),
    BigInt('0x56E9CBE52A30B6E4'),
    BigInt('0x1E383FCEE22F9BE0'),
    BigInt('0x6156CF06D21A1299'),
    BigInt('0xE0E5DE5E82448912'),
    BigInt('0x9F8B2E96B271006B'),
    BigInt('0x71463609127AD31A'),
    BigInt('0x0E28C6C1224F5A63'),
    BigInt('0x8F9BD7997211C1E8'),
    BigInt('0xF0F5275142244891'),
    BigInt('0xB824D37A8A3B6595'),
    BigInt('0xC74A23B2BA0EECEC'),
    BigInt('0x46F932EAEA507767'),
    BigInt('0x3997C222DA65FE1E'),
    BigInt('0xAFBA2586F2D042EE'),
    BigInt('0xD0D4D54EC2E5CB97'),
    BigInt('0x5167C41692BB501C'),
    BigInt('0x2E0934DEA28ED965'),
    BigInt('0x66D8C0F56A91F461'),
    BigInt('0x19B6303D5AA47D18'),
    BigInt('0x980521650AFAE693'),
    BigInt('0xE76BD1AD3ACF6FEA'),
    BigInt('0x09A6C9329AC4BC9B'),
    BigInt('0x76C839FAAAF135E2'),
    BigInt('0xF77B28A2FAAFAE69'),
    BigInt('0x8815D86ACA9A2710'),
    BigInt('0xC0C42C4102850A14'),
    BigInt('0xBFAADC8932B0836D'),
    BigInt('0x3E19CDD162EE18E6'),
    BigInt('0x41773D1952DB919F'),
    BigInt('0x269B24CA6B12F26D'),
    BigInt('0x59F5D4025B277B14'),
    BigInt('0xD846C55A0B79E09F'),
    BigInt('0xA72835923B4C69E6'),
    BigInt('0xEFF9C1B9F35344E2'),
    BigInt('0x90973171C366CD9B'),
    BigInt('0x1124202993385610'),
    BigInt('0x6E4AD0E1A30DDF69'),
    BigInt('0x8087C87E03060C18'),
    BigInt('0xFFE938B633338561'),
    BigInt('0x7E5A29EE636D1EEA'),
    BigInt('0x0134D92653589793'),
    BigInt('0x49E52D0D9B47BA97'),
    BigInt('0x368BDDC5AB7233EE'),
    BigInt('0xB738CC9DFB2CA865'),
    BigInt('0xC8563C55CB19211C'),
    BigInt('0x5E7BDBF1E3AC9DEC'),
    BigInt('0x21152B39D3991495'),
    BigInt('0xA0A63A6183C78F1E'),
    BigInt('0xDFC8CAA9B3F20667'),
    BigInt('0x97193E827BED2B63'),
    BigInt('0xE877CE4A4BD8A21A'),
    BigInt('0x69C4DF121B863991'),
    BigInt('0x16AA2FDA2BB3B0E8'),
    BigInt('0xF86737458BB86399'),
    BigInt('0x8709C78DBB8DEAE0'),
    BigInt('0x06BAD6D5EBD3716B'),
    BigInt('0x79D4261DDBE6F812'),
    BigInt('0x3105D23613F9D516'),
    BigInt('0x4E6B22FE23CC5C6F'),
    BigInt('0xCFD833A67392C7E4'),
    BigInt('0xB0B6C36E43A74E9D'),
    BigInt('0x9A6C9329AC4BC9B5'),
    BigInt('0xE50263E19C7E40CC'),
    BigInt('0x64B172B9CC20DB47'),
    BigInt('0x1BDF8271FC15523E'),
    BigInt('0x530E765A340A7F3A'),
    BigInt('0x2C608692043FF643'),
    BigInt('0xADD397CA54616DC8'),
    BigInt('0xD2BD67026454E4B1'),
    BigInt('0x3C707F9DC45F37C0'),
    BigInt('0x431E8F55F46ABEB9'),
    BigInt('0xC2AD9E0DA4342532'),
    BigInt('0xBDC36EC59401AC4B'),
    BigInt('0xF5129AEE5C1E814F'),
    BigInt('0x8A7C6A266C2B0836'),
    BigInt('0x0BCF7B7E3C7593BD'),
    BigInt('0x74A18BB60C401AC4'),
    BigInt('0xE28C6C1224F5A634'),
    BigInt('0x9DE29CDA14C02F4D'),
    BigInt('0x1C518D82449EB4C6'),
    BigInt('0x633F7D4A74AB3DBF'),
    BigInt('0x2BEE8961BCB410BB'),
    BigInt('0x548079A98C8199C2'),
    BigInt('0xD53368F1DCDF0249'),
    BigInt('0xAA5D9839ECEA8B30'),
    BigInt('0x449080A64CE15841'),
    BigInt('0x3BFE706E7CD4D138'),
    BigInt('0xBA4D61362C8A4AB3'),
    BigInt('0xC52391FE1CBFC3CA'),
    BigInt('0x8DF265D5D4A0EECE'),
    BigInt('0xF29C951DE49567B7'),
    BigInt('0x732F8445B4CBFC3C'),
    BigInt('0x0C41748D84FE7545'),
    BigInt('0x6BAD6D5EBD3716B7'),
    BigInt('0x14C39D968D029FCE'),
    BigInt('0x95708CCEDD5C0445'),
    BigInt('0xEA1E7C06ED698D3C'),
    BigInt('0xA2CF882D2576A038'),
    BigInt('0xDDA178E515432941'),
    BigInt('0x5C1269BD451DB2CA'),
    BigInt('0x237C997575283BB3'),
    BigInt('0xCDB181EAD523E8C2'),
    BigInt('0xB2DF7122E51661BB'),
    BigInt('0x336C607AB548FA30'),
    BigInt('0x4C0290B2857D7349'),
    BigInt('0x04D364994D625E4D'),
    BigInt('0x7BBD94517D57D734'),
    BigInt('0xFA0E85092D094CBF'),
    BigInt('0x856075C11D3CC5C6'),
    BigInt('0x134D926535897936'),
    BigInt('0x6C2362AD05BCF04F'),
    BigInt('0xED9073F555E26BC4'),
    BigInt('0x92FE833D65D7E2BD'),
    BigInt('0xDA2F7716ADC8CFB9'),
    BigInt('0xA54187DE9DFD46C0'),
    BigInt('0x24F29686CDA3DD4B'),
    BigInt('0x5B9C664EFD965432'),
    BigInt('0xB5517ED15D9D8743'),
    BigInt('0xCA3F8E196DA80E3A'),
    BigInt('0x4B8C9F413DF695B1'),
    BigInt('0x34E26F890DC31CC8'),
    BigInt('0x7C339BA2C5DC31CC'),
    BigInt('0x035D6B6AF5E9B8B5'),
    BigInt('0x82EE7A32A5B7233E'),
    BigInt('0xFD808AFA9582AA47'),
    BigInt('0x4D364994D625E4DA'),
    BigInt('0x3258B95CE6106DA3'),
    BigInt('0xB3EBA804B64EF628'),
    BigInt('0xCC8558CC867B7F51'),
    BigInt('0x8454ACE74E645255'),
    BigInt('0xFB3A5C2F7E51DB2C'),
    BigInt('0x7A894D772E0F40A7'),
    BigInt('0x05E7BDBF1E3AC9DE'),
    BigInt('0xEB2AA520BE311AAF'),
    BigInt('0x944455E88E0493D6'),
    BigInt('0x15F744B0DE5A085D'),
    BigInt('0x6A99B478EE6F8124'),
    BigInt('0x224840532670AC20'),
    BigInt('0x5D26B09B16452559'),
    BigInt('0xDC95A1C3461BBED2'),
    BigInt('0xA3FB510B762E37AB'),
    BigInt('0x35D6B6AF5E9B8B5B'),
    BigInt('0x4AB846676EAE0222'),
    BigInt('0xCB0B573F3EF099A9'),
    BigInt('0xB465A7F70EC510D0'),
    BigInt('0xFCB453DCC6DA3DD4'),
    BigInt('0x83DAA314F6EFB4AD'),
    BigInt('0x0269B24CA6B12F26'),
    BigInt('0x7D0742849684A65F'),
    BigInt('0x93CA5A1B368F752E'),
    BigInt('0xECA4AAD306BAFC57'),
    BigInt('0x6D17BB8B56E467DC'),
    BigInt('0x12794B4366D1EEA5'),
    BigInt('0x5AA8BF68AECEC3A1'),
    BigInt('0x25C64FA09EFB4AD8'),
    BigInt('0xA4755EF8CEA5D153'),
    BigInt('0xDB1BAE30FE90582A'),
    BigInt('0xBCF7B7E3C7593BD8'),
    BigInt('0xC399472BF76CB2A1'),
    BigInt('0x422A5673A732292A'),
    BigInt('0x3D44A6BB9707A053'),
    BigInt('0x759552905F188D57'),
    BigInt('0x0AFBA2586F2D042E'),
    BigInt('0x8B48B3003F739FA5'),
    BigInt('0xF42643C80F4616DC'),
    BigInt('0x1AEB5B57AF4DC5AD'),
    BigInt('0x6585AB9F9F784CD4'),
    BigInt('0xE436BAC7CF26D75F'),
    BigInt('0x9B584A0FFF135E26'),
    BigInt('0xD389BE24370C7322'),
    BigInt('0xACE74EEC0739FA5B'),
    BigInt('0x2D545FB4576761D0'),
    BigInt('0x523AAF7C6752E8A9'),
    BigInt('0xC41748D84FE75459'),
    BigInt('0xBB79B8107FD2DD20'),
    BigInt('0x3ACAA9482F8C46AB'),
    BigInt('0x45A459801FB9CFD2'),
    BigInt('0x0D75ADABD7A6E2D6'),
    BigInt('0x721B5D63E7936BAF'),
    BigInt('0xF3A84C3BB7CDF024'),
    BigInt('0x8CC6BCF387F8795D'),
    BigInt('0x620BA46C27F3AA2C'),
    BigInt('0x1D6554A417C62355'),
    BigInt('0x9CD645FC4798B8DE'),
    BigInt('0xE3B8B53477AD31A7'),
    BigInt('0xAB69411FBFB21CA3'),
    BigInt('0xD407B1D78F8795DA'),
    BigInt('0x55B4A08FDFD90E51'),
    BigInt('0x2ADA5047EFEC8728')
];
class CRC64 {
    constructor() {
        this._crc = BigInt(0);
    }
    update(data) {
        const buffer = typeof data === 'string' ? Buffer.from(data) : data;
        let crc = CRC64.flip64Bits(this._crc);
        for (const dataByte of buffer) {
            const crcByte = Number(crc & BigInt(0xff));
            crc = PREGEN_POLY_TABLE[crcByte ^ dataByte] ^ (crc >> BigInt(8));
        }
        this._crc = CRC64.flip64Bits(crc);
    }
    digest(encoding) {
        switch (encoding) {
            case 'hex':
                return this._crc.toString(16).toUpperCase();
            case 'base64':
                return this.toBuffer().toString('base64');
            default:
                return this.toBuffer();
        }
    }
    toBuffer() {
        return Buffer.from([0, 8, 16, 24, 32, 40, 48, 56].map(s => Number((this._crc >> BigInt(s)) & BigInt(0xff))));
    }
    static flip64Bits(n) {
        return (BigInt(1) << BigInt(64)) - BigInt(1) - n;
    }
}
exports["default"] = CRC64;
//# sourceMappingURL=crc64.js.map

/***/ }),

/***/ 8538:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DownloadHttpClient = void 0;
const fs = __importStar(__nccwpck_require__(7147));
const core = __importStar(__nccwpck_require__(2186));
const zlib = __importStar(__nccwpck_require__(9796));
const utils_1 = __nccwpck_require__(6327);
const url_1 = __nccwpck_require__(7310);
const status_reporter_1 = __nccwpck_require__(9081);
const perf_hooks_1 = __nccwpck_require__(4074);
const http_manager_1 = __nccwpck_require__(6527);
const config_variables_1 = __nccwpck_require__(2222);
const requestUtils_1 = __nccwpck_require__(755);
class DownloadHttpClient {
    constructor() {
        this.downloadHttpManager = new http_manager_1.HttpManager(config_variables_1.getDownloadFileConcurrency(), '@actions/artifact-download');
        // downloads are usually significantly faster than uploads so display status information every second
        this.statusReporter = new status_reporter_1.StatusReporter(1000);
    }
    /**
     * Gets a list of all artifacts that are in a specific container
     */
    listArtifacts() {
        return __awaiter(this, void 0, void 0, function* () {
            const artifactUrl = utils_1.getArtifactUrl();
            // use the first client from the httpManager, `keep-alive` is not used so the connection will close immediately
            const client = this.downloadHttpManager.getClient(0);
            const headers = utils_1.getDownloadHeaders('application/json');
            const response = yield requestUtils_1.retryHttpClientRequest('List Artifacts', () => __awaiter(this, void 0, void 0, function* () { return client.get(artifactUrl, headers); }));
            const body = yield response.readBody();
            return JSON.parse(body);
        });
    }
    /**
     * Fetches a set of container items that describe the contents of an artifact
     * @param artifactName the name of the artifact
     * @param containerUrl the artifact container URL for the run
     */
    getContainerItems(artifactName, containerUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            // the itemPath search parameter controls which containers will be returned
            const resourceUrl = new url_1.URL(containerUrl);
            resourceUrl.searchParams.append('itemPath', artifactName);
            // use the first client from the httpManager, `keep-alive` is not used so the connection will close immediately
            const client = this.downloadHttpManager.getClient(0);
            const headers = utils_1.getDownloadHeaders('application/json');
            const response = yield requestUtils_1.retryHttpClientRequest('Get Container Items', () => __awaiter(this, void 0, void 0, function* () { return client.get(resourceUrl.toString(), headers); }));
            const body = yield response.readBody();
            return JSON.parse(body);
        });
    }
    /**
     * Concurrently downloads all the files that are part of an artifact
     * @param downloadItems information about what items to download and where to save them
     */
    downloadSingleArtifact(downloadItems) {
        return __awaiter(this, void 0, void 0, function* () {
            const DOWNLOAD_CONCURRENCY = config_variables_1.getDownloadFileConcurrency();
            // limit the number of files downloaded at a single time
            core.debug(`Download file concurrency is set to ${DOWNLOAD_CONCURRENCY}`);
            const parallelDownloads = [...new Array(DOWNLOAD_CONCURRENCY).keys()];
            let currentFile = 0;
            let downloadedFiles = 0;
            core.info(`Total number of files that will be downloaded: ${downloadItems.length}`);
            this.statusReporter.setTotalNumberOfFilesToProcess(downloadItems.length);
            this.statusReporter.start();
            yield Promise.all(parallelDownloads.map((index) => __awaiter(this, void 0, void 0, function* () {
                while (currentFile < downloadItems.length) {
                    const currentFileToDownload = downloadItems[currentFile];
                    currentFile += 1;
                    const startTime = perf_hooks_1.performance.now();
                    yield this.downloadIndividualFile(index, currentFileToDownload.sourceLocation, currentFileToDownload.targetPath);
                    if (core.isDebug()) {
                        core.debug(`File: ${++downloadedFiles}/${downloadItems.length}. ${currentFileToDownload.targetPath} took ${(perf_hooks_1.performance.now() - startTime).toFixed(3)} milliseconds to finish downloading`);
                    }
                    this.statusReporter.incrementProcessedCount();
                }
            })))
                .catch(error => {
                throw new Error(`Unable to download the artifact: ${error}`);
            })
                .finally(() => {
                this.statusReporter.stop();
                // safety dispose all connections
                this.downloadHttpManager.disposeAndReplaceAllClients();
            });
        });
    }
    /**
     * Downloads an individual file
     * @param httpClientIndex the index of the http client that is used to make all of the calls
     * @param artifactLocation origin location where a file will be downloaded from
     * @param downloadPath destination location for the file being downloaded
     */
    downloadIndividualFile(httpClientIndex, artifactLocation, downloadPath) {
        return __awaiter(this, void 0, void 0, function* () {
            let retryCount = 0;
            const retryLimit = config_variables_1.getRetryLimit();
            let destinationStream = fs.createWriteStream(downloadPath);
            const headers = utils_1.getDownloadHeaders('application/json', true, true);
            // a single GET request is used to download a file
            const makeDownloadRequest = () => __awaiter(this, void 0, void 0, function* () {
                const client = this.downloadHttpManager.getClient(httpClientIndex);
                return yield client.get(artifactLocation, headers);
            });
            // check the response headers to determine if the file was compressed using gzip
            const isGzip = (incomingHeaders) => {
                return ('content-encoding' in incomingHeaders &&
                    incomingHeaders['content-encoding'] === 'gzip');
            };
            // Increments the current retry count and then checks if the retry limit has been reached
            // If there have been too many retries, fail so the download stops. If there is a retryAfterValue value provided,
            // it will be used
            const backOff = (retryAfterValue) => __awaiter(this, void 0, void 0, function* () {
                retryCount++;
                if (retryCount > retryLimit) {
                    return Promise.reject(new Error(`Retry limit has been reached. Unable to download ${artifactLocation}`));
                }
                else {
                    this.downloadHttpManager.disposeAndReplaceClient(httpClientIndex);
                    if (retryAfterValue) {
                        // Back off by waiting the specified time denoted by the retry-after header
                        core.info(`Backoff due to too many requests, retry #${retryCount}. Waiting for ${retryAfterValue} milliseconds before continuing the download`);
                        yield utils_1.sleep(retryAfterValue);
                    }
                    else {
                        // Back off using an exponential value that depends on the retry count
                        const backoffTime = utils_1.getExponentialRetryTimeInMilliseconds(retryCount);
                        core.info(`Exponential backoff for retry #${retryCount}. Waiting for ${backoffTime} milliseconds before continuing the download`);
                        yield utils_1.sleep(backoffTime);
                    }
                    core.info(`Finished backoff for retry #${retryCount}, continuing with download`);
                }
            });
            const isAllBytesReceived = (expected, received) => {
                // be lenient, if any input is missing, assume success, i.e. not truncated
                if (!expected ||
                    !received ||
                    process.env['ACTIONS_ARTIFACT_SKIP_DOWNLOAD_VALIDATION']) {
                    core.info('Skipping download validation.');
                    return true;
                }
                return parseInt(expected) === received;
            };
            const resetDestinationStream = (fileDownloadPath) => __awaiter(this, void 0, void 0, function* () {
                destinationStream.close();
                // await until file is created at downloadpath; node15 and up fs.createWriteStream had not created a file yet
                yield new Promise(resolve => {
                    destinationStream.on('close', resolve);
                    if (destinationStream.writableFinished) {
                        resolve();
                    }
                });
                yield utils_1.rmFile(fileDownloadPath);
                destinationStream = fs.createWriteStream(fileDownloadPath);
            });
            // keep trying to download a file until a retry limit has been reached
            while (retryCount <= retryLimit) {
                let response;
                try {
                    response = yield makeDownloadRequest();
                }
                catch (error) {
                    // if an error is caught, it is usually indicative of a timeout so retry the download
                    core.info('An error occurred while attempting to download a file');
                    // eslint-disable-next-line no-console
                    console.log(error);
                    // increment the retryCount and use exponential backoff to wait before making the next request
                    yield backOff();
                    continue;
                }
                let forceRetry = false;
                if (utils_1.isSuccessStatusCode(response.message.statusCode)) {
                    // The body contains the contents of the file however calling response.readBody() causes all the content to be converted to a string
                    // which can cause some gzip encoded data to be lost
                    // Instead of using response.readBody(), response.message is a readableStream that can be directly used to get the raw body contents
                    try {
                        const isGzipped = isGzip(response.message.headers);
                        yield this.pipeResponseToFile(response, destinationStream, isGzipped);
                        if (isGzipped ||
                            isAllBytesReceived(response.message.headers['content-length'], yield utils_1.getFileSize(downloadPath))) {
                            return;
                        }
                        else {
                            forceRetry = true;
                        }
                    }
                    catch (error) {
                        // retry on error, most likely streams were corrupted
                        forceRetry = true;
                    }
                }
                if (forceRetry || utils_1.isRetryableStatusCode(response.message.statusCode)) {
                    core.info(`A ${response.message.statusCode} response code has been received while attempting to download an artifact`);
                    resetDestinationStream(downloadPath);
                    // if a throttled status code is received, try to get the retryAfter header value, else differ to standard exponential backoff
                    utils_1.isThrottledStatusCode(response.message.statusCode)
                        ? yield backOff(utils_1.tryGetRetryAfterValueTimeInMilliseconds(response.message.headers))
                        : yield backOff();
                }
                else {
                    // Some unexpected response code, fail immediately and stop the download
                    utils_1.displayHttpDiagnostics(response);
                    return Promise.reject(new Error(`Unexpected http ${response.message.statusCode} during download for ${artifactLocation}`));
                }
            }
        });
    }
    /**
     * Pipes the response from downloading an individual file to the appropriate destination stream while decoding gzip content if necessary
     * @param response the http response received when downloading a file
     * @param destinationStream the stream where the file should be written to
     * @param isGzip a boolean denoting if the content is compressed using gzip and if we need to decode it
     */
    pipeResponseToFile(response, destinationStream, isGzip) {
        return __awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve, reject) => {
                if (isGzip) {
                    const gunzip = zlib.createGunzip();
                    response.message
                        .on('error', error => {
                        core.error(`An error occurred while attempting to read the response stream`);
                        gunzip.close();
                        destinationStream.close();
                        reject(error);
                    })
                        .pipe(gunzip)
                        .on('error', error => {
                        core.error(`An error occurred while attempting to decompress the response stream`);
                        destinationStream.close();
                        reject(error);
                    })
                        .pipe(destinationStream)
                        .on('close', () => {
                        resolve();
                    })
                        .on('error', error => {
                        core.error(`An error occurred while writing a downloaded file to ${destinationStream.path}`);
                        reject(error);
                    });
                }
                else {
                    response.message
                        .on('error', error => {
                        core.error(`An error occurred while attempting to read the response stream`);
                        destinationStream.close();
                        reject(error);
                    })
                        .pipe(destinationStream)
                        .on('close', () => {
                        resolve();
                    })
                        .on('error', error => {
                        core.error(`An error occurred while writing a downloaded file to ${destinationStream.path}`);
                        reject(error);
                    });
                }
            });
            return;
        });
    }
}
exports.DownloadHttpClient = DownloadHttpClient;
//# sourceMappingURL=download-http-client.js.map

/***/ }),

/***/ 5686:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDownloadSpecification = void 0;
const path = __importStar(__nccwpck_require__(1017));
/**
 * Creates a specification for a set of files that will be downloaded
 * @param artifactName the name of the artifact
 * @param artifactEntries a set of container entries that describe that files that make up an artifact
 * @param downloadPath the path where the artifact will be downloaded to
 * @param includeRootDirectory specifies if there should be an extra directory (denoted by the artifact name) where the artifact files should be downloaded to
 */
function getDownloadSpecification(artifactName, artifactEntries, downloadPath, includeRootDirectory) {
    // use a set for the directory paths so that there are no duplicates
    const directories = new Set();
    const specifications = {
        rootDownloadLocation: includeRootDirectory
            ? path.join(downloadPath, artifactName)
            : downloadPath,
        directoryStructure: [],
        emptyFilesToCreate: [],
        filesToDownload: []
    };
    for (const entry of artifactEntries) {
        // Ignore artifacts in the container that don't begin with the same name
        if (entry.path.startsWith(`${artifactName}/`) ||
            entry.path.startsWith(`${artifactName}\\`)) {
            // normalize all separators to the local OS
            const normalizedPathEntry = path.normalize(entry.path);
            // entry.path always starts with the artifact name, if includeRootDirectory is false, remove the name from the beginning of the path
            const filePath = path.join(downloadPath, includeRootDirectory
                ? normalizedPathEntry
                : normalizedPathEntry.replace(artifactName, ''));
            // Case insensitive folder structure maintained in the backend, not every folder is created so the 'folder'
            // itemType cannot be relied upon. The file must be used to determine the directory structure
            if (entry.itemType === 'file') {
                // Get the directories that we need to create from the filePath for each individual file
                directories.add(path.dirname(filePath));
                if (entry.fileLength === 0) {
                    // An empty file was uploaded, create the empty files locally so that no extra http calls are made
                    specifications.emptyFilesToCreate.push(filePath);
                }
                else {
                    specifications.filesToDownload.push({
                        sourceLocation: entry.contentLocation,
                        targetPath: filePath
                    });
                }
            }
        }
    }
    specifications.directoryStructure = Array.from(directories);
    return specifications;
}
exports.getDownloadSpecification = getDownloadSpecification;
//# sourceMappingURL=download-specification.js.map

/***/ }),

/***/ 6527:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpManager = void 0;
const utils_1 = __nccwpck_require__(6327);
/**
 * Used for managing http clients during either upload or download
 */
class HttpManager {
    constructor(clientCount, userAgent) {
        if (clientCount < 1) {
            throw new Error('There must be at least one client');
        }
        this.userAgent = userAgent;
        this.clients = new Array(clientCount).fill(utils_1.createHttpClient(userAgent));
    }
    getClient(index) {
        return this.clients[index];
    }
    // client disposal is necessary if a keep-alive connection is used to properly close the connection
    // for more information see: https://github.com/actions/http-client/blob/04e5ad73cd3fd1f5610a32116b0759eddf6570d2/index.ts#L292
    disposeAndReplaceClient(index) {
        this.clients[index].dispose();
        this.clients[index] = utils_1.createHttpClient(this.userAgent);
    }
    disposeAndReplaceAllClients() {
        for (const [index] of this.clients.entries()) {
            this.disposeAndReplaceClient(index);
        }
    }
}
exports.HttpManager = HttpManager;
//# sourceMappingURL=http-manager.js.map

/***/ }),

/***/ 7398:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkArtifactFilePath = exports.checkArtifactName = void 0;
const core_1 = __nccwpck_require__(2186);
/**
 * Invalid characters that cannot be in the artifact name or an uploaded file. Will be rejected
 * from the server if attempted to be sent over. These characters are not allowed due to limitations with certain
 * file systems such as NTFS. To maintain platform-agnostic behavior, all characters that are not supported by an
 * individual filesystem/platform will not be supported on all fileSystems/platforms
 *
 * FilePaths can include characters such as \ and / which are not permitted in the artifact name alone
 */
const invalidArtifactFilePathCharacters = new Map([
    ['"', ' Double quote "'],
    [':', ' Colon :'],
    ['<', ' Less than <'],
    ['>', ' Greater than >'],
    ['|', ' Vertical bar |'],
    ['*', ' Asterisk *'],
    ['?', ' Question mark ?'],
    ['\r', ' Carriage return \\r'],
    ['\n', ' Line feed \\n']
]);
const invalidArtifactNameCharacters = new Map([
    ...invalidArtifactFilePathCharacters,
    ['\\', ' Backslash \\'],
    ['/', ' Forward slash /']
]);
/**
 * Scans the name of the artifact to make sure there are no illegal characters
 */
function checkArtifactName(name) {
    if (!name) {
        throw new Error(`Artifact name: ${name}, is incorrectly provided`);
    }
    for (const [invalidCharacterKey, errorMessageForCharacter] of invalidArtifactNameCharacters) {
        if (name.includes(invalidCharacterKey)) {
            throw new Error(`Artifact name is not valid: ${name}. Contains the following character: ${errorMessageForCharacter}
          
Invalid characters include: ${Array.from(invalidArtifactNameCharacters.values()).toString()}
          
These characters are not allowed in the artifact name due to limitations with certain file systems such as NTFS. To maintain file system agnostic behavior, these characters are intentionally not allowed to prevent potential problems with downloads on different file systems.`);
        }
    }
    core_1.info(`Artifact name is valid!`);
}
exports.checkArtifactName = checkArtifactName;
/**
 * Scans the name of the filePath used to make sure there are no illegal characters
 */
function checkArtifactFilePath(path) {
    if (!path) {
        throw new Error(`Artifact path: ${path}, is incorrectly provided`);
    }
    for (const [invalidCharacterKey, errorMessageForCharacter] of invalidArtifactFilePathCharacters) {
        if (path.includes(invalidCharacterKey)) {
            throw new Error(`Artifact path is not valid: ${path}. Contains the following character: ${errorMessageForCharacter}
          
Invalid characters include: ${Array.from(invalidArtifactFilePathCharacters.values()).toString()}
          
The following characters are not allowed in files that are uploaded due to limitations with certain file systems such as NTFS. To maintain file system agnostic behavior, these characters are intentionally not allowed to prevent potential problems with downloads on different file systems.
          `);
        }
    }
}
exports.checkArtifactFilePath = checkArtifactFilePath;
//# sourceMappingURL=path-and-artifact-name-validation.js.map

/***/ }),

/***/ 755:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.retryHttpClientRequest = exports.retry = void 0;
const utils_1 = __nccwpck_require__(6327);
const core = __importStar(__nccwpck_require__(2186));
const config_variables_1 = __nccwpck_require__(2222);
function retry(name, operation, customErrorMessages, maxAttempts) {
    return __awaiter(this, void 0, void 0, function* () {
        let response = undefined;
        let statusCode = undefined;
        let isRetryable = false;
        let errorMessage = '';
        let customErrorInformation = undefined;
        let attempt = 1;
        while (attempt <= maxAttempts) {
            try {
                response = yield operation();
                statusCode = response.message.statusCode;
                if (utils_1.isSuccessStatusCode(statusCode)) {
                    return response;
                }
                // Extra error information that we want to display if a particular response code is hit
                if (statusCode) {
                    customErrorInformation = customErrorMessages.get(statusCode);
                }
                isRetryable = utils_1.isRetryableStatusCode(statusCode);
                errorMessage = `Artifact service responded with ${statusCode}`;
            }
            catch (error) {
                isRetryable = true;
                errorMessage = error.message;
            }
            if (!isRetryable) {
                core.info(`${name} - Error is not retryable`);
                if (response) {
                    utils_1.displayHttpDiagnostics(response);
                }
                break;
            }
            core.info(`${name} - Attempt ${attempt} of ${maxAttempts} failed with error: ${errorMessage}`);
            yield utils_1.sleep(utils_1.getExponentialRetryTimeInMilliseconds(attempt));
            attempt++;
        }
        if (response) {
            utils_1.displayHttpDiagnostics(response);
        }
        if (customErrorInformation) {
            throw Error(`${name} failed: ${customErrorInformation}`);
        }
        throw Error(`${name} failed: ${errorMessage}`);
    });
}
exports.retry = retry;
function retryHttpClientRequest(name, method, customErrorMessages = new Map(), maxAttempts = config_variables_1.getRetryLimit()) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield retry(name, method, customErrorMessages, maxAttempts);
    });
}
exports.retryHttpClientRequest = retryHttpClientRequest;
//# sourceMappingURL=requestUtils.js.map

/***/ }),

/***/ 9081:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatusReporter = void 0;
const core_1 = __nccwpck_require__(2186);
/**
 * Status Reporter that displays information about the progress/status of an artifact that is being uploaded or downloaded
 *
 * Variable display time that can be adjusted using the displayFrequencyInMilliseconds variable
 * The total status of the upload/download gets displayed according to this value
 * If there is a large file that is being uploaded, extra information about the individual status can also be displayed using the updateLargeFileStatus function
 */
class StatusReporter {
    constructor(displayFrequencyInMilliseconds) {
        this.totalNumberOfFilesToProcess = 0;
        this.processedCount = 0;
        this.largeFiles = new Map();
        this.totalFileStatus = undefined;
        this.displayFrequencyInMilliseconds = displayFrequencyInMilliseconds;
    }
    setTotalNumberOfFilesToProcess(fileTotal) {
        this.totalNumberOfFilesToProcess = fileTotal;
        this.processedCount = 0;
    }
    start() {
        // displays information about the total upload/download status
        this.totalFileStatus = setInterval(() => {
            // display 1 decimal place without any rounding
            const percentage = this.formatPercentage(this.processedCount, this.totalNumberOfFilesToProcess);
            core_1.info(`Total file count: ${this.totalNumberOfFilesToProcess} ---- Processed file #${this.processedCount} (${percentage.slice(0, percentage.indexOf('.') + 2)}%)`);
        }, this.displayFrequencyInMilliseconds);
    }
    // if there is a large file that is being uploaded in chunks, this is used to display extra information about the status of the upload
    updateLargeFileStatus(fileName, chunkStartIndex, chunkEndIndex, totalUploadFileSize) {
        // display 1 decimal place without any rounding
        const percentage = this.formatPercentage(chunkEndIndex, totalUploadFileSize);
        core_1.info(`Uploaded ${fileName} (${percentage.slice(0, percentage.indexOf('.') + 2)}%) bytes ${chunkStartIndex}:${chunkEndIndex}`);
    }
    stop() {
        if (this.totalFileStatus) {
            clearInterval(this.totalFileStatus);
        }
    }
    incrementProcessedCount() {
        this.processedCount++;
    }
    formatPercentage(numerator, denominator) {
        // toFixed() rounds, so use extra precision to display accurate information even though 4 decimal places are not displayed
        return ((numerator / denominator) * 100).toFixed(4).toString();
    }
}
exports.StatusReporter = StatusReporter;
//# sourceMappingURL=status-reporter.js.map

/***/ }),

/***/ 606:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createGZipFileInBuffer = exports.createGZipFileOnDisk = void 0;
const fs = __importStar(__nccwpck_require__(7147));
const zlib = __importStar(__nccwpck_require__(9796));
const util_1 = __nccwpck_require__(3837);
const stat = util_1.promisify(fs.stat);
/**
 * GZipping certain files that are already compressed will likely not yield further size reductions. Creating large temporary gzip
 * files then will just waste a lot of time before ultimately being discarded (especially for very large files).
 * If any of these types of files are encountered then on-disk gzip creation will be skipped and the original file will be uploaded as-is
 */
const gzipExemptFileExtensions = [
    '.gzip',
    '.zip',
    '.tar.lz',
    '.tar.gz',
    '.tar.bz2',
    '.7z'
];
/**
 * Creates a Gzip compressed file of an original file at the provided temporary filepath location
 * @param {string} originalFilePath filepath of whatever will be compressed. The original file will be unmodified
 * @param {string} tempFilePath the location of where the Gzip file will be created
 * @returns the size of gzip file that gets created
 */
function createGZipFileOnDisk(originalFilePath, tempFilePath) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const gzipExemptExtension of gzipExemptFileExtensions) {
            if (originalFilePath.endsWith(gzipExemptExtension)) {
                // return a really large number so that the original file gets uploaded
                return Number.MAX_SAFE_INTEGER;
            }
        }
        return new Promise((resolve, reject) => {
            const inputStream = fs.createReadStream(originalFilePath);
            const gzip = zlib.createGzip();
            const outputStream = fs.createWriteStream(tempFilePath);
            inputStream.pipe(gzip).pipe(outputStream);
            outputStream.on('finish', () => __awaiter(this, void 0, void 0, function* () {
                // wait for stream to finish before calculating the size which is needed as part of the Content-Length header when starting an upload
                const size = (yield stat(tempFilePath)).size;
                resolve(size);
            }));
            outputStream.on('error', error => {
                // eslint-disable-next-line no-console
                console.log(error);
                reject;
            });
        });
    });
}
exports.createGZipFileOnDisk = createGZipFileOnDisk;
/**
 * Creates a GZip file in memory using a buffer. Should be used for smaller files to reduce disk I/O
 * @param originalFilePath the path to the original file that is being GZipped
 * @returns a buffer with the GZip file
 */
function createGZipFileInBuffer(originalFilePath) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            var e_1, _a;
            const inputStream = fs.createReadStream(originalFilePath);
            const gzip = zlib.createGzip();
            inputStream.pipe(gzip);
            // read stream into buffer, using experimental async iterators see https://github.com/nodejs/readable-stream/issues/403#issuecomment-479069043
            const chunks = [];
            try {
                for (var gzip_1 = __asyncValues(gzip), gzip_1_1; gzip_1_1 = yield gzip_1.next(), !gzip_1_1.done;) {
                    const chunk = gzip_1_1.value;
                    chunks.push(chunk);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (gzip_1_1 && !gzip_1_1.done && (_a = gzip_1.return)) yield _a.call(gzip_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            resolve(Buffer.concat(chunks));
        }));
    });
}
exports.createGZipFileInBuffer = createGZipFileInBuffer;
//# sourceMappingURL=upload-gzip.js.map

/***/ }),

/***/ 4354:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UploadHttpClient = void 0;
const fs = __importStar(__nccwpck_require__(7147));
const core = __importStar(__nccwpck_require__(2186));
const tmp = __importStar(__nccwpck_require__(8065));
const stream = __importStar(__nccwpck_require__(2781));
const utils_1 = __nccwpck_require__(6327);
const config_variables_1 = __nccwpck_require__(2222);
const util_1 = __nccwpck_require__(3837);
const url_1 = __nccwpck_require__(7310);
const perf_hooks_1 = __nccwpck_require__(4074);
const status_reporter_1 = __nccwpck_require__(9081);
const http_client_1 = __nccwpck_require__(6255);
const http_manager_1 = __nccwpck_require__(6527);
const upload_gzip_1 = __nccwpck_require__(606);
const requestUtils_1 = __nccwpck_require__(755);
const stat = util_1.promisify(fs.stat);
class UploadHttpClient {
    constructor() {
        this.uploadHttpManager = new http_manager_1.HttpManager(config_variables_1.getUploadFileConcurrency(), '@actions/artifact-upload');
        this.statusReporter = new status_reporter_1.StatusReporter(10000);
    }
    /**
     * Creates a file container for the new artifact in the remote blob storage/file service
     * @param {string} artifactName Name of the artifact being created
     * @returns The response from the Artifact Service if the file container was successfully created
     */
    createArtifactInFileContainer(artifactName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const parameters = {
                Type: 'actions_storage',
                Name: artifactName
            };
            // calculate retention period
            if (options && options.retentionDays) {
                const maxRetentionStr = config_variables_1.getRetentionDays();
                parameters.RetentionDays = utils_1.getProperRetention(options.retentionDays, maxRetentionStr);
            }
            const data = JSON.stringify(parameters, null, 2);
            const artifactUrl = utils_1.getArtifactUrl();
            // use the first client from the httpManager, `keep-alive` is not used so the connection will close immediately
            const client = this.uploadHttpManager.getClient(0);
            const headers = utils_1.getUploadHeaders('application/json', false);
            // Extra information to display when a particular HTTP code is returned
            // If a 403 is returned when trying to create a file container, the customer has exceeded
            // their storage quota so no new artifact containers can be created
            const customErrorMessages = new Map([
                [
                    http_client_1.HttpCodes.Forbidden,
                    'Artifact storage quota has been hit. Unable to upload any new artifacts'
                ],
                [
                    http_client_1.HttpCodes.BadRequest,
                    `The artifact name ${artifactName} is not valid. Request URL ${artifactUrl}`
                ]
            ]);
            const response = yield requestUtils_1.retryHttpClientRequest('Create Artifact Container', () => __awaiter(this, void 0, void 0, function* () { return client.post(artifactUrl, data, headers); }), customErrorMessages);
            const body = yield response.readBody();
            return JSON.parse(body);
        });
    }
    /**
     * Concurrently upload all of the files in chunks
     * @param {string} uploadUrl Base Url for the artifact that was created
     * @param {SearchResult[]} filesToUpload A list of information about the files being uploaded
     * @returns The size of all the files uploaded in bytes
     */
    uploadArtifactToFileContainer(uploadUrl, filesToUpload, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const FILE_CONCURRENCY = config_variables_1.getUploadFileConcurrency();
            const MAX_CHUNK_SIZE = config_variables_1.getUploadChunkSize();
            core.debug(`File Concurrency: ${FILE_CONCURRENCY}, and Chunk Size: ${MAX_CHUNK_SIZE}`);
            const parameters = [];
            // by default, file uploads will continue if there is an error unless specified differently in the options
            let continueOnError = true;
            if (options) {
                if (options.continueOnError === false) {
                    continueOnError = false;
                }
            }
            // prepare the necessary parameters to upload all the files
            for (const file of filesToUpload) {
                const resourceUrl = new url_1.URL(uploadUrl);
                resourceUrl.searchParams.append('itemPath', file.uploadFilePath);
                parameters.push({
                    file: file.absoluteFilePath,
                    resourceUrl: resourceUrl.toString(),
                    maxChunkSize: MAX_CHUNK_SIZE,
                    continueOnError
                });
            }
            const parallelUploads = [...new Array(FILE_CONCURRENCY).keys()];
            const failedItemsToReport = [];
            let currentFile = 0;
            let completedFiles = 0;
            let uploadFileSize = 0;
            let totalFileSize = 0;
            let abortPendingFileUploads = false;
            this.statusReporter.setTotalNumberOfFilesToProcess(filesToUpload.length);
            this.statusReporter.start();
            // only allow a certain amount of files to be uploaded at once, this is done to reduce potential errors
            yield Promise.all(parallelUploads.map((index) => __awaiter(this, void 0, void 0, function* () {
                while (currentFile < filesToUpload.length) {
                    const currentFileParameters = parameters[currentFile];
                    currentFile += 1;
                    if (abortPendingFileUploads) {
                        failedItemsToReport.push(currentFileParameters.file);
                        continue;
                    }
                    const startTime = perf_hooks_1.performance.now();
                    const uploadFileResult = yield this.uploadFileAsync(index, currentFileParameters);
                    if (core.isDebug()) {
                        core.debug(`File: ${++completedFiles}/${filesToUpload.length}. ${currentFileParameters.file} took ${(perf_hooks_1.performance.now() - startTime).toFixed(3)} milliseconds to finish upload`);
                    }
                    uploadFileSize += uploadFileResult.successfulUploadSize;
                    totalFileSize += uploadFileResult.totalSize;
                    if (uploadFileResult.isSuccess === false) {
                        failedItemsToReport.push(currentFileParameters.file);
                        if (!continueOnError) {
                            // fail fast
                            core.error(`aborting artifact upload`);
                            abortPendingFileUploads = true;
                        }
                    }
                    this.statusReporter.incrementProcessedCount();
                }
            })));
            this.statusReporter.stop();
            // done uploading, safety dispose all connections
            this.uploadHttpManager.disposeAndReplaceAllClients();
            core.info(`Total size of all the files uploaded is ${uploadFileSize} bytes`);
            return {
                uploadSize: uploadFileSize,
                totalSize: totalFileSize,
                failedItems: failedItemsToReport
            };
        });
    }
    /**
     * Asynchronously uploads a file. The file is compressed and uploaded using GZip if it is determined to save space.
     * If the upload file is bigger than the max chunk size it will be uploaded via multiple calls
     * @param {number} httpClientIndex The index of the httpClient that is being used to make all of the calls
     * @param {UploadFileParameters} parameters Information about the file that needs to be uploaded
     * @returns The size of the file that was uploaded in bytes along with any failed uploads
     */
    uploadFileAsync(httpClientIndex, parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileStat = yield stat(parameters.file);
            const totalFileSize = fileStat.size;
            const isFIFO = fileStat.isFIFO();
            let offset = 0;
            let isUploadSuccessful = true;
            let failedChunkSizes = 0;
            let uploadFileSize = 0;
            let isGzip = true;
            // the file that is being uploaded is less than 64k in size to increase throughput and to minimize disk I/O
            // for creating a new GZip file, an in-memory buffer is used for compression
            // with named pipes the file size is reported as zero in that case don't read the file in memory
            if (!isFIFO && totalFileSize < 65536) {
                core.debug(`${parameters.file} is less than 64k in size. Creating a gzip file in-memory to potentially reduce the upload size`);
                const buffer = yield upload_gzip_1.createGZipFileInBuffer(parameters.file);
                // An open stream is needed in the event of a failure and we need to retry. If a NodeJS.ReadableStream is directly passed in,
                // it will not properly get reset to the start of the stream if a chunk upload needs to be retried
                let openUploadStream;
                if (totalFileSize < buffer.byteLength) {
                    // compression did not help with reducing the size, use a readable stream from the original file for upload
                    core.debug(`The gzip file created for ${parameters.file} did not help with reducing the size of the file. The original file will be uploaded as-is`);
                    openUploadStream = () => fs.createReadStream(parameters.file);
                    isGzip = false;
                    uploadFileSize = totalFileSize;
                }
                else {
                    // create a readable stream using a PassThrough stream that is both readable and writable
                    core.debug(`A gzip file created for ${parameters.file} helped with reducing the size of the original file. The file will be uploaded using gzip.`);
                    openUploadStream = () => {
                        const passThrough = new stream.PassThrough();
                        passThrough.end(buffer);
                        return passThrough;
                    };
                    uploadFileSize = buffer.byteLength;
                }
                const result = yield this.uploadChunk(httpClientIndex, parameters.resourceUrl, openUploadStream, 0, uploadFileSize - 1, uploadFileSize, isGzip, totalFileSize);
                if (!result) {
                    // chunk failed to upload
                    isUploadSuccessful = false;
                    failedChunkSizes += uploadFileSize;
                    core.warning(`Aborting upload for ${parameters.file} due to failure`);
                }
                return {
                    isSuccess: isUploadSuccessful,
                    successfulUploadSize: uploadFileSize - failedChunkSizes,
                    totalSize: totalFileSize
                };
            }
            else {
                // the file that is being uploaded is greater than 64k in size, a temporary file gets created on disk using the
                // npm tmp-promise package and this file gets used to create a GZipped file
                const tempFile = yield tmp.file();
                core.debug(`${parameters.file} is greater than 64k in size. Creating a gzip file on-disk ${tempFile.path} to potentially reduce the upload size`);
                // create a GZip file of the original file being uploaded, the original file should not be modified in any way
                uploadFileSize = yield upload_gzip_1.createGZipFileOnDisk(parameters.file, tempFile.path);
                let uploadFilePath = tempFile.path;
                // compression did not help with size reduction, use the original file for upload and delete the temp GZip file
                // for named pipes totalFileSize is zero, this assumes compression did help
                if (!isFIFO && totalFileSize < uploadFileSize) {
                    core.debug(`The gzip file created for ${parameters.file} did not help with reducing the size of the file. The original file will be uploaded as-is`);
                    uploadFileSize = totalFileSize;
                    uploadFilePath = parameters.file;
                    isGzip = false;
                }
                else {
                    core.debug(`The gzip file created for ${parameters.file} is smaller than the original file. The file will be uploaded using gzip.`);
                }
                let abortFileUpload = false;
                // upload only a single chunk at a time
                while (offset < uploadFileSize) {
                    const chunkSize = Math.min(uploadFileSize - offset, parameters.maxChunkSize);
                    const startChunkIndex = offset;
                    const endChunkIndex = offset + chunkSize - 1;
                    offset += parameters.maxChunkSize;
                    if (abortFileUpload) {
                        // if we don't want to continue in the event of an error, any pending upload chunks will be marked as failed
                        failedChunkSizes += chunkSize;
                        continue;
                    }
                    const result = yield this.uploadChunk(httpClientIndex, parameters.resourceUrl, () => fs.createReadStream(uploadFilePath, {
                        start: startChunkIndex,
                        end: endChunkIndex,
                        autoClose: false
                    }), startChunkIndex, endChunkIndex, uploadFileSize, isGzip, totalFileSize);
                    if (!result) {
                        // Chunk failed to upload, report as failed and do not continue uploading any more chunks for the file. It is possible that part of a chunk was
                        // successfully uploaded so the server may report a different size for what was uploaded
                        isUploadSuccessful = false;
                        failedChunkSizes += chunkSize;
                        core.warning(`Aborting upload for ${parameters.file} due to failure`);
                        abortFileUpload = true;
                    }
                    else {
                        // if an individual file is greater than 8MB (1024*1024*8) in size, display extra information about the upload status
                        if (uploadFileSize > 8388608) {
                            this.statusReporter.updateLargeFileStatus(parameters.file, startChunkIndex, endChunkIndex, uploadFileSize);
                        }
                    }
                }
                // Delete the temporary file that was created as part of the upload. If the temp file does not get manually deleted by
                // calling cleanup, it gets removed when the node process exits. For more info see: https://www.npmjs.com/package/tmp-promise#about
                core.debug(`deleting temporary gzip file ${tempFile.path}`);
                yield tempFile.cleanup();
                return {
                    isSuccess: isUploadSuccessful,
                    successfulUploadSize: uploadFileSize - failedChunkSizes,
                    totalSize: totalFileSize
                };
            }
        });
    }
    /**
     * Uploads a chunk of an individual file to the specified resourceUrl. If the upload fails and the status code
     * indicates a retryable status, we try to upload the chunk as well
     * @param {number} httpClientIndex The index of the httpClient being used to make all the necessary calls
     * @param {string} resourceUrl Url of the resource that the chunk will be uploaded to
     * @param {NodeJS.ReadableStream} openStream Stream of the file that will be uploaded
     * @param {number} start Starting byte index of file that the chunk belongs to
     * @param {number} end Ending byte index of file that the chunk belongs to
     * @param {number} uploadFileSize Total size of the file in bytes that is being uploaded
     * @param {boolean} isGzip Denotes if we are uploading a Gzip compressed stream
     * @param {number} totalFileSize Original total size of the file that is being uploaded
     * @returns if the chunk was successfully uploaded
     */
    uploadChunk(httpClientIndex, resourceUrl, openStream, start, end, uploadFileSize, isGzip, totalFileSize) {
        return __awaiter(this, void 0, void 0, function* () {
            // open a new stream and read it to compute the digest
            const digest = yield utils_1.digestForStream(openStream());
            // prepare all the necessary headers before making any http call
            const headers = utils_1.getUploadHeaders('application/octet-stream', true, isGzip, totalFileSize, end - start + 1, utils_1.getContentRange(start, end, uploadFileSize), digest);
            const uploadChunkRequest = () => __awaiter(this, void 0, void 0, function* () {
                const client = this.uploadHttpManager.getClient(httpClientIndex);
                return yield client.sendStream('PUT', resourceUrl, openStream(), headers);
            });
            let retryCount = 0;
            const retryLimit = config_variables_1.getRetryLimit();
            // Increments the current retry count and then checks if the retry limit has been reached
            // If there have been too many retries, fail so the download stops
            const incrementAndCheckRetryLimit = (response) => {
                retryCount++;
                if (retryCount > retryLimit) {
                    if (response) {
                        utils_1.displayHttpDiagnostics(response);
                    }
                    core.info(`Retry limit has been reached for chunk at offset ${start} to ${resourceUrl}`);
                    return true;
                }
                return false;
            };
            const backOff = (retryAfterValue) => __awaiter(this, void 0, void 0, function* () {
                this.uploadHttpManager.disposeAndReplaceClient(httpClientIndex);
                if (retryAfterValue) {
                    core.info(`Backoff due to too many requests, retry #${retryCount}. Waiting for ${retryAfterValue} milliseconds before continuing the upload`);
                    yield utils_1.sleep(retryAfterValue);
                }
                else {
                    const backoffTime = utils_1.getExponentialRetryTimeInMilliseconds(retryCount);
                    core.info(`Exponential backoff for retry #${retryCount}. Waiting for ${backoffTime} milliseconds before continuing the upload at offset ${start}`);
                    yield utils_1.sleep(backoffTime);
                }
                core.info(`Finished backoff for retry #${retryCount}, continuing with upload`);
                return;
            });
            // allow for failed chunks to be retried multiple times
            while (retryCount <= retryLimit) {
                let response;
                try {
                    response = yield uploadChunkRequest();
                }
                catch (error) {
                    // if an error is caught, it is usually indicative of a timeout so retry the upload
                    core.info(`An error has been caught http-client index ${httpClientIndex}, retrying the upload`);
                    // eslint-disable-next-line no-console
                    console.log(error);
                    if (incrementAndCheckRetryLimit()) {
                        return false;
                    }
                    yield backOff();
                    continue;
                }
                // Always read the body of the response. There is potential for a resource leak if the body is not read which will
                // result in the connection remaining open along with unintended consequences when trying to dispose of the client
                yield response.readBody();
                if (utils_1.isSuccessStatusCode(response.message.statusCode)) {
                    return true;
                }
                else if (utils_1.isRetryableStatusCode(response.message.statusCode)) {
                    core.info(`A ${response.message.statusCode} status code has been received, will attempt to retry the upload`);
                    if (incrementAndCheckRetryLimit(response)) {
                        return false;
                    }
                    utils_1.isThrottledStatusCode(response.message.statusCode)
                        ? yield backOff(utils_1.tryGetRetryAfterValueTimeInMilliseconds(response.message.headers))
                        : yield backOff();
                }
                else {
                    core.error(`Unexpected response. Unable to upload chunk to ${resourceUrl}`);
                    utils_1.displayHttpDiagnostics(response);
                    return false;
                }
            }
            return false;
        });
    }
    /**
     * Updates the size of the artifact from -1 which was initially set when the container was first created for the artifact.
     * Updating the size indicates that we are done uploading all the contents of the artifact
     */
    patchArtifactSize(size, artifactName) {
        return __awaiter(this, void 0, void 0, function* () {
            const resourceUrl = new url_1.URL(utils_1.getArtifactUrl());
            resourceUrl.searchParams.append('artifactName', artifactName);
            const parameters = { Size: size };
            const data = JSON.stringify(parameters, null, 2);
            core.debug(`URL is ${resourceUrl.toString()}`);
            // use the first client from the httpManager, `keep-alive` is not used so the connection will close immediately
            const client = this.uploadHttpManager.getClient(0);
            const headers = utils_1.getUploadHeaders('application/json', false);
            // Extra information to display when a particular HTTP code is returned
            const customErrorMessages = new Map([
                [
                    http_client_1.HttpCodes.NotFound,
                    `An Artifact with the name ${artifactName} was not found`
                ]
            ]);
            // TODO retry for all possible response codes, the artifact upload is pretty much complete so it at all costs we should try to finish this
            const response = yield requestUtils_1.retryHttpClientRequest('Finalize artifact upload', () => __awaiter(this, void 0, void 0, function* () { return client.patch(resourceUrl.toString(), data, headers); }), customErrorMessages);
            yield response.readBody();
            core.debug(`Artifact ${artifactName} has been successfully uploaded, total size in bytes: ${size}`);
        });
    }
}
exports.UploadHttpClient = UploadHttpClient;
//# sourceMappingURL=upload-http-client.js.map

/***/ }),

/***/ 183:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUploadSpecification = void 0;
const fs = __importStar(__nccwpck_require__(7147));
const core_1 = __nccwpck_require__(2186);
const path_1 = __nccwpck_require__(1017);
const path_and_artifact_name_validation_1 = __nccwpck_require__(7398);
/**
 * Creates a specification that describes how each file that is part of the artifact will be uploaded
 * @param artifactName the name of the artifact being uploaded. Used during upload to denote where the artifact is stored on the server
 * @param rootDirectory an absolute file path that denotes the path that should be removed from the beginning of each artifact file
 * @param artifactFiles a list of absolute file paths that denote what should be uploaded as part of the artifact
 */
function getUploadSpecification(artifactName, rootDirectory, artifactFiles) {
    // artifact name was checked earlier on, no need to check again
    const specifications = [];
    if (!fs.existsSync(rootDirectory)) {
        throw new Error(`Provided rootDirectory ${rootDirectory} does not exist`);
    }
    if (!fs.lstatSync(rootDirectory).isDirectory()) {
        throw new Error(`Provided rootDirectory ${rootDirectory} is not a valid directory`);
    }
    // Normalize and resolve, this allows for either absolute or relative paths to be used
    rootDirectory = path_1.normalize(rootDirectory);
    rootDirectory = path_1.resolve(rootDirectory);
    /*
       Example to demonstrate behavior
       
       Input:
         artifactName: my-artifact
         rootDirectory: '/home/user/files/plz-upload'
         artifactFiles: [
           '/home/user/files/plz-upload/file1.txt',
           '/home/user/files/plz-upload/file2.txt',
           '/home/user/files/plz-upload/dir/file3.txt'
         ]
       
       Output:
         specifications: [
           ['/home/user/files/plz-upload/file1.txt', 'my-artifact/file1.txt'],
           ['/home/user/files/plz-upload/file1.txt', 'my-artifact/file2.txt'],
           ['/home/user/files/plz-upload/file1.txt', 'my-artifact/dir/file3.txt']
         ]
    */
    for (let file of artifactFiles) {
        if (!fs.existsSync(file)) {
            throw new Error(`File ${file} does not exist`);
        }
        if (!fs.lstatSync(file).isDirectory()) {
            // Normalize and resolve, this allows for either absolute or relative paths to be used
            file = path_1.normalize(file);
            file = path_1.resolve(file);
            if (!file.startsWith(rootDirectory)) {
                throw new Error(`The rootDirectory: ${rootDirectory} is not a parent directory of the file: ${file}`);
            }
            // Check for forbidden characters in file paths that will be rejected during upload
            const uploadPath = file.replace(rootDirectory, '');
            path_and_artifact_name_validation_1.checkArtifactFilePath(uploadPath);
            /*
              uploadFilePath denotes where the file will be uploaded in the file container on the server. During a run, if multiple artifacts are uploaded, they will all
              be saved in the same container. The artifact name is used as the root directory in the container to separate and distinguish uploaded artifacts
      
              path.join handles all the following cases and would return 'artifact-name/file-to-upload.txt
                join('artifact-name/', 'file-to-upload.txt')
                join('artifact-name/', '/file-to-upload.txt')
                join('artifact-name', 'file-to-upload.txt')
                join('artifact-name', '/file-to-upload.txt')
            */
            specifications.push({
                absoluteFilePath: file,
                uploadFilePath: path_1.join(artifactName, uploadPath)
            });
        }
        else {
            // Directories are rejected by the server during upload
            core_1.debug(`Removing ${file} from rawSearchResults because it is a directory`);
        }
    }
    return specifications;
}
exports.getUploadSpecification = getUploadSpecification;
//# sourceMappingURL=upload-specification.js.map

/***/ }),

/***/ 6327:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.digestForStream = exports.sleep = exports.getProperRetention = exports.rmFile = exports.getFileSize = exports.createEmptyFilesForArtifact = exports.createDirectoriesForArtifact = exports.displayHttpDiagnostics = exports.getArtifactUrl = exports.createHttpClient = exports.getUploadHeaders = exports.getDownloadHeaders = exports.getContentRange = exports.tryGetRetryAfterValueTimeInMilliseconds = exports.isThrottledStatusCode = exports.isRetryableStatusCode = exports.isForbiddenStatusCode = exports.isSuccessStatusCode = exports.getApiVersion = exports.parseEnvNumber = exports.getExponentialRetryTimeInMilliseconds = void 0;
const crypto_1 = __importDefault(__nccwpck_require__(6113));
const fs_1 = __nccwpck_require__(7147);
const core_1 = __nccwpck_require__(2186);
const http_client_1 = __nccwpck_require__(6255);
const auth_1 = __nccwpck_require__(5526);
const config_variables_1 = __nccwpck_require__(2222);
const crc64_1 = __importDefault(__nccwpck_require__(3549));
/**
 * Returns a retry time in milliseconds that exponentially gets larger
 * depending on the amount of retries that have been attempted
 */
function getExponentialRetryTimeInMilliseconds(retryCount) {
    if (retryCount < 0) {
        throw new Error('RetryCount should not be negative');
    }
    else if (retryCount === 0) {
        return config_variables_1.getInitialRetryIntervalInMilliseconds();
    }
    const minTime = config_variables_1.getInitialRetryIntervalInMilliseconds() * config_variables_1.getRetryMultiplier() * retryCount;
    const maxTime = minTime * config_variables_1.getRetryMultiplier();
    // returns a random number between the minTime (inclusive) and the maxTime (exclusive)
    return Math.trunc(Math.random() * (maxTime - minTime) + minTime);
}
exports.getExponentialRetryTimeInMilliseconds = getExponentialRetryTimeInMilliseconds;
/**
 * Parses a env variable that is a number
 */
function parseEnvNumber(key) {
    const value = Number(process.env[key]);
    if (Number.isNaN(value) || value < 0) {
        return undefined;
    }
    return value;
}
exports.parseEnvNumber = parseEnvNumber;
/**
 * Various utility functions to help with the necessary API calls
 */
function getApiVersion() {
    return '6.0-preview';
}
exports.getApiVersion = getApiVersion;
function isSuccessStatusCode(statusCode) {
    if (!statusCode) {
        return false;
    }
    return statusCode >= 200 && statusCode < 300;
}
exports.isSuccessStatusCode = isSuccessStatusCode;
function isForbiddenStatusCode(statusCode) {
    if (!statusCode) {
        return false;
    }
    return statusCode === http_client_1.HttpCodes.Forbidden;
}
exports.isForbiddenStatusCode = isForbiddenStatusCode;
function isRetryableStatusCode(statusCode) {
    if (!statusCode) {
        return false;
    }
    const retryableStatusCodes = [
        http_client_1.HttpCodes.BadGateway,
        http_client_1.HttpCodes.GatewayTimeout,
        http_client_1.HttpCodes.InternalServerError,
        http_client_1.HttpCodes.ServiceUnavailable,
        http_client_1.HttpCodes.TooManyRequests,
        413 // Payload Too Large
    ];
    return retryableStatusCodes.includes(statusCode);
}
exports.isRetryableStatusCode = isRetryableStatusCode;
function isThrottledStatusCode(statusCode) {
    if (!statusCode) {
        return false;
    }
    return statusCode === http_client_1.HttpCodes.TooManyRequests;
}
exports.isThrottledStatusCode = isThrottledStatusCode;
/**
 * Attempts to get the retry-after value from a set of http headers. The retry time
 * is originally denoted in seconds, so if present, it is converted to milliseconds
 * @param headers all the headers received when making an http call
 */
function tryGetRetryAfterValueTimeInMilliseconds(headers) {
    if (headers['retry-after']) {
        const retryTime = Number(headers['retry-after']);
        if (!isNaN(retryTime)) {
            core_1.info(`Retry-After header is present with a value of ${retryTime}`);
            return retryTime * 1000;
        }
        core_1.info(`Returned retry-after header value: ${retryTime} is non-numeric and cannot be used`);
        return undefined;
    }
    core_1.info(`No retry-after header was found. Dumping all headers for diagnostic purposes`);
    // eslint-disable-next-line no-console
    console.log(headers);
    return undefined;
}
exports.tryGetRetryAfterValueTimeInMilliseconds = tryGetRetryAfterValueTimeInMilliseconds;
function getContentRange(start, end, total) {
    // Format: `bytes start-end/fileSize
    // start and end are inclusive
    // For a 200 byte chunk starting at byte 0:
    // Content-Range: bytes 0-199/200
    return `bytes ${start}-${end}/${total}`;
}
exports.getContentRange = getContentRange;
/**
 * Sets all the necessary headers when downloading an artifact
 * @param {string} contentType the type of content being uploaded
 * @param {boolean} isKeepAlive is the same connection being used to make multiple calls
 * @param {boolean} acceptGzip can we accept a gzip encoded response
 * @param {string} acceptType the type of content that we can accept
 * @returns appropriate headers to make a specific http call during artifact download
 */
function getDownloadHeaders(contentType, isKeepAlive, acceptGzip) {
    const requestOptions = {};
    if (contentType) {
        requestOptions['Content-Type'] = contentType;
    }
    if (isKeepAlive) {
        requestOptions['Connection'] = 'Keep-Alive';
        // keep alive for at least 10 seconds before closing the connection
        requestOptions['Keep-Alive'] = '10';
    }
    if (acceptGzip) {
        // if we are expecting a response with gzip encoding, it should be using an octet-stream in the accept header
        requestOptions['Accept-Encoding'] = 'gzip';
        requestOptions['Accept'] = `application/octet-stream;api-version=${getApiVersion()}`;
    }
    else {
        // default to application/json if we are not working with gzip content
        requestOptions['Accept'] = `application/json;api-version=${getApiVersion()}`;
    }
    return requestOptions;
}
exports.getDownloadHeaders = getDownloadHeaders;
/**
 * Sets all the necessary headers when uploading an artifact
 * @param {string} contentType the type of content being uploaded
 * @param {boolean} isKeepAlive is the same connection being used to make multiple calls
 * @param {boolean} isGzip is the connection being used to upload GZip compressed content
 * @param {number} uncompressedLength the original size of the content if something is being uploaded that has been compressed
 * @param {number} contentLength the length of the content that is being uploaded
 * @param {string} contentRange the range of the content that is being uploaded
 * @returns appropriate headers to make a specific http call during artifact upload
 */
function getUploadHeaders(contentType, isKeepAlive, isGzip, uncompressedLength, contentLength, contentRange, digest) {
    const requestOptions = {};
    requestOptions['Accept'] = `application/json;api-version=${getApiVersion()}`;
    if (contentType) {
        requestOptions['Content-Type'] = contentType;
    }
    if (isKeepAlive) {
        requestOptions['Connection'] = 'Keep-Alive';
        // keep alive for at least 10 seconds before closing the connection
        requestOptions['Keep-Alive'] = '10';
    }
    if (isGzip) {
        requestOptions['Content-Encoding'] = 'gzip';
        requestOptions['x-tfs-filelength'] = uncompressedLength;
    }
    if (contentLength) {
        requestOptions['Content-Length'] = contentLength;
    }
    if (contentRange) {
        requestOptions['Content-Range'] = contentRange;
    }
    if (digest) {
        requestOptions['x-actions-results-crc64'] = digest.crc64;
        requestOptions['x-actions-results-md5'] = digest.md5;
    }
    return requestOptions;
}
exports.getUploadHeaders = getUploadHeaders;
function createHttpClient(userAgent) {
    return new http_client_1.HttpClient(userAgent, [
        new auth_1.BearerCredentialHandler(config_variables_1.getRuntimeToken())
    ]);
}
exports.createHttpClient = createHttpClient;
function getArtifactUrl() {
    const artifactUrl = `${config_variables_1.getRuntimeUrl()}_apis/pipelines/workflows/${config_variables_1.getWorkFlowRunId()}/artifacts?api-version=${getApiVersion()}`;
    core_1.debug(`Artifact Url: ${artifactUrl}`);
    return artifactUrl;
}
exports.getArtifactUrl = getArtifactUrl;
/**
 * Uh oh! Something might have gone wrong during either upload or download. The IHtttpClientResponse object contains information
 * about the http call that was made by the actions http client. This information might be useful to display for diagnostic purposes, but
 * this entire object is really big and most of the information is not really useful. This function takes the response object and displays only
 * the information that we want.
 *
 * Certain information such as the TLSSocket and the Readable state are not really useful for diagnostic purposes so they can be avoided.
 * Other information such as the headers, the response code and message might be useful, so this is displayed.
 */
function displayHttpDiagnostics(response) {
    core_1.info(`##### Begin Diagnostic HTTP information #####
Status Code: ${response.message.statusCode}
Status Message: ${response.message.statusMessage}
Header Information: ${JSON.stringify(response.message.headers, undefined, 2)}
###### End Diagnostic HTTP information ######`);
}
exports.displayHttpDiagnostics = displayHttpDiagnostics;
function createDirectoriesForArtifact(directories) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const directory of directories) {
            yield fs_1.promises.mkdir(directory, {
                recursive: true
            });
        }
    });
}
exports.createDirectoriesForArtifact = createDirectoriesForArtifact;
function createEmptyFilesForArtifact(emptyFilesToCreate) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const filePath of emptyFilesToCreate) {
            yield (yield fs_1.promises.open(filePath, 'w')).close();
        }
    });
}
exports.createEmptyFilesForArtifact = createEmptyFilesForArtifact;
function getFileSize(filePath) {
    return __awaiter(this, void 0, void 0, function* () {
        const stats = yield fs_1.promises.stat(filePath);
        core_1.debug(`${filePath} size:(${stats.size}) blksize:(${stats.blksize}) blocks:(${stats.blocks})`);
        return stats.size;
    });
}
exports.getFileSize = getFileSize;
function rmFile(filePath) {
    return __awaiter(this, void 0, void 0, function* () {
        yield fs_1.promises.unlink(filePath);
    });
}
exports.rmFile = rmFile;
function getProperRetention(retentionInput, retentionSetting) {
    if (retentionInput < 0) {
        throw new Error('Invalid retention, minimum value is 1.');
    }
    let retention = retentionInput;
    if (retentionSetting) {
        const maxRetention = parseInt(retentionSetting);
        if (!isNaN(maxRetention) && maxRetention < retention) {
            core_1.warning(`Retention days is greater than the max value allowed by the repository setting, reduce retention to ${maxRetention} days`);
            retention = maxRetention;
        }
    }
    return retention;
}
exports.getProperRetention = getProperRetention;
function sleep(milliseconds) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise(resolve => setTimeout(resolve, milliseconds));
    });
}
exports.sleep = sleep;
function digestForStream(stream) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const crc64 = new crc64_1.default();
            const md5 = crypto_1.default.createHash('md5');
            stream
                .on('data', data => {
                crc64.update(data);
                md5.update(data);
            })
                .on('end', () => resolve({
                crc64: crc64.digest('base64'),
                md5: md5.digest('base64')
            }))
                .on('error', reject);
        });
    });
}
exports.digestForStream = digestForStream;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 7351:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issue = exports.issueCommand = void 0;
const os = __importStar(__nccwpck_require__(2037));
const utils_1 = __nccwpck_require__(5278);
/**
 * Commands
 *
 * Command Format:
 *   ::name key=value,key=value::message
 *
 * Examples:
 *   ::warning::This is the message
 *   ::set-env name=MY_VAR::some value
 */
function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
}
exports.issueCommand = issueCommand;
function issue(name, message = '') {
    issueCommand(name, {}, message);
}
exports.issue = issue;
const CMD_STRING = '::';
class Command {
    constructor(command, properties, message) {
        if (!command) {
            command = 'missing.command';
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
    }
    toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += ' ';
            let first = true;
            for (const key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    const val = this.properties[key];
                    if (val) {
                        if (first) {
                            first = false;
                        }
                        else {
                            cmdStr += ',';
                        }
                        cmdStr += `${key}=${escapeProperty(val)}`;
                    }
                }
            }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
    }
}
function escapeData(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A');
}
function escapeProperty(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A')
        .replace(/:/g, '%3A')
        .replace(/,/g, '%2C');
}
//# sourceMappingURL=command.js.map

/***/ }),

/***/ 2186:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
const command_1 = __nccwpck_require__(7351);
const file_command_1 = __nccwpck_require__(717);
const utils_1 = __nccwpck_require__(5278);
const os = __importStar(__nccwpck_require__(2037));
const path = __importStar(__nccwpck_require__(1017));
const oidc_utils_1 = __nccwpck_require__(8041);
/**
 * The code to exit an action
 */
var ExitCode;
(function (ExitCode) {
    /**
     * A code indicating that the action was successful
     */
    ExitCode[ExitCode["Success"] = 0] = "Success";
    /**
     * A code indicating that the action was a failure
     */
    ExitCode[ExitCode["Failure"] = 1] = "Failure";
})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
//-----------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------
/**
 * Sets env variable for this action and future actions in the job
 * @param name the name of the variable to set
 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function exportVariable(name, val) {
    const convertedVal = utils_1.toCommandValue(val);
    process.env[name] = convertedVal;
    const filePath = process.env['GITHUB_ENV'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('ENV', file_command_1.prepareKeyValueMessage(name, val));
    }
    command_1.issueCommand('set-env', { name }, convertedVal);
}
exports.exportVariable = exportVariable;
/**
 * Registers a secret which will get masked from logs
 * @param secret value of the secret
 */
function setSecret(secret) {
    command_1.issueCommand('add-mask', {}, secret);
}
exports.setSecret = setSecret;
/**
 * Prepends inputPath to the PATH (for this action and future actions)
 * @param inputPath
 */
function addPath(inputPath) {
    const filePath = process.env['GITHUB_PATH'] || '';
    if (filePath) {
        file_command_1.issueFileCommand('PATH', inputPath);
    }
    else {
        command_1.issueCommand('add-path', {}, inputPath);
    }
    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
}
exports.addPath = addPath;
/**
 * Gets the value of an input.
 * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
 * Returns an empty string if the value is not defined.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string
 */
function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
    if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
    }
    if (options && options.trimWhitespace === false) {
        return val;
    }
    return val.trim();
}
exports.getInput = getInput;
/**
 * Gets the values of an multiline input.  Each value is also trimmed.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string[]
 *
 */
function getMultilineInput(name, options) {
    const inputs = getInput(name, options)
        .split('\n')
        .filter(x => x !== '');
    if (options && options.trimWhitespace === false) {
        return inputs;
    }
    return inputs.map(input => input.trim());
}
exports.getMultilineInput = getMultilineInput;
/**
 * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
 * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
 * The return value is also in boolean type.
 * ref: https://yaml.org/spec/1.2/spec.html#id2804923
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   boolean
 */
function getBooleanInput(name, options) {
    const trueValue = ['true', 'True', 'TRUE'];
    const falseValue = ['false', 'False', 'FALSE'];
    const val = getInput(name, options);
    if (trueValue.includes(val))
        return true;
    if (falseValue.includes(val))
        return false;
    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
        `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
}
exports.getBooleanInput = getBooleanInput;
/**
 * Sets the value of an output.
 *
 * @param     name     name of the output to set
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setOutput(name, value) {
    const filePath = process.env['GITHUB_OUTPUT'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('OUTPUT', file_command_1.prepareKeyValueMessage(name, value));
    }
    process.stdout.write(os.EOL);
    command_1.issueCommand('set-output', { name }, utils_1.toCommandValue(value));
}
exports.setOutput = setOutput;
/**
 * Enables or disables the echoing of commands into stdout for the rest of the step.
 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
 *
 */
function setCommandEcho(enabled) {
    command_1.issue('echo', enabled ? 'on' : 'off');
}
exports.setCommandEcho = setCommandEcho;
//-----------------------------------------------------------------------
// Results
//-----------------------------------------------------------------------
/**
 * Sets the action status to failed.
 * When the action exits it will be with an exit code of 1
 * @param message add error issue message
 */
function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
}
exports.setFailed = setFailed;
//-----------------------------------------------------------------------
// Logging Commands
//-----------------------------------------------------------------------
/**
 * Gets whether Actions Step Debug is on or not
 */
function isDebug() {
    return process.env['RUNNER_DEBUG'] === '1';
}
exports.isDebug = isDebug;
/**
 * Writes debug message to user log
 * @param message debug message
 */
function debug(message) {
    command_1.issueCommand('debug', {}, message);
}
exports.debug = debug;
/**
 * Adds an error issue
 * @param message error issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function error(message, properties = {}) {
    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.error = error;
/**
 * Adds a warning issue
 * @param message warning issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function warning(message, properties = {}) {
    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.warning = warning;
/**
 * Adds a notice issue
 * @param message notice issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function notice(message, properties = {}) {
    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.notice = notice;
/**
 * Writes info to log with console.log.
 * @param message info message
 */
function info(message) {
    process.stdout.write(message + os.EOL);
}
exports.info = info;
/**
 * Begin an output group.
 *
 * Output until the next `groupEnd` will be foldable in this group
 *
 * @param name The name of the output group
 */
function startGroup(name) {
    command_1.issue('group', name);
}
exports.startGroup = startGroup;
/**
 * End an output group.
 */
function endGroup() {
    command_1.issue('endgroup');
}
exports.endGroup = endGroup;
/**
 * Wrap an asynchronous function call in a group.
 *
 * Returns the same type as the function itself.
 *
 * @param name The name of the group
 * @param fn The function to wrap in the group
 */
function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
            result = yield fn();
        }
        finally {
            endGroup();
        }
        return result;
    });
}
exports.group = group;
//-----------------------------------------------------------------------
// Wrapper action state
//-----------------------------------------------------------------------
/**
 * Saves state for current action, the state can only be retrieved by this action's post job execution.
 *
 * @param     name     name of the state to store
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function saveState(name, value) {
    const filePath = process.env['GITHUB_STATE'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('STATE', file_command_1.prepareKeyValueMessage(name, value));
    }
    command_1.issueCommand('save-state', { name }, utils_1.toCommandValue(value));
}
exports.saveState = saveState;
/**
 * Gets the value of an state set by this action's main execution.
 *
 * @param     name     name of the state to get
 * @returns   string
 */
function getState(name) {
    return process.env[`STATE_${name}`] || '';
}
exports.getState = getState;
function getIDToken(aud) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
    });
}
exports.getIDToken = getIDToken;
/**
 * Summary exports
 */
var summary_1 = __nccwpck_require__(1327);
Object.defineProperty(exports, "summary", ({ enumerable: true, get: function () { return summary_1.summary; } }));
/**
 * @deprecated use core.summary
 */
var summary_2 = __nccwpck_require__(1327);
Object.defineProperty(exports, "markdownSummary", ({ enumerable: true, get: function () { return summary_2.markdownSummary; } }));
/**
 * Path exports
 */
var path_utils_1 = __nccwpck_require__(2981);
Object.defineProperty(exports, "toPosixPath", ({ enumerable: true, get: function () { return path_utils_1.toPosixPath; } }));
Object.defineProperty(exports, "toWin32Path", ({ enumerable: true, get: function () { return path_utils_1.toWin32Path; } }));
Object.defineProperty(exports, "toPlatformPath", ({ enumerable: true, get: function () { return path_utils_1.toPlatformPath; } }));
//# sourceMappingURL=core.js.map

/***/ }),

/***/ 717:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

// For internal use, subject to change.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
const fs = __importStar(__nccwpck_require__(7147));
const os = __importStar(__nccwpck_require__(2037));
const uuid_1 = __nccwpck_require__(5840);
const utils_1 = __nccwpck_require__(5278);
function issueFileCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: 'utf8'
    });
}
exports.issueFileCommand = issueFileCommand;
function prepareKeyValueMessage(key, value) {
    const delimiter = `ghadelimiter_${uuid_1.v4()}`;
    const convertedValue = utils_1.toCommandValue(value);
    // These should realistically never happen, but just in case someone finds a
    // way to exploit uuid generation let's not allow keys or values that contain
    // the delimiter.
    if (key.includes(delimiter)) {
        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
    }
    if (convertedValue.includes(delimiter)) {
        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
    }
    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
}
exports.prepareKeyValueMessage = prepareKeyValueMessage;
//# sourceMappingURL=file-command.js.map

/***/ }),

/***/ 8041:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OidcClient = void 0;
const http_client_1 = __nccwpck_require__(6255);
const auth_1 = __nccwpck_require__(5526);
const core_1 = __nccwpck_require__(2186);
class OidcClient {
    static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
            allowRetries: allowRetry,
            maxRetries: maxRetry
        };
        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
    }
    static getRequestToken() {
        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
        if (!token) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
        }
        return token;
    }
    static getIDTokenUrl() {
        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
        if (!runtimeUrl) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
        }
        return runtimeUrl;
    }
    static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const httpclient = OidcClient.createHttpClient();
            const res = yield httpclient
                .getJson(id_token_url)
                .catch(error => {
                throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.result.message}`);
            });
            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
            if (!id_token) {
                throw new Error('Response json body do not have ID Token field');
            }
            return id_token;
        });
    }
    static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // New ID Token is requested from action service
                let id_token_url = OidcClient.getIDTokenUrl();
                if (audience) {
                    const encodedAudience = encodeURIComponent(audience);
                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;
                }
                core_1.debug(`ID token url is ${id_token_url}`);
                const id_token = yield OidcClient.getCall(id_token_url);
                core_1.setSecret(id_token);
                return id_token;
            }
            catch (error) {
                throw new Error(`Error message: ${error.message}`);
            }
        });
    }
}
exports.OidcClient = OidcClient;
//# sourceMappingURL=oidc-utils.js.map

/***/ }),

/***/ 2981:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
const path = __importStar(__nccwpck_require__(1017));
/**
 * toPosixPath converts the given path to the posix form. On Windows, \\ will be
 * replaced with /.
 *
 * @param pth. Path to transform.
 * @return string Posix path.
 */
function toPosixPath(pth) {
    return pth.replace(/[\\]/g, '/');
}
exports.toPosixPath = toPosixPath;
/**
 * toWin32Path converts the given path to the win32 form. On Linux, / will be
 * replaced with \\.
 *
 * @param pth. Path to transform.
 * @return string Win32 path.
 */
function toWin32Path(pth) {
    return pth.replace(/[/]/g, '\\');
}
exports.toWin32Path = toWin32Path;
/**
 * toPlatformPath converts the given path to a platform-specific path. It does
 * this by replacing instances of / and \ with the platform-specific path
 * separator.
 *
 * @param pth The path to platformize.
 * @return string The platform-specific path.
 */
function toPlatformPath(pth) {
    return pth.replace(/[/\\]/g, path.sep);
}
exports.toPlatformPath = toPlatformPath;
//# sourceMappingURL=path-utils.js.map

/***/ }),

/***/ 1327:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
const os_1 = __nccwpck_require__(2037);
const fs_1 = __nccwpck_require__(7147);
const { access, appendFile, writeFile } = fs_1.promises;
exports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';
exports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';
class Summary {
    constructor() {
        this._buffer = '';
    }
    /**
     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
     * Also checks r/w permissions.
     *
     * @returns step summary file path
     */
    filePath() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._filePath) {
                return this._filePath;
            }
            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
            if (!pathFromEnv) {
                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
            }
            try {
                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
            }
            catch (_a) {
                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
            }
            this._filePath = pathFromEnv;
            return this._filePath;
        });
    }
    /**
     * Wraps content in an HTML tag, adding any HTML attributes
     *
     * @param {string} tag HTML tag to wrap
     * @param {string | null} content content within the tag
     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
     *
     * @returns {string} content wrapped in HTML element
     */
    wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs)
            .map(([key, value]) => ` ${key}="${value}"`)
            .join('');
        if (!content) {
            return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
    }
    /**
     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
     *
     * @param {SummaryWriteOptions} [options] (optional) options for write operation
     *
     * @returns {Promise<Summary>} summary instance
     */
    write(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
            const filePath = yield this.filePath();
            const writeFunc = overwrite ? writeFile : appendFile;
            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });
            return this.emptyBuffer();
        });
    }
    /**
     * Clears the summary buffer and wipes the summary file
     *
     * @returns {Summary} summary instance
     */
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.emptyBuffer().write({ overwrite: true });
        });
    }
    /**
     * Returns the current summary buffer as a string
     *
     * @returns {string} string of summary buffer
     */
    stringify() {
        return this._buffer;
    }
    /**
     * If the summary buffer is empty
     *
     * @returns {boolen} true if the buffer is empty
     */
    isEmptyBuffer() {
        return this._buffer.length === 0;
    }
    /**
     * Resets the summary buffer without writing to summary file
     *
     * @returns {Summary} summary instance
     */
    emptyBuffer() {
        this._buffer = '';
        return this;
    }
    /**
     * Adds raw text to the summary buffer
     *
     * @param {string} text content to add
     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
     *
     * @returns {Summary} summary instance
     */
    addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
    }
    /**
     * Adds the operating system-specific end-of-line marker to the buffer
     *
     * @returns {Summary} summary instance
     */
    addEOL() {
        return this.addRaw(os_1.EOL);
    }
    /**
     * Adds an HTML codeblock to the summary buffer
     *
     * @param {string} code content to render within fenced code block
     * @param {string} lang (optional) language to syntax highlight code
     *
     * @returns {Summary} summary instance
     */
    addCodeBlock(code, lang) {
        const attrs = Object.assign({}, (lang && { lang }));
        const element = this.wrap('pre', this.wrap('code', code), attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML list to the summary buffer
     *
     * @param {string[]} items list of items to render
     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
     *
     * @returns {Summary} summary instance
     */
    addList(items, ordered = false) {
        const tag = ordered ? 'ol' : 'ul';
        const listItems = items.map(item => this.wrap('li', item)).join('');
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML table to the summary buffer
     *
     * @param {SummaryTableCell[]} rows table rows
     *
     * @returns {Summary} summary instance
     */
    addTable(rows) {
        const tableBody = rows
            .map(row => {
            const cells = row
                .map(cell => {
                if (typeof cell === 'string') {
                    return this.wrap('td', cell);
                }
                const { header, data, colspan, rowspan } = cell;
                const tag = header ? 'th' : 'td';
                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));
                return this.wrap(tag, data, attrs);
            })
                .join('');
            return this.wrap('tr', cells);
        })
            .join('');
        const element = this.wrap('table', tableBody);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds a collapsable HTML details element to the summary buffer
     *
     * @param {string} label text for the closed state
     * @param {string} content collapsable content
     *
     * @returns {Summary} summary instance
     */
    addDetails(label, content) {
        const element = this.wrap('details', this.wrap('summary', label) + content);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML image tag to the summary buffer
     *
     * @param {string} src path to the image you to embed
     * @param {string} alt text description of the image
     * @param {SummaryImageOptions} options (optional) addition image attributes
     *
     * @returns {Summary} summary instance
     */
    addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));
        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML section heading element
     *
     * @param {string} text heading text
     * @param {number | string} [level=1] (optional) the heading level, default: 1
     *
     * @returns {Summary} summary instance
     */
    addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)
            ? tag
            : 'h1';
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML thematic break (<hr>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addSeparator() {
        const element = this.wrap('hr', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML line break (<br>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addBreak() {
        const element = this.wrap('br', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML blockquote to the summary buffer
     *
     * @param {string} text quote text
     * @param {string} cite (optional) citation url
     *
     * @returns {Summary} summary instance
     */
    addQuote(text, cite) {
        const attrs = Object.assign({}, (cite && { cite }));
        const element = this.wrap('blockquote', text, attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML anchor tag to the summary buffer
     *
     * @param {string} text link text/content
     * @param {string} href hyperlink
     *
     * @returns {Summary} summary instance
     */
    addLink(text, href) {
        const element = this.wrap('a', text, { href });
        return this.addRaw(element).addEOL();
    }
}
const _summary = new Summary();
/**
 * @deprecated use `core.summary`
 */
exports.markdownSummary = _summary;
exports.summary = _summary;
//# sourceMappingURL=summary.js.map

/***/ }),

/***/ 5278:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toCommandProperties = exports.toCommandValue = void 0;
/**
 * Sanitizes an input into a string so it can be passed into issueCommand safely
 * @param input input to sanitize into a string
 */
function toCommandValue(input) {
    if (input === null || input === undefined) {
        return '';
    }
    else if (typeof input === 'string' || input instanceof String) {
        return input;
    }
    return JSON.stringify(input);
}
exports.toCommandValue = toCommandValue;
/**
 *
 * @param annotationProperties
 * @returns The command properties to send with the actual annotation command
 * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
 */
function toCommandProperties(annotationProperties) {
    if (!Object.keys(annotationProperties).length) {
        return {};
    }
    return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
    };
}
exports.toCommandProperties = toCommandProperties;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 4087:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Context = void 0;
const fs_1 = __nccwpck_require__(7147);
const os_1 = __nccwpck_require__(2037);
class Context {
    /**
     * Hydrate the context from the environment
     */
    constructor() {
        var _a, _b, _c;
        this.payload = {};
        if (process.env.GITHUB_EVENT_PATH) {
            if (fs_1.existsSync(process.env.GITHUB_EVENT_PATH)) {
                this.payload = JSON.parse(fs_1.readFileSync(process.env.GITHUB_EVENT_PATH, { encoding: 'utf8' }));
            }
            else {
                const path = process.env.GITHUB_EVENT_PATH;
                process.stdout.write(`GITHUB_EVENT_PATH ${path} does not exist${os_1.EOL}`);
            }
        }
        this.eventName = process.env.GITHUB_EVENT_NAME;
        this.sha = process.env.GITHUB_SHA;
        this.ref = process.env.GITHUB_REF;
        this.workflow = process.env.GITHUB_WORKFLOW;
        this.action = process.env.GITHUB_ACTION;
        this.actor = process.env.GITHUB_ACTOR;
        this.job = process.env.GITHUB_JOB;
        this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
        this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
        this.apiUrl = (_a = process.env.GITHUB_API_URL) !== null && _a !== void 0 ? _a : `https://api.github.com`;
        this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== void 0 ? _b : `https://github.com`;
        this.graphqlUrl = (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== void 0 ? _c : `https://api.github.com/graphql`;
    }
    get issue() {
        const payload = this.payload;
        return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
    }
    get repo() {
        if (process.env.GITHUB_REPOSITORY) {
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
            return { owner, repo };
        }
        if (this.payload.repository) {
            return {
                owner: this.payload.repository.owner.login,
                repo: this.payload.repository.name
            };
        }
        throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
    }
}
exports.Context = Context;
//# sourceMappingURL=context.js.map

/***/ }),

/***/ 5438:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOctokit = exports.context = void 0;
const Context = __importStar(__nccwpck_require__(4087));
const utils_1 = __nccwpck_require__(3030);
exports.context = new Context.Context();
/**
 * Returns a hydrated octokit ready to use for GitHub Actions
 *
 * @param     token    the repo PAT or GITHUB_TOKEN
 * @param     options  other options to set
 */
function getOctokit(token, options, ...additionalPlugins) {
    const GitHubWithPlugins = utils_1.GitHub.plugin(...additionalPlugins);
    return new GitHubWithPlugins(utils_1.getOctokitOptions(token, options));
}
exports.getOctokit = getOctokit;
//# sourceMappingURL=github.js.map

/***/ }),

/***/ 7914:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getApiBaseUrl = exports.getProxyAgent = exports.getAuthString = void 0;
const httpClient = __importStar(__nccwpck_require__(6255));
function getAuthString(token, options) {
    if (!token && !options.auth) {
        throw new Error('Parameter token or opts.auth is required');
    }
    else if (token && options.auth) {
        throw new Error('Parameters token and opts.auth may not both be specified');
    }
    return typeof options.auth === 'string' ? options.auth : `token ${token}`;
}
exports.getAuthString = getAuthString;
function getProxyAgent(destinationUrl) {
    const hc = new httpClient.HttpClient();
    return hc.getAgent(destinationUrl);
}
exports.getProxyAgent = getProxyAgent;
function getApiBaseUrl() {
    return process.env['GITHUB_API_URL'] || 'https://api.github.com';
}
exports.getApiBaseUrl = getApiBaseUrl;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 3030:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOctokitOptions = exports.GitHub = exports.defaults = exports.context = void 0;
const Context = __importStar(__nccwpck_require__(4087));
const Utils = __importStar(__nccwpck_require__(7914));
// octokit + plugins
const core_1 = __nccwpck_require__(8525);
const plugin_rest_endpoint_methods_1 = __nccwpck_require__(4045);
const plugin_paginate_rest_1 = __nccwpck_require__(8945);
exports.context = new Context.Context();
const baseUrl = Utils.getApiBaseUrl();
exports.defaults = {
    baseUrl,
    request: {
        agent: Utils.getProxyAgent(baseUrl)
    }
};
exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(exports.defaults);
/**
 * Convience function to correctly format Octokit Options to pass into the constructor.
 *
 * @param     token    the repo PAT or GITHUB_TOKEN
 * @param     options  other options to set
 */
function getOctokitOptions(token, options) {
    const opts = Object.assign({}, options || {}); // Shallow clone - don't mutate the object provided by the caller
    // Auth
    const auth = Utils.getAuthString(token, opts);
    if (auth) {
        opts.auth = auth;
    }
    return opts;
}
exports.getOctokitOptions = getOctokitOptions;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 673:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
const REGEX_IS_INSTALLATION = /^ghs_/;
const REGEX_IS_USER_TO_SERVER = /^ghu_/;
async function auth(token) {
  const isApp = token.split(/\./).length === 3;
  const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
  const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
  const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
  return {
    type: "token",
    token: token,
    tokenType
  };
}

/**
 * Prefix token for usage in the Authorization header
 *
 * @param token OAuth token or JSON Web Token
 */
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }

  return `token ${token}`;
}

async function hook(token, request, route, parameters) {
  const endpoint = request.endpoint.merge(route, parameters);
  endpoint.headers.authorization = withAuthorizationPrefix(token);
  return request(endpoint);
}

const createTokenAuth = function createTokenAuth(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }

  if (typeof token !== "string") {
    throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
  }

  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

exports.createTokenAuth = createTokenAuth;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 8525:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var universalUserAgent = __nccwpck_require__(5030);
var beforeAfterHook = __nccwpck_require__(3682);
var request = __nccwpck_require__(6234);
var graphql = __nccwpck_require__(6422);
var authToken = __nccwpck_require__(673);

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

const VERSION = "3.6.0";

const _excluded = ["authStrategy"];
class Octokit {
  constructor(options = {}) {
    const hook = new beforeAfterHook.Collection();
    const requestDefaults = {
      baseUrl: request.request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        // @ts-ignore internal usage only, no need to type
        hook: hook.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    }; // prepend default user agent with `options.userAgent` if set

    requestDefaults.headers["user-agent"] = [options.userAgent, `octokit-core.js/${VERSION} ${universalUserAgent.getUserAgent()}`].filter(Boolean).join(" ");

    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }

    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }

    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }

    this.request = request.request.defaults(requestDefaults);
    this.graphql = graphql.withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign({
      debug: () => {},
      info: () => {},
      warn: console.warn.bind(console),
      error: console.error.bind(console)
    }, options.log);
    this.hook = hook; // (1) If neither `options.authStrategy` nor `options.auth` are set, the `octokit` instance
    //     is unauthenticated. The `this.auth()` method is a no-op and no request hook is registered.
    // (2) If only `options.auth` is set, use the default token authentication strategy.
    // (3) If `options.authStrategy` is set then use it and pass in `options.auth`. Always pass own request as many strategies accept a custom request instance.
    // TODO: type `options.auth` based on `options.authStrategy`.

    if (!options.authStrategy) {
      if (!options.auth) {
        // (1)
        this.auth = async () => ({
          type: "unauthenticated"
        });
      } else {
        // (2)
        const auth = authToken.createTokenAuth(options.auth); // @ts-ignore  ¯\_(ツ)_/¯

        hook.wrap("request", auth.hook);
        this.auth = auth;
      }
    } else {
      const {
        authStrategy
      } = options,
            otherOptions = _objectWithoutProperties(options, _excluded);

      const auth = authStrategy(Object.assign({
        request: this.request,
        log: this.log,
        // we pass the current octokit instance as well as its constructor options
        // to allow for authentication strategies that return a new octokit instance
        // that shares the same internal state as the current one. The original
        // requirement for this was the "event-octokit" authentication strategy
        // of https://github.com/probot/octokit-auth-probot.
        octokit: this,
        octokitOptions: otherOptions
      }, options.auth)); // @ts-ignore  ¯\_(ツ)_/¯

      hook.wrap("request", auth.hook);
      this.auth = auth;
    } // apply plugins
    // https://stackoverflow.com/a/16345172


    const classConstructor = this.constructor;
    classConstructor.plugins.forEach(plugin => {
      Object.assign(this, plugin(this, options));
    });
  }

  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};

        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }

        super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
          userAgent: `${options.userAgent} ${defaults.userAgent}`
        } : null));
      }

    };
    return OctokitWithDefaults;
  }
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */


  static plugin(...newPlugins) {
    var _a;

    const currentPlugins = this.plugins;
    const NewOctokit = (_a = class extends this {}, _a.plugins = currentPlugins.concat(newPlugins.filter(plugin => !currentPlugins.includes(plugin))), _a);
    return NewOctokit;
  }

}
Octokit.VERSION = VERSION;
Octokit.plugins = [];

exports.Octokit = Octokit;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 6422:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var request = __nccwpck_require__(6234);
var universalUserAgent = __nccwpck_require__(5030);

const VERSION = "4.8.0";

function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:\n` + data.errors.map(e => ` - ${e.message}`).join("\n");
}

class GraphqlResponseError extends Error {
  constructor(request, headers, response) {
    super(_buildMessageForResponseErrors(response));
    this.request = request;
    this.headers = headers;
    this.response = response;
    this.name = "GraphqlResponseError"; // Expose the errors and response data in their shorthand properties.

    this.errors = response.errors;
    this.data = response.data; // Maintains proper stack trace (only available on V8)

    /* istanbul ignore next */

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }

}

const NON_VARIABLE_OPTIONS = ["method", "baseUrl", "url", "headers", "request", "query", "mediaType"];
const FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
const GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
    }

    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;
      return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
    }
  }

  const parsedOptions = typeof query === "string" ? Object.assign({
    query
  }, options) : query;
  const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }

    if (!result.variables) {
      result.variables = {};
    }

    result.variables[key] = parsedOptions[key];
    return result;
  }, {}); // workaround for GitHub Enterprise baseUrl set with /api/v3 suffix
  // https://github.com/octokit/auth-app.js/issues/111#issuecomment-657610451

  const baseUrl = parsedOptions.baseUrl || request.endpoint.DEFAULTS.baseUrl;

  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }

  return request(requestOptions).then(response => {
    if (response.data.errors) {
      const headers = {};

      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }

      throw new GraphqlResponseError(requestOptions, headers, response.data);
    }

    return response.data.data;
  });
}

function withDefaults(request$1, newDefaults) {
  const newRequest = request$1.defaults(newDefaults);

  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };

  return Object.assign(newApi, {
    defaults: withDefaults.bind(null, newRequest),
    endpoint: request.request.endpoint
  });
}

const graphql$1 = withDefaults(request.request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION} ${universalUserAgent.getUserAgent()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

exports.GraphqlResponseError = GraphqlResponseError;
exports.graphql = graphql$1;
exports.withCustomRequest = withCustomRequest;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 8945:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

const VERSION = "2.21.2";

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/**
 * Some “list” response that can be paginated have a different response structure
 *
 * They have a `total_count` key in the response (search also has `incomplete_results`,
 * /installation/repositories also has `repository_selection`), as well as a key with
 * the list of the items which name varies from endpoint to endpoint.
 *
 * Octokit normalizes these responses so that paginated results are always returned following
 * the same structure. One challenge is that if the list response has only one page, no Link
 * header is provided, so this header alone is not sufficient to check wether a response is
 * paginated or not.
 *
 * We check if a "total_count" key is present in the response data, but also make sure that
 * a "url" property is not, as the "Get the combined status for a specific ref" endpoint would
 * otherwise match: https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-ref
 */
function normalizePaginatedListResponse(response) {
  // endpoints can respond with 204 if repository is empty
  if (!response.data) {
    return _objectSpread2(_objectSpread2({}, response), {}, {
      data: []
    });
  }

  const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
  if (!responseNeedsNormalization) return response; // keep the additional properties intact as there is currently no other way
  // to retrieve the same information.

  const incompleteResults = response.data.incomplete_results;
  const repositorySelection = response.data.repository_selection;
  const totalCount = response.data.total_count;
  delete response.data.incomplete_results;
  delete response.data.repository_selection;
  delete response.data.total_count;
  const namespaceKey = Object.keys(response.data)[0];
  const data = response.data[namespaceKey];
  response.data = data;

  if (typeof incompleteResults !== "undefined") {
    response.data.incomplete_results = incompleteResults;
  }

  if (typeof repositorySelection !== "undefined") {
    response.data.repository_selection = repositorySelection;
  }

  response.data.total_count = totalCount;
  return response;
}

function iterator(octokit, route, parameters) {
  const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
  const requestMethod = typeof route === "function" ? route : octokit.request;
  const method = options.method;
  const headers = options.headers;
  let url = options.url;
  return {
    [Symbol.asyncIterator]: () => ({
      async next() {
        if (!url) return {
          done: true
        };

        try {
          const response = await requestMethod({
            method,
            url,
            headers
          });
          const normalizedResponse = normalizePaginatedListResponse(response); // `response.headers.link` format:
          // '<https://api.github.com/users/aseemk/followers?page=2>; rel="next", <https://api.github.com/users/aseemk/followers?page=2>; rel="last"'
          // sets `url` to undefined if "next" URL is not present or `link` header is not set

          url = ((normalizedResponse.headers.link || "").match(/<([^>]+)>;\s*rel="next"/) || [])[1];
          return {
            value: normalizedResponse
          };
        } catch (error) {
          if (error.status !== 409) throw error;
          url = "";
          return {
            value: {
              status: 200,
              headers: {},
              data: []
            }
          };
        }
      }

    })
  };
}

function paginate(octokit, route, parameters, mapFn) {
  if (typeof parameters === "function") {
    mapFn = parameters;
    parameters = undefined;
  }

  return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
}

function gather(octokit, results, iterator, mapFn) {
  return iterator.next().then(result => {
    if (result.done) {
      return results;
    }

    let earlyExit = false;

    function done() {
      earlyExit = true;
    }

    results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);

    if (earlyExit) {
      return results;
    }

    return gather(octokit, results, iterator, mapFn);
  });
}

const composePaginateRest = Object.assign(paginate, {
  iterator
});

const paginatingEndpoints = ["GET /app/hook/deliveries", "GET /app/installations", "GET /applications/grants", "GET /authorizations", "GET /enterprises/{enterprise}/actions/permissions/organizations", "GET /enterprises/{enterprise}/actions/runner-groups", "GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/organizations", "GET /enterprises/{enterprise}/actions/runner-groups/{runner_group_id}/runners", "GET /enterprises/{enterprise}/actions/runners", "GET /enterprises/{enterprise}/audit-log", "GET /enterprises/{enterprise}/secret-scanning/alerts", "GET /enterprises/{enterprise}/settings/billing/advanced-security", "GET /events", "GET /gists", "GET /gists/public", "GET /gists/starred", "GET /gists/{gist_id}/comments", "GET /gists/{gist_id}/commits", "GET /gists/{gist_id}/forks", "GET /installation/repositories", "GET /issues", "GET /licenses", "GET /marketplace_listing/plans", "GET /marketplace_listing/plans/{plan_id}/accounts", "GET /marketplace_listing/stubbed/plans", "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts", "GET /networks/{owner}/{repo}/events", "GET /notifications", "GET /organizations", "GET /orgs/{org}/actions/cache/usage-by-repository", "GET /orgs/{org}/actions/permissions/repositories", "GET /orgs/{org}/actions/runner-groups", "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories", "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners", "GET /orgs/{org}/actions/runners", "GET /orgs/{org}/actions/secrets", "GET /orgs/{org}/actions/secrets/{secret_name}/repositories", "GET /orgs/{org}/audit-log", "GET /orgs/{org}/blocks", "GET /orgs/{org}/code-scanning/alerts", "GET /orgs/{org}/codespaces", "GET /orgs/{org}/credential-authorizations", "GET /orgs/{org}/dependabot/secrets", "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories", "GET /orgs/{org}/events", "GET /orgs/{org}/external-groups", "GET /orgs/{org}/failed_invitations", "GET /orgs/{org}/hooks", "GET /orgs/{org}/hooks/{hook_id}/deliveries", "GET /orgs/{org}/installations", "GET /orgs/{org}/invitations", "GET /orgs/{org}/invitations/{invitation_id}/teams", "GET /orgs/{org}/issues", "GET /orgs/{org}/members", "GET /orgs/{org}/migrations", "GET /orgs/{org}/migrations/{migration_id}/repositories", "GET /orgs/{org}/outside_collaborators", "GET /orgs/{org}/packages", "GET /orgs/{org}/packages/{package_type}/{package_name}/versions", "GET /orgs/{org}/projects", "GET /orgs/{org}/public_members", "GET /orgs/{org}/repos", "GET /orgs/{org}/secret-scanning/alerts", "GET /orgs/{org}/settings/billing/advanced-security", "GET /orgs/{org}/team-sync/groups", "GET /orgs/{org}/teams", "GET /orgs/{org}/teams/{team_slug}/discussions", "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments", "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions", "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions", "GET /orgs/{org}/teams/{team_slug}/invitations", "GET /orgs/{org}/teams/{team_slug}/members", "GET /orgs/{org}/teams/{team_slug}/projects", "GET /orgs/{org}/teams/{team_slug}/repos", "GET /orgs/{org}/teams/{team_slug}/teams", "GET /projects/columns/{column_id}/cards", "GET /projects/{project_id}/collaborators", "GET /projects/{project_id}/columns", "GET /repos/{owner}/{repo}/actions/artifacts", "GET /repos/{owner}/{repo}/actions/caches", "GET /repos/{owner}/{repo}/actions/runners", "GET /repos/{owner}/{repo}/actions/runs", "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts", "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs", "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs", "GET /repos/{owner}/{repo}/actions/secrets", "GET /repos/{owner}/{repo}/actions/workflows", "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs", "GET /repos/{owner}/{repo}/assignees", "GET /repos/{owner}/{repo}/branches", "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations", "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs", "GET /repos/{owner}/{repo}/code-scanning/alerts", "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances", "GET /repos/{owner}/{repo}/code-scanning/analyses", "GET /repos/{owner}/{repo}/codespaces", "GET /repos/{owner}/{repo}/codespaces/devcontainers", "GET /repos/{owner}/{repo}/codespaces/secrets", "GET /repos/{owner}/{repo}/collaborators", "GET /repos/{owner}/{repo}/comments", "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions", "GET /repos/{owner}/{repo}/commits", "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments", "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls", "GET /repos/{owner}/{repo}/commits/{ref}/check-runs", "GET /repos/{owner}/{repo}/commits/{ref}/check-suites", "GET /repos/{owner}/{repo}/commits/{ref}/status", "GET /repos/{owner}/{repo}/commits/{ref}/statuses", "GET /repos/{owner}/{repo}/contributors", "GET /repos/{owner}/{repo}/dependabot/secrets", "GET /repos/{owner}/{repo}/deployments", "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses", "GET /repos/{owner}/{repo}/environments", "GET /repos/{owner}/{repo}/events", "GET /repos/{owner}/{repo}/forks", "GET /repos/{owner}/{repo}/git/matching-refs/{ref}", "GET /repos/{owner}/{repo}/hooks", "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries", "GET /repos/{owner}/{repo}/invitations", "GET /repos/{owner}/{repo}/issues", "GET /repos/{owner}/{repo}/issues/comments", "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions", "GET /repos/{owner}/{repo}/issues/events", "GET /repos/{owner}/{repo}/issues/{issue_number}/comments", "GET /repos/{owner}/{repo}/issues/{issue_number}/events", "GET /repos/{owner}/{repo}/issues/{issue_number}/labels", "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions", "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline", "GET /repos/{owner}/{repo}/keys", "GET /repos/{owner}/{repo}/labels", "GET /repos/{owner}/{repo}/milestones", "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels", "GET /repos/{owner}/{repo}/notifications", "GET /repos/{owner}/{repo}/pages/builds", "GET /repos/{owner}/{repo}/projects", "GET /repos/{owner}/{repo}/pulls", "GET /repos/{owner}/{repo}/pulls/comments", "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions", "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments", "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits", "GET /repos/{owner}/{repo}/pulls/{pull_number}/files", "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers", "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews", "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments", "GET /repos/{owner}/{repo}/releases", "GET /repos/{owner}/{repo}/releases/{release_id}/assets", "GET /repos/{owner}/{repo}/releases/{release_id}/reactions", "GET /repos/{owner}/{repo}/secret-scanning/alerts", "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations", "GET /repos/{owner}/{repo}/stargazers", "GET /repos/{owner}/{repo}/subscribers", "GET /repos/{owner}/{repo}/tags", "GET /repos/{owner}/{repo}/teams", "GET /repos/{owner}/{repo}/topics", "GET /repositories", "GET /repositories/{repository_id}/environments/{environment_name}/secrets", "GET /search/code", "GET /search/commits", "GET /search/issues", "GET /search/labels", "GET /search/repositories", "GET /search/topics", "GET /search/users", "GET /teams/{team_id}/discussions", "GET /teams/{team_id}/discussions/{discussion_number}/comments", "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions", "GET /teams/{team_id}/discussions/{discussion_number}/reactions", "GET /teams/{team_id}/invitations", "GET /teams/{team_id}/members", "GET /teams/{team_id}/projects", "GET /teams/{team_id}/repos", "GET /teams/{team_id}/teams", "GET /user/blocks", "GET /user/codespaces", "GET /user/codespaces/secrets", "GET /user/emails", "GET /user/followers", "GET /user/following", "GET /user/gpg_keys", "GET /user/installations", "GET /user/installations/{installation_id}/repositories", "GET /user/issues", "GET /user/keys", "GET /user/marketplace_purchases", "GET /user/marketplace_purchases/stubbed", "GET /user/memberships/orgs", "GET /user/migrations", "GET /user/migrations/{migration_id}/repositories", "GET /user/orgs", "GET /user/packages", "GET /user/packages/{package_type}/{package_name}/versions", "GET /user/public_emails", "GET /user/repos", "GET /user/repository_invitations", "GET /user/starred", "GET /user/subscriptions", "GET /user/teams", "GET /users", "GET /users/{username}/events", "GET /users/{username}/events/orgs/{org}", "GET /users/{username}/events/public", "GET /users/{username}/followers", "GET /users/{username}/following", "GET /users/{username}/gists", "GET /users/{username}/gpg_keys", "GET /users/{username}/keys", "GET /users/{username}/orgs", "GET /users/{username}/packages", "GET /users/{username}/projects", "GET /users/{username}/received_events", "GET /users/{username}/received_events/public", "GET /users/{username}/repos", "GET /users/{username}/starred", "GET /users/{username}/subscriptions"];

function isPaginatingEndpoint(arg) {
  if (typeof arg === "string") {
    return paginatingEndpoints.includes(arg);
  } else {
    return false;
  }
}

/**
 * @param octokit Octokit instance
 * @param options Options passed to Octokit constructor
 */

function paginateRest(octokit) {
  return {
    paginate: Object.assign(paginate.bind(null, octokit), {
      iterator: iterator.bind(null, octokit)
    })
  };
}
paginateRest.VERSION = VERSION;

exports.composePaginateRest = composePaginateRest;
exports.isPaginatingEndpoint = isPaginatingEndpoint;
exports.paginateRest = paginateRest;
exports.paginatingEndpoints = paginatingEndpoints;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 4045:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

const Endpoints = {
  actions: {
    addCustomLabelsToSelfHostedRunnerForOrg: ["POST /orgs/{org}/actions/runners/{runner_id}/labels"],
    addCustomLabelsToSelfHostedRunnerForRepo: ["POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
    addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
    approveWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"],
    cancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"],
    createOrUpdateEnvironmentSecret: ["PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
    createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
    createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    createRegistrationTokenForOrg: ["POST /orgs/{org}/actions/runners/registration-token"],
    createRegistrationTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/registration-token"],
    createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
    createRemoveTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/remove-token"],
    createWorkflowDispatch: ["POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"],
    deleteActionsCacheById: ["DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"],
    deleteActionsCacheByKey: ["DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"],
    deleteArtifact: ["DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
    deleteEnvironmentSecret: ["DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
    deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
    deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    deleteSelfHostedRunnerFromOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}"],
    deleteSelfHostedRunnerFromRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"],
    deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
    deleteWorkflowRunLogs: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
    disableSelectedRepositoryGithubActionsOrganization: ["DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"],
    disableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"],
    downloadArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"],
    downloadJobLogsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"],
    downloadWorkflowRunAttemptLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"],
    downloadWorkflowRunLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
    enableSelectedRepositoryGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"],
    enableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"],
    getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
    getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
    getActionsCacheUsageByRepoForOrg: ["GET /orgs/{org}/actions/cache/usage-by-repository"],
    getActionsCacheUsageForEnterprise: ["GET /enterprises/{enterprise}/actions/cache/usage"],
    getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
    getAllowedActionsOrganization: ["GET /orgs/{org}/actions/permissions/selected-actions"],
    getAllowedActionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/selected-actions"],
    getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
    getEnvironmentPublicKey: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"],
    getEnvironmentSecret: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
    getGithubActionsDefaultWorkflowPermissionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions/workflow"],
    getGithubActionsDefaultWorkflowPermissionsOrganization: ["GET /orgs/{org}/actions/permissions/workflow"],
    getGithubActionsDefaultWorkflowPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/workflow"],
    getGithubActionsPermissionsOrganization: ["GET /orgs/{org}/actions/permissions"],
    getGithubActionsPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions"],
    getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
    getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
    getPendingDeploymentsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
    getRepoPermissions: ["GET /repos/{owner}/{repo}/actions/permissions", {}, {
      renamed: ["actions", "getGithubActionsPermissionsRepository"]
    }],
    getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
    getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    getReviewsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"],
    getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
    getSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}"],
    getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
    getWorkflowAccessToRepository: ["GET /repos/{owner}/{repo}/actions/permissions/access"],
    getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
    getWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"],
    getWorkflowRunUsage: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"],
    getWorkflowUsage: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"],
    listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
    listEnvironmentSecrets: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets"],
    listJobsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"],
    listJobsForWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"],
    listLabelsForSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}/labels"],
    listLabelsForSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
    listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
    listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
    listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
    listRunnerApplicationsForRepo: ["GET /repos/{owner}/{repo}/actions/runners/downloads"],
    listSelectedReposForOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}/repositories"],
    listSelectedRepositoriesEnabledGithubActionsOrganization: ["GET /orgs/{org}/actions/permissions/repositories"],
    listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
    listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
    listWorkflowRunArtifacts: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"],
    listWorkflowRuns: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"],
    listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
    reRunJobForWorkflowRun: ["POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"],
    reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
    reRunWorkflowFailedJobs: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"],
    removeAllCustomLabelsFromSelfHostedRunnerForOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}/labels"],
    removeAllCustomLabelsFromSelfHostedRunnerForRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
    removeCustomLabelFromSelfHostedRunnerForOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"],
    removeCustomLabelFromSelfHostedRunnerForRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"],
    removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
    reviewPendingDeploymentsForRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
    setAllowedActionsOrganization: ["PUT /orgs/{org}/actions/permissions/selected-actions"],
    setAllowedActionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"],
    setCustomLabelsForSelfHostedRunnerForOrg: ["PUT /orgs/{org}/actions/runners/{runner_id}/labels"],
    setCustomLabelsForSelfHostedRunnerForRepo: ["PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
    setGithubActionsDefaultWorkflowPermissionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/workflow"],
    setGithubActionsDefaultWorkflowPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions/workflow"],
    setGithubActionsDefaultWorkflowPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/workflow"],
    setGithubActionsPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions"],
    setGithubActionsPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions"],
    setSelectedReposForOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"],
    setSelectedRepositoriesEnabledGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories"],
    setWorkflowAccessToRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/access"]
  },
  activity: {
    checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
    deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
    deleteThreadSubscription: ["DELETE /notifications/threads/{thread_id}/subscription"],
    getFeeds: ["GET /feeds"],
    getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
    getThread: ["GET /notifications/threads/{thread_id}"],
    getThreadSubscriptionForAuthenticatedUser: ["GET /notifications/threads/{thread_id}/subscription"],
    listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
    listNotificationsForAuthenticatedUser: ["GET /notifications"],
    listOrgEventsForAuthenticatedUser: ["GET /users/{username}/events/orgs/{org}"],
    listPublicEvents: ["GET /events"],
    listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
    listPublicEventsForUser: ["GET /users/{username}/events/public"],
    listPublicOrgEvents: ["GET /orgs/{org}/events"],
    listReceivedEventsForUser: ["GET /users/{username}/received_events"],
    listReceivedPublicEventsForUser: ["GET /users/{username}/received_events/public"],
    listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
    listRepoNotificationsForAuthenticatedUser: ["GET /repos/{owner}/{repo}/notifications"],
    listReposStarredByAuthenticatedUser: ["GET /user/starred"],
    listReposStarredByUser: ["GET /users/{username}/starred"],
    listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
    listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
    listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
    listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
    markNotificationsAsRead: ["PUT /notifications"],
    markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
    markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
    setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
    setThreadSubscription: ["PUT /notifications/threads/{thread_id}/subscription"],
    starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
    unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
  },
  apps: {
    addRepoToInstallation: ["PUT /user/installations/{installation_id}/repositories/{repository_id}", {}, {
      renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"]
    }],
    addRepoToInstallationForAuthenticatedUser: ["PUT /user/installations/{installation_id}/repositories/{repository_id}"],
    checkToken: ["POST /applications/{client_id}/token"],
    createFromManifest: ["POST /app-manifests/{code}/conversions"],
    createInstallationAccessToken: ["POST /app/installations/{installation_id}/access_tokens"],
    deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
    deleteInstallation: ["DELETE /app/installations/{installation_id}"],
    deleteToken: ["DELETE /applications/{client_id}/token"],
    getAuthenticated: ["GET /app"],
    getBySlug: ["GET /apps/{app_slug}"],
    getInstallation: ["GET /app/installations/{installation_id}"],
    getOrgInstallation: ["GET /orgs/{org}/installation"],
    getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
    getSubscriptionPlanForAccount: ["GET /marketplace_listing/accounts/{account_id}"],
    getSubscriptionPlanForAccountStubbed: ["GET /marketplace_listing/stubbed/accounts/{account_id}"],
    getUserInstallation: ["GET /users/{username}/installation"],
    getWebhookConfigForApp: ["GET /app/hook/config"],
    getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
    listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
    listAccountsForPlanStubbed: ["GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"],
    listInstallationReposForAuthenticatedUser: ["GET /user/installations/{installation_id}/repositories"],
    listInstallations: ["GET /app/installations"],
    listInstallationsForAuthenticatedUser: ["GET /user/installations"],
    listPlans: ["GET /marketplace_listing/plans"],
    listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
    listReposAccessibleToInstallation: ["GET /installation/repositories"],
    listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
    listSubscriptionsForAuthenticatedUserStubbed: ["GET /user/marketplace_purchases/stubbed"],
    listWebhookDeliveries: ["GET /app/hook/deliveries"],
    redeliverWebhookDelivery: ["POST /app/hook/deliveries/{delivery_id}/attempts"],
    removeRepoFromInstallation: ["DELETE /user/installations/{installation_id}/repositories/{repository_id}", {}, {
      renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"]
    }],
    removeRepoFromInstallationForAuthenticatedUser: ["DELETE /user/installations/{installation_id}/repositories/{repository_id}"],
    resetToken: ["PATCH /applications/{client_id}/token"],
    revokeInstallationAccessToken: ["DELETE /installation/token"],
    scopeToken: ["POST /applications/{client_id}/token/scoped"],
    suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
    unsuspendInstallation: ["DELETE /app/installations/{installation_id}/suspended"],
    updateWebhookConfigForApp: ["PATCH /app/hook/config"]
  },
  billing: {
    getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
    getGithubActionsBillingUser: ["GET /users/{username}/settings/billing/actions"],
    getGithubAdvancedSecurityBillingGhe: ["GET /enterprises/{enterprise}/settings/billing/advanced-security"],
    getGithubAdvancedSecurityBillingOrg: ["GET /orgs/{org}/settings/billing/advanced-security"],
    getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
    getGithubPackagesBillingUser: ["GET /users/{username}/settings/billing/packages"],
    getSharedStorageBillingOrg: ["GET /orgs/{org}/settings/billing/shared-storage"],
    getSharedStorageBillingUser: ["GET /users/{username}/settings/billing/shared-storage"]
  },
  checks: {
    create: ["POST /repos/{owner}/{repo}/check-runs"],
    createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
    get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
    getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
    listAnnotations: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"],
    listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
    listForSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"],
    listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
    rerequestRun: ["POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"],
    rerequestSuite: ["POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"],
    setSuitesPreferences: ["PATCH /repos/{owner}/{repo}/check-suites/preferences"],
    update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
  },
  codeScanning: {
    deleteAnalysis: ["DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"],
    getAlert: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}", {}, {
      renamedParameters: {
        alert_id: "alert_number"
      }
    }],
    getAnalysis: ["GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"],
    getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
    listAlertInstances: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"],
    listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
    listAlertsInstances: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances", {}, {
      renamed: ["codeScanning", "listAlertInstances"]
    }],
    listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
    updateAlert: ["PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"],
    uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
  },
  codesOfConduct: {
    getAllCodesOfConduct: ["GET /codes_of_conduct"],
    getConductCode: ["GET /codes_of_conduct/{key}"]
  },
  codespaces: {
    addRepositoryForSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
    codespaceMachinesForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}/machines"],
    createForAuthenticatedUser: ["POST /user/codespaces"],
    createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
    createOrUpdateSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}"],
    createWithPrForAuthenticatedUser: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"],
    createWithRepoForAuthenticatedUser: ["POST /repos/{owner}/{repo}/codespaces"],
    deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
    deleteFromOrganization: ["DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"],
    deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
    deleteSecretForAuthenticatedUser: ["DELETE /user/codespaces/secrets/{secret_name}"],
    exportForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/exports"],
    getExportDetailsForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}/exports/{export_id}"],
    getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
    getPublicKeyForAuthenticatedUser: ["GET /user/codespaces/secrets/public-key"],
    getRepoPublicKey: ["GET /repos/{owner}/{repo}/codespaces/secrets/public-key"],
    getRepoSecret: ["GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
    getSecretForAuthenticatedUser: ["GET /user/codespaces/secrets/{secret_name}"],
    listDevcontainersInRepositoryForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/devcontainers"],
    listForAuthenticatedUser: ["GET /user/codespaces"],
    listInOrganization: ["GET /orgs/{org}/codespaces", {}, {
      renamedParameters: {
        org_id: "org"
      }
    }],
    listInRepositoryForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
    listRepositoriesForSecretForAuthenticatedUser: ["GET /user/codespaces/secrets/{secret_name}/repositories"],
    listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
    removeRepositoryForSecretForAuthenticatedUser: ["DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
    repoMachinesForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/machines"],
    setRepositoriesForSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}/repositories"],
    startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
    stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
    stopInOrganization: ["POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"],
    updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
  },
  dependabot: {
    addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],
    createOrUpdateOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}"],
    createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
    deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
    deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
    getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
    getRepoPublicKey: ["GET /repos/{owner}/{repo}/dependabot/secrets/public-key"],
    getRepoSecret: ["GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
    listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
    listSelectedReposForOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"],
    removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],
    setSelectedReposForOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"]
  },
  dependencyGraph: {
    createRepositorySnapshot: ["POST /repos/{owner}/{repo}/dependency-graph/snapshots"],
    diffRange: ["GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"]
  },
  emojis: {
    get: ["GET /emojis"]
  },
  enterpriseAdmin: {
    addCustomLabelsToSelfHostedRunnerForEnterprise: ["POST /enterprises/{enterprise}/actions/runners/{runner_id}/labels"],
    disableSelectedOrganizationGithubActionsEnterprise: ["DELETE /enterprises/{enterprise}/actions/permissions/organizations/{org_id}"],
    enableSelectedOrganizationGithubActionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/organizations/{org_id}"],
    getAllowedActionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions/selected-actions"],
    getGithubActionsPermissionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions"],
    getServerStatistics: ["GET /enterprise-installation/{enterprise_or_org}/server-statistics"],
    listLabelsForSelfHostedRunnerForEnterprise: ["GET /enterprises/{enterprise}/actions/runners/{runner_id}/labels"],
    listSelectedOrganizationsEnabledGithubActionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions/organizations"],
    removeAllCustomLabelsFromSelfHostedRunnerForEnterprise: ["DELETE /enterprises/{enterprise}/actions/runners/{runner_id}/labels"],
    removeCustomLabelFromSelfHostedRunnerForEnterprise: ["DELETE /enterprises/{enterprise}/actions/runners/{runner_id}/labels/{name}"],
    setAllowedActionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/selected-actions"],
    setCustomLabelsForSelfHostedRunnerForEnterprise: ["PUT /enterprises/{enterprise}/actions/runners/{runner_id}/labels"],
    setGithubActionsPermissionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions"],
    setSelectedOrganizationsEnabledGithubActionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/organizations"]
  },
  gists: {
    checkIsStarred: ["GET /gists/{gist_id}/star"],
    create: ["POST /gists"],
    createComment: ["POST /gists/{gist_id}/comments"],
    delete: ["DELETE /gists/{gist_id}"],
    deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
    fork: ["POST /gists/{gist_id}/forks"],
    get: ["GET /gists/{gist_id}"],
    getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
    getRevision: ["GET /gists/{gist_id}/{sha}"],
    list: ["GET /gists"],
    listComments: ["GET /gists/{gist_id}/comments"],
    listCommits: ["GET /gists/{gist_id}/commits"],
    listForUser: ["GET /users/{username}/gists"],
    listForks: ["GET /gists/{gist_id}/forks"],
    listPublic: ["GET /gists/public"],
    listStarred: ["GET /gists/starred"],
    star: ["PUT /gists/{gist_id}/star"],
    unstar: ["DELETE /gists/{gist_id}/star"],
    update: ["PATCH /gists/{gist_id}"],
    updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
  },
  git: {
    createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
    createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
    createRef: ["POST /repos/{owner}/{repo}/git/refs"],
    createTag: ["POST /repos/{owner}/{repo}/git/tags"],
    createTree: ["POST /repos/{owner}/{repo}/git/trees"],
    deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
    getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
    getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
    getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
    getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
    getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
    listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
    updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
  },
  gitignore: {
    getAllTemplates: ["GET /gitignore/templates"],
    getTemplate: ["GET /gitignore/templates/{name}"]
  },
  interactions: {
    getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
    getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
    getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
    getRestrictionsForYourPublicRepos: ["GET /user/interaction-limits", {}, {
      renamed: ["interactions", "getRestrictionsForAuthenticatedUser"]
    }],
    removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
    removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
    removeRestrictionsForRepo: ["DELETE /repos/{owner}/{repo}/interaction-limits"],
    removeRestrictionsForYourPublicRepos: ["DELETE /user/interaction-limits", {}, {
      renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"]
    }],
    setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
    setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
    setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
    setRestrictionsForYourPublicRepos: ["PUT /user/interaction-limits", {}, {
      renamed: ["interactions", "setRestrictionsForAuthenticatedUser"]
    }]
  },
  issues: {
    addAssignees: ["POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
    addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
    create: ["POST /repos/{owner}/{repo}/issues"],
    createComment: ["POST /repos/{owner}/{repo}/issues/{issue_number}/comments"],
    createLabel: ["POST /repos/{owner}/{repo}/labels"],
    createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
    deleteComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
    deleteMilestone: ["DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"],
    get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
    getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
    getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
    getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
    list: ["GET /issues"],
    listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
    listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
    listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
    listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
    listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
    listEventsForTimeline: ["GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"],
    listForAuthenticatedUser: ["GET /user/issues"],
    listForOrg: ["GET /orgs/{org}/issues"],
    listForRepo: ["GET /repos/{owner}/{repo}/issues"],
    listLabelsForMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"],
    listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
    listLabelsOnIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
    lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    removeAllLabels: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    removeAssignees: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
    removeLabel: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"],
    setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
    updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
    updateMilestone: ["PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"]
  },
  licenses: {
    get: ["GET /licenses/{license}"],
    getAllCommonlyUsed: ["GET /licenses"],
    getForRepo: ["GET /repos/{owner}/{repo}/license"]
  },
  markdown: {
    render: ["POST /markdown"],
    renderRaw: ["POST /markdown/raw", {
      headers: {
        "content-type": "text/plain; charset=utf-8"
      }
    }]
  },
  meta: {
    get: ["GET /meta"],
    getOctocat: ["GET /octocat"],
    getZen: ["GET /zen"],
    root: ["GET /"]
  },
  migrations: {
    cancelImport: ["DELETE /repos/{owner}/{repo}/import"],
    deleteArchiveForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/archive"],
    deleteArchiveForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/archive"],
    downloadArchiveForOrg: ["GET /orgs/{org}/migrations/{migration_id}/archive"],
    getArchiveForAuthenticatedUser: ["GET /user/migrations/{migration_id}/archive"],
    getCommitAuthors: ["GET /repos/{owner}/{repo}/import/authors"],
    getImportStatus: ["GET /repos/{owner}/{repo}/import"],
    getLargeFiles: ["GET /repos/{owner}/{repo}/import/large_files"],
    getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
    getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
    listForAuthenticatedUser: ["GET /user/migrations"],
    listForOrg: ["GET /orgs/{org}/migrations"],
    listReposForAuthenticatedUser: ["GET /user/migrations/{migration_id}/repositories"],
    listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
    listReposForUser: ["GET /user/migrations/{migration_id}/repositories", {}, {
      renamed: ["migrations", "listReposForAuthenticatedUser"]
    }],
    mapCommitAuthor: ["PATCH /repos/{owner}/{repo}/import/authors/{author_id}"],
    setLfsPreference: ["PATCH /repos/{owner}/{repo}/import/lfs"],
    startForAuthenticatedUser: ["POST /user/migrations"],
    startForOrg: ["POST /orgs/{org}/migrations"],
    startImport: ["PUT /repos/{owner}/{repo}/import"],
    unlockRepoForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"],
    unlockRepoForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"],
    updateImport: ["PATCH /repos/{owner}/{repo}/import"]
  },
  orgs: {
    blockUser: ["PUT /orgs/{org}/blocks/{username}"],
    cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
    checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
    checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
    checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
    convertMemberToOutsideCollaborator: ["PUT /orgs/{org}/outside_collaborators/{username}"],
    createInvitation: ["POST /orgs/{org}/invitations"],
    createWebhook: ["POST /orgs/{org}/hooks"],
    deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
    get: ["GET /orgs/{org}"],
    getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
    getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
    getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
    getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
    getWebhookDelivery: ["GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"],
    list: ["GET /organizations"],
    listAppInstallations: ["GET /orgs/{org}/installations"],
    listBlockedUsers: ["GET /orgs/{org}/blocks"],
    listCustomRoles: ["GET /organizations/{organization_id}/custom_roles"],
    listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
    listForAuthenticatedUser: ["GET /user/orgs"],
    listForUser: ["GET /users/{username}/orgs"],
    listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
    listMembers: ["GET /orgs/{org}/members"],
    listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
    listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
    listPendingInvitations: ["GET /orgs/{org}/invitations"],
    listPublicMembers: ["GET /orgs/{org}/public_members"],
    listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
    listWebhooks: ["GET /orgs/{org}/hooks"],
    pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: ["POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
    removeMember: ["DELETE /orgs/{org}/members/{username}"],
    removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
    removeOutsideCollaborator: ["DELETE /orgs/{org}/outside_collaborators/{username}"],
    removePublicMembershipForAuthenticatedUser: ["DELETE /orgs/{org}/public_members/{username}"],
    setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
    setPublicMembershipForAuthenticatedUser: ["PUT /orgs/{org}/public_members/{username}"],
    unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
    update: ["PATCH /orgs/{org}"],
    updateMembershipForAuthenticatedUser: ["PATCH /user/memberships/orgs/{org}"],
    updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
    updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
  },
  packages: {
    deletePackageForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}"],
    deletePackageForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}"],
    deletePackageForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}"],
    deletePackageVersionForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
    deletePackageVersionForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
    deletePackageVersionForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
    getAllPackageVersionsForAPackageOwnedByAnOrg: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions", {}, {
      renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"]
    }],
    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions", {}, {
      renamed: ["packages", "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"]
    }],
    getAllPackageVersionsForPackageOwnedByAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions"],
    getAllPackageVersionsForPackageOwnedByOrg: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions"],
    getAllPackageVersionsForPackageOwnedByUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions"],
    getPackageForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}"],
    getPackageForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}"],
    getPackageForUser: ["GET /users/{username}/packages/{package_type}/{package_name}"],
    getPackageVersionForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
    getPackageVersionForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
    getPackageVersionForUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
    listPackagesForAuthenticatedUser: ["GET /user/packages"],
    listPackagesForOrganization: ["GET /orgs/{org}/packages"],
    listPackagesForUser: ["GET /users/{username}/packages"],
    restorePackageForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/restore{?token}"],
    restorePackageForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"],
    restorePackageForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"],
    restorePackageVersionForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
    restorePackageVersionForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
    restorePackageVersionForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"]
  },
  projects: {
    addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
    createCard: ["POST /projects/columns/{column_id}/cards"],
    createColumn: ["POST /projects/{project_id}/columns"],
    createForAuthenticatedUser: ["POST /user/projects"],
    createForOrg: ["POST /orgs/{org}/projects"],
    createForRepo: ["POST /repos/{owner}/{repo}/projects"],
    delete: ["DELETE /projects/{project_id}"],
    deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
    deleteColumn: ["DELETE /projects/columns/{column_id}"],
    get: ["GET /projects/{project_id}"],
    getCard: ["GET /projects/columns/cards/{card_id}"],
    getColumn: ["GET /projects/columns/{column_id}"],
    getPermissionForUser: ["GET /projects/{project_id}/collaborators/{username}/permission"],
    listCards: ["GET /projects/columns/{column_id}/cards"],
    listCollaborators: ["GET /projects/{project_id}/collaborators"],
    listColumns: ["GET /projects/{project_id}/columns"],
    listForOrg: ["GET /orgs/{org}/projects"],
    listForRepo: ["GET /repos/{owner}/{repo}/projects"],
    listForUser: ["GET /users/{username}/projects"],
    moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
    moveColumn: ["POST /projects/columns/{column_id}/moves"],
    removeCollaborator: ["DELETE /projects/{project_id}/collaborators/{username}"],
    update: ["PATCH /projects/{project_id}"],
    updateCard: ["PATCH /projects/columns/cards/{card_id}"],
    updateColumn: ["PATCH /projects/columns/{column_id}"]
  },
  pulls: {
    checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    create: ["POST /repos/{owner}/{repo}/pulls"],
    createReplyForReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"],
    createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    createReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
    deletePendingReview: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
    deleteReviewComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
    dismissReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"],
    get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
    getReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
    getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
    list: ["GET /repos/{owner}/{repo}/pulls"],
    listCommentsForReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"],
    listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
    listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
    listRequestedReviewers: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
    listReviewComments: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
    listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
    listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    removeRequestedReviewers: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
    requestReviewers: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
    submitReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"],
    update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
    updateBranch: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"],
    updateReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
    updateReviewComment: ["PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"]
  },
  rateLimit: {
    get: ["GET /rate_limit"]
  },
  reactions: {
    createForCommitComment: ["POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
    createForIssue: ["POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
    createForIssueComment: ["POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
    createForPullRequestReviewComment: ["POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
    createForRelease: ["POST /repos/{owner}/{repo}/releases/{release_id}/reactions"],
    createForTeamDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
    createForTeamDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"],
    deleteForCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"],
    deleteForIssue: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"],
    deleteForIssueComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"],
    deleteForPullRequestComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"],
    deleteForRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"],
    deleteForTeamDiscussion: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"],
    deleteForTeamDiscussionComment: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"],
    listForCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
    listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
    listForIssueComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
    listForPullRequestReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
    listForRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}/reactions"],
    listForTeamDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
    listForTeamDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"]
  },
  repos: {
    acceptInvitation: ["PATCH /user/repository_invitations/{invitation_id}", {}, {
      renamed: ["repos", "acceptInvitationForAuthenticatedUser"]
    }],
    acceptInvitationForAuthenticatedUser: ["PATCH /user/repository_invitations/{invitation_id}"],
    addAppAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
      mapToData: "apps"
    }],
    addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
    addStatusCheckContexts: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
      mapToData: "contexts"
    }],
    addTeamAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
      mapToData: "teams"
    }],
    addUserAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
      mapToData: "users"
    }],
    checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
    checkVulnerabilityAlerts: ["GET /repos/{owner}/{repo}/vulnerability-alerts"],
    codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
    compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
    compareCommitsWithBasehead: ["GET /repos/{owner}/{repo}/compare/{basehead}"],
    createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
    createCommitComment: ["POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
    createCommitSignatureProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
    createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
    createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
    createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
    createDeploymentStatus: ["POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
    createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
    createForAuthenticatedUser: ["POST /user/repos"],
    createFork: ["POST /repos/{owner}/{repo}/forks"],
    createInOrg: ["POST /orgs/{org}/repos"],
    createOrUpdateEnvironment: ["PUT /repos/{owner}/{repo}/environments/{environment_name}"],
    createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
    createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
    createRelease: ["POST /repos/{owner}/{repo}/releases"],
    createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
    createUsingTemplate: ["POST /repos/{template_owner}/{template_repo}/generate"],
    createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
    declineInvitation: ["DELETE /user/repository_invitations/{invitation_id}", {}, {
      renamed: ["repos", "declineInvitationForAuthenticatedUser"]
    }],
    declineInvitationForAuthenticatedUser: ["DELETE /user/repository_invitations/{invitation_id}"],
    delete: ["DELETE /repos/{owner}/{repo}"],
    deleteAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
    deleteAdminBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
    deleteAnEnvironment: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}"],
    deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    deleteBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection"],
    deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
    deleteCommitSignatureProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
    deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
    deleteDeployment: ["DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"],
    deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
    deleteInvitation: ["DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"],
    deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
    deletePullRequestReviewProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
    deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
    deleteReleaseAsset: ["DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    deleteTagProtection: ["DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"],
    deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
    disableAutomatedSecurityFixes: ["DELETE /repos/{owner}/{repo}/automated-security-fixes"],
    disableLfsForRepo: ["DELETE /repos/{owner}/{repo}/lfs"],
    disableVulnerabilityAlerts: ["DELETE /repos/{owner}/{repo}/vulnerability-alerts"],
    downloadArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}", {}, {
      renamed: ["repos", "downloadZipballArchive"]
    }],
    downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
    downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
    enableAutomatedSecurityFixes: ["PUT /repos/{owner}/{repo}/automated-security-fixes"],
    enableLfsForRepo: ["PUT /repos/{owner}/{repo}/lfs"],
    enableVulnerabilityAlerts: ["PUT /repos/{owner}/{repo}/vulnerability-alerts"],
    generateReleaseNotes: ["POST /repos/{owner}/{repo}/releases/generate-notes"],
    get: ["GET /repos/{owner}/{repo}"],
    getAccessRestrictions: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
    getAdminBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
    getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
    getAllStatusCheckContexts: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"],
    getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
    getAppsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"],
    getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
    getBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection"],
    getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
    getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
    getCollaboratorPermissionLevel: ["GET /repos/{owner}/{repo}/collaborators/{username}/permission"],
    getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
    getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
    getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
    getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
    getCommitSignatureProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
    getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
    getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
    getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
    getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
    getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
    getDeploymentStatus: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"],
    getEnvironment: ["GET /repos/{owner}/{repo}/environments/{environment_name}"],
    getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
    getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
    getPages: ["GET /repos/{owner}/{repo}/pages"],
    getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
    getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
    getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
    getPullRequestReviewProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
    getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
    getReadme: ["GET /repos/{owner}/{repo}/readme"],
    getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
    getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
    getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
    getStatusChecksProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
    getTeamsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"],
    getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
    getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
    getUsersWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"],
    getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
    getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
    getWebhookConfigForRepo: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/config"],
    getWebhookDelivery: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"],
    listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
    listBranches: ["GET /repos/{owner}/{repo}/branches"],
    listBranchesForHeadCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"],
    listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
    listCommentsForCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
    listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
    listCommitStatusesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/statuses"],
    listCommits: ["GET /repos/{owner}/{repo}/commits"],
    listContributors: ["GET /repos/{owner}/{repo}/contributors"],
    listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
    listDeploymentStatuses: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
    listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
    listForAuthenticatedUser: ["GET /user/repos"],
    listForOrg: ["GET /orgs/{org}/repos"],
    listForUser: ["GET /users/{username}/repos"],
    listForks: ["GET /repos/{owner}/{repo}/forks"],
    listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
    listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
    listLanguages: ["GET /repos/{owner}/{repo}/languages"],
    listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
    listPublic: ["GET /repositories"],
    listPullRequestsAssociatedWithCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"],
    listReleaseAssets: ["GET /repos/{owner}/{repo}/releases/{release_id}/assets"],
    listReleases: ["GET /repos/{owner}/{repo}/releases"],
    listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
    listTags: ["GET /repos/{owner}/{repo}/tags"],
    listTeams: ["GET /repos/{owner}/{repo}/teams"],
    listWebhookDeliveries: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"],
    listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
    merge: ["POST /repos/{owner}/{repo}/merges"],
    mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
    pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
    removeAppAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
      mapToData: "apps"
    }],
    removeCollaborator: ["DELETE /repos/{owner}/{repo}/collaborators/{username}"],
    removeStatusCheckContexts: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
      mapToData: "contexts"
    }],
    removeStatusCheckProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
    removeTeamAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
      mapToData: "teams"
    }],
    removeUserAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
      mapToData: "users"
    }],
    renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
    replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
    requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
    setAdminBranchProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
    setAppAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
      mapToData: "apps"
    }],
    setStatusCheckContexts: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
      mapToData: "contexts"
    }],
    setTeamAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
      mapToData: "teams"
    }],
    setUserAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
      mapToData: "users"
    }],
    testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
    transfer: ["POST /repos/{owner}/{repo}/transfer"],
    update: ["PATCH /repos/{owner}/{repo}"],
    updateBranchProtection: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection"],
    updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
    updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
    updateInvitation: ["PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"],
    updatePullRequestReviewProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
    updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
    updateReleaseAsset: ["PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    updateStatusCheckPotection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks", {}, {
      renamed: ["repos", "updateStatusCheckProtection"]
    }],
    updateStatusCheckProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
    updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
    updateWebhookConfigForRepo: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"],
    uploadReleaseAsset: ["POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}", {
      baseUrl: "https://uploads.github.com"
    }]
  },
  search: {
    code: ["GET /search/code"],
    commits: ["GET /search/commits"],
    issuesAndPullRequests: ["GET /search/issues"],
    labels: ["GET /search/labels"],
    repos: ["GET /search/repositories"],
    topics: ["GET /search/topics"],
    users: ["GET /search/users"]
  },
  secretScanning: {
    getAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"],
    listAlertsForEnterprise: ["GET /enterprises/{enterprise}/secret-scanning/alerts"],
    listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
    listLocationsForAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"],
    updateAlert: ["PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"]
  },
  teams: {
    addOrUpdateMembershipForUserInOrg: ["PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"],
    addOrUpdateProjectPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
    addOrUpdateRepoPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
    checkPermissionsForProjectInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
    checkPermissionsForRepoInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
    create: ["POST /orgs/{org}/teams"],
    createDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
    createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
    deleteDiscussionCommentInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
    deleteDiscussionInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
    deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
    getByName: ["GET /orgs/{org}/teams/{team_slug}"],
    getDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
    getDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
    getMembershipForUserInOrg: ["GET /orgs/{org}/teams/{team_slug}/memberships/{username}"],
    list: ["GET /orgs/{org}/teams"],
    listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
    listDiscussionCommentsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
    listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
    listForAuthenticatedUser: ["GET /user/teams"],
    listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
    listPendingInvitationsInOrg: ["GET /orgs/{org}/teams/{team_slug}/invitations"],
    listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
    listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
    removeMembershipForUserInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"],
    removeProjectInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
    removeRepoInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
    updateDiscussionCommentInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
    updateDiscussionInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
    updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
  },
  users: {
    addEmailForAuthenticated: ["POST /user/emails", {}, {
      renamed: ["users", "addEmailForAuthenticatedUser"]
    }],
    addEmailForAuthenticatedUser: ["POST /user/emails"],
    block: ["PUT /user/blocks/{username}"],
    checkBlocked: ["GET /user/blocks/{username}"],
    checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
    checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
    createGpgKeyForAuthenticated: ["POST /user/gpg_keys", {}, {
      renamed: ["users", "createGpgKeyForAuthenticatedUser"]
    }],
    createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
    createPublicSshKeyForAuthenticated: ["POST /user/keys", {}, {
      renamed: ["users", "createPublicSshKeyForAuthenticatedUser"]
    }],
    createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
    deleteEmailForAuthenticated: ["DELETE /user/emails", {}, {
      renamed: ["users", "deleteEmailForAuthenticatedUser"]
    }],
    deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
    deleteGpgKeyForAuthenticated: ["DELETE /user/gpg_keys/{gpg_key_id}", {}, {
      renamed: ["users", "deleteGpgKeyForAuthenticatedUser"]
    }],
    deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
    deletePublicSshKeyForAuthenticated: ["DELETE /user/keys/{key_id}", {}, {
      renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"]
    }],
    deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
    follow: ["PUT /user/following/{username}"],
    getAuthenticated: ["GET /user"],
    getByUsername: ["GET /users/{username}"],
    getContextForUser: ["GET /users/{username}/hovercard"],
    getGpgKeyForAuthenticated: ["GET /user/gpg_keys/{gpg_key_id}", {}, {
      renamed: ["users", "getGpgKeyForAuthenticatedUser"]
    }],
    getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
    getPublicSshKeyForAuthenticated: ["GET /user/keys/{key_id}", {}, {
      renamed: ["users", "getPublicSshKeyForAuthenticatedUser"]
    }],
    getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
    list: ["GET /users"],
    listBlockedByAuthenticated: ["GET /user/blocks", {}, {
      renamed: ["users", "listBlockedByAuthenticatedUser"]
    }],
    listBlockedByAuthenticatedUser: ["GET /user/blocks"],
    listEmailsForAuthenticated: ["GET /user/emails", {}, {
      renamed: ["users", "listEmailsForAuthenticatedUser"]
    }],
    listEmailsForAuthenticatedUser: ["GET /user/emails"],
    listFollowedByAuthenticated: ["GET /user/following", {}, {
      renamed: ["users", "listFollowedByAuthenticatedUser"]
    }],
    listFollowedByAuthenticatedUser: ["GET /user/following"],
    listFollowersForAuthenticatedUser: ["GET /user/followers"],
    listFollowersForUser: ["GET /users/{username}/followers"],
    listFollowingForUser: ["GET /users/{username}/following"],
    listGpgKeysForAuthenticated: ["GET /user/gpg_keys", {}, {
      renamed: ["users", "listGpgKeysForAuthenticatedUser"]
    }],
    listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
    listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
    listPublicEmailsForAuthenticated: ["GET /user/public_emails", {}, {
      renamed: ["users", "listPublicEmailsForAuthenticatedUser"]
    }],
    listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
    listPublicKeysForUser: ["GET /users/{username}/keys"],
    listPublicSshKeysForAuthenticated: ["GET /user/keys", {}, {
      renamed: ["users", "listPublicSshKeysForAuthenticatedUser"]
    }],
    listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
    setPrimaryEmailVisibilityForAuthenticated: ["PATCH /user/email/visibility", {}, {
      renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"]
    }],
    setPrimaryEmailVisibilityForAuthenticatedUser: ["PATCH /user/email/visibility"],
    unblock: ["DELETE /user/blocks/{username}"],
    unfollow: ["DELETE /user/following/{username}"],
    updateAuthenticated: ["PATCH /user"]
  }
};

const VERSION = "5.16.2";

function endpointsToMethods(octokit, endpointsMap) {
  const newMethods = {};

  for (const [scope, endpoints] of Object.entries(endpointsMap)) {
    for (const [methodName, endpoint] of Object.entries(endpoints)) {
      const [route, defaults, decorations] = endpoint;
      const [method, url] = route.split(/ /);
      const endpointDefaults = Object.assign({
        method,
        url
      }, defaults);

      if (!newMethods[scope]) {
        newMethods[scope] = {};
      }

      const scopeMethods = newMethods[scope];

      if (decorations) {
        scopeMethods[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
        continue;
      }

      scopeMethods[methodName] = octokit.request.defaults(endpointDefaults);
    }
  }

  return newMethods;
}

function decorate(octokit, scope, methodName, defaults, decorations) {
  const requestWithDefaults = octokit.request.defaults(defaults);
  /* istanbul ignore next */

  function withDecorations(...args) {
    // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
    let options = requestWithDefaults.endpoint.merge(...args); // There are currently no other decorations than `.mapToData`

    if (decorations.mapToData) {
      options = Object.assign({}, options, {
        data: options[decorations.mapToData],
        [decorations.mapToData]: undefined
      });
      return requestWithDefaults(options);
    }

    if (decorations.renamed) {
      const [newScope, newMethodName] = decorations.renamed;
      octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
    }

    if (decorations.deprecated) {
      octokit.log.warn(decorations.deprecated);
    }

    if (decorations.renamedParameters) {
      // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
      const options = requestWithDefaults.endpoint.merge(...args);

      for (const [name, alias] of Object.entries(decorations.renamedParameters)) {
        if (name in options) {
          octokit.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`);

          if (!(alias in options)) {
            options[alias] = options[name];
          }

          delete options[name];
        }
      }

      return requestWithDefaults(options);
    } // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488


    return requestWithDefaults(...args);
  }

  return Object.assign(withDecorations, requestWithDefaults);
}

function restEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit, Endpoints);
  return {
    rest: api
  };
}
restEndpointMethods.VERSION = VERSION;
function legacyRestEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit, Endpoints);
  return _objectSpread2(_objectSpread2({}, api), {}, {
    rest: api
  });
}
legacyRestEndpointMethods.VERSION = VERSION;

exports.legacyRestEndpointMethods = legacyRestEndpointMethods;
exports.restEndpointMethods = restEndpointMethods;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 5526:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
class BasicCredentialHandler {
    constructor(username, password) {
        this.username = username;
        this.password = password;
    }
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BasicCredentialHandler = BasicCredentialHandler;
class BearerCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Bearer ${this.token}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BearerCredentialHandler = BearerCredentialHandler;
class PersonalAccessTokenCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
//# sourceMappingURL=auth.js.map

/***/ }),

/***/ 6255:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/* eslint-disable @typescript-eslint/no-explicit-any */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
const http = __importStar(__nccwpck_require__(3685));
const https = __importStar(__nccwpck_require__(5687));
const pm = __importStar(__nccwpck_require__(9835));
const tunnel = __importStar(__nccwpck_require__(4294));
var HttpCodes;
(function (HttpCodes) {
    HttpCodes[HttpCodes["OK"] = 200] = "OK";
    HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
    HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
    HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
    HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
    HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
    HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
    HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
    HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
    HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
    HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));
var Headers;
(function (Headers) {
    Headers["Accept"] = "accept";
    Headers["ContentType"] = "content-type";
})(Headers = exports.Headers || (exports.Headers = {}));
var MediaTypes;
(function (MediaTypes) {
    MediaTypes["ApplicationJson"] = "application/json";
})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));
/**
 * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
 */
function getProxyUrl(serverUrl) {
    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : '';
}
exports.getProxyUrl = getProxyUrl;
const HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
];
const HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
];
const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
const ExponentialBackoffCeiling = 10;
const ExponentialBackoffTimeSlice = 5;
class HttpClientError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.name = 'HttpClientError';
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, HttpClientError.prototype);
    }
}
exports.HttpClientError = HttpClientError;
class HttpClientResponse {
    constructor(message) {
        this.message = message;
    }
    readBody() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                let output = Buffer.alloc(0);
                this.message.on('data', (chunk) => {
                    output = Buffer.concat([output, chunk]);
                });
                this.message.on('end', () => {
                    resolve(output.toString());
                });
            }));
        });
    }
}
exports.HttpClientResponse = HttpClientResponse;
function isHttps(requestUrl) {
    const parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === 'https:';
}
exports.isHttps = isHttps;
class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
            if (requestOptions.ignoreSslError != null) {
                this._ignoreSslError = requestOptions.ignoreSslError;
            }
            this._socketTimeout = requestOptions.socketTimeout;
            if (requestOptions.allowRedirects != null) {
                this._allowRedirects = requestOptions.allowRedirects;
            }
            if (requestOptions.allowRedirectDowngrade != null) {
                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
            }
            if (requestOptions.maxRedirects != null) {
                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
            }
            if (requestOptions.keepAlive != null) {
                this._keepAlive = requestOptions.keepAlive;
            }
            if (requestOptions.allowRetries != null) {
                this._allowRetries = requestOptions.allowRetries;
            }
            if (requestOptions.maxRetries != null) {
                this._maxRetries = requestOptions.maxRetries;
            }
        }
    }
    options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
        });
    }
    get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('GET', requestUrl, null, additionalHeaders || {});
        });
    }
    del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('DELETE', requestUrl, null, additionalHeaders || {});
        });
    }
    post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('POST', requestUrl, data, additionalHeaders || {});
        });
    }
    patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PATCH', requestUrl, data, additionalHeaders || {});
        });
    }
    put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PUT', requestUrl, data, additionalHeaders || {});
        });
    }
    head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('HEAD', requestUrl, null, additionalHeaders || {});
        });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request(verb, requestUrl, stream, additionalHeaders);
        });
    }
    /**
     * Gets a typed object from an endpoint
     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
     */
    getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            const res = yield this.get(requestUrl, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.post(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.put(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.patch(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    /**
     * Makes a raw http request.
     * All other methods such as get, post, patch, and request ultimately call this.
     * Prefer get, del, post and patch
     */
    request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._disposed) {
                throw new Error('Client has already been disposed.');
            }
            const parsedUrl = new URL(requestUrl);
            let info = this._prepareRequest(verb, parsedUrl, headers);
            // Only perform retries on reads since writes may not be idempotent.
            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)
                ? this._maxRetries + 1
                : 1;
            let numTries = 0;
            let response;
            do {
                response = yield this.requestRaw(info, data);
                // Check if it's an authentication challenge
                if (response &&
                    response.message &&
                    response.message.statusCode === HttpCodes.Unauthorized) {
                    let authenticationHandler;
                    for (const handler of this.handlers) {
                        if (handler.canHandleAuthentication(response)) {
                            authenticationHandler = handler;
                            break;
                        }
                    }
                    if (authenticationHandler) {
                        return authenticationHandler.handleAuthentication(this, info, data);
                    }
                    else {
                        // We have received an unauthorized response but have no handlers to handle it.
                        // Let the response return to the caller.
                        return response;
                    }
                }
                let redirectsRemaining = this._maxRedirects;
                while (response.message.statusCode &&
                    HttpRedirectCodes.includes(response.message.statusCode) &&
                    this._allowRedirects &&
                    redirectsRemaining > 0) {
                    const redirectUrl = response.message.headers['location'];
                    if (!redirectUrl) {
                        // if there's no location to redirect to, we won't
                        break;
                    }
                    const parsedRedirectUrl = new URL(redirectUrl);
                    if (parsedUrl.protocol === 'https:' &&
                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&
                        !this._allowRedirectDowngrade) {
                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
                    }
                    // we need to finish reading the response before reassigning response
                    // which will leak the open socket.
                    yield response.readBody();
                    // strip authorization header if redirected to a different hostname
                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                        for (const header in headers) {
                            // header names are case insensitive
                            if (header.toLowerCase() === 'authorization') {
                                delete headers[header];
                            }
                        }
                    }
                    // let's make the request with the new redirectUrl
                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                    response = yield this.requestRaw(info, data);
                    redirectsRemaining--;
                }
                if (!response.message.statusCode ||
                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {
                    // If not a retry code, return immediately instead of retrying
                    return response;
                }
                numTries += 1;
                if (numTries < maxTries) {
                    yield response.readBody();
                    yield this._performExponentialBackoff(numTries);
                }
            } while (numTries < maxTries);
            return response;
        });
    }
    /**
     * Needs to be called if keepAlive is set to true in request options.
     */
    dispose() {
        if (this._agent) {
            this._agent.destroy();
        }
        this._disposed = true;
    }
    /**
     * Raw request.
     * @param info
     * @param data
     */
    requestRaw(info, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                function callbackForResult(err, res) {
                    if (err) {
                        reject(err);
                    }
                    else if (!res) {
                        // If `err` is not passed, then `res` must be passed.
                        reject(new Error('Unknown error'));
                    }
                    else {
                        resolve(res);
                    }
                }
                this.requestRawWithCallback(info, data, callbackForResult);
            });
        });
    }
    /**
     * Raw request with callback.
     * @param info
     * @param data
     * @param onResult
     */
    requestRawWithCallback(info, data, onResult) {
        if (typeof data === 'string') {
            if (!info.options.headers) {
                info.options.headers = {};
            }
            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
        }
        let callbackCalled = false;
        function handleResult(err, res) {
            if (!callbackCalled) {
                callbackCalled = true;
                onResult(err, res);
            }
        }
        const req = info.httpModule.request(info.options, (msg) => {
            const res = new HttpClientResponse(msg);
            handleResult(undefined, res);
        });
        let socket;
        req.on('socket', sock => {
            socket = sock;
        });
        // If we ever get disconnected, we want the socket to timeout eventually
        req.setTimeout(this._socketTimeout || 3 * 60000, () => {
            if (socket) {
                socket.end();
            }
            handleResult(new Error(`Request timeout: ${info.options.path}`));
        });
        req.on('error', function (err) {
            // err has statusCode property
            // res should have headers
            handleResult(err);
        });
        if (data && typeof data === 'string') {
            req.write(data, 'utf8');
        }
        if (data && typeof data !== 'string') {
            data.on('close', function () {
                req.end();
            });
            data.pipe(req);
        }
        else {
            req.end();
        }
    }
    /**
     * Gets an http agent. This function is useful when you need an http agent that handles
     * routing through a proxy server - depending upon the url and proxy environment variables.
     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
     */
    getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === 'https:';
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port
            ? parseInt(info.parsedUrl.port)
            : defaultPort;
        info.options.path =
            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
            info.options.headers['user-agent'] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        // gives handlers an opportunity to participate
        if (this.handlers) {
            for (const handler of this.handlers) {
                handler.prepareRequest(info.options);
            }
        }
        return info;
    }
    _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
            agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
            agent = this._agent;
        }
        // if agent is already assigned use that agent.
        if (agent) {
            return agent;
        }
        const usingSsl = parsedUrl.protocol === 'https:';
        let maxSockets = 100;
        if (this.requestOptions) {
            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.
        if (proxyUrl && proxyUrl.hostname) {
            const agentOptions = {
                maxSockets,
                keepAlive: this._keepAlive,
                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {
                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
                })), { host: proxyUrl.hostname, port: proxyUrl.port })
            };
            let tunnelAgent;
            const overHttps = proxyUrl.protocol === 'https:';
            if (usingSsl) {
                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
            }
            else {
                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
            }
            agent = tunnelAgent(agentOptions);
            this._proxyAgent = agent;
        }
        // if reusing agent across request and tunneling agent isn't assigned create a new agent
        if (this._keepAlive && !agent) {
            const options = { keepAlive: this._keepAlive, maxSockets };
            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
            this._agent = agent;
        }
        // if not using private agent and tunnel agent isn't setup then use global agent
        if (!agent) {
            agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
            // we have to cast it to any and change it directly
            agent.options = Object.assign(agent.options || {}, {
                rejectUnauthorized: false
            });
        }
        return agent;
    }
    _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
            return new Promise(resolve => setTimeout(() => resolve(), ms));
        });
    }
    _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const statusCode = res.message.statusCode || 0;
                const response = {
                    statusCode,
                    result: null,
                    headers: {}
                };
                // not found leads to null obj returned
                if (statusCode === HttpCodes.NotFound) {
                    resolve(response);
                }
                // get the result from the body
                function dateTimeDeserializer(key, value) {
                    if (typeof value === 'string') {
                        const a = new Date(value);
                        if (!isNaN(a.valueOf())) {
                            return a;
                        }
                    }
                    return value;
                }
                let obj;
                let contents;
                try {
                    contents = yield res.readBody();
                    if (contents && contents.length > 0) {
                        if (options && options.deserializeDates) {
                            obj = JSON.parse(contents, dateTimeDeserializer);
                        }
                        else {
                            obj = JSON.parse(contents);
                        }
                        response.result = obj;
                    }
                    response.headers = res.message.headers;
                }
                catch (err) {
                    // Invalid resource (contents not json);  leaving result obj null
                }
                // note that 3xx redirects are handled by the http layer.
                if (statusCode > 299) {
                    let msg;
                    // if exception/error in body, attempt to get better error
                    if (obj && obj.message) {
                        msg = obj.message;
                    }
                    else if (contents && contents.length > 0) {
                        // it may be the case that the exception is in the body message as string
                        msg = contents;
                    }
                    else {
                        msg = `Failed request: (${statusCode})`;
                    }
                    const err = new HttpClientError(msg, statusCode);
                    err.result = response.result;
                    reject(err);
                }
                else {
                    resolve(response);
                }
            }));
        });
    }
}
exports.HttpClient = HttpClient;
const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9835:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkBypass = exports.getProxyUrl = void 0;
function getProxyUrl(reqUrl) {
    const usingSsl = reqUrl.protocol === 'https:';
    if (checkBypass(reqUrl)) {
        return undefined;
    }
    const proxyVar = (() => {
        if (usingSsl) {
            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];
        }
        else {
            return process.env['http_proxy'] || process.env['HTTP_PROXY'];
        }
    })();
    if (proxyVar) {
        return new URL(proxyVar);
    }
    else {
        return undefined;
    }
}
exports.getProxyUrl = getProxyUrl;
function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
        return false;
    }
    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
    if (!noProxy) {
        return false;
    }
    // Determine the request port
    let reqPort;
    if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
    }
    else if (reqUrl.protocol === 'http:') {
        reqPort = 80;
    }
    else if (reqUrl.protocol === 'https:') {
        reqPort = 443;
    }
    // Format the request hostname and hostname with port
    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === 'number') {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    // Compare request host against noproxy
    for (const upperNoProxyItem of noProxy
        .split(',')
        .map(x => x.trim().toUpperCase())
        .filter(x => x)) {
        if (upperReqHosts.some(x => x === upperNoProxyItem)) {
            return true;
        }
    }
    return false;
}
exports.checkBypass = checkBypass;
//# sourceMappingURL=proxy.js.map

/***/ }),

/***/ 1141:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = "abstract-provider/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ 1698:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Provider = exports.TransactionOrderForkEvent = exports.TransactionForkEvent = exports.BlockForkEvent = exports.ForkEvent = void 0;
var bignumber_1 = __nccwpck_require__(1267);
var bytes_1 = __nccwpck_require__(2056);
var properties_1 = __nccwpck_require__(8078);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(1141);
var logger = new logger_1.Logger(_version_1.version);
;
;
//export type CallTransactionable = {
//    call(transaction: TransactionRequest): Promise<TransactionResponse>;
//};
var ForkEvent = /** @class */ (function (_super) {
    __extends(ForkEvent, _super);
    function ForkEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ForkEvent.isForkEvent = function (value) {
        return !!(value && value._isForkEvent);
    };
    return ForkEvent;
}(properties_1.Description));
exports.ForkEvent = ForkEvent;
var BlockForkEvent = /** @class */ (function (_super) {
    __extends(BlockForkEvent, _super);
    function BlockForkEvent(blockHash, expiry) {
        var _this = this;
        if (!(0, bytes_1.isHexString)(blockHash, 32)) {
            logger.throwArgumentError("invalid blockHash", "blockHash", blockHash);
        }
        _this = _super.call(this, {
            _isForkEvent: true,
            _isBlockForkEvent: true,
            expiry: (expiry || 0),
            blockHash: blockHash
        }) || this;
        return _this;
    }
    return BlockForkEvent;
}(ForkEvent));
exports.BlockForkEvent = BlockForkEvent;
var TransactionForkEvent = /** @class */ (function (_super) {
    __extends(TransactionForkEvent, _super);
    function TransactionForkEvent(hash, expiry) {
        var _this = this;
        if (!(0, bytes_1.isHexString)(hash, 32)) {
            logger.throwArgumentError("invalid transaction hash", "hash", hash);
        }
        _this = _super.call(this, {
            _isForkEvent: true,
            _isTransactionForkEvent: true,
            expiry: (expiry || 0),
            hash: hash
        }) || this;
        return _this;
    }
    return TransactionForkEvent;
}(ForkEvent));
exports.TransactionForkEvent = TransactionForkEvent;
var TransactionOrderForkEvent = /** @class */ (function (_super) {
    __extends(TransactionOrderForkEvent, _super);
    function TransactionOrderForkEvent(beforeHash, afterHash, expiry) {
        var _this = this;
        if (!(0, bytes_1.isHexString)(beforeHash, 32)) {
            logger.throwArgumentError("invalid transaction hash", "beforeHash", beforeHash);
        }
        if (!(0, bytes_1.isHexString)(afterHash, 32)) {
            logger.throwArgumentError("invalid transaction hash", "afterHash", afterHash);
        }
        _this = _super.call(this, {
            _isForkEvent: true,
            _isTransactionOrderForkEvent: true,
            expiry: (expiry || 0),
            beforeHash: beforeHash,
            afterHash: afterHash
        }) || this;
        return _this;
    }
    return TransactionOrderForkEvent;
}(ForkEvent));
exports.TransactionOrderForkEvent = TransactionOrderForkEvent;
///////////////////////////////
// Exported Abstracts
var Provider = /** @class */ (function () {
    function Provider() {
        var _newTarget = this.constructor;
        logger.checkAbstract(_newTarget, Provider);
        (0, properties_1.defineReadOnly)(this, "_isProvider", true);
    }
    Provider.prototype.getFeeData = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, block, gasPrice, lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, (0, properties_1.resolveProperties)({
                            block: this.getBlock("latest"),
                            gasPrice: this.getGasPrice().catch(function (error) {
                                // @TODO: Why is this now failing on Calaveras?
                                //console.log(error);
                                return null;
                            })
                        })];
                    case 1:
                        _a = _b.sent(), block = _a.block, gasPrice = _a.gasPrice;
                        lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
                        if (block && block.baseFeePerGas) {
                            // We may want to compute this more accurately in the future,
                            // using the formula "check if the base fee is correct".
                            // See: https://eips.ethereum.org/EIPS/eip-1559
                            lastBaseFeePerGas = block.baseFeePerGas;
                            maxPriorityFeePerGas = bignumber_1.BigNumber.from("1500000000");
                            maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
                        }
                        return [2 /*return*/, { lastBaseFeePerGas: lastBaseFeePerGas, maxFeePerGas: maxFeePerGas, maxPriorityFeePerGas: maxPriorityFeePerGas, gasPrice: gasPrice }];
                }
            });
        });
    };
    // Alias for "on"
    Provider.prototype.addListener = function (eventName, listener) {
        return this.on(eventName, listener);
    };
    // Alias for "off"
    Provider.prototype.removeListener = function (eventName, listener) {
        return this.off(eventName, listener);
    };
    Provider.isProvider = function (value) {
        return !!(value && value._isProvider);
    };
    return Provider;
}());
exports.Provider = Provider;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 6001:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = "abstract-signer/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ 6324:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VoidSigner = exports.Signer = void 0;
var properties_1 = __nccwpck_require__(8078);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(6001);
var logger = new logger_1.Logger(_version_1.version);
var allowedTransactionKeys = [
    "accessList", "ccipReadEnabled", "chainId", "customData", "data", "from", "gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "to", "type", "value"
];
var forwardErrors = [
    logger_1.Logger.errors.INSUFFICIENT_FUNDS,
    logger_1.Logger.errors.NONCE_EXPIRED,
    logger_1.Logger.errors.REPLACEMENT_UNDERPRICED,
];
;
;
var Signer = /** @class */ (function () {
    ///////////////////
    // Sub-classes MUST call super
    function Signer() {
        var _newTarget = this.constructor;
        logger.checkAbstract(_newTarget, Signer);
        (0, properties_1.defineReadOnly)(this, "_isSigner", true);
    }
    ///////////////////
    // Sub-classes MAY override these
    Signer.prototype.getBalance = function (blockTag) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._checkProvider("getBalance");
                        return [4 /*yield*/, this.provider.getBalance(this.getAddress(), blockTag)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Signer.prototype.getTransactionCount = function (blockTag) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._checkProvider("getTransactionCount");
                        return [4 /*yield*/, this.provider.getTransactionCount(this.getAddress(), blockTag)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // Populates "from" if unspecified, and estimates the gas for the transaction
    Signer.prototype.estimateGas = function (transaction) {
        return __awaiter(this, void 0, void 0, function () {
            var tx;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._checkProvider("estimateGas");
                        return [4 /*yield*/, (0, properties_1.resolveProperties)(this.checkTransaction(transaction))];
                    case 1:
                        tx = _a.sent();
                        return [4 /*yield*/, this.provider.estimateGas(tx)];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // Populates "from" if unspecified, and calls with the transaction
    Signer.prototype.call = function (transaction, blockTag) {
        return __awaiter(this, void 0, void 0, function () {
            var tx;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._checkProvider("call");
                        return [4 /*yield*/, (0, properties_1.resolveProperties)(this.checkTransaction(transaction))];
                    case 1:
                        tx = _a.sent();
                        return [4 /*yield*/, this.provider.call(tx, blockTag)];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // Populates all fields in a transaction, signs it and sends it to the network
    Signer.prototype.sendTransaction = function (transaction) {
        return __awaiter(this, void 0, void 0, function () {
            var tx, signedTx;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._checkProvider("sendTransaction");
                        return [4 /*yield*/, this.populateTransaction(transaction)];
                    case 1:
                        tx = _a.sent();
                        return [4 /*yield*/, this.signTransaction(tx)];
                    case 2:
                        signedTx = _a.sent();
                        return [4 /*yield*/, this.provider.sendTransaction(signedTx)];
                    case 3: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Signer.prototype.getChainId = function () {
        return __awaiter(this, void 0, void 0, function () {
            var network;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._checkProvider("getChainId");
                        return [4 /*yield*/, this.provider.getNetwork()];
                    case 1:
                        network = _a.sent();
                        return [2 /*return*/, network.chainId];
                }
            });
        });
    };
    Signer.prototype.getGasPrice = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._checkProvider("getGasPrice");
                        return [4 /*yield*/, this.provider.getGasPrice()];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Signer.prototype.getFeeData = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._checkProvider("getFeeData");
                        return [4 /*yield*/, this.provider.getFeeData()];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Signer.prototype.resolveName = function (name) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._checkProvider("resolveName");
                        return [4 /*yield*/, this.provider.resolveName(name)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    // Checks a transaction does not contain invalid keys and if
    // no "from" is provided, populates it.
    // - does NOT require a provider
    // - adds "from" is not present
    // - returns a COPY (safe to mutate the result)
    // By default called from: (overriding these prevents it)
    //   - call
    //   - estimateGas
    //   - populateTransaction (and therefor sendTransaction)
    Signer.prototype.checkTransaction = function (transaction) {
        for (var key in transaction) {
            if (allowedTransactionKeys.indexOf(key) === -1) {
                logger.throwArgumentError("invalid transaction key: " + key, "transaction", transaction);
            }
        }
        var tx = (0, properties_1.shallowCopy)(transaction);
        if (tx.from == null) {
            tx.from = this.getAddress();
        }
        else {
            // Make sure any provided address matches this signer
            tx.from = Promise.all([
                Promise.resolve(tx.from),
                this.getAddress()
            ]).then(function (result) {
                if (result[0].toLowerCase() !== result[1].toLowerCase()) {
                    logger.throwArgumentError("from address mismatch", "transaction", transaction);
                }
                return result[0];
            });
        }
        return tx;
    };
    // Populates ALL keys for a transaction and checks that "from" matches
    // this Signer. Should be used by sendTransaction but NOT by signTransaction.
    // By default called from: (overriding these prevents it)
    //   - sendTransaction
    //
    // Notes:
    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
    Signer.prototype.populateTransaction = function (transaction) {
        return __awaiter(this, void 0, void 0, function () {
            var tx, hasEip1559, feeData, gasPrice;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, properties_1.resolveProperties)(this.checkTransaction(transaction))];
                    case 1:
                        tx = _a.sent();
                        if (tx.to != null) {
                            tx.to = Promise.resolve(tx.to).then(function (to) { return __awaiter(_this, void 0, void 0, function () {
                                var address;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            if (to == null) {
                                                return [2 /*return*/, null];
                                            }
                                            return [4 /*yield*/, this.resolveName(to)];
                                        case 1:
                                            address = _a.sent();
                                            if (address == null) {
                                                logger.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
                                            }
                                            return [2 /*return*/, address];
                                    }
                                });
                            }); });
                            // Prevent this error from causing an UnhandledPromiseException
                            tx.to.catch(function (error) { });
                        }
                        hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);
                        if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
                            logger.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
                        }
                        else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
                            logger.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
                        }
                        if (!((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null))) return [3 /*break*/, 2];
                        // Fully-formed EIP-1559 transaction (skip getFeeData)
                        tx.type = 2;
                        return [3 /*break*/, 5];
                    case 2:
                        if (!(tx.type === 0 || tx.type === 1)) return [3 /*break*/, 3];
                        // Explicit Legacy or EIP-2930 transaction
                        // Populate missing gasPrice
                        if (tx.gasPrice == null) {
                            tx.gasPrice = this.getGasPrice();
                        }
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, this.getFeeData()];
                    case 4:
                        feeData = _a.sent();
                        if (tx.type == null) {
                            // We need to auto-detect the intended type of this transaction...
                            if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                                // The network supports EIP-1559!
                                // Upgrade transaction from null to eip-1559
                                tx.type = 2;
                                if (tx.gasPrice != null) {
                                    gasPrice = tx.gasPrice;
                                    delete tx.gasPrice;
                                    tx.maxFeePerGas = gasPrice;
                                    tx.maxPriorityFeePerGas = gasPrice;
                                }
                                else {
                                    // Populate missing fee data
                                    if (tx.maxFeePerGas == null) {
                                        tx.maxFeePerGas = feeData.maxFeePerGas;
                                    }
                                    if (tx.maxPriorityFeePerGas == null) {
                                        tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                                    }
                                }
                            }
                            else if (feeData.gasPrice != null) {
                                // Network doesn't support EIP-1559...
                                // ...but they are trying to use EIP-1559 properties
                                if (hasEip1559) {
                                    logger.throwError("network does not support EIP-1559", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                                        operation: "populateTransaction"
                                    });
                                }
                                // Populate missing fee data
                                if (tx.gasPrice == null) {
                                    tx.gasPrice = feeData.gasPrice;
                                }
                                // Explicitly set untyped transaction to legacy
                                tx.type = 0;
                            }
                            else {
                                // getFeeData has failed us.
                                logger.throwError("failed to get consistent fee data", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                                    operation: "signer.getFeeData"
                                });
                            }
                        }
                        else if (tx.type === 2) {
                            // Explicitly using EIP-1559
                            // Populate missing fee data
                            if (tx.maxFeePerGas == null) {
                                tx.maxFeePerGas = feeData.maxFeePerGas;
                            }
                            if (tx.maxPriorityFeePerGas == null) {
                                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                            }
                        }
                        _a.label = 5;
                    case 5:
                        if (tx.nonce == null) {
                            tx.nonce = this.getTransactionCount("pending");
                        }
                        if (tx.gasLimit == null) {
                            tx.gasLimit = this.estimateGas(tx).catch(function (error) {
                                if (forwardErrors.indexOf(error.code) >= 0) {
                                    throw error;
                                }
                                return logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
                                    error: error,
                                    tx: tx
                                });
                            });
                        }
                        if (tx.chainId == null) {
                            tx.chainId = this.getChainId();
                        }
                        else {
                            tx.chainId = Promise.all([
                                Promise.resolve(tx.chainId),
                                this.getChainId()
                            ]).then(function (results) {
                                if (results[1] !== 0 && results[0] !== results[1]) {
                                    logger.throwArgumentError("chainId address mismatch", "transaction", transaction);
                                }
                                return results[0];
                            });
                        }
                        return [4 /*yield*/, (0, properties_1.resolveProperties)(tx)];
                    case 6: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    ///////////////////
    // Sub-classes SHOULD leave these alone
    Signer.prototype._checkProvider = function (operation) {
        if (!this.provider) {
            logger.throwError("missing provider", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: (operation || "_checkProvider")
            });
        }
    };
    Signer.isSigner = function (value) {
        return !!(value && value._isSigner);
    };
    return Signer;
}());
exports.Signer = Signer;
var VoidSigner = /** @class */ (function (_super) {
    __extends(VoidSigner, _super);
    function VoidSigner(address, provider) {
        var _this = _super.call(this) || this;
        (0, properties_1.defineReadOnly)(_this, "address", address);
        (0, properties_1.defineReadOnly)(_this, "provider", provider || null);
        return _this;
    }
    VoidSigner.prototype.getAddress = function () {
        return Promise.resolve(this.address);
    };
    VoidSigner.prototype._fail = function (message, operation) {
        return Promise.resolve().then(function () {
            logger.throwError(message, logger_1.Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });
        });
    };
    VoidSigner.prototype.signMessage = function (message) {
        return this._fail("VoidSigner cannot sign messages", "signMessage");
    };
    VoidSigner.prototype.signTransaction = function (transaction) {
        return this._fail("VoidSigner cannot sign transactions", "signTransaction");
    };
    VoidSigner.prototype._signTypedData = function (domain, types, value) {
        return this._fail("VoidSigner cannot sign typed data", "signTypedData");
    };
    VoidSigner.prototype.connect = function (provider) {
        return new VoidSigner(this.address, provider);
    };
    return VoidSigner;
}(Signer));
exports.VoidSigner = VoidSigner;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3627:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = "address/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ 8957:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.isAddress = exports.getAddress = void 0;
var bytes_1 = __nccwpck_require__(2056);
var bignumber_1 = __nccwpck_require__(1267);
var keccak256_1 = __nccwpck_require__(3100);
var rlp_1 = __nccwpck_require__(2099);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(3627);
var logger = new logger_1.Logger(_version_1.version);
function getChecksumAddress(address) {
    if (!(0, bytes_1.isHexString)(address, 20)) {
        logger.throwArgumentError("invalid address", "address", address);
    }
    address = address.toLowerCase();
    var chars = address.substring(2).split("");
    var expanded = new Uint8Array(40);
    for (var i = 0; i < 40; i++) {
        expanded[i] = chars[i].charCodeAt(0);
    }
    var hashed = (0, bytes_1.arrayify)((0, keccak256_1.keccak256)(expanded));
    for (var i = 0; i < 40; i += 2) {
        if ((hashed[i >> 1] >> 4) >= 8) {
            chars[i] = chars[i].toUpperCase();
        }
        if ((hashed[i >> 1] & 0x0f) >= 8) {
            chars[i + 1] = chars[i + 1].toUpperCase();
        }
    }
    return "0x" + chars.join("");
}
// Shims for environments that are missing some required constants and functions
var MAX_SAFE_INTEGER = 0x1fffffffffffff;
function log10(x) {
    if (Math.log10) {
        return Math.log10(x);
    }
    return Math.log(x) / Math.LN10;
}
// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
// Create lookup table
var ibanLookup = {};
for (var i = 0; i < 10; i++) {
    ibanLookup[String(i)] = String(i);
}
for (var i = 0; i < 26; i++) {
    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
// How many decimal digits can we process? (for 64-bit float, this is 15)
var safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    var expanded = address.split("").map(function (c) { return ibanLookup[c]; }).join("");
    // Javascript can handle integers safely up to 15 (decimal) digits
    while (expanded.length >= safeDigits) {
        var block = expanded.substring(0, safeDigits);
        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
    }
    var checksum = String(98 - (parseInt(expanded, 10) % 97));
    while (checksum.length < 2) {
        checksum = "0" + checksum;
    }
    return checksum;
}
;
function getAddress(address) {
    var result = null;
    if (typeof (address) !== "string") {
        logger.throwArgumentError("invalid address", "address", address);
    }
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        // Missing the 0x prefix
        if (address.substring(0, 2) !== "0x") {
            address = "0x" + address;
        }
        result = getChecksumAddress(address);
        // It is a checksummed address with a bad checksum
        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
            logger.throwArgumentError("bad address checksum", "address", address);
        }
        // Maybe ICAP? (we only support direct mode)
    }
    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        // It is an ICAP address with a bad checksum
        if (address.substring(2, 4) !== ibanChecksum(address)) {
            logger.throwArgumentError("bad icap checksum", "address", address);
        }
        result = (0, bignumber_1._base36To16)(address.substring(4));
        while (result.length < 40) {
            result = "0" + result;
        }
        result = getChecksumAddress("0x" + result);
    }
    else {
        logger.throwArgumentError("invalid address", "address", address);
    }
    return result;
}
exports.getAddress = getAddress;
function isAddress(address) {
    try {
        getAddress(address);
        return true;
    }
    catch (error) { }
    return false;
}
exports.isAddress = isAddress;
function getIcapAddress(address) {
    var base36 = (0, bignumber_1._base16To36)(getAddress(address).substring(2)).toUpperCase();
    while (base36.length < 30) {
        base36 = "0" + base36;
    }
    return "XE" + ibanChecksum("XE00" + base36) + base36;
}
exports.getIcapAddress = getIcapAddress;
// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed
function getContractAddress(transaction) {
    var from = null;
    try {
        from = getAddress(transaction.from);
    }
    catch (error) {
        logger.throwArgumentError("missing from address", "transaction", transaction);
    }
    var nonce = (0, bytes_1.stripZeros)((0, bytes_1.arrayify)(bignumber_1.BigNumber.from(transaction.nonce).toHexString()));
    return getAddress((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, rlp_1.encode)([from, nonce])), 12));
}
exports.getContractAddress = getContractAddress;
function getCreate2Address(from, salt, initCodeHash) {
    if ((0, bytes_1.hexDataLength)(salt) !== 32) {
        logger.throwArgumentError("salt must be 32 bytes", "salt", salt);
    }
    if ((0, bytes_1.hexDataLength)(initCodeHash) !== 32) {
        logger.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
    }
    return getAddress((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.concat)(["0xff", getAddress(from), salt, initCodeHash])), 12));
}
exports.getCreate2Address = getCreate2Address;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3119:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encode = exports.decode = void 0;
var bytes_1 = __nccwpck_require__(2056);
function decode(textData) {
    return (0, bytes_1.arrayify)(new Uint8Array(Buffer.from(textData, "base64")));
}
exports.decode = decode;
;
function encode(data) {
    return Buffer.from((0, bytes_1.arrayify)(data)).toString("base64");
}
exports.encode = encode;
//# sourceMappingURL=base64.js.map

/***/ }),

/***/ 8144:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encode = exports.decode = void 0;
var base64_1 = __nccwpck_require__(3119);
Object.defineProperty(exports, "decode", ({ enumerable: true, get: function () { return base64_1.decode; } }));
Object.defineProperty(exports, "encode", ({ enumerable: true, get: function () { return base64_1.encode; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8241:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * var basex = require("base-x");
 *
 * This implementation is heavily based on base-x. The main reason to
 * deviate was to prevent the dependency of Buffer.
 *
 * Contributors:
 *
 * base-x encoding
 * Forked from https://github.com/cryptocoinjs/bs58
 * Originally written by Mike Hearn for BitcoinJ
 * Copyright (c) 2011 Google Inc
 * Ported to JavaScript by Stefan Thomas
 * Merged Buffer refactorings from base58-native by Stephen Pair
 * Copyright (c) 2013 BitPay Inc
 *
 * The MIT License (MIT)
 *
 * Copyright base-x contributors (c) 2016
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Base58 = exports.Base32 = exports.BaseX = void 0;
var bytes_1 = __nccwpck_require__(2056);
var properties_1 = __nccwpck_require__(8078);
var BaseX = /** @class */ (function () {
    function BaseX(alphabet) {
        (0, properties_1.defineReadOnly)(this, "alphabet", alphabet);
        (0, properties_1.defineReadOnly)(this, "base", alphabet.length);
        (0, properties_1.defineReadOnly)(this, "_alphabetMap", {});
        (0, properties_1.defineReadOnly)(this, "_leader", alphabet.charAt(0));
        // pre-compute lookup table
        for (var i = 0; i < alphabet.length; i++) {
            this._alphabetMap[alphabet.charAt(i)] = i;
        }
    }
    BaseX.prototype.encode = function (value) {
        var source = (0, bytes_1.arrayify)(value);
        if (source.length === 0) {
            return "";
        }
        var digits = [0];
        for (var i = 0; i < source.length; ++i) {
            var carry = source[i];
            for (var j = 0; j < digits.length; ++j) {
                carry += digits[j] << 8;
                digits[j] = carry % this.base;
                carry = (carry / this.base) | 0;
            }
            while (carry > 0) {
                digits.push(carry % this.base);
                carry = (carry / this.base) | 0;
            }
        }
        var string = "";
        // deal with leading zeros
        for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) {
            string += this._leader;
        }
        // convert digits to a string
        for (var q = digits.length - 1; q >= 0; --q) {
            string += this.alphabet[digits[q]];
        }
        return string;
    };
    BaseX.prototype.decode = function (value) {
        if (typeof (value) !== "string") {
            throw new TypeError("Expected String");
        }
        var bytes = [];
        if (value.length === 0) {
            return new Uint8Array(bytes);
        }
        bytes.push(0);
        for (var i = 0; i < value.length; i++) {
            var byte = this._alphabetMap[value[i]];
            if (byte === undefined) {
                throw new Error("Non-base" + this.base + " character");
            }
            var carry = byte;
            for (var j = 0; j < bytes.length; ++j) {
                carry += bytes[j] * this.base;
                bytes[j] = carry & 0xff;
                carry >>= 8;
            }
            while (carry > 0) {
                bytes.push(carry & 0xff);
                carry >>= 8;
            }
        }
        // deal with leading zeros
        for (var k = 0; value[k] === this._leader && k < value.length - 1; ++k) {
            bytes.push(0);
        }
        return (0, bytes_1.arrayify)(new Uint8Array(bytes.reverse()));
    };
    return BaseX;
}());
exports.BaseX = BaseX;
var Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
exports.Base32 = Base32;
var Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
exports.Base58 = Base58;
//console.log(Base58.decode("Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj"))
//console.log(Base58.encode(Base58.decode("Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj")))
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3181:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = "bignumber/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ 3876:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._base16To36 = exports._base36To16 = exports.BigNumber = exports.isBigNumberish = void 0;
/**
 *  BigNumber
 *
 *  A wrapper around the BN.js object. We use the BN.js library
 *  because it is used by elliptic, so it is required regardless.
 *
 */
var bn_js_1 = __importDefault(__nccwpck_require__(6641));
var BN = bn_js_1.default.BN;
var bytes_1 = __nccwpck_require__(2056);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(3181);
var logger = new logger_1.Logger(_version_1.version);
var _constructorGuard = {};
var MAX_SAFE = 0x1fffffffffffff;
function isBigNumberish(value) {
    return (value != null) && (BigNumber.isBigNumber(value) ||
        (typeof (value) === "number" && (value % 1) === 0) ||
        (typeof (value) === "string" && !!value.match(/^-?[0-9]+$/)) ||
        (0, bytes_1.isHexString)(value) ||
        (typeof (value) === "bigint") ||
        (0, bytes_1.isBytes)(value));
}
exports.isBigNumberish = isBigNumberish;
// Only warn about passing 10 into radix once
var _warnedToStringRadix = false;
var BigNumber = /** @class */ (function () {
    function BigNumber(constructorGuard, hex) {
        if (constructorGuard !== _constructorGuard) {
            logger.throwError("cannot call constructor directly; use BigNumber.from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new (BigNumber)"
            });
        }
        this._hex = hex;
        this._isBigNumber = true;
        Object.freeze(this);
    }
    BigNumber.prototype.fromTwos = function (value) {
        return toBigNumber(toBN(this).fromTwos(value));
    };
    BigNumber.prototype.toTwos = function (value) {
        return toBigNumber(toBN(this).toTwos(value));
    };
    BigNumber.prototype.abs = function () {
        if (this._hex[0] === "-") {
            return BigNumber.from(this._hex.substring(1));
        }
        return this;
    };
    BigNumber.prototype.add = function (other) {
        return toBigNumber(toBN(this).add(toBN(other)));
    };
    BigNumber.prototype.sub = function (other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
    };
    BigNumber.prototype.div = function (other) {
        var o = BigNumber.from(other);
        if (o.isZero()) {
            throwFault("division-by-zero", "div");
        }
        return toBigNumber(toBN(this).div(toBN(other)));
    };
    BigNumber.prototype.mul = function (other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
    };
    BigNumber.prototype.mod = function (other) {
        var value = toBN(other);
        if (value.isNeg()) {
            throwFault("division-by-zero", "mod");
        }
        return toBigNumber(toBN(this).umod(value));
    };
    BigNumber.prototype.pow = function (other) {
        var value = toBN(other);
        if (value.isNeg()) {
            throwFault("negative-power", "pow");
        }
        return toBigNumber(toBN(this).pow(value));
    };
    BigNumber.prototype.and = function (other) {
        var value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("unbound-bitwise-result", "and");
        }
        return toBigNumber(toBN(this).and(value));
    };
    BigNumber.prototype.or = function (other) {
        var value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("unbound-bitwise-result", "or");
        }
        return toBigNumber(toBN(this).or(value));
    };
    BigNumber.prototype.xor = function (other) {
        var value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("unbound-bitwise-result", "xor");
        }
        return toBigNumber(toBN(this).xor(value));
    };
    BigNumber.prototype.mask = function (value) {
        if (this.isNegative() || value < 0) {
            throwFault("negative-width", "mask");
        }
        return toBigNumber(toBN(this).maskn(value));
    };
    BigNumber.prototype.shl = function (value) {
        if (this.isNegative() || value < 0) {
            throwFault("negative-width", "shl");
        }
        return toBigNumber(toBN(this).shln(value));
    };
    BigNumber.prototype.shr = function (value) {
        if (this.isNegative() || value < 0) {
            throwFault("negative-width", "shr");
        }
        return toBigNumber(toBN(this).shrn(value));
    };
    BigNumber.prototype.eq = function (other) {
        return toBN(this).eq(toBN(other));
    };
    BigNumber.prototype.lt = function (other) {
        return toBN(this).lt(toBN(other));
    };
    BigNumber.prototype.lte = function (other) {
        return toBN(this).lte(toBN(other));
    };
    BigNumber.prototype.gt = function (other) {
        return toBN(this).gt(toBN(other));
    };
    BigNumber.prototype.gte = function (other) {
        return toBN(this).gte(toBN(other));
    };
    BigNumber.prototype.isNegative = function () {
        return (this._hex[0] === "-");
    };
    BigNumber.prototype.isZero = function () {
        return toBN(this).isZero();
    };
    BigNumber.prototype.toNumber = function () {
        try {
            return toBN(this).toNumber();
        }
        catch (error) {
            throwFault("overflow", "toNumber", this.toString());
        }
        return null;
    };
    BigNumber.prototype.toBigInt = function () {
        try {
            return BigInt(this.toString());
        }
        catch (e) { }
        return logger.throwError("this platform does not support BigInt", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        });
    };
    BigNumber.prototype.toString = function () {
        // Lots of people expect this, which we do not support, so check (See: #889)
        if (arguments.length > 0) {
            if (arguments[0] === 10) {
                if (!_warnedToStringRadix) {
                    _warnedToStringRadix = true;
                    logger.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
                }
            }
            else if (arguments[0] === 16) {
                logger.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {});
            }
            else {
                logger.throwError("BigNumber.toString does not accept parameters", logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {});
            }
        }
        return toBN(this).toString(10);
    };
    BigNumber.prototype.toHexString = function () {
        return this._hex;
    };
    BigNumber.prototype.toJSON = function (key) {
        return { type: "BigNumber", hex: this.toHexString() };
    };
    BigNumber.from = function (value) {
        if (value instanceof BigNumber) {
            return value;
        }
        if (typeof (value) === "string") {
            if (value.match(/^-?0x[0-9a-f]+$/i)) {
                return new BigNumber(_constructorGuard, toHex(value));
            }
            if (value.match(/^-?[0-9]+$/)) {
                return new BigNumber(_constructorGuard, toHex(new BN(value)));
            }
            return logger.throwArgumentError("invalid BigNumber string", "value", value);
        }
        if (typeof (value) === "number") {
            if (value % 1) {
                throwFault("underflow", "BigNumber.from", value);
            }
            if (value >= MAX_SAFE || value <= -MAX_SAFE) {
                throwFault("overflow", "BigNumber.from", value);
            }
            return BigNumber.from(String(value));
        }
        var anyValue = value;
        if (typeof (anyValue) === "bigint") {
            return BigNumber.from(anyValue.toString());
        }
        if ((0, bytes_1.isBytes)(anyValue)) {
            return BigNumber.from((0, bytes_1.hexlify)(anyValue));
        }
        if (anyValue) {
            // Hexable interface (takes priority)
            if (anyValue.toHexString) {
                var hex = anyValue.toHexString();
                if (typeof (hex) === "string") {
                    return BigNumber.from(hex);
                }
            }
            else {
                // For now, handle legacy JSON-ified values (goes away in v6)
                var hex = anyValue._hex;
                // New-form JSON
                if (hex == null && anyValue.type === "BigNumber") {
                    hex = anyValue.hex;
                }
                if (typeof (hex) === "string") {
                    if ((0, bytes_1.isHexString)(hex) || (hex[0] === "-" && (0, bytes_1.isHexString)(hex.substring(1)))) {
                        return BigNumber.from(hex);
                    }
                }
            }
        }
        return logger.throwArgumentError("invalid BigNumber value", "value", value);
    };
    BigNumber.isBigNumber = function (value) {
        return !!(value && value._isBigNumber);
    };
    return BigNumber;
}());
exports.BigNumber = BigNumber;
// Normalize the hex string
function toHex(value) {
    // For BN, call on the hex string
    if (typeof (value) !== "string") {
        return toHex(value.toString(16));
    }
    // If negative, prepend the negative sign to the normalized positive value
    if (value[0] === "-") {
        // Strip off the negative sign
        value = value.substring(1);
        // Cannot have multiple negative signs (e.g. "--0x04")
        if (value[0] === "-") {
            logger.throwArgumentError("invalid hex", "value", value);
        }
        // Call toHex on the positive component
        value = toHex(value);
        // Do not allow "-0x00"
        if (value === "0x00") {
            return value;
        }
        // Negate the value
        return "-" + value;
    }
    // Add a "0x" prefix if missing
    if (value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    // Normalize zero
    if (value === "0x") {
        return "0x00";
    }
    // Make the string even length
    if (value.length % 2) {
        value = "0x0" + value.substring(2);
    }
    // Trim to smallest even-length string
    while (value.length > 4 && value.substring(0, 4) === "0x00") {
        value = "0x" + value.substring(4);
    }
    return value;
}
function toBigNumber(value) {
    return BigNumber.from(toHex(value));
}
function toBN(value) {
    var hex = BigNumber.from(value).toHexString();
    if (hex[0] === "-") {
        return (new BN("-" + hex.substring(3), 16));
    }
    return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
    var params = { fault: fault, operation: operation };
    if (value != null) {
        params.value = value;
    }
    return logger.throwError(fault, logger_1.Logger.errors.NUMERIC_FAULT, params);
}
// value should have no prefix
function _base36To16(value) {
    return (new BN(value, 36)).toString(16);
}
exports._base36To16 = _base36To16;
// value should have no prefix
function _base16To36(value) {
    return (new BN(value, 16)).toString(36);
}
exports._base16To36 = _base16To36;
//# sourceMappingURL=bignumber.js.map

/***/ }),

/***/ 1276:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FixedNumber = exports.FixedFormat = exports.parseFixed = exports.formatFixed = void 0;
var bytes_1 = __nccwpck_require__(2056);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(3181);
var logger = new logger_1.Logger(_version_1.version);
var bignumber_1 = __nccwpck_require__(3876);
var _constructorGuard = {};
var Zero = bignumber_1.BigNumber.from(0);
var NegativeOne = bignumber_1.BigNumber.from(-1);
function throwFault(message, fault, operation, value) {
    var params = { fault: fault, operation: operation };
    if (value !== undefined) {
        params.value = value;
    }
    return logger.throwError(message, logger_1.Logger.errors.NUMERIC_FAULT, params);
}
// Constant to pull zeros from for multipliers
var zeros = "0";
while (zeros.length < 256) {
    zeros += zeros;
}
// Returns a string "1" followed by decimal "0"s
function getMultiplier(decimals) {
    if (typeof (decimals) !== "number") {
        try {
            decimals = bignumber_1.BigNumber.from(decimals).toNumber();
        }
        catch (e) { }
    }
    if (typeof (decimals) === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
        return ("1" + zeros.substring(0, decimals));
    }
    return logger.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
    if (decimals == null) {
        decimals = 0;
    }
    var multiplier = getMultiplier(decimals);
    // Make sure wei is a big number (convert as necessary)
    value = bignumber_1.BigNumber.from(value);
    var negative = value.lt(Zero);
    if (negative) {
        value = value.mul(NegativeOne);
    }
    var fraction = value.mod(multiplier).toString();
    while (fraction.length < multiplier.length - 1) {
        fraction = "0" + fraction;
    }
    // Strip training 0
    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    var whole = value.div(multiplier).toString();
    if (multiplier.length === 1) {
        value = whole;
    }
    else {
        value = whole + "." + fraction;
    }
    if (negative) {
        value = "-" + value;
    }
    return value;
}
exports.formatFixed = formatFixed;
function parseFixed(value, decimals) {
    if (decimals == null) {
        decimals = 0;
    }
    var multiplier = getMultiplier(decimals);
    if (typeof (value) !== "string" || !value.match(/^-?[0-9.]+$/)) {
        logger.throwArgumentError("invalid decimal value", "value", value);
    }
    // Is it negative?
    var negative = (value.substring(0, 1) === "-");
    if (negative) {
        value = value.substring(1);
    }
    if (value === ".") {
        logger.throwArgumentError("missing value", "value", value);
    }
    // Split it into a whole and fractional part
    var comps = value.split(".");
    if (comps.length > 2) {
        logger.throwArgumentError("too many decimal points", "value", value);
    }
    var whole = comps[0], fraction = comps[1];
    if (!whole) {
        whole = "0";
    }
    if (!fraction) {
        fraction = "0";
    }
    // Trim trailing zeros
    while (fraction[fraction.length - 1] === "0") {
        fraction = fraction.substring(0, fraction.length - 1);
    }
    // Check the fraction doesn't exceed our decimals size
    if (fraction.length > multiplier.length - 1) {
        throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
    }
    // If decimals is 0, we have an empty string for fraction
    if (fraction === "") {
        fraction = "0";
    }
    // Fully pad the string with zeros to get to wei
    while (fraction.length < multiplier.length - 1) {
        fraction += "0";
    }
    var wholeValue = bignumber_1.BigNumber.from(whole);
    var fractionValue = bignumber_1.BigNumber.from(fraction);
    var wei = (wholeValue.mul(multiplier)).add(fractionValue);
    if (negative) {
        wei = wei.mul(NegativeOne);
    }
    return wei;
}
exports.parseFixed = parseFixed;
var FixedFormat = /** @class */ (function () {
    function FixedFormat(constructorGuard, signed, width, decimals) {
        if (constructorGuard !== _constructorGuard) {
            logger.throwError("cannot use FixedFormat constructor; use FixedFormat.from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new FixedFormat"
            });
        }
        this.signed = signed;
        this.width = width;
        this.decimals = decimals;
        this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
        this._multiplier = getMultiplier(decimals);
        Object.freeze(this);
    }
    FixedFormat.from = function (value) {
        if (value instanceof FixedFormat) {
            return value;
        }
        if (typeof (value) === "number") {
            value = "fixed128x" + value;
        }
        var signed = true;
        var width = 128;
        var decimals = 18;
        if (typeof (value) === "string") {
            if (value === "fixed") {
                // defaults...
            }
            else if (value === "ufixed") {
                signed = false;
            }
            else {
                var match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
                if (!match) {
                    logger.throwArgumentError("invalid fixed format", "format", value);
                }
                signed = (match[1] !== "u");
                width = parseInt(match[2]);
                decimals = parseInt(match[3]);
            }
        }
        else if (value) {
            var check = function (key, type, defaultValue) {
                if (value[key] == null) {
                    return defaultValue;
                }
                if (typeof (value[key]) !== type) {
                    logger.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
                }
                return value[key];
            };
            signed = check("signed", "boolean", signed);
            width = check("width", "number", width);
            decimals = check("decimals", "number", decimals);
        }
        if (width % 8) {
            logger.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
        }
        if (decimals > 80) {
            logger.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
        }
        return new FixedFormat(_constructorGuard, signed, width, decimals);
    };
    return FixedFormat;
}());
exports.FixedFormat = FixedFormat;
var FixedNumber = /** @class */ (function () {
    function FixedNumber(constructorGuard, hex, value, format) {
        if (constructorGuard !== _constructorGuard) {
            logger.throwError("cannot use FixedNumber constructor; use FixedNumber.from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new FixedFormat"
            });
        }
        this.format = format;
        this._hex = hex;
        this._value = value;
        this._isFixedNumber = true;
        Object.freeze(this);
    }
    FixedNumber.prototype._checkFormat = function (other) {
        if (this.format.name !== other.format.name) {
            logger.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
        }
    };
    FixedNumber.prototype.addUnsafe = function (other) {
        this._checkFormat(other);
        var a = parseFixed(this._value, this.format.decimals);
        var b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);
    };
    FixedNumber.prototype.subUnsafe = function (other) {
        this._checkFormat(other);
        var a = parseFixed(this._value, this.format.decimals);
        var b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);
    };
    FixedNumber.prototype.mulUnsafe = function (other) {
        this._checkFormat(other);
        var a = parseFixed(this._value, this.format.decimals);
        var b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
    };
    FixedNumber.prototype.divUnsafe = function (other) {
        this._checkFormat(other);
        var a = parseFixed(this._value, this.format.decimals);
        var b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
    };
    FixedNumber.prototype.floor = function () {
        var comps = this.toString().split(".");
        if (comps.length === 1) {
            comps.push("0");
        }
        var result = FixedNumber.from(comps[0], this.format);
        var hasFraction = !comps[1].match(/^(0*)$/);
        if (this.isNegative() && hasFraction) {
            result = result.subUnsafe(ONE.toFormat(result.format));
        }
        return result;
    };
    FixedNumber.prototype.ceiling = function () {
        var comps = this.toString().split(".");
        if (comps.length === 1) {
            comps.push("0");
        }
        var result = FixedNumber.from(comps[0], this.format);
        var hasFraction = !comps[1].match(/^(0*)$/);
        if (!this.isNegative() && hasFraction) {
            result = result.addUnsafe(ONE.toFormat(result.format));
        }
        return result;
    };
    // @TODO: Support other rounding algorithms
    FixedNumber.prototype.round = function (decimals) {
        if (decimals == null) {
            decimals = 0;
        }
        // If we are already in range, we're done
        var comps = this.toString().split(".");
        if (comps.length === 1) {
            comps.push("0");
        }
        if (decimals < 0 || decimals > 80 || (decimals % 1)) {
            logger.throwArgumentError("invalid decimal count", "decimals", decimals);
        }
        if (comps[1].length <= decimals) {
            return this;
        }
        var factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
        var bump = BUMP.toFormat(this.format);
        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
    };
    FixedNumber.prototype.isZero = function () {
        return (this._value === "0.0" || this._value === "0");
    };
    FixedNumber.prototype.isNegative = function () {
        return (this._value[0] === "-");
    };
    FixedNumber.prototype.toString = function () { return this._value; };
    FixedNumber.prototype.toHexString = function (width) {
        if (width == null) {
            return this._hex;
        }
        if (width % 8) {
            logger.throwArgumentError("invalid byte width", "width", width);
        }
        var hex = bignumber_1.BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
        return (0, bytes_1.hexZeroPad)(hex, width / 8);
    };
    FixedNumber.prototype.toUnsafeFloat = function () { return parseFloat(this.toString()); };
    FixedNumber.prototype.toFormat = function (format) {
        return FixedNumber.fromString(this._value, format);
    };
    FixedNumber.fromValue = function (value, decimals, format) {
        // If decimals looks more like a format, and there is no format, shift the parameters
        if (format == null && decimals != null && !(0, bignumber_1.isBigNumberish)(decimals)) {
            format = decimals;
            decimals = null;
        }
        if (decimals == null) {
            decimals = 0;
        }
        if (format == null) {
            format = "fixed";
        }
        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
    };
    FixedNumber.fromString = function (value, format) {
        if (format == null) {
            format = "fixed";
        }
        var fixedFormat = FixedFormat.from(format);
        var numeric = parseFixed(value, fixedFormat.decimals);
        if (!fixedFormat.signed && numeric.lt(Zero)) {
            throwFault("unsigned value cannot be negative", "overflow", "value", value);
        }
        var hex = null;
        if (fixedFormat.signed) {
            hex = numeric.toTwos(fixedFormat.width).toHexString();
        }
        else {
            hex = numeric.toHexString();
            hex = (0, bytes_1.hexZeroPad)(hex, fixedFormat.width / 8);
        }
        var decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);
    };
    FixedNumber.fromBytes = function (value, format) {
        if (format == null) {
            format = "fixed";
        }
        var fixedFormat = FixedFormat.from(format);
        if ((0, bytes_1.arrayify)(value).length > fixedFormat.width / 8) {
            throw new Error("overflow");
        }
        var numeric = bignumber_1.BigNumber.from(value);
        if (fixedFormat.signed) {
            numeric = numeric.fromTwos(fixedFormat.width);
        }
        var hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
        var decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);
    };
    FixedNumber.from = function (value, format) {
        if (typeof (value) === "string") {
            return FixedNumber.fromString(value, format);
        }
        if ((0, bytes_1.isBytes)(value)) {
            return FixedNumber.fromBytes(value, format);
        }
        try {
            return FixedNumber.fromValue(value, 0, format);
        }
        catch (error) {
            // Allow NUMERIC_FAULT to bubble up
            if (error.code !== logger_1.Logger.errors.INVALID_ARGUMENT) {
                throw error;
            }
        }
        return logger.throwArgumentError("invalid FixedNumber value", "value", value);
    };
    FixedNumber.isFixedNumber = function (value) {
        return !!(value && value._isFixedNumber);
    };
    return FixedNumber;
}());
exports.FixedNumber = FixedNumber;
var ONE = FixedNumber.from(1);
var BUMP = FixedNumber.from("0.5");
//# sourceMappingURL=fixednumber.js.map

/***/ }),

/***/ 1267:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._base36To16 = exports._base16To36 = exports.parseFixed = exports.FixedNumber = exports.FixedFormat = exports.formatFixed = exports.BigNumber = void 0;
var bignumber_1 = __nccwpck_require__(3876);
Object.defineProperty(exports, "BigNumber", ({ enumerable: true, get: function () { return bignumber_1.BigNumber; } }));
var fixednumber_1 = __nccwpck_require__(1276);
Object.defineProperty(exports, "formatFixed", ({ enumerable: true, get: function () { return fixednumber_1.formatFixed; } }));
Object.defineProperty(exports, "FixedFormat", ({ enumerable: true, get: function () { return fixednumber_1.FixedFormat; } }));
Object.defineProperty(exports, "FixedNumber", ({ enumerable: true, get: function () { return fixednumber_1.FixedNumber; } }));
Object.defineProperty(exports, "parseFixed", ({ enumerable: true, get: function () { return fixednumber_1.parseFixed; } }));
// Internal methods used by address
var bignumber_2 = __nccwpck_require__(3876);
Object.defineProperty(exports, "_base16To36", ({ enumerable: true, get: function () { return bignumber_2._base16To36; } }));
Object.defineProperty(exports, "_base36To16", ({ enumerable: true, get: function () { return bignumber_2._base36To16; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9433:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = "bytes/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ 2056:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.joinSignature = exports.splitSignature = exports.hexZeroPad = exports.hexStripZeros = exports.hexValue = exports.hexConcat = exports.hexDataSlice = exports.hexDataLength = exports.hexlify = exports.isHexString = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.isBytes = exports.isBytesLike = void 0;
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(9433);
var logger = new logger_1.Logger(_version_1.version);
///////////////////////////////
function isHexable(value) {
    return !!(value.toHexString);
}
function addSlice(array) {
    if (array.slice) {
        return array;
    }
    array.slice = function () {
        var args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
    };
    return array;
}
function isBytesLike(value) {
    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));
}
exports.isBytesLike = isBytesLike;
function isInteger(value) {
    return (typeof (value) === "number" && value == value && (value % 1) === 0);
}
function isBytes(value) {
    if (value == null) {
        return false;
    }
    if (value.constructor === Uint8Array) {
        return true;
    }
    if (typeof (value) === "string") {
        return false;
    }
    if (!isInteger(value.length) || value.length < 0) {
        return false;
    }
    for (var i = 0; i < value.length; i++) {
        var v = value[i];
        if (!isInteger(v) || v < 0 || v >= 256) {
            return false;
        }
    }
    return true;
}
exports.isBytes = isBytes;
function arrayify(value, options) {
    if (!options) {
        options = {};
    }
    if (typeof (value) === "number") {
        logger.checkSafeUint53(value, "invalid arrayify value");
        var result = [];
        while (value) {
            result.unshift(value & 0xff);
            value = parseInt(String(value / 256));
        }
        if (result.length === 0) {
            result.push(0);
        }
        return addSlice(new Uint8Array(result));
    }
    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    if (isHexable(value)) {
        value = value.toHexString();
    }
    if (isHexString(value)) {
        var hex = value.substring(2);
        if (hex.length % 2) {
            if (options.hexPad === "left") {
                hex = "0" + hex;
            }
            else if (options.hexPad === "right") {
                hex += "0";
            }
            else {
                logger.throwArgumentError("hex data is odd-length", "value", value);
            }
        }
        var result = [];
        for (var i = 0; i < hex.length; i += 2) {
            result.push(parseInt(hex.substring(i, i + 2), 16));
        }
        return addSlice(new Uint8Array(result));
    }
    if (isBytes(value)) {
        return addSlice(new Uint8Array(value));
    }
    return logger.throwArgumentError("invalid arrayify value", "value", value);
}
exports.arrayify = arrayify;
function concat(items) {
    var objects = items.map(function (item) { return arrayify(item); });
    var length = objects.reduce(function (accum, item) { return (accum + item.length); }, 0);
    var result = new Uint8Array(length);
    objects.reduce(function (offset, object) {
        result.set(object, offset);
        return offset + object.length;
    }, 0);
    return addSlice(result);
}
exports.concat = concat;
function stripZeros(value) {
    var result = arrayify(value);
    if (result.length === 0) {
        return result;
    }
    // Find the first non-zero entry
    var start = 0;
    while (start < result.length && result[start] === 0) {
        start++;
    }
    // If we started with zeros, strip them
    if (start) {
        result = result.slice(start);
    }
    return result;
}
exports.stripZeros = stripZeros;
function zeroPad(value, length) {
    value = arrayify(value);
    if (value.length > length) {
        logger.throwArgumentError("value out of range", "value", arguments[0]);
    }
    var result = new Uint8Array(length);
    result.set(value, length - value.length);
    return addSlice(result);
}
exports.zeroPad = zeroPad;
function isHexString(value, length) {
    if (typeof (value) !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
    }
    if (length && value.length !== 2 + 2 * length) {
        return false;
    }
    return true;
}
exports.isHexString = isHexString;
var HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
    if (!options) {
        options = {};
    }
    if (typeof (value) === "number") {
        logger.checkSafeUint53(value, "invalid hexlify value");
        var hex = "";
        while (value) {
            hex = HexCharacters[value & 0xf] + hex;
            value = Math.floor(value / 16);
        }
        if (hex.length) {
            if (hex.length % 2) {
                hex = "0" + hex;
            }
            return "0x" + hex;
        }
        return "0x00";
    }
    if (typeof (value) === "bigint") {
        value = value.toString(16);
        if (value.length % 2) {
            return ("0x0" + value);
        }
        return "0x" + value;
    }
    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    if (isHexable(value)) {
        return value.toHexString();
    }
    if (isHexString(value)) {
        if (value.length % 2) {
            if (options.hexPad === "left") {
                value = "0x0" + value.substring(2);
            }
            else if (options.hexPad === "right") {
                value += "0";
            }
            else {
                logger.throwArgumentError("hex data is odd-length", "value", value);
            }
        }
        return value.toLowerCase();
    }
    if (isBytes(value)) {
        var result = "0x";
        for (var i = 0; i < value.length; i++) {
            var v = value[i];
            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
        }
        return result;
    }
    return logger.throwArgumentError("invalid hexlify value", "value", value);
}
exports.hexlify = hexlify;
/*
function unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {
    if (typeof(value) === "string" && value.length % 2 && value.substring(0, 2) === "0x") {
        return "0x0" + value.substring(2);
    }
    return value;
}
*/
function hexDataLength(data) {
    if (typeof (data) !== "string") {
        data = hexlify(data);
    }
    else if (!isHexString(data) || (data.length % 2)) {
        return null;
    }
    return (data.length - 2) / 2;
}
exports.hexDataLength = hexDataLength;
function hexDataSlice(data, offset, endOffset) {
    if (typeof (data) !== "string") {
        data = hexlify(data);
    }
    else if (!isHexString(data) || (data.length % 2)) {
        logger.throwArgumentError("invalid hexData", "value", data);
    }
    offset = 2 + 2 * offset;
    if (endOffset != null) {
        return "0x" + data.substring(offset, 2 + 2 * endOffset);
    }
    return "0x" + data.substring(offset);
}
exports.hexDataSlice = hexDataSlice;
function hexConcat(items) {
    var result = "0x";
    items.forEach(function (item) {
        result += hexlify(item).substring(2);
    });
    return result;
}
exports.hexConcat = hexConcat;
function hexValue(value) {
    var trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
    if (trimmed === "0x") {
        return "0x0";
    }
    return trimmed;
}
exports.hexValue = hexValue;
function hexStripZeros(value) {
    if (typeof (value) !== "string") {
        value = hexlify(value);
    }
    if (!isHexString(value)) {
        logger.throwArgumentError("invalid hex string", "value", value);
    }
    value = value.substring(2);
    var offset = 0;
    while (offset < value.length && value[offset] === "0") {
        offset++;
    }
    return "0x" + value.substring(offset);
}
exports.hexStripZeros = hexStripZeros;
function hexZeroPad(value, length) {
    if (typeof (value) !== "string") {
        value = hexlify(value);
    }
    else if (!isHexString(value)) {
        logger.throwArgumentError("invalid hex string", "value", value);
    }
    if (value.length > 2 * length + 2) {
        logger.throwArgumentError("value out of range", "value", arguments[1]);
    }
    while (value.length < 2 * length + 2) {
        value = "0x0" + value.substring(2);
    }
    return value;
}
exports.hexZeroPad = hexZeroPad;
function splitSignature(signature) {
    var result = {
        r: "0x",
        s: "0x",
        _vs: "0x",
        recoveryParam: 0,
        v: 0,
        yParityAndS: "0x",
        compact: "0x"
    };
    if (isBytesLike(signature)) {
        var bytes = arrayify(signature);
        // Get the r, s and v
        if (bytes.length === 64) {
            // EIP-2098; pull the v from the top bit of s and clear it
            result.v = 27 + (bytes[32] >> 7);
            bytes[32] &= 0x7f;
            result.r = hexlify(bytes.slice(0, 32));
            result.s = hexlify(bytes.slice(32, 64));
        }
        else if (bytes.length === 65) {
            result.r = hexlify(bytes.slice(0, 32));
            result.s = hexlify(bytes.slice(32, 64));
            result.v = bytes[64];
        }
        else {
            logger.throwArgumentError("invalid signature string", "signature", signature);
        }
        // Allow a recid to be used as the v
        if (result.v < 27) {
            if (result.v === 0 || result.v === 1) {
                result.v += 27;
            }
            else {
                logger.throwArgumentError("signature invalid v byte", "signature", signature);
            }
        }
        // Compute recoveryParam from v
        result.recoveryParam = 1 - (result.v % 2);
        // Compute _vs from recoveryParam and s
        if (result.recoveryParam) {
            bytes[32] |= 0x80;
        }
        result._vs = hexlify(bytes.slice(32, 64));
    }
    else {
        result.r = signature.r;
        result.s = signature.s;
        result.v = signature.v;
        result.recoveryParam = signature.recoveryParam;
        result._vs = signature._vs;
        // If the _vs is available, use it to populate missing s, v and recoveryParam
        // and verify non-missing s, v and recoveryParam
        if (result._vs != null) {
            var vs_1 = zeroPad(arrayify(result._vs), 32);
            result._vs = hexlify(vs_1);
            // Set or check the recid
            var recoveryParam = ((vs_1[0] >= 128) ? 1 : 0);
            if (result.recoveryParam == null) {
                result.recoveryParam = recoveryParam;
            }
            else if (result.recoveryParam !== recoveryParam) {
                logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature);
            }
            // Set or check the s
            vs_1[0] &= 0x7f;
            var s = hexlify(vs_1);
            if (result.s == null) {
                result.s = s;
            }
            else if (result.s !== s) {
                logger.throwArgumentError("signature v mismatch _vs", "signature", signature);
            }
        }
        // Use recid and v to populate each other
        if (result.recoveryParam == null) {
            if (result.v == null) {
                logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature);
            }
            else if (result.v === 0 || result.v === 1) {
                result.recoveryParam = result.v;
            }
            else {
                result.recoveryParam = 1 - (result.v % 2);
            }
        }
        else {
            if (result.v == null) {
                result.v = 27 + result.recoveryParam;
            }
            else {
                var recId = (result.v === 0 || result.v === 1) ? result.v : (1 - (result.v % 2));
                if (result.recoveryParam !== recId) {
                    logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature);
                }
            }
        }
        if (result.r == null || !isHexString(result.r)) {
            logger.throwArgumentError("signature missing or invalid r", "signature", signature);
        }
        else {
            result.r = hexZeroPad(result.r, 32);
        }
        if (result.s == null || !isHexString(result.s)) {
            logger.throwArgumentError("signature missing or invalid s", "signature", signature);
        }
        else {
            result.s = hexZeroPad(result.s, 32);
        }
        var vs = arrayify(result.s);
        if (vs[0] >= 128) {
            logger.throwArgumentError("signature s out of range", "signature", signature);
        }
        if (result.recoveryParam) {
            vs[0] |= 0x80;
        }
        var _vs = hexlify(vs);
        if (result._vs) {
            if (!isHexString(result._vs)) {
                logger.throwArgumentError("signature invalid _vs", "signature", signature);
            }
            result._vs = hexZeroPad(result._vs, 32);
        }
        // Set or check the _vs
        if (result._vs == null) {
            result._vs = _vs;
        }
        else if (result._vs !== _vs) {
            logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature);
        }
    }
    result.yParityAndS = result._vs;
    result.compact = result.r + result.yParityAndS.substring(2);
    return result;
}
exports.splitSignature = splitSignature;
function joinSignature(signature) {
    signature = splitSignature(signature);
    return hexlify(concat([
        signature.r,
        signature.s,
        (signature.recoveryParam ? "0x1c" : "0x1b")
    ]));
}
exports.joinSignature = joinSignature;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8611:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddressZero = void 0;
exports.AddressZero = "0x0000000000000000000000000000000000000000";
//# sourceMappingURL=addresses.js.map

/***/ }),

/***/ 6662:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.Two = exports.One = exports.Zero = exports.NegativeOne = void 0;
var bignumber_1 = __nccwpck_require__(1267);
var NegativeOne = ( /*#__PURE__*/bignumber_1.BigNumber.from(-1));
exports.NegativeOne = NegativeOne;
var Zero = ( /*#__PURE__*/bignumber_1.BigNumber.from(0));
exports.Zero = Zero;
var One = ( /*#__PURE__*/bignumber_1.BigNumber.from(1));
exports.One = One;
var Two = ( /*#__PURE__*/bignumber_1.BigNumber.from(2));
exports.Two = Two;
var WeiPerEther = ( /*#__PURE__*/bignumber_1.BigNumber.from("1000000000000000000"));
exports.WeiPerEther = WeiPerEther;
var MaxUint256 = ( /*#__PURE__*/bignumber_1.BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
exports.MaxUint256 = MaxUint256;
var MinInt256 = ( /*#__PURE__*/bignumber_1.BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000"));
exports.MinInt256 = MinInt256;
var MaxInt256 = ( /*#__PURE__*/bignumber_1.BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
exports.MaxInt256 = MaxInt256;
//# sourceMappingURL=bignumbers.js.map

/***/ }),

/***/ 7788:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HashZero = void 0;
exports.HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
//# sourceMappingURL=hashes.js.map

/***/ }),

/***/ 1309:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EtherSymbol = exports.HashZero = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.Two = exports.One = exports.Zero = exports.NegativeOne = exports.AddressZero = void 0;
var addresses_1 = __nccwpck_require__(8611);
Object.defineProperty(exports, "AddressZero", ({ enumerable: true, get: function () { return addresses_1.AddressZero; } }));
var bignumbers_1 = __nccwpck_require__(6662);
Object.defineProperty(exports, "NegativeOne", ({ enumerable: true, get: function () { return bignumbers_1.NegativeOne; } }));
Object.defineProperty(exports, "Zero", ({ enumerable: true, get: function () { return bignumbers_1.Zero; } }));
Object.defineProperty(exports, "One", ({ enumerable: true, get: function () { return bignumbers_1.One; } }));
Object.defineProperty(exports, "Two", ({ enumerable: true, get: function () { return bignumbers_1.Two; } }));
Object.defineProperty(exports, "WeiPerEther", ({ enumerable: true, get: function () { return bignumbers_1.WeiPerEther; } }));
Object.defineProperty(exports, "MaxUint256", ({ enumerable: true, get: function () { return bignumbers_1.MaxUint256; } }));
Object.defineProperty(exports, "MinInt256", ({ enumerable: true, get: function () { return bignumbers_1.MinInt256; } }));
Object.defineProperty(exports, "MaxInt256", ({ enumerable: true, get: function () { return bignumbers_1.MaxInt256; } }));
var hashes_1 = __nccwpck_require__(7788);
Object.defineProperty(exports, "HashZero", ({ enumerable: true, get: function () { return hashes_1.HashZero; } }));
var strings_1 = __nccwpck_require__(5454);
Object.defineProperty(exports, "EtherSymbol", ({ enumerable: true, get: function () { return strings_1.EtherSymbol; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 5454:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EtherSymbol = void 0;
// NFKC (composed)             // (decomposed)
exports.EtherSymbol = "\u039e"; // "\uD835\uDF63";
//# sourceMappingURL=strings.js.map

/***/ }),

/***/ 9553:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = "hash/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ 4021:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * MIT License
 *
 * Copyright (c) 2021 Andrew Raffensperger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This is a near carbon-copy of the original source (link below) with the
 * TypeScript typings added and a few tweaks to make it ES3-compatible.
 *
 * See: https://github.com/adraffy/ens-normalize.js
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.read_emoji_trie = exports.read_zero_terminated_array = exports.read_mapped_map = exports.read_member_array = exports.signed = exports.read_compressed_payload = exports.read_payload = exports.decode_arithmetic = void 0;
// https://github.com/behnammodi/polyfill/blob/master/array.polyfill.js
function flat(array, depth) {
    if (depth == null) {
        depth = 1;
    }
    var result = [];
    var forEach = result.forEach;
    var flatDeep = function (arr, depth) {
        forEach.call(arr, function (val) {
            if (depth > 0 && Array.isArray(val)) {
                flatDeep(val, depth - 1);
            }
            else {
                result.push(val);
            }
        });
    };
    flatDeep(array, depth);
    return result;
}
function fromEntries(array) {
    var result = {};
    for (var i = 0; i < array.length; i++) {
        var value = array[i];
        result[value[0]] = value[1];
    }
    return result;
}
function decode_arithmetic(bytes) {
    var pos = 0;
    function u16() { return (bytes[pos++] << 8) | bytes[pos++]; }
    // decode the frequency table
    var symbol_count = u16();
    var total = 1;
    var acc = [0, 1]; // first symbol has frequency 1
    for (var i = 1; i < symbol_count; i++) {
        acc.push(total += u16());
    }
    // skip the sized-payload that the last 3 symbols index into
    var skip = u16();
    var pos_payload = pos;
    pos += skip;
    var read_width = 0;
    var read_buffer = 0;
    function read_bit() {
        if (read_width == 0) {
            // this will read beyond end of buffer
            // but (undefined|0) => zero pad
            read_buffer = (read_buffer << 8) | bytes[pos++];
            read_width = 8;
        }
        return (read_buffer >> --read_width) & 1;
    }
    var N = 31;
    var FULL = Math.pow(2, N);
    var HALF = FULL >>> 1;
    var QRTR = HALF >> 1;
    var MASK = FULL - 1;
    // fill register
    var register = 0;
    for (var i = 0; i < N; i++)
        register = (register << 1) | read_bit();
    var symbols = [];
    var low = 0;
    var range = FULL; // treat like a float
    while (true) {
        var value = Math.floor((((register - low + 1) * total) - 1) / range);
        var start = 0;
        var end = symbol_count;
        while (end - start > 1) { // binary search
            var mid = (start + end) >>> 1;
            if (value < acc[mid]) {
                end = mid;
            }
            else {
                start = mid;
            }
        }
        if (start == 0)
            break; // first symbol is end mark
        symbols.push(start);
        var a = low + Math.floor(range * acc[start] / total);
        var b = low + Math.floor(range * acc[start + 1] / total) - 1;
        while (((a ^ b) & HALF) == 0) {
            register = (register << 1) & MASK | read_bit();
            a = (a << 1) & MASK;
            b = (b << 1) & MASK | 1;
        }
        while (a & ~b & QRTR) {
            register = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();
            a = (a << 1) ^ HALF;
            b = ((b ^ HALF) << 1) | HALF | 1;
        }
        low = a;
        range = 1 + b - a;
    }
    var offset = symbol_count - 4;
    return symbols.map(function (x) {
        switch (x - offset) {
            case 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);
            case 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);
            case 1: return offset + bytes[pos_payload++];
            default: return x - 1;
        }
    });
}
exports.decode_arithmetic = decode_arithmetic;
// returns an iterator which returns the next symbol
function read_payload(v) {
    var pos = 0;
    return function () { return v[pos++]; };
}
exports.read_payload = read_payload;
function read_compressed_payload(bytes) {
    return read_payload(decode_arithmetic(bytes));
}
exports.read_compressed_payload = read_compressed_payload;
// eg. [0,1,2,3...] => [0,-1,1,-2,...]
function signed(i) {
    return (i & 1) ? (~i >> 1) : (i >> 1);
}
exports.signed = signed;
function read_counts(n, next) {
    var v = Array(n);
    for (var i = 0; i < n; i++)
        v[i] = 1 + next();
    return v;
}
function read_ascending(n, next) {
    var v = Array(n);
    for (var i = 0, x = -1; i < n; i++)
        v[i] = x += 1 + next();
    return v;
}
function read_deltas(n, next) {
    var v = Array(n);
    for (var i = 0, x = 0; i < n; i++)
        v[i] = x += signed(next());
    return v;
}
function read_member_array(next, lookup) {
    var v = read_ascending(next(), next);
    var n = next();
    var vX = read_ascending(n, next);
    var vN = read_counts(n, next);
    for (var i = 0; i < n; i++) {
        for (var j = 0; j < vN[i]; j++) {
            v.push(vX[i] + j);
        }
    }
    return lookup ? v.map(function (x) { return lookup[x]; }) : v;
}
exports.read_member_array = read_member_array;
// returns array of 
// [x, ys] => single replacement rule
// [x, ys, n, dx, dx] => linear map
function read_mapped_map(next) {
    var ret = [];
    while (true) {
        var w = next();
        if (w == 0)
            break;
        ret.push(read_linear_table(w, next));
    }
    while (true) {
        var w = next() - 1;
        if (w < 0)
            break;
        ret.push(read_replacement_table(w, next));
    }
    return fromEntries(flat(ret));
}
exports.read_mapped_map = read_mapped_map;
function read_zero_terminated_array(next) {
    var v = [];
    while (true) {
        var i = next();
        if (i == 0)
            break;
        v.push(i);
    }
    return v;
}
exports.read_zero_terminated_array = read_zero_terminated_array;
function read_transposed(n, w, next) {
    var m = Array(n).fill(undefined).map(function () { return []; });
    for (var i = 0; i < w; i++) {
        read_deltas(n, next).forEach(function (x, j) { return m[j].push(x); });
    }
    return m;
}
function read_linear_table(w, next) {
    var dx = 1 + next();
    var dy = next();
    var vN = read_zero_terminated_array(next);
    var m = read_transposed(vN.length, 1 + w, next);
    return flat(m.map(function (v, i) {
        var x = v[0], ys = v.slice(1);
        //let [x, ...ys] = v;
        //return Array(vN[i]).fill().map((_, j) => {
        return Array(vN[i]).fill(undefined).map(function (_, j) {
            var j_dy = j * dy;
            return [x + j * dx, ys.map(function (y) { return y + j_dy; })];
        });
    }));
}
function read_replacement_table(w, next) {
    var n = 1 + next();
    var m = read_transposed(n, 1 + w, next);
    return m.map(function (v) { return [v[0], v.slice(1)]; });
}
function read_emoji_trie(next) {
    var sorted = read_member_array(next).sort(function (a, b) { return a - b; });
    return read();
    function read() {
        var branches = [];
        while (true) {
            var keys = read_member_array(next, sorted);
            if (keys.length == 0)
                break;
            branches.push({ set: new Set(keys), node: read() });
        }
        branches.sort(function (a, b) { return b.set.size - a.set.size; }); // sort by likelihood
        var temp = next();
        var valid = temp % 3;
        temp = (temp / 3) | 0;
        var fe0f = !!(temp & 1);
        temp >>= 1;
        var save = temp == 1;
        var check = temp == 2;
        return { branches: branches, valid: valid, fe0f: fe0f, save: save, check: check };
    }
}
exports.read_emoji_trie = read_emoji_trie;
//# sourceMappingURL=decoder.js.map

/***/ }),

/***/ 2250:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * MIT License
 *
 * Copyright (c) 2021 Andrew Raffensperger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This is a near carbon-copy of the original source (link below) with the
 * TypeScript typings added and a few tweaks to make it ES3-compatible.
 *
 * See: https://github.com/adraffy/ens-normalize.js
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getData = void 0;
var base64_1 = __nccwpck_require__(8144);
var decoder_js_1 = __nccwpck_require__(4021);
function getData() {
    return (0, decoder_js_1.read_compressed_payload)((0, base64_1.decode)('AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=='));
}
exports.getData = getData;
//# sourceMappingURL=include.js.map

/***/ }),

/***/ 8732:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * MIT License
 *
 * Copyright (c) 2021 Andrew Raffensperger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This is a near carbon-copy of the original source (link below) with the
 * TypeScript typings added and a few tweaks to make it ES3-compatible.
 *
 * See: https://github.com/adraffy/ens-normalize.js
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ens_normalize = exports.ens_normalize_post_check = void 0;
var strings_1 = __nccwpck_require__(9115);
var include_js_1 = __nccwpck_require__(2250);
var r = (0, include_js_1.getData)();
var decoder_js_1 = __nccwpck_require__(4021);
// @TODO: This should be lazily loaded
var VALID = new Set((0, decoder_js_1.read_member_array)(r));
var IGNORED = new Set((0, decoder_js_1.read_member_array)(r));
var MAPPED = (0, decoder_js_1.read_mapped_map)(r);
var EMOJI_ROOT = (0, decoder_js_1.read_emoji_trie)(r);
//const NFC_CHECK = new Set(read_member_array(r, Array.from(VALID.values()).sort((a, b) => a - b)));
//const STOP = 0x2E;
var HYPHEN = 0x2D;
var UNDERSCORE = 0x5F;
function explode_cp(name) {
    return (0, strings_1.toUtf8CodePoints)(name);
}
function filter_fe0f(cps) {
    return cps.filter(function (cp) { return cp != 0xFE0F; });
}
function ens_normalize_post_check(name) {
    for (var _i = 0, _a = name.split('.'); _i < _a.length; _i++) {
        var label = _a[_i];
        var cps = explode_cp(label);
        try {
            for (var i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) {
                if (cps[i] !== UNDERSCORE) {
                    throw new Error("underscore only allowed at start");
                }
            }
            if (cps.length >= 4 && cps.every(function (cp) { return cp < 0x80; }) && cps[2] === HYPHEN && cps[3] === HYPHEN) {
                throw new Error("invalid label extension");
            }
        }
        catch (err) {
            throw new Error("Invalid label \"" + label + "\": " + err.message);
        }
    }
    return name;
}
exports.ens_normalize_post_check = ens_normalize_post_check;
function ens_normalize(name) {
    return ens_normalize_post_check(normalize(name, filter_fe0f));
}
exports.ens_normalize = ens_normalize;
function normalize(name, emoji_filter) {
    var input = explode_cp(name).reverse(); // flip for pop
    var output = [];
    while (input.length) {
        var emoji = consume_emoji_reversed(input);
        if (emoji) {
            output.push.apply(output, emoji_filter(emoji));
            continue;
        }
        var cp = input.pop();
        if (VALID.has(cp)) {
            output.push(cp);
            continue;
        }
        if (IGNORED.has(cp)) {
            continue;
        }
        var cps = MAPPED[cp];
        if (cps) {
            output.push.apply(output, cps);
            continue;
        }
        throw new Error("Disallowed codepoint: 0x" + cp.toString(16).toUpperCase());
    }
    return ens_normalize_post_check(nfc(String.fromCodePoint.apply(String, output)));
}
function nfc(s) {
    return s.normalize('NFC');
}
function consume_emoji_reversed(cps, eaten) {
    var _a;
    var node = EMOJI_ROOT;
    var emoji;
    var saved;
    var stack = [];
    var pos = cps.length;
    if (eaten)
        eaten.length = 0; // clear input buffer (if needed)
    var _loop_1 = function () {
        var cp = cps[--pos];
        node = (_a = node.branches.find(function (x) { return x.set.has(cp); })) === null || _a === void 0 ? void 0 : _a.node;
        if (!node)
            return "break";
        if (node.save) { // remember
            saved = cp;
        }
        else if (node.check) { // check exclusion
            if (cp === saved)
                return "break";
        }
        stack.push(cp);
        if (node.fe0f) {
            stack.push(0xFE0F);
            if (pos > 0 && cps[pos - 1] == 0xFE0F)
                pos--; // consume optional FE0F
        }
        if (node.valid) { // this is a valid emoji (so far)
            emoji = stack.slice(); // copy stack
            if (node.valid == 2)
                emoji.splice(1, 1); // delete FE0F at position 1 (RGI ZWJ don't follow spec!)
            if (eaten)
                eaten.push.apply(eaten, cps.slice(pos).reverse()); // copy input (if needed)
            cps.length = pos; // truncate
        }
    };
    while (pos) {
        var state_1 = _loop_1();
        if (state_1 === "break")
            break;
    }
    return emoji;
}
//# sourceMappingURL=lib.js.map

/***/ }),

/***/ 3727:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.id = void 0;
var keccak256_1 = __nccwpck_require__(3100);
var strings_1 = __nccwpck_require__(9115);
function id(text) {
    return (0, keccak256_1.keccak256)((0, strings_1.toUtf8Bytes)(text));
}
exports.id = id;
//# sourceMappingURL=id.js.map

/***/ }),

/***/ 7866:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._TypedDataEncoder = exports.hashMessage = exports.messagePrefix = exports.ensNormalize = exports.isValidName = exports.namehash = exports.dnsEncode = exports.id = void 0;
var id_1 = __nccwpck_require__(3727);
Object.defineProperty(exports, "id", ({ enumerable: true, get: function () { return id_1.id; } }));
var namehash_1 = __nccwpck_require__(4267);
Object.defineProperty(exports, "dnsEncode", ({ enumerable: true, get: function () { return namehash_1.dnsEncode; } }));
Object.defineProperty(exports, "isValidName", ({ enumerable: true, get: function () { return namehash_1.isValidName; } }));
Object.defineProperty(exports, "namehash", ({ enumerable: true, get: function () { return namehash_1.namehash; } }));
var message_1 = __nccwpck_require__(2512);
Object.defineProperty(exports, "hashMessage", ({ enumerable: true, get: function () { return message_1.hashMessage; } }));
Object.defineProperty(exports, "messagePrefix", ({ enumerable: true, get: function () { return message_1.messagePrefix; } }));
var namehash_2 = __nccwpck_require__(4267);
Object.defineProperty(exports, "ensNormalize", ({ enumerable: true, get: function () { return namehash_2.ensNormalize; } }));
var typed_data_1 = __nccwpck_require__(7516);
Object.defineProperty(exports, "_TypedDataEncoder", ({ enumerable: true, get: function () { return typed_data_1.TypedDataEncoder; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 2512:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hashMessage = exports.messagePrefix = void 0;
var bytes_1 = __nccwpck_require__(2056);
var keccak256_1 = __nccwpck_require__(3100);
var strings_1 = __nccwpck_require__(9115);
exports.messagePrefix = "\x19Ethereum Signed Message:\n";
function hashMessage(message) {
    if (typeof (message) === "string") {
        message = (0, strings_1.toUtf8Bytes)(message);
    }
    return (0, keccak256_1.keccak256)((0, bytes_1.concat)([
        (0, strings_1.toUtf8Bytes)(exports.messagePrefix),
        (0, strings_1.toUtf8Bytes)(String(message.length)),
        message
    ]));
}
exports.hashMessage = hashMessage;
//# sourceMappingURL=message.js.map

/***/ }),

/***/ 4267:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = void 0;
var bytes_1 = __nccwpck_require__(2056);
var strings_1 = __nccwpck_require__(9115);
var keccak256_1 = __nccwpck_require__(3100);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(9553);
var logger = new logger_1.Logger(_version_1.version);
var lib_1 = __nccwpck_require__(8732);
var Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
    if (comp.length === 0) {
        throw new Error("invalid ENS name; empty component");
    }
    return comp;
}
function ensNameSplit(name) {
    var bytes = (0, strings_1.toUtf8Bytes)((0, lib_1.ens_normalize)(name));
    var comps = [];
    if (name.length === 0) {
        return comps;
    }
    var last = 0;
    for (var i = 0; i < bytes.length; i++) {
        var d = bytes[i];
        // A separator (i.e. "."); copy this component
        if (d === 0x2e) {
            comps.push(checkComponent(bytes.slice(last, i)));
            last = i + 1;
        }
    }
    // There was a stray separator at the end of the name
    if (last >= bytes.length) {
        throw new Error("invalid ENS name; empty component");
    }
    comps.push(checkComponent(bytes.slice(last)));
    return comps;
}
function ensNormalize(name) {
    return ensNameSplit(name).map(function (comp) { return (0, strings_1.toUtf8String)(comp); }).join(".");
}
exports.ensNormalize = ensNormalize;
function isValidName(name) {
    try {
        return (ensNameSplit(name).length !== 0);
    }
    catch (error) { }
    return false;
}
exports.isValidName = isValidName;
function namehash(name) {
    /* istanbul ignore if */
    if (typeof (name) !== "string") {
        logger.throwArgumentError("invalid ENS name; not a string", "name", name);
    }
    var result = Zeros;
    var comps = ensNameSplit(name);
    while (comps.length) {
        result = (0, keccak256_1.keccak256)((0, bytes_1.concat)([result, (0, keccak256_1.keccak256)(comps.pop())]));
    }
    return (0, bytes_1.hexlify)(result);
}
exports.namehash = namehash;
function dnsEncode(name) {
    return (0, bytes_1.hexlify)((0, bytes_1.concat)(ensNameSplit(name).map(function (comp) {
        // DNS does not allow components over 63 bytes in length
        if (comp.length > 63) {
            throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
        }
        var bytes = new Uint8Array(comp.length + 1);
        bytes.set(comp, 1);
        bytes[0] = bytes.length - 1;
        return bytes;
    }))) + "00";
}
exports.dnsEncode = dnsEncode;
//# sourceMappingURL=namehash.js.map

/***/ }),

/***/ 7516:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypedDataEncoder = void 0;
var address_1 = __nccwpck_require__(8957);
var bignumber_1 = __nccwpck_require__(1267);
var bytes_1 = __nccwpck_require__(2056);
var keccak256_1 = __nccwpck_require__(3100);
var properties_1 = __nccwpck_require__(8078);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(9553);
var logger = new logger_1.Logger(_version_1.version);
var id_1 = __nccwpck_require__(3727);
var padding = new Uint8Array(32);
padding.fill(0);
var NegativeOne = bignumber_1.BigNumber.from(-1);
var Zero = bignumber_1.BigNumber.from(0);
var One = bignumber_1.BigNumber.from(1);
var MaxUint256 = bignumber_1.BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
    var bytes = (0, bytes_1.arrayify)(value);
    var padOffset = bytes.length % 32;
    if (padOffset) {
        return (0, bytes_1.hexConcat)([bytes, padding.slice(padOffset)]);
    }
    return (0, bytes_1.hexlify)(bytes);
}
var hexTrue = (0, bytes_1.hexZeroPad)(One.toHexString(), 32);
var hexFalse = (0, bytes_1.hexZeroPad)(Zero.toHexString(), 32);
var domainFieldTypes = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32"
};
var domainFieldNames = [
    "name", "version", "chainId", "verifyingContract", "salt"
];
function checkString(key) {
    return function (value) {
        if (typeof (value) !== "string") {
            logger.throwArgumentError("invalid domain value for " + JSON.stringify(key), "domain." + key, value);
        }
        return value;
    };
}
var domainChecks = {
    name: checkString("name"),
    version: checkString("version"),
    chainId: function (value) {
        try {
            return bignumber_1.BigNumber.from(value).toString();
        }
        catch (error) { }
        return logger.throwArgumentError("invalid domain value for \"chainId\"", "domain.chainId", value);
    },
    verifyingContract: function (value) {
        try {
            return (0, address_1.getAddress)(value).toLowerCase();
        }
        catch (error) { }
        return logger.throwArgumentError("invalid domain value \"verifyingContract\"", "domain.verifyingContract", value);
    },
    salt: function (value) {
        try {
            var bytes = (0, bytes_1.arrayify)(value);
            if (bytes.length !== 32) {
                throw new Error("bad length");
            }
            return (0, bytes_1.hexlify)(bytes);
        }
        catch (error) { }
        return logger.throwArgumentError("invalid domain value \"salt\"", "domain.salt", value);
    }
};
function getBaseEncoder(type) {
    // intXX and uintXX
    {
        var match = type.match(/^(u?)int(\d*)$/);
        if (match) {
            var signed = (match[1] === "");
            var width = parseInt(match[2] || "256");
            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {
                logger.throwArgumentError("invalid numeric width", "type", type);
            }
            var boundsUpper_1 = MaxUint256.mask(signed ? (width - 1) : width);
            var boundsLower_1 = signed ? boundsUpper_1.add(One).mul(NegativeOne) : Zero;
            return function (value) {
                var v = bignumber_1.BigNumber.from(value);
                if (v.lt(boundsLower_1) || v.gt(boundsUpper_1)) {
                    logger.throwArgumentError("value out-of-bounds for " + type, "value", value);
                }
                return (0, bytes_1.hexZeroPad)(v.toTwos(256).toHexString(), 32);
            };
        }
    }
    // bytesXX
    {
        var match = type.match(/^bytes(\d+)$/);
        if (match) {
            var width_1 = parseInt(match[1]);
            if (width_1 === 0 || width_1 > 32 || match[1] !== String(width_1)) {
                logger.throwArgumentError("invalid bytes width", "type", type);
            }
            return function (value) {
                var bytes = (0, bytes_1.arrayify)(value);
                if (bytes.length !== width_1) {
                    logger.throwArgumentError("invalid length for " + type, "value", value);
                }
                return hexPadRight(value);
            };
        }
    }
    switch (type) {
        case "address": return function (value) {
            return (0, bytes_1.hexZeroPad)((0, address_1.getAddress)(value), 32);
        };
        case "bool": return function (value) {
            return ((!value) ? hexFalse : hexTrue);
        };
        case "bytes": return function (value) {
            return (0, keccak256_1.keccak256)(value);
        };
        case "string": return function (value) {
            return (0, id_1.id)(value);
        };
    }
    return null;
}
function encodeType(name, fields) {
    return name + "(" + fields.map(function (_a) {
        var name = _a.name, type = _a.type;
        return (type + " " + name);
    }).join(",") + ")";
}
var TypedDataEncoder = /** @class */ (function () {
    function TypedDataEncoder(types) {
        (0, properties_1.defineReadOnly)(this, "types", Object.freeze((0, properties_1.deepCopy)(types)));
        (0, properties_1.defineReadOnly)(this, "_encoderCache", {});
        (0, properties_1.defineReadOnly)(this, "_types", {});
        // Link struct types to their direct child structs
        var links = {};
        // Link structs to structs which contain them as a child
        var parents = {};
        // Link all subtypes within a given struct
        var subtypes = {};
        Object.keys(types).forEach(function (type) {
            links[type] = {};
            parents[type] = [];
            subtypes[type] = {};
        });
        var _loop_1 = function (name_1) {
            var uniqueNames = {};
            types[name_1].forEach(function (field) {
                // Check each field has a unique name
                if (uniqueNames[field.name]) {
                    logger.throwArgumentError("duplicate variable name " + JSON.stringify(field.name) + " in " + JSON.stringify(name_1), "types", types);
                }
                uniqueNames[field.name] = true;
                // Get the base type (drop any array specifiers)
                var baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
                if (baseType === name_1) {
                    logger.throwArgumentError("circular type reference to " + JSON.stringify(baseType), "types", types);
                }
                // Is this a base encoding type?
                var encoder = getBaseEncoder(baseType);
                if (encoder) {
                    return;
                }
                if (!parents[baseType]) {
                    logger.throwArgumentError("unknown type " + JSON.stringify(baseType), "types", types);
                }
                // Add linkage
                parents[baseType].push(name_1);
                links[name_1][baseType] = true;
            });
        };
        for (var name_1 in types) {
            _loop_1(name_1);
        }
        // Deduce the primary type
        var primaryTypes = Object.keys(parents).filter(function (n) { return (parents[n].length === 0); });
        if (primaryTypes.length === 0) {
            logger.throwArgumentError("missing primary type", "types", types);
        }
        else if (primaryTypes.length > 1) {
            logger.throwArgumentError("ambiguous primary types or unused types: " + primaryTypes.map(function (t) { return (JSON.stringify(t)); }).join(", "), "types", types);
        }
        (0, properties_1.defineReadOnly)(this, "primaryType", primaryTypes[0]);
        // Check for circular type references
        function checkCircular(type, found) {
            if (found[type]) {
                logger.throwArgumentError("circular type reference to " + JSON.stringify(type), "types", types);
            }
            found[type] = true;
            Object.keys(links[type]).forEach(function (child) {
                if (!parents[child]) {
                    return;
                }
                // Recursively check children
                checkCircular(child, found);
                // Mark all ancestors as having this decendant
                Object.keys(found).forEach(function (subtype) {
                    subtypes[subtype][child] = true;
                });
            });
            delete found[type];
        }
        checkCircular(this.primaryType, {});
        // Compute each fully describe type
        for (var name_2 in subtypes) {
            var st = Object.keys(subtypes[name_2]);
            st.sort();
            this._types[name_2] = encodeType(name_2, types[name_2]) + st.map(function (t) { return encodeType(t, types[t]); }).join("");
        }
    }
    TypedDataEncoder.prototype.getEncoder = function (type) {
        var encoder = this._encoderCache[type];
        if (!encoder) {
            encoder = this._encoderCache[type] = this._getEncoder(type);
        }
        return encoder;
    };
    TypedDataEncoder.prototype._getEncoder = function (type) {
        var _this = this;
        // Basic encoder type (address, bool, uint256, etc)
        {
            var encoder = getBaseEncoder(type);
            if (encoder) {
                return encoder;
            }
        }
        // Array
        var match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
            var subtype_1 = match[1];
            var subEncoder_1 = this.getEncoder(subtype_1);
            var length_1 = parseInt(match[3]);
            return function (value) {
                if (length_1 >= 0 && value.length !== length_1) {
                    logger.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
                }
                var result = value.map(subEncoder_1);
                if (_this._types[subtype_1]) {
                    result = result.map(keccak256_1.keccak256);
                }
                return (0, keccak256_1.keccak256)((0, bytes_1.hexConcat)(result));
            };
        }
        // Struct
        var fields = this.types[type];
        if (fields) {
            var encodedType_1 = (0, id_1.id)(this._types[type]);
            return function (value) {
                var values = fields.map(function (_a) {
                    var name = _a.name, type = _a.type;
                    var result = _this.getEncoder(type)(value[name]);
                    if (_this._types[type]) {
                        return (0, keccak256_1.keccak256)(result);
                    }
                    return result;
                });
                values.unshift(encodedType_1);
                return (0, bytes_1.hexConcat)(values);
            };
        }
        return logger.throwArgumentError("unknown type: " + type, "type", type);
    };
    TypedDataEncoder.prototype.encodeType = function (name) {
        var result = this._types[name];
        if (!result) {
            logger.throwArgumentError("unknown type: " + JSON.stringify(name), "name", name);
        }
        return result;
    };
    TypedDataEncoder.prototype.encodeData = function (type, value) {
        return this.getEncoder(type)(value);
    };
    TypedDataEncoder.prototype.hashStruct = function (name, value) {
        return (0, keccak256_1.keccak256)(this.encodeData(name, value));
    };
    TypedDataEncoder.prototype.encode = function (value) {
        return this.encodeData(this.primaryType, value);
    };
    TypedDataEncoder.prototype.hash = function (value) {
        return this.hashStruct(this.primaryType, value);
    };
    TypedDataEncoder.prototype._visit = function (type, value, callback) {
        var _this = this;
        // Basic encoder type (address, bool, uint256, etc)
        {
            var encoder = getBaseEncoder(type);
            if (encoder) {
                return callback(type, value);
            }
        }
        // Array
        var match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
            var subtype_2 = match[1];
            var length_2 = parseInt(match[3]);
            if (length_2 >= 0 && value.length !== length_2) {
                logger.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
            }
            return value.map(function (v) { return _this._visit(subtype_2, v, callback); });
        }
        // Struct
        var fields = this.types[type];
        if (fields) {
            return fields.reduce(function (accum, _a) {
                var name = _a.name, type = _a.type;
                accum[name] = _this._visit(type, value[name], callback);
                return accum;
            }, {});
        }
        return logger.throwArgumentError("unknown type: " + type, "type", type);
    };
    TypedDataEncoder.prototype.visit = function (value, callback) {
        return this._visit(this.primaryType, value, callback);
    };
    TypedDataEncoder.from = function (types) {
        return new TypedDataEncoder(types);
    };
    TypedDataEncoder.getPrimaryType = function (types) {
        return TypedDataEncoder.from(types).primaryType;
    };
    TypedDataEncoder.hashStruct = function (name, types, value) {
        return TypedDataEncoder.from(types).hashStruct(name, value);
    };
    TypedDataEncoder.hashDomain = function (domain) {
        var domainFields = [];
        for (var name_3 in domain) {
            var type = domainFieldTypes[name_3];
            if (!type) {
                logger.throwArgumentError("invalid typed-data domain key: " + JSON.stringify(name_3), "domain", domain);
            }
            domainFields.push({ name: name_3, type: type });
        }
        domainFields.sort(function (a, b) {
            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
        });
        return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
    };
    TypedDataEncoder.encode = function (domain, types, value) {
        return (0, bytes_1.hexConcat)([
            "0x1901",
            TypedDataEncoder.hashDomain(domain),
            TypedDataEncoder.from(types).hash(value)
        ]);
    };
    TypedDataEncoder.hash = function (domain, types, value) {
        return (0, keccak256_1.keccak256)(TypedDataEncoder.encode(domain, types, value));
    };
    // Replaces all address types with ENS names with their looked up address
    TypedDataEncoder.resolveNames = function (domain, types, value, resolveName) {
        return __awaiter(this, void 0, void 0, function () {
            var ensCache, encoder, _a, _b, _i, name_4, _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        // Make a copy to isolate it from the object passed in
                        domain = (0, properties_1.shallowCopy)(domain);
                        ensCache = {};
                        // Do we need to look up the domain's verifyingContract?
                        if (domain.verifyingContract && !(0, bytes_1.isHexString)(domain.verifyingContract, 20)) {
                            ensCache[domain.verifyingContract] = "0x";
                        }
                        encoder = TypedDataEncoder.from(types);
                        // Get a list of all the addresses
                        encoder.visit(value, function (type, value) {
                            if (type === "address" && !(0, bytes_1.isHexString)(value, 20)) {
                                ensCache[value] = "0x";
                            }
                            return value;
                        });
                        _a = [];
                        for (_b in ensCache)
                            _a.push(_b);
                        _i = 0;
                        _e.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 4];
                        name_4 = _a[_i];
                        _c = ensCache;
                        _d = name_4;
                        return [4 /*yield*/, resolveName(name_4)];
                    case 2:
                        _c[_d] = _e.sent();
                        _e.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        // Replace the domain verifyingContract if needed
                        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
                            domain.verifyingContract = ensCache[domain.verifyingContract];
                        }
                        // Replace all ENS names with their address
                        value = encoder.visit(value, function (type, value) {
                            if (type === "address" && ensCache[value]) {
                                return ensCache[value];
                            }
                            return value;
                        });
                        return [2 /*return*/, { domain: domain, value: value }];
                }
            });
        });
    };
    TypedDataEncoder.getPayload = function (domain, types, value) {
        // Validate the domain fields
        TypedDataEncoder.hashDomain(domain);
        // Derive the EIP712Domain Struct reference type
        var domainValues = {};
        var domainTypes = [];
        domainFieldNames.forEach(function (name) {
            var value = domain[name];
            if (value == null) {
                return;
            }
            domainValues[name] = domainChecks[name](value);
            domainTypes.push({ name: name, type: domainFieldTypes[name] });
        });
        var encoder = TypedDataEncoder.from(types);
        var typesWithDomain = (0, properties_1.shallowCopy)(types);
        if (typesWithDomain.EIP712Domain) {
            logger.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
        }
        else {
            typesWithDomain.EIP712Domain = domainTypes;
        }
        // Validate the data structures and types
        encoder.encode(value);
        return {
            types: typesWithDomain,
            domain: domainValues,
            primaryType: encoder.primaryType,
            message: encoder.visit(value, function (type, value) {
                // bytes
                if (type.match(/^bytes(\d*)/)) {
                    return (0, bytes_1.hexlify)((0, bytes_1.arrayify)(value));
                }
                // uint or int
                if (type.match(/^u?int/)) {
                    return bignumber_1.BigNumber.from(value).toString();
                }
                switch (type) {
                    case "address":
                        return value.toLowerCase();
                    case "bool":
                        return !!value;
                    case "string":
                        if (typeof (value) !== "string") {
                            logger.throwArgumentError("invalid string", "value", value);
                        }
                        return value;
                }
                return logger.throwArgumentError("unsupported type", "type", type);
            })
        };
    };
    return TypedDataEncoder;
}());
exports.TypedDataEncoder = TypedDataEncoder;
//# sourceMappingURL=typed-data.js.map

/***/ }),

/***/ 3100:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.keccak256 = void 0;
var js_sha3_1 = __importDefault(__nccwpck_require__(1434));
var bytes_1 = __nccwpck_require__(2056);
function keccak256(data) {
    return '0x' + js_sha3_1.default.keccak_256((0, bytes_1.arrayify)(data));
}
exports.keccak256 = keccak256;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 790:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = "logger/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ 2975:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Logger = exports.ErrorCode = exports.LogLevel = void 0;
var _permanentCensorErrors = false;
var _censorErrors = false;
var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel = LogLevels["default"];
var _version_1 = __nccwpck_require__(790);
var _globalLogger = null;
function _checkNormalize() {
    try {
        var missing_1 = [];
        // Make sure all forms of normalization are supported
        ["NFD", "NFC", "NFKD", "NFKC"].forEach(function (form) {
            try {
                if ("test".normalize(form) !== "test") {
                    throw new Error("bad normalize");
                }
                ;
            }
            catch (error) {
                missing_1.push(form);
            }
        });
        if (missing_1.length) {
            throw new Error("missing " + missing_1.join(", "));
        }
        if (String.fromCharCode(0xe9).normalize("NFD") !== String.fromCharCode(0x65, 0x0301)) {
            throw new Error("broken implementation");
        }
    }
    catch (error) {
        return error.message;
    }
    return null;
}
var _normalizeError = _checkNormalize();
var LogLevel;
(function (LogLevel) {
    LogLevel["DEBUG"] = "DEBUG";
    LogLevel["INFO"] = "INFO";
    LogLevel["WARNING"] = "WARNING";
    LogLevel["ERROR"] = "ERROR";
    LogLevel["OFF"] = "OFF";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
var ErrorCode;
(function (ErrorCode) {
    ///////////////////
    // Generic Errors
    // Unknown Error
    ErrorCode["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    // Not Implemented
    ErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    // Unsupported Operation
    //   - operation
    ErrorCode["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)
    //   - event ("noNetwork" is not re-thrown in provider.ready; otherwise thrown)
    ErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR";
    // Some sort of bad response from the server
    ErrorCode["SERVER_ERROR"] = "SERVER_ERROR";
    // Timeout
    ErrorCode["TIMEOUT"] = "TIMEOUT";
    ///////////////////
    // Operational  Errors
    // Buffer Overrun
    ErrorCode["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
    // Numeric Fault
    //   - operation: the operation being executed
    //   - fault: the reason this faulted
    ErrorCode["NUMERIC_FAULT"] = "NUMERIC_FAULT";
    ///////////////////
    // Argument Errors
    // Missing new operator to an object
    //  - name: The name of the class
    ErrorCode["MISSING_NEW"] = "MISSING_NEW";
    // Invalid argument (e.g. value is incompatible with type) to a function:
    //   - argument: The argument name that was invalid
    //   - value: The value of the argument
    ErrorCode["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
    // Missing argument to a function:
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
    // Too many arguments
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
    ///////////////////
    // Blockchain Errors
    // Call exception
    //  - transaction: the transaction
    //  - address?: the contract address
    //  - args?: The arguments passed into the function
    //  - method?: The Solidity method signature
    //  - errorSignature?: The EIP848 error signature
    //  - errorArgs?: The EIP848 error parameters
    //  - reason: The reason (only for EIP848 "Error(string)")
    ErrorCode["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    // Insufficient funds (< value + gasLimit * gasPrice)
    //   - transaction: the transaction attempted
    ErrorCode["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    // Nonce has already been used
    //   - transaction: the transaction attempted
    ErrorCode["NONCE_EXPIRED"] = "NONCE_EXPIRED";
    // The replacement fee for the transaction is too low
    //   - transaction: the transaction attempted
    ErrorCode["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
    // The gas limit could not be estimated
    //   - transaction: the transaction passed to estimateGas
    ErrorCode["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    // The transaction was replaced by one with a higher gas price
    //   - reason: "cancelled", "replaced" or "repriced"
    //   - cancelled: true if reason == "cancelled" or reason == "replaced")
    //   - hash: original transaction hash
    //   - replacement: the full TransactionsResponse for the replacement
    //   - receipt: the receipt of the replacement
    ErrorCode["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
    ///////////////////
    // Interaction Errors
    // The user rejected the action, such as signing a message or sending
    // a transaction
    ErrorCode["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));
;
var HEX = "0123456789abcdef";
var Logger = /** @class */ (function () {
    function Logger(version) {
        Object.defineProperty(this, "version", {
            enumerable: true,
            value: version,
            writable: false
        });
    }
    Logger.prototype._log = function (logLevel, args) {
        var level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
            this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
            return;
        }
        console.log.apply(console, args);
    };
    Logger.prototype.debug = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this._log(Logger.levels.DEBUG, args);
    };
    Logger.prototype.info = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this._log(Logger.levels.INFO, args);
    };
    Logger.prototype.warn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this._log(Logger.levels.WARNING, args);
    };
    Logger.prototype.makeError = function (message, code, params) {
        // Errors are being censored
        if (_censorErrors) {
            return this.makeError("censored error", code, {});
        }
        if (!code) {
            code = Logger.errors.UNKNOWN_ERROR;
        }
        if (!params) {
            params = {};
        }
        var messageDetails = [];
        Object.keys(params).forEach(function (key) {
            var value = params[key];
            try {
                if (value instanceof Uint8Array) {
                    var hex = "";
                    for (var i = 0; i < value.length; i++) {
                        hex += HEX[value[i] >> 4];
                        hex += HEX[value[i] & 0x0f];
                    }
                    messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
                }
                else {
                    messageDetails.push(key + "=" + JSON.stringify(value));
                }
            }
            catch (error) {
                messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
            }
        });
        messageDetails.push("code=" + code);
        messageDetails.push("version=" + this.version);
        var reason = message;
        var url = "";
        switch (code) {
            case ErrorCode.NUMERIC_FAULT: {
                url = "NUMERIC_FAULT";
                var fault = message;
                switch (fault) {
                    case "overflow":
                    case "underflow":
                    case "division-by-zero":
                        url += "-" + fault;
                        break;
                    case "negative-power":
                    case "negative-width":
                        url += "-unsupported";
                        break;
                    case "unbound-bitwise-result":
                        url += "-unbound-result";
                        break;
                }
                break;
            }
            case ErrorCode.CALL_EXCEPTION:
            case ErrorCode.INSUFFICIENT_FUNDS:
            case ErrorCode.MISSING_NEW:
            case ErrorCode.NONCE_EXPIRED:
            case ErrorCode.REPLACEMENT_UNDERPRICED:
            case ErrorCode.TRANSACTION_REPLACED:
            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
                url = code;
                break;
        }
        if (url) {
            message += " [ See: https:/\/links.ethers.org/v5-errors-" + url + " ]";
        }
        if (messageDetails.length) {
            message += " (" + messageDetails.join(", ") + ")";
        }
        // @TODO: Any??
        var error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function (key) {
            error[key] = params[key];
        });
        return error;
    };
    Logger.prototype.throwError = function (message, code, params) {
        throw this.makeError(message, code, params);
    };
    Logger.prototype.throwArgumentError = function (message, name, value) {
        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
            argument: name,
            value: value
        });
    };
    Logger.prototype.assert = function (condition, message, code, params) {
        if (!!condition) {
            return;
        }
        this.throwError(message, code, params);
    };
    Logger.prototype.assertArgument = function (condition, message, name, value) {
        if (!!condition) {
            return;
        }
        this.throwArgumentError(message, name, value);
    };
    Logger.prototype.checkNormalize = function (message) {
        if (message == null) {
            message = "platform missing String.prototype.normalize";
        }
        if (_normalizeError) {
            this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "String.prototype.normalize", form: _normalizeError
            });
        }
    };
    Logger.prototype.checkSafeUint53 = function (value, message) {
        if (typeof (value) !== "number") {
            return;
        }
        if (message == null) {
            message = "value not safe";
        }
        if (value < 0 || value >= 0x1fffffffffffff) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "out-of-safe-range",
                value: value
            });
        }
        if (value % 1) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "non-integer",
                value: value
            });
        }
    };
    Logger.prototype.checkArgumentCount = function (count, expectedCount, message) {
        if (message) {
            message = ": " + message;
        }
        else {
            message = "";
        }
        if (count < expectedCount) {
            this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
        if (count > expectedCount) {
            this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
    };
    Logger.prototype.checkNew = function (target, kind) {
        if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    };
    Logger.prototype.checkAbstract = function (target, kind) {
        if (target === kind) {
            this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        }
        else if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    };
    Logger.globalLogger = function () {
        if (!_globalLogger) {
            _globalLogger = new Logger(_version_1.version);
        }
        return _globalLogger;
    };
    Logger.setCensorship = function (censorship, permanent) {
        if (!censorship && permanent) {
            this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        if (_permanentCensorErrors) {
            if (!censorship) {
                return;
            }
            this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
    };
    Logger.setLogLevel = function (logLevel) {
        var level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
            Logger.globalLogger().warn("invalid log level - " + logLevel);
            return;
        }
        _logLevel = level;
    };
    Logger.from = function (version) {
        return new Logger(version);
    };
    Logger.errors = ErrorCode;
    Logger.levels = LogLevel;
    return Logger;
}());
exports.Logger = Logger;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 4063:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = "networks/5.7.1";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ 1888:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getNetwork = void 0;
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(4063);
var logger = new logger_1.Logger(_version_1.version);
;
function isRenetworkable(value) {
    return (value && typeof (value.renetwork) === "function");
}
function ethDefaultProvider(network) {
    var func = function (providers, options) {
        if (options == null) {
            options = {};
        }
        var providerList = [];
        if (providers.InfuraProvider && options.infura !== "-") {
            try {
                providerList.push(new providers.InfuraProvider(network, options.infura));
            }
            catch (error) { }
        }
        if (providers.EtherscanProvider && options.etherscan !== "-") {
            try {
                providerList.push(new providers.EtherscanProvider(network, options.etherscan));
            }
            catch (error) { }
        }
        if (providers.AlchemyProvider && options.alchemy !== "-") {
            try {
                providerList.push(new providers.AlchemyProvider(network, options.alchemy));
            }
            catch (error) { }
        }
        if (providers.PocketProvider && options.pocket !== "-") {
            // These networks are currently faulty on Pocket as their
            // network does not handle the Berlin hardfork, which is
            // live on these ones.
            // @TODO: This goes away once Pocket has upgraded their nodes
            var skip = ["goerli", "ropsten", "rinkeby", "sepolia"];
            try {
                var provider = new providers.PocketProvider(network, options.pocket);
                if (provider.network && skip.indexOf(provider.network.name) === -1) {
                    providerList.push(provider);
                }
            }
            catch (error) { }
        }
        if (providers.CloudflareProvider && options.cloudflare !== "-") {
            try {
                providerList.push(new providers.CloudflareProvider(network));
            }
            catch (error) { }
        }
        if (providers.AnkrProvider && options.ankr !== "-") {
            try {
                var skip = ["ropsten"];
                var provider = new providers.AnkrProvider(network, options.ankr);
                if (provider.network && skip.indexOf(provider.network.name) === -1) {
                    providerList.push(provider);
                }
            }
            catch (error) { }
        }
        if (providerList.length === 0) {
            return null;
        }
        if (providers.FallbackProvider) {
            var quorum = 1;
            if (options.quorum != null) {
                quorum = options.quorum;
            }
            else if (network === "homestead") {
                quorum = 2;
            }
            return new providers.FallbackProvider(providerList, quorum);
        }
        return providerList[0];
    };
    func.renetwork = function (network) {
        return ethDefaultProvider(network);
    };
    return func;
}
function etcDefaultProvider(url, network) {
    var func = function (providers, options) {
        if (providers.JsonRpcProvider) {
            return new providers.JsonRpcProvider(url, network);
        }
        return null;
    };
    func.renetwork = function (network) {
        return etcDefaultProvider(url, network);
    };
    return func;
}
var homestead = {
    chainId: 1,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "homestead",
    _defaultProvider: ethDefaultProvider("homestead")
};
var ropsten = {
    chainId: 3,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "ropsten",
    _defaultProvider: ethDefaultProvider("ropsten")
};
var classicMordor = {
    chainId: 63,
    name: "classicMordor",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
// See: https://chainlist.org
var networks = {
    unspecified: { chainId: 0, name: "unspecified" },
    homestead: homestead,
    mainnet: homestead,
    morden: { chainId: 2, name: "morden" },
    ropsten: ropsten,
    testnet: ropsten,
    rinkeby: {
        chainId: 4,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "rinkeby",
        _defaultProvider: ethDefaultProvider("rinkeby")
    },
    kovan: {
        chainId: 42,
        name: "kovan",
        _defaultProvider: ethDefaultProvider("kovan")
    },
    goerli: {
        chainId: 5,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "goerli",
        _defaultProvider: ethDefaultProvider("goerli")
    },
    kintsugi: { chainId: 1337702, name: "kintsugi" },
    sepolia: {
        chainId: 11155111,
        name: "sepolia",
        _defaultProvider: ethDefaultProvider("sepolia")
    },
    // ETC (See: #351)
    classic: {
        chainId: 61,
        name: "classic",
        _defaultProvider: etcDefaultProvider("https:/\/www.ethercluster.com/etc", "classic")
    },
    classicMorden: { chainId: 62, name: "classicMorden" },
    classicMordor: classicMordor,
    classicTestnet: classicMordor,
    classicKotti: {
        chainId: 6,
        name: "classicKotti",
        _defaultProvider: etcDefaultProvider("https:/\/www.ethercluster.com/kotti", "classicKotti")
    },
    xdai: { chainId: 100, name: "xdai" },
    matic: {
        chainId: 137,
        name: "matic",
        _defaultProvider: ethDefaultProvider("matic")
    },
    maticmum: { chainId: 80001, name: "maticmum" },
    optimism: {
        chainId: 10,
        name: "optimism",
        _defaultProvider: ethDefaultProvider("optimism")
    },
    "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
    "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
    arbitrum: { chainId: 42161, name: "arbitrum" },
    "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
    "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
    bnb: { chainId: 56, name: "bnb" },
    bnbt: { chainId: 97, name: "bnbt" },
};
/**
 *  getNetwork
 *
 *  Converts a named common networks or chain ID (network ID) to a Network
 *  and verifies a network is a valid Network..
 */
function getNetwork(network) {
    // No network (null)
    if (network == null) {
        return null;
    }
    if (typeof (network) === "number") {
        for (var name_1 in networks) {
            var standard_1 = networks[name_1];
            if (standard_1.chainId === network) {
                return {
                    name: standard_1.name,
                    chainId: standard_1.chainId,
                    ensAddress: (standard_1.ensAddress || null),
                    _defaultProvider: (standard_1._defaultProvider || null)
                };
            }
        }
        return {
            chainId: network,
            name: "unknown"
        };
    }
    if (typeof (network) === "string") {
        var standard_2 = networks[network];
        if (standard_2 == null) {
            return null;
        }
        return {
            name: standard_2.name,
            chainId: standard_2.chainId,
            ensAddress: standard_2.ensAddress,
            _defaultProvider: (standard_2._defaultProvider || null)
        };
    }
    var standard = networks[network.name];
    // Not a standard network; check that it is a valid network in general
    if (!standard) {
        if (typeof (network.chainId) !== "number") {
            logger.throwArgumentError("invalid network chainId", "network", network);
        }
        return network;
    }
    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)
    if (network.chainId !== 0 && network.chainId !== standard.chainId) {
        logger.throwArgumentError("network chainId mismatch", "network", network);
    }
    // @TODO: In the next major version add an attach function to a defaultProvider
    // class and move the _defaultProvider internal to this file (extend Network)
    var defaultProvider = network._defaultProvider || null;
    if (defaultProvider == null && standard._defaultProvider) {
        if (isRenetworkable(standard._defaultProvider)) {
            defaultProvider = standard._defaultProvider.renetwork(network);
        }
        else {
            defaultProvider = standard._defaultProvider;
        }
    }
    // Standard Network (allow overriding the ENS address)
    return {
        name: network.name,
        chainId: standard.chainId,
        ensAddress: (network.ensAddress || standard.ensAddress || null),
        _defaultProvider: defaultProvider
    };
}
exports.getNetwork = getNetwork;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 5212:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = "properties/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ 8078:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Description = exports.deepCopy = exports.shallowCopy = exports.checkProperties = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = void 0;
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(5212);
var logger = new logger_1.Logger(_version_1.version);
function defineReadOnly(object, name, value) {
    Object.defineProperty(object, name, {
        enumerable: true,
        value: value,
        writable: false,
    });
}
exports.defineReadOnly = defineReadOnly;
// Crawl up the constructor chain to find a static method
function getStatic(ctor, key) {
    for (var i = 0; i < 32; i++) {
        if (ctor[key]) {
            return ctor[key];
        }
        if (!ctor.prototype || typeof (ctor.prototype) !== "object") {
            break;
        }
        ctor = Object.getPrototypeOf(ctor.prototype).constructor;
    }
    return null;
}
exports.getStatic = getStatic;
function resolveProperties(object) {
    return __awaiter(this, void 0, void 0, function () {
        var promises, results;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    promises = Object.keys(object).map(function (key) {
                        var value = object[key];
                        return Promise.resolve(value).then(function (v) { return ({ key: key, value: v }); });
                    });
                    return [4 /*yield*/, Promise.all(promises)];
                case 1:
                    results = _a.sent();
                    return [2 /*return*/, results.reduce(function (accum, result) {
                            accum[(result.key)] = result.value;
                            return accum;
                        }, {})];
            }
        });
    });
}
exports.resolveProperties = resolveProperties;
function checkProperties(object, properties) {
    if (!object || typeof (object) !== "object") {
        logger.throwArgumentError("invalid object", "object", object);
    }
    Object.keys(object).forEach(function (key) {
        if (!properties[key]) {
            logger.throwArgumentError("invalid object key - " + key, "transaction:" + key, object);
        }
    });
}
exports.checkProperties = checkProperties;
function shallowCopy(object) {
    var result = {};
    for (var key in object) {
        result[key] = object[key];
    }
    return result;
}
exports.shallowCopy = shallowCopy;
var opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object) {
    // Opaque objects are not mutable, so safe to copy by assignment
    if (object === undefined || object === null || opaque[typeof (object)]) {
        return true;
    }
    if (Array.isArray(object) || typeof (object) === "object") {
        if (!Object.isFrozen(object)) {
            return false;
        }
        var keys = Object.keys(object);
        for (var i = 0; i < keys.length; i++) {
            var value = null;
            try {
                value = object[keys[i]];
            }
            catch (error) {
                // If accessing a value triggers an error, it is a getter
                // designed to do so (e.g. Result) and is therefore "frozen"
                continue;
            }
            if (!_isFrozen(value)) {
                return false;
            }
        }
        return true;
    }
    return logger.throwArgumentError("Cannot deepCopy " + typeof (object), "object", object);
}
// Returns a new copy of object, such that no properties may be replaced.
// New properties may be added only to objects.
function _deepCopy(object) {
    if (_isFrozen(object)) {
        return object;
    }
    // Arrays are mutable, so we need to create a copy
    if (Array.isArray(object)) {
        return Object.freeze(object.map(function (item) { return deepCopy(item); }));
    }
    if (typeof (object) === "object") {
        var result = {};
        for (var key in object) {
            var value = object[key];
            if (value === undefined) {
                continue;
            }
            defineReadOnly(result, key, deepCopy(value));
        }
        return result;
    }
    return logger.throwArgumentError("Cannot deepCopy " + typeof (object), "object", object);
}
function deepCopy(object) {
    return _deepCopy(object);
}
exports.deepCopy = deepCopy;
var Description = /** @class */ (function () {
    function Description(info) {
        for (var key in info) {
            this[key] = deepCopy(info[key]);
        }
    }
    return Description;
}());
exports.Description = Description;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1594:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = "providers/5.7.2";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ 3738:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AlchemyProvider = exports.AlchemyWebSocketProvider = void 0;
var properties_1 = __nccwpck_require__(8078);
var formatter_1 = __nccwpck_require__(3995);
var websocket_provider_1 = __nccwpck_require__(4405);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(1594);
var logger = new logger_1.Logger(_version_1.version);
var url_json_rpc_provider_1 = __nccwpck_require__(3480);
// This key was provided to ethers.js by Alchemy to be used by the
// default provider, but it is recommended that for your own
// production environments, that you acquire your own API key at:
//   https://dashboard.alchemyapi.io
var defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
var AlchemyWebSocketProvider = /** @class */ (function (_super) {
    __extends(AlchemyWebSocketProvider, _super);
    function AlchemyWebSocketProvider(network, apiKey) {
        var _this = this;
        var provider = new AlchemyProvider(network, apiKey);
        var url = provider.connection.url.replace(/^http/i, "ws")
            .replace(".alchemyapi.", ".ws.alchemyapi.");
        _this = _super.call(this, url, provider.network) || this;
        (0, properties_1.defineReadOnly)(_this, "apiKey", provider.apiKey);
        return _this;
    }
    AlchemyWebSocketProvider.prototype.isCommunityResource = function () {
        return (this.apiKey === defaultApiKey);
    };
    return AlchemyWebSocketProvider;
}(websocket_provider_1.WebSocketProvider));
exports.AlchemyWebSocketProvider = AlchemyWebSocketProvider;
var AlchemyProvider = /** @class */ (function (_super) {
    __extends(AlchemyProvider, _super);
    function AlchemyProvider() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AlchemyProvider.getWebSocketProvider = function (network, apiKey) {
        return new AlchemyWebSocketProvider(network, apiKey);
    };
    AlchemyProvider.getApiKey = function (apiKey) {
        if (apiKey == null) {
            return defaultApiKey;
        }
        if (apiKey && typeof (apiKey) !== "string") {
            logger.throwArgumentError("invalid apiKey", "apiKey", apiKey);
        }
        return apiKey;
    };
    AlchemyProvider.getUrl = function (network, apiKey) {
        var host = null;
        switch (network.name) {
            case "homestead":
                host = "eth-mainnet.alchemyapi.io/v2/";
                break;
            case "goerli":
                host = "eth-goerli.g.alchemy.com/v2/";
                break;
            case "matic":
                host = "polygon-mainnet.g.alchemy.com/v2/";
                break;
            case "maticmum":
                host = "polygon-mumbai.g.alchemy.com/v2/";
                break;
            case "arbitrum":
                host = "arb-mainnet.g.alchemy.com/v2/";
                break;
            case "arbitrum-goerli":
                host = "arb-goerli.g.alchemy.com/v2/";
                break;
            case "optimism":
                host = "opt-mainnet.g.alchemy.com/v2/";
                break;
            case "optimism-goerli":
                host = "opt-goerli.g.alchemy.com/v2/";
                break;
            default:
                logger.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return {
            allowGzip: true,
            url: ("https:/" + "/" + host + apiKey),
            throttleCallback: function (attempt, url) {
                if (apiKey === defaultApiKey) {
                    (0, formatter_1.showThrottleMessage)();
                }
                return Promise.resolve(true);
            }
        };
    };
    AlchemyProvider.prototype.isCommunityResource = function () {
        return (this.apiKey === defaultApiKey);
    };
    return AlchemyProvider;
}(url_json_rpc_provider_1.UrlJsonRpcProvider));
exports.AlchemyProvider = AlchemyProvider;
//# sourceMappingURL=alchemy-provider.js.map

/***/ }),

/***/ 841:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnkrProvider = void 0;
var formatter_1 = __nccwpck_require__(3995);
var url_json_rpc_provider_1 = __nccwpck_require__(3480);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(1594);
var logger = new logger_1.Logger(_version_1.version);
var defaultApiKey = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost(name) {
    switch (name) {
        case "homestead":
            return "rpc.ankr.com/eth/";
        case "ropsten":
            return "rpc.ankr.com/eth_ropsten/";
        case "rinkeby":
            return "rpc.ankr.com/eth_rinkeby/";
        case "goerli":
            return "rpc.ankr.com/eth_goerli/";
        case "matic":
            return "rpc.ankr.com/polygon/";
        case "arbitrum":
            return "rpc.ankr.com/arbitrum/";
    }
    return logger.throwArgumentError("unsupported network", "name", name);
}
var AnkrProvider = /** @class */ (function (_super) {
    __extends(AnkrProvider, _super);
    function AnkrProvider() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnkrProvider.prototype.isCommunityResource = function () {
        return (this.apiKey === defaultApiKey);
    };
    AnkrProvider.getApiKey = function (apiKey) {
        if (apiKey == null) {
            return defaultApiKey;
        }
        return apiKey;
    };
    AnkrProvider.getUrl = function (network, apiKey) {
        if (apiKey == null) {
            apiKey = defaultApiKey;
        }
        var connection = {
            allowGzip: true,
            url: ("https:/\/" + getHost(network.name) + apiKey),
            throttleCallback: function (attempt, url) {
                if (apiKey.apiKey === defaultApiKey) {
                    (0, formatter_1.showThrottleMessage)();
                }
                return Promise.resolve(true);
            }
        };
        if (apiKey.projectSecret != null) {
            connection.user = "";
            connection.password = apiKey.projectSecret;
        }
        return connection;
    };
    return AnkrProvider;
}(url_json_rpc_provider_1.UrlJsonRpcProvider));
exports.AnkrProvider = AnkrProvider;
//# sourceMappingURL=ankr-provider.js.map

/***/ }),

/***/ 3387:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseProvider = exports.Resolver = exports.Event = void 0;
var abstract_provider_1 = __nccwpck_require__(1698);
var base64_1 = __nccwpck_require__(8144);
var basex_1 = __nccwpck_require__(8241);
var bignumber_1 = __nccwpck_require__(1267);
var bytes_1 = __nccwpck_require__(2056);
var constants_1 = __nccwpck_require__(1309);
var hash_1 = __nccwpck_require__(7866);
var networks_1 = __nccwpck_require__(1888);
var properties_1 = __nccwpck_require__(8078);
var sha2_1 = __nccwpck_require__(9863);
var strings_1 = __nccwpck_require__(9115);
var web_1 = __nccwpck_require__(3138);
var bech32_1 = __importDefault(__nccwpck_require__(8464));
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(1594);
var logger = new logger_1.Logger(_version_1.version);
var formatter_1 = __nccwpck_require__(3995);
var MAX_CCIP_REDIRECTS = 10;
//////////////////////////////
// Event Serializeing
function checkTopic(topic) {
    if (topic == null) {
        return "null";
    }
    if ((0, bytes_1.hexDataLength)(topic) !== 32) {
        logger.throwArgumentError("invalid topic", "topic", topic);
    }
    return topic.toLowerCase();
}
function serializeTopics(topics) {
    // Remove trailing null AND-topics; they are redundant
    topics = topics.slice();
    while (topics.length > 0 && topics[topics.length - 1] == null) {
        topics.pop();
    }
    return topics.map(function (topic) {
        if (Array.isArray(topic)) {
            // Only track unique OR-topics
            var unique_1 = {};
            topic.forEach(function (topic) {
                unique_1[checkTopic(topic)] = true;
            });
            // The order of OR-topics does not matter
            var sorted = Object.keys(unique_1);
            sorted.sort();
            return sorted.join("|");
        }
        else {
            return checkTopic(topic);
        }
    }).join("&");
}
function deserializeTopics(data) {
    if (data === "") {
        return [];
    }
    return data.split(/&/g).map(function (topic) {
        if (topic === "") {
            return [];
        }
        var comps = topic.split("|").map(function (topic) {
            return ((topic === "null") ? null : topic);
        });
        return ((comps.length === 1) ? comps[0] : comps);
    });
}
function getEventTag(eventName) {
    if (typeof (eventName) === "string") {
        eventName = eventName.toLowerCase();
        if ((0, bytes_1.hexDataLength)(eventName) === 32) {
            return "tx:" + eventName;
        }
        if (eventName.indexOf(":") === -1) {
            return eventName;
        }
    }
    else if (Array.isArray(eventName)) {
        return "filter:*:" + serializeTopics(eventName);
    }
    else if (abstract_provider_1.ForkEvent.isForkEvent(eventName)) {
        logger.warn("not implemented");
        throw new Error("not implemented");
    }
    else if (eventName && typeof (eventName) === "object") {
        return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
    }
    throw new Error("invalid event - " + eventName);
}
//////////////////////////////
// Helper Object
function getTime() {
    return (new Date()).getTime();
}
function stall(duration) {
    return new Promise(function (resolve) {
        setTimeout(resolve, duration);
    });
}
//////////////////////////////
// Provider Object
/**
 *  EventType
 *   - "block"
 *   - "poll"
 *   - "didPoll"
 *   - "pending"
 *   - "error"
 *   - "network"
 *   - filter
 *   - topics array
 *   - transaction hash
 */
var PollableEvents = ["block", "network", "pending", "poll"];
var Event = /** @class */ (function () {
    function Event(tag, listener, once) {
        (0, properties_1.defineReadOnly)(this, "tag", tag);
        (0, properties_1.defineReadOnly)(this, "listener", listener);
        (0, properties_1.defineReadOnly)(this, "once", once);
        this._lastBlockNumber = -2;
        this._inflight = false;
    }
    Object.defineProperty(Event.prototype, "event", {
        get: function () {
            switch (this.type) {
                case "tx":
                    return this.hash;
                case "filter":
                    return this.filter;
            }
            return this.tag;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Event.prototype, "type", {
        get: function () {
            return this.tag.split(":")[0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Event.prototype, "hash", {
        get: function () {
            var comps = this.tag.split(":");
            if (comps[0] !== "tx") {
                return null;
            }
            return comps[1];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Event.prototype, "filter", {
        get: function () {
            var comps = this.tag.split(":");
            if (comps[0] !== "filter") {
                return null;
            }
            var address = comps[1];
            var topics = deserializeTopics(comps[2]);
            var filter = {};
            if (topics.length > 0) {
                filter.topics = topics;
            }
            if (address && address !== "*") {
                filter.address = address;
            }
            return filter;
        },
        enumerable: false,
        configurable: true
    });
    Event.prototype.pollable = function () {
        return (this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0);
    };
    return Event;
}());
exports.Event = Event;
;
// https://github.com/satoshilabs/slips/blob/master/slip-0044.md
var coinInfos = {
    "0": { symbol: "btc", p2pkh: 0x00, p2sh: 0x05, prefix: "bc" },
    "2": { symbol: "ltc", p2pkh: 0x30, p2sh: 0x32, prefix: "ltc" },
    "3": { symbol: "doge", p2pkh: 0x1e, p2sh: 0x16 },
    "60": { symbol: "eth", ilk: "eth" },
    "61": { symbol: "etc", ilk: "eth" },
    "700": { symbol: "xdai", ilk: "eth" },
};
function bytes32ify(value) {
    return (0, bytes_1.hexZeroPad)(bignumber_1.BigNumber.from(value).toHexString(), 32);
}
// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)
function base58Encode(data) {
    return basex_1.Base58.encode((0, bytes_1.concat)([data, (0, bytes_1.hexDataSlice)((0, sha2_1.sha256)((0, sha2_1.sha256)(data)), 0, 4)]));
}
var matcherIpfs = new RegExp("^(ipfs):/\/(.*)$", "i");
var matchers = [
    new RegExp("^(https):/\/(.*)$", "i"),
    new RegExp("^(data):(.*)$", "i"),
    matcherIpfs,
    new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i"),
];
function _parseString(result, start) {
    try {
        return (0, strings_1.toUtf8String)(_parseBytes(result, start));
    }
    catch (error) { }
    return null;
}
function _parseBytes(result, start) {
    if (result === "0x") {
        return null;
    }
    var offset = bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(result, start, start + 32)).toNumber();
    var length = bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(result, offset, offset + 32)).toNumber();
    return (0, bytes_1.hexDataSlice)(result, offset + 32, offset + 32 + length);
}
// Trim off the ipfs:// prefix and return the default gateway URL
function getIpfsLink(link) {
    if (link.match(/^ipfs:\/\/ipfs\//i)) {
        link = link.substring(12);
    }
    else if (link.match(/^ipfs:\/\//i)) {
        link = link.substring(7);
    }
    else {
        logger.throwArgumentError("unsupported IPFS format", "link", link);
    }
    return "https://gateway.ipfs.io/ipfs/" + link;
}
function numPad(value) {
    var result = (0, bytes_1.arrayify)(value);
    if (result.length > 32) {
        throw new Error("internal; should not happen");
    }
    var padded = new Uint8Array(32);
    padded.set(result, 32 - result.length);
    return padded;
}
function bytesPad(value) {
    if ((value.length % 32) === 0) {
        return value;
    }
    var result = new Uint8Array(Math.ceil(value.length / 32) * 32);
    result.set(value);
    return result;
}
// ABI Encodes a series of (bytes, bytes, ...)
function encodeBytes(datas) {
    var result = [];
    var byteCount = 0;
    // Add place-holders for pointers as we add items
    for (var i = 0; i < datas.length; i++) {
        result.push(null);
        byteCount += 32;
    }
    for (var i = 0; i < datas.length; i++) {
        var data = (0, bytes_1.arrayify)(datas[i]);
        // Update the bytes offset
        result[i] = numPad(byteCount);
        // The length and padded value of data
        result.push(numPad(data.length));
        result.push(bytesPad(data));
        byteCount += 32 + Math.ceil(data.length / 32) * 32;
    }
    return (0, bytes_1.hexConcat)(result);
}
var Resolver = /** @class */ (function () {
    // The resolvedAddress is only for creating a ReverseLookup resolver
    function Resolver(provider, address, name, resolvedAddress) {
        (0, properties_1.defineReadOnly)(this, "provider", provider);
        (0, properties_1.defineReadOnly)(this, "name", name);
        (0, properties_1.defineReadOnly)(this, "address", provider.formatter.address(address));
        (0, properties_1.defineReadOnly)(this, "_resolvedAddress", resolvedAddress);
    }
    Resolver.prototype.supportsWildcard = function () {
        var _this = this;
        if (!this._supportsEip2544) {
            // supportsInterface(bytes4 = selector("resolve(bytes,bytes)"))
            this._supportsEip2544 = this.provider.call({
                to: this.address,
                data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
            }).then(function (result) {
                return bignumber_1.BigNumber.from(result).eq(1);
            }).catch(function (error) {
                if (error.code === logger_1.Logger.errors.CALL_EXCEPTION) {
                    return false;
                }
                // Rethrow the error: link is down, etc. Let future attempts retry.
                _this._supportsEip2544 = null;
                throw error;
            });
        }
        return this._supportsEip2544;
    };
    Resolver.prototype._fetch = function (selector, parameters) {
        return __awaiter(this, void 0, void 0, function () {
            var tx, parseBytes, result, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tx = {
                            to: this.address,
                            ccipReadEnabled: true,
                            data: (0, bytes_1.hexConcat)([selector, (0, hash_1.namehash)(this.name), (parameters || "0x")])
                        };
                        parseBytes = false;
                        return [4 /*yield*/, this.supportsWildcard()];
                    case 1:
                        if (_a.sent()) {
                            parseBytes = true;
                            // selector("resolve(bytes,bytes)")
                            tx.data = (0, bytes_1.hexConcat)(["0x9061b923", encodeBytes([(0, hash_1.dnsEncode)(this.name), tx.data])]);
                        }
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, this.provider.call(tx)];
                    case 3:
                        result = _a.sent();
                        if (((0, bytes_1.arrayify)(result).length % 32) === 4) {
                            logger.throwError("resolver threw error", logger_1.Logger.errors.CALL_EXCEPTION, {
                                transaction: tx, data: result
                            });
                        }
                        if (parseBytes) {
                            result = _parseBytes(result, 0);
                        }
                        return [2 /*return*/, result];
                    case 4:
                        error_1 = _a.sent();
                        if (error_1.code === logger_1.Logger.errors.CALL_EXCEPTION) {
                            return [2 /*return*/, null];
                        }
                        throw error_1;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    Resolver.prototype._fetchBytes = function (selector, parameters) {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._fetch(selector, parameters)];
                    case 1:
                        result = _a.sent();
                        if (result != null) {
                            return [2 /*return*/, _parseBytes(result, 0)];
                        }
                        return [2 /*return*/, null];
                }
            });
        });
    };
    Resolver.prototype._getAddress = function (coinType, hexBytes) {
        var coinInfo = coinInfos[String(coinType)];
        if (coinInfo == null) {
            logger.throwError("unsupported coin type: " + coinType, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "getAddress(" + coinType + ")"
            });
        }
        if (coinInfo.ilk === "eth") {
            return this.provider.formatter.address(hexBytes);
        }
        var bytes = (0, bytes_1.arrayify)(hexBytes);
        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
        if (coinInfo.p2pkh != null) {
            var p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
            if (p2pkh) {
                var length_1 = parseInt(p2pkh[1], 16);
                if (p2pkh[2].length === length_1 * 2 && length_1 >= 1 && length_1 <= 75) {
                    return base58Encode((0, bytes_1.concat)([[coinInfo.p2pkh], ("0x" + p2pkh[2])]));
                }
            }
        }
        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL
        if (coinInfo.p2sh != null) {
            var p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
            if (p2sh) {
                var length_2 = parseInt(p2sh[1], 16);
                if (p2sh[2].length === length_2 * 2 && length_2 >= 1 && length_2 <= 75) {
                    return base58Encode((0, bytes_1.concat)([[coinInfo.p2sh], ("0x" + p2sh[2])]));
                }
            }
        }
        // Bech32
        if (coinInfo.prefix != null) {
            var length_3 = bytes[1];
            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program
            var version_1 = bytes[0];
            if (version_1 === 0x00) {
                if (length_3 !== 20 && length_3 !== 32) {
                    version_1 = -1;
                }
            }
            else {
                version_1 = -1;
            }
            if (version_1 >= 0 && bytes.length === 2 + length_3 && length_3 >= 1 && length_3 <= 75) {
                var words = bech32_1.default.toWords(bytes.slice(2));
                words.unshift(version_1);
                return bech32_1.default.encode(coinInfo.prefix, words);
            }
        }
        return null;
    };
    Resolver.prototype.getAddress = function (coinType) {
        return __awaiter(this, void 0, void 0, function () {
            var result, error_2, hexBytes, address;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (coinType == null) {
                            coinType = 60;
                        }
                        if (!(coinType === 60)) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._fetch("0x3b3b57de")];
                    case 2:
                        result = _a.sent();
                        // No address
                        if (result === "0x" || result === constants_1.HashZero) {
                            return [2 /*return*/, null];
                        }
                        return [2 /*return*/, this.provider.formatter.callAddress(result)];
                    case 3:
                        error_2 = _a.sent();
                        if (error_2.code === logger_1.Logger.errors.CALL_EXCEPTION) {
                            return [2 /*return*/, null];
                        }
                        throw error_2;
                    case 4: return [4 /*yield*/, this._fetchBytes("0xf1cb7e06", bytes32ify(coinType))];
                    case 5:
                        hexBytes = _a.sent();
                        // No address
                        if (hexBytes == null || hexBytes === "0x") {
                            return [2 /*return*/, null];
                        }
                        address = this._getAddress(coinType, hexBytes);
                        if (address == null) {
                            logger.throwError("invalid or unsupported coin data", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                                operation: "getAddress(" + coinType + ")",
                                coinType: coinType,
                                data: hexBytes
                            });
                        }
                        return [2 /*return*/, address];
                }
            });
        });
    };
    Resolver.prototype.getAvatar = function () {
        return __awaiter(this, void 0, void 0, function () {
            var linkage, avatar, i, match, scheme, _a, selector, owner, _b, comps, addr, tokenId, tokenOwner, _c, _d, balance, _e, _f, tx, metadataUrl, _g, metadata, imageUrl, ipfs, error_3;
            return __generator(this, function (_h) {
                switch (_h.label) {
                    case 0:
                        linkage = [{ type: "name", content: this.name }];
                        _h.label = 1;
                    case 1:
                        _h.trys.push([1, 19, , 20]);
                        return [4 /*yield*/, this.getText("avatar")];
                    case 2:
                        avatar = _h.sent();
                        if (avatar == null) {
                            return [2 /*return*/, null];
                        }
                        i = 0;
                        _h.label = 3;
                    case 3:
                        if (!(i < matchers.length)) return [3 /*break*/, 18];
                        match = avatar.match(matchers[i]);
                        if (match == null) {
                            return [3 /*break*/, 17];
                        }
                        scheme = match[1].toLowerCase();
                        _a = scheme;
                        switch (_a) {
                            case "https": return [3 /*break*/, 4];
                            case "data": return [3 /*break*/, 5];
                            case "ipfs": return [3 /*break*/, 6];
                            case "erc721": return [3 /*break*/, 7];
                            case "erc1155": return [3 /*break*/, 7];
                        }
                        return [3 /*break*/, 17];
                    case 4:
                        linkage.push({ type: "url", content: avatar });
                        return [2 /*return*/, { linkage: linkage, url: avatar }];
                    case 5:
                        linkage.push({ type: "data", content: avatar });
                        return [2 /*return*/, { linkage: linkage, url: avatar }];
                    case 6:
                        linkage.push({ type: "ipfs", content: avatar });
                        return [2 /*return*/, { linkage: linkage, url: getIpfsLink(avatar) }];
                    case 7:
                        selector = (scheme === "erc721") ? "0xc87b56dd" : "0x0e89341c";
                        linkage.push({ type: scheme, content: avatar });
                        _b = this._resolvedAddress;
                        if (_b) return [3 /*break*/, 9];
                        return [4 /*yield*/, this.getAddress()];
                    case 8:
                        _b = (_h.sent());
                        _h.label = 9;
                    case 9:
                        owner = (_b);
                        comps = (match[2] || "").split("/");
                        if (comps.length !== 2) {
                            return [2 /*return*/, null];
                        }
                        return [4 /*yield*/, this.provider.formatter.address(comps[0])];
                    case 10:
                        addr = _h.sent();
                        tokenId = (0, bytes_1.hexZeroPad)(bignumber_1.BigNumber.from(comps[1]).toHexString(), 32);
                        if (!(scheme === "erc721")) return [3 /*break*/, 12];
                        _d = (_c = this.provider.formatter).callAddress;
                        return [4 /*yield*/, this.provider.call({
                                to: addr, data: (0, bytes_1.hexConcat)(["0x6352211e", tokenId])
                            })];
                    case 11:
                        tokenOwner = _d.apply(_c, [_h.sent()]);
                        if (owner !== tokenOwner) {
                            return [2 /*return*/, null];
                        }
                        linkage.push({ type: "owner", content: tokenOwner });
                        return [3 /*break*/, 14];
                    case 12:
                        if (!(scheme === "erc1155")) return [3 /*break*/, 14];
                        _f = (_e = bignumber_1.BigNumber).from;
                        return [4 /*yield*/, this.provider.call({
                                to: addr, data: (0, bytes_1.hexConcat)(["0x00fdd58e", (0, bytes_1.hexZeroPad)(owner, 32), tokenId])
                            })];
                    case 13:
                        balance = _f.apply(_e, [_h.sent()]);
                        if (balance.isZero()) {
                            return [2 /*return*/, null];
                        }
                        linkage.push({ type: "balance", content: balance.toString() });
                        _h.label = 14;
                    case 14:
                        tx = {
                            to: this.provider.formatter.address(comps[0]),
                            data: (0, bytes_1.hexConcat)([selector, tokenId])
                        };
                        _g = _parseString;
                        return [4 /*yield*/, this.provider.call(tx)];
                    case 15:
                        metadataUrl = _g.apply(void 0, [_h.sent(), 0]);
                        if (metadataUrl == null) {
                            return [2 /*return*/, null];
                        }
                        linkage.push({ type: "metadata-url-base", content: metadataUrl });
                        // ERC-1155 allows a generic {id} in the URL
                        if (scheme === "erc1155") {
                            metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                            linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
                        }
                        // Transform IPFS metadata links
                        if (metadataUrl.match(/^ipfs:/i)) {
                            metadataUrl = getIpfsLink(metadataUrl);
                        }
                        linkage.push({ type: "metadata-url", content: metadataUrl });
                        return [4 /*yield*/, (0, web_1.fetchJson)(metadataUrl)];
                    case 16:
                        metadata = _h.sent();
                        if (!metadata) {
                            return [2 /*return*/, null];
                        }
                        linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
                        imageUrl = metadata.image;
                        if (typeof (imageUrl) !== "string") {
                            return [2 /*return*/, null];
                        }
                        if (imageUrl.match(/^(https:\/\/|data:)/i)) {
                            // Allow
                        }
                        else {
                            ipfs = imageUrl.match(matcherIpfs);
                            if (ipfs == null) {
                                return [2 /*return*/, null];
                            }
                            linkage.push({ type: "url-ipfs", content: imageUrl });
                            imageUrl = getIpfsLink(imageUrl);
                        }
                        linkage.push({ type: "url", content: imageUrl });
                        return [2 /*return*/, { linkage: linkage, url: imageUrl }];
                    case 17:
                        i++;
                        return [3 /*break*/, 3];
                    case 18: return [3 /*break*/, 20];
                    case 19:
                        error_3 = _h.sent();
                        return [3 /*break*/, 20];
                    case 20: return [2 /*return*/, null];
                }
            });
        });
    };
    Resolver.prototype.getContentHash = function () {
        return __awaiter(this, void 0, void 0, function () {
            var hexBytes, ipfs, length_4, ipns, length_5, swarm, skynet, urlSafe_1, hash;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._fetchBytes("0xbc1c58d1")];
                    case 1:
                        hexBytes = _a.sent();
                        // No contenthash
                        if (hexBytes == null || hexBytes === "0x") {
                            return [2 /*return*/, null];
                        }
                        ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
                        if (ipfs) {
                            length_4 = parseInt(ipfs[3], 16);
                            if (ipfs[4].length === length_4 * 2) {
                                return [2 /*return*/, "ipfs:/\/" + basex_1.Base58.encode("0x" + ipfs[1])];
                            }
                        }
                        ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
                        if (ipns) {
                            length_5 = parseInt(ipns[3], 16);
                            if (ipns[4].length === length_5 * 2) {
                                return [2 /*return*/, "ipns:/\/" + basex_1.Base58.encode("0x" + ipns[1])];
                            }
                        }
                        swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
                        if (swarm) {
                            if (swarm[1].length === (32 * 2)) {
                                return [2 /*return*/, "bzz:/\/" + swarm[1]];
                            }
                        }
                        skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
                        if (skynet) {
                            if (skynet[1].length === (34 * 2)) {
                                urlSafe_1 = { "=": "", "+": "-", "/": "_" };
                                hash = (0, base64_1.encode)("0x" + skynet[1]).replace(/[=+\/]/g, function (a) { return (urlSafe_1[a]); });
                                return [2 /*return*/, "sia:/\/" + hash];
                            }
                        }
                        return [2 /*return*/, logger.throwError("invalid or unsupported content hash data", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                                operation: "getContentHash()",
                                data: hexBytes
                            })];
                }
            });
        });
    };
    Resolver.prototype.getText = function (key) {
        return __awaiter(this, void 0, void 0, function () {
            var keyBytes, hexBytes;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyBytes = (0, strings_1.toUtf8Bytes)(key);
                        // The nodehash consumes the first slot, so the string pointer targets
                        // offset 64, with the length at offset 64 and data starting at offset 96
                        keyBytes = (0, bytes_1.concat)([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
                        // Pad to word-size (32 bytes)
                        if ((keyBytes.length % 32) !== 0) {
                            keyBytes = (0, bytes_1.concat)([keyBytes, (0, bytes_1.hexZeroPad)("0x", 32 - (key.length % 32))]);
                        }
                        return [4 /*yield*/, this._fetchBytes("0x59d1d43c", (0, bytes_1.hexlify)(keyBytes))];
                    case 1:
                        hexBytes = _a.sent();
                        if (hexBytes == null || hexBytes === "0x") {
                            return [2 /*return*/, null];
                        }
                        return [2 /*return*/, (0, strings_1.toUtf8String)(hexBytes)];
                }
            });
        });
    };
    return Resolver;
}());
exports.Resolver = Resolver;
var defaultFormatter = null;
var nextPollId = 1;
var BaseProvider = /** @class */ (function (_super) {
    __extends(BaseProvider, _super);
    /**
     *  ready
     *
     *  A Promise<Network> that resolves only once the provider is ready.
     *
     *  Sub-classes that call the super with a network without a chainId
     *  MUST set this. Standard named networks have a known chainId.
     *
     */
    function BaseProvider(network) {
        var _newTarget = this.constructor;
        var _this = _super.call(this) || this;
        // Events being listened to
        _this._events = [];
        _this._emitted = { block: -2 };
        _this.disableCcipRead = false;
        _this.formatter = _newTarget.getFormatter();
        // If network is any, this Provider allows the underlying
        // network to change dynamically, and we auto-detect the
        // current network
        (0, properties_1.defineReadOnly)(_this, "anyNetwork", (network === "any"));
        if (_this.anyNetwork) {
            network = _this.detectNetwork();
        }
        if (network instanceof Promise) {
            _this._networkPromise = network;
            // Squash any "unhandled promise" errors; that do not need to be handled
            network.catch(function (error) { });
            // Trigger initial network setting (async)
            _this._ready().catch(function (error) { });
        }
        else {
            var knownNetwork = (0, properties_1.getStatic)(_newTarget, "getNetwork")(network);
            if (knownNetwork) {
                (0, properties_1.defineReadOnly)(_this, "_network", knownNetwork);
                _this.emit("network", knownNetwork, null);
            }
            else {
                logger.throwArgumentError("invalid network", "network", network);
            }
        }
        _this._maxInternalBlockNumber = -1024;
        _this._lastBlockNumber = -2;
        _this._maxFilterBlockRange = 10;
        _this._pollingInterval = 4000;
        _this._fastQueryDate = 0;
        return _this;
    }
    BaseProvider.prototype._ready = function () {
        return __awaiter(this, void 0, void 0, function () {
            var network, error_4;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this._network == null)) return [3 /*break*/, 7];
                        network = null;
                        if (!this._networkPromise) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._networkPromise];
                    case 2:
                        network = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_4 = _a.sent();
                        return [3 /*break*/, 4];
                    case 4:
                        if (!(network == null)) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.detectNetwork()];
                    case 5:
                        network = _a.sent();
                        _a.label = 6;
                    case 6:
                        // This should never happen; every Provider sub-class should have
                        // suggested a network by here (or have thrown).
                        if (!network) {
                            logger.throwError("no network detected", logger_1.Logger.errors.UNKNOWN_ERROR, {});
                        }
                        // Possible this call stacked so do not call defineReadOnly again
                        if (this._network == null) {
                            if (this.anyNetwork) {
                                this._network = network;
                            }
                            else {
                                (0, properties_1.defineReadOnly)(this, "_network", network);
                            }
                            this.emit("network", network, null);
                        }
                        _a.label = 7;
                    case 7: return [2 /*return*/, this._network];
                }
            });
        });
    };
    Object.defineProperty(BaseProvider.prototype, "ready", {
        // This will always return the most recently established network.
        // For "any", this can change (a "network" event is emitted before
        // any change is reflected); otherwise this cannot change
        get: function () {
            var _this = this;
            return (0, web_1.poll)(function () {
                return _this._ready().then(function (network) {
                    return network;
                }, function (error) {
                    // If the network isn't running yet, we will wait
                    if (error.code === logger_1.Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
                        return undefined;
                    }
                    throw error;
                });
            });
        },
        enumerable: false,
        configurable: true
    });
    // @TODO: Remove this and just create a singleton formatter
    BaseProvider.getFormatter = function () {
        if (defaultFormatter == null) {
            defaultFormatter = new formatter_1.Formatter();
        }
        return defaultFormatter;
    };
    // @TODO: Remove this and just use getNetwork
    BaseProvider.getNetwork = function (network) {
        return (0, networks_1.getNetwork)((network == null) ? "homestead" : network);
    };
    BaseProvider.prototype.ccipReadFetch = function (tx, calldata, urls) {
        return __awaiter(this, void 0, void 0, function () {
            var sender, data, errorMessages, i, url, href, json, result, errorMessage;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.disableCcipRead || urls.length === 0) {
                            return [2 /*return*/, null];
                        }
                        sender = tx.to.toLowerCase();
                        data = calldata.toLowerCase();
                        errorMessages = [];
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < urls.length)) return [3 /*break*/, 4];
                        url = urls[i];
                        href = url.replace("{sender}", sender).replace("{data}", data);
                        json = (url.indexOf("{data}") >= 0) ? null : JSON.stringify({ data: data, sender: sender });
                        return [4 /*yield*/, (0, web_1.fetchJson)({ url: href, errorPassThrough: true }, json, function (value, response) {
                                value.status = response.statusCode;
                                return value;
                            })];
                    case 2:
                        result = _a.sent();
                        if (result.data) {
                            return [2 /*return*/, result.data];
                        }
                        errorMessage = (result.message || "unknown error");
                        // 4xx indicates the result is not present; stop
                        if (result.status >= 400 && result.status < 500) {
                            return [2 /*return*/, logger.throwError("response not found during CCIP fetch: " + errorMessage, logger_1.Logger.errors.SERVER_ERROR, { url: url, errorMessage: errorMessage })];
                        }
                        // 5xx indicates server issue; try the next url
                        errorMessages.push(errorMessage);
                        _a.label = 3;
                    case 3:
                        i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/, logger.throwError("error encountered during CCIP fetch: " + errorMessages.map(function (m) { return JSON.stringify(m); }).join(", "), logger_1.Logger.errors.SERVER_ERROR, {
                            urls: urls,
                            errorMessages: errorMessages
                        })];
                }
            });
        });
    };
    // Fetches the blockNumber, but will reuse any result that is less
    // than maxAge old or has been requested since the last request
    BaseProvider.prototype._getInternalBlockNumber = function (maxAge) {
        return __awaiter(this, void 0, void 0, function () {
            var internalBlockNumber, result, error_5, reqTime, checkInternalBlockNumber;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._ready()];
                    case 1:
                        _a.sent();
                        if (!(maxAge > 0)) return [3 /*break*/, 7];
                        _a.label = 2;
                    case 2:
                        if (!this._internalBlockNumber) return [3 /*break*/, 7];
                        internalBlockNumber = this._internalBlockNumber;
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, internalBlockNumber];
                    case 4:
                        result = _a.sent();
                        if ((getTime() - result.respTime) <= maxAge) {
                            return [2 /*return*/, result.blockNumber];
                        }
                        // Too old; fetch a new value
                        return [3 /*break*/, 7];
                    case 5:
                        error_5 = _a.sent();
                        // The fetch rejected; if we are the first to get the
                        // rejection, drop through so we replace it with a new
                        // fetch; all others blocked will then get that fetch
                        // which won't match the one they "remembered" and loop
                        if (this._internalBlockNumber === internalBlockNumber) {
                            return [3 /*break*/, 7];
                        }
                        return [3 /*break*/, 6];
                    case 6: return [3 /*break*/, 2];
                    case 7:
                        reqTime = getTime();
                        checkInternalBlockNumber = (0, properties_1.resolveProperties)({
                            blockNumber: this.perform("getBlockNumber", {}),
                            networkError: this.getNetwork().then(function (network) { return (null); }, function (error) { return (error); })
                        }).then(function (_a) {
                            var blockNumber = _a.blockNumber, networkError = _a.networkError;
                            if (networkError) {
                                // Unremember this bad internal block number
                                if (_this._internalBlockNumber === checkInternalBlockNumber) {
                                    _this._internalBlockNumber = null;
                                }
                                throw networkError;
                            }
                            var respTime = getTime();
                            blockNumber = bignumber_1.BigNumber.from(blockNumber).toNumber();
                            if (blockNumber < _this._maxInternalBlockNumber) {
                                blockNumber = _this._maxInternalBlockNumber;
                            }
                            _this._maxInternalBlockNumber = blockNumber;
                            _this._setFastBlockNumber(blockNumber); // @TODO: Still need this?
                            return { blockNumber: blockNumber, reqTime: reqTime, respTime: respTime };
                        });
                        this._internalBlockNumber = checkInternalBlockNumber;
                        // Swallow unhandled exceptions; if needed they are handled else where
                        checkInternalBlockNumber.catch(function (error) {
                            // Don't null the dead (rejected) fetch, if it has already been updated
                            if (_this._internalBlockNumber === checkInternalBlockNumber) {
                                _this._internalBlockNumber = null;
                            }
                        });
                        return [4 /*yield*/, checkInternalBlockNumber];
                    case 8: return [2 /*return*/, (_a.sent()).blockNumber];
                }
            });
        });
    };
    BaseProvider.prototype.poll = function () {
        return __awaiter(this, void 0, void 0, function () {
            var pollId, runners, blockNumber, error_6, i;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        pollId = nextPollId++;
                        runners = [];
                        blockNumber = null;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._getInternalBlockNumber(100 + this.pollingInterval / 2)];
                    case 2:
                        blockNumber = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_6 = _a.sent();
                        this.emit("error", error_6);
                        return [2 /*return*/];
                    case 4:
                        this._setFastBlockNumber(blockNumber);
                        // Emit a poll event after we have the latest (fast) block number
                        this.emit("poll", pollId, blockNumber);
                        // If the block has not changed, meh.
                        if (blockNumber === this._lastBlockNumber) {
                            this.emit("didPoll", pollId);
                            return [2 /*return*/];
                        }
                        // First polling cycle, trigger a "block" events
                        if (this._emitted.block === -2) {
                            this._emitted.block = blockNumber - 1;
                        }
                        if (Math.abs((this._emitted.block) - blockNumber) > 1000) {
                            logger.warn("network block skew detected; skipping block events (emitted=" + this._emitted.block + " blockNumber" + blockNumber + ")");
                            this.emit("error", logger.makeError("network block skew detected", logger_1.Logger.errors.NETWORK_ERROR, {
                                blockNumber: blockNumber,
                                event: "blockSkew",
                                previousBlockNumber: this._emitted.block
                            }));
                            this.emit("block", blockNumber);
                        }
                        else {
                            // Notify all listener for each block that has passed
                            for (i = this._emitted.block + 1; i <= blockNumber; i++) {
                                this.emit("block", i);
                            }
                        }
                        // The emitted block was updated, check for obsolete events
                        if (this._emitted.block !== blockNumber) {
                            this._emitted.block = blockNumber;
                            Object.keys(this._emitted).forEach(function (key) {
                                // The block event does not expire
                                if (key === "block") {
                                    return;
                                }
                                // The block we were at when we emitted this event
                                var eventBlockNumber = _this._emitted[key];
                                // We cannot garbage collect pending transactions or blocks here
                                // They should be garbage collected by the Provider when setting
                                // "pending" events
                                if (eventBlockNumber === "pending") {
                                    return;
                                }
                                // Evict any transaction hashes or block hashes over 12 blocks
                                // old, since they should not return null anyways
                                if (blockNumber - eventBlockNumber > 12) {
                                    delete _this._emitted[key];
                                }
                            });
                        }
                        // First polling cycle
                        if (this._lastBlockNumber === -2) {
                            this._lastBlockNumber = blockNumber - 1;
                        }
                        // Find all transaction hashes we are waiting on
                        this._events.forEach(function (event) {
                            switch (event.type) {
                                case "tx": {
                                    var hash_2 = event.hash;
                                    var runner = _this.getTransactionReceipt(hash_2).then(function (receipt) {
                                        if (!receipt || receipt.blockNumber == null) {
                                            return null;
                                        }
                                        _this._emitted["t:" + hash_2] = receipt.blockNumber;
                                        _this.emit(hash_2, receipt);
                                        return null;
                                    }).catch(function (error) { _this.emit("error", error); });
                                    runners.push(runner);
                                    break;
                                }
                                case "filter": {
                                    // We only allow a single getLogs to be in-flight at a time
                                    if (!event._inflight) {
                                        event._inflight = true;
                                        // This is the first filter for this event, so we want to
                                        // restrict events to events that happened no earlier than now
                                        if (event._lastBlockNumber === -2) {
                                            event._lastBlockNumber = blockNumber - 1;
                                        }
                                        // Filter from the last *known* event; due to load-balancing
                                        // and some nodes returning updated block numbers before
                                        // indexing events, a logs result with 0 entries cannot be
                                        // trusted and we must retry a range which includes it again
                                        var filter_1 = event.filter;
                                        filter_1.fromBlock = event._lastBlockNumber + 1;
                                        filter_1.toBlock = blockNumber;
                                        // Prevent fitler ranges from growing too wild, since it is quite
                                        // likely there just haven't been any events to move the lastBlockNumber.
                                        var minFromBlock = filter_1.toBlock - _this._maxFilterBlockRange;
                                        if (minFromBlock > filter_1.fromBlock) {
                                            filter_1.fromBlock = minFromBlock;
                                        }
                                        if (filter_1.fromBlock < 0) {
                                            filter_1.fromBlock = 0;
                                        }
                                        var runner = _this.getLogs(filter_1).then(function (logs) {
                                            // Allow the next getLogs
                                            event._inflight = false;
                                            if (logs.length === 0) {
                                                return;
                                            }
                                            logs.forEach(function (log) {
                                                // Only when we get an event for a given block number
                                                // can we trust the events are indexed
                                                if (log.blockNumber > event._lastBlockNumber) {
                                                    event._lastBlockNumber = log.blockNumber;
                                                }
                                                // Make sure we stall requests to fetch blocks and txs
                                                _this._emitted["b:" + log.blockHash] = log.blockNumber;
                                                _this._emitted["t:" + log.transactionHash] = log.blockNumber;
                                                _this.emit(filter_1, log);
                                            });
                                        }).catch(function (error) {
                                            _this.emit("error", error);
                                            // Allow another getLogs (the range was not updated)
                                            event._inflight = false;
                                        });
                                        runners.push(runner);
                                    }
                                    break;
                                }
                            }
                        });
                        this._lastBlockNumber = blockNumber;
                        // Once all events for this loop have been processed, emit "didPoll"
                        Promise.all(runners).then(function () {
                            _this.emit("didPoll", pollId);
                        }).catch(function (error) { _this.emit("error", error); });
                        return [2 /*return*/];
                }
            });
        });
    };
    // Deprecated; do not use this
    BaseProvider.prototype.resetEventsBlock = function (blockNumber) {
        this._lastBlockNumber = blockNumber - 1;
        if (this.polling) {
            this.poll();
        }
    };
    Object.defineProperty(BaseProvider.prototype, "network", {
        get: function () {
            return this._network;
        },
        enumerable: false,
        configurable: true
    });
    // This method should query the network if the underlying network
    // can change, such as when connected to a JSON-RPC backend
    BaseProvider.prototype.detectNetwork = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, logger.throwError("provider does not support network detection", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                        operation: "provider.detectNetwork"
                    })];
            });
        });
    };
    BaseProvider.prototype.getNetwork = function () {
        return __awaiter(this, void 0, void 0, function () {
            var network, currentNetwork, error;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._ready()];
                    case 1:
                        network = _a.sent();
                        return [4 /*yield*/, this.detectNetwork()];
                    case 2:
                        currentNetwork = _a.sent();
                        if (!(network.chainId !== currentNetwork.chainId)) return [3 /*break*/, 5];
                        if (!this.anyNetwork) return [3 /*break*/, 4];
                        this._network = currentNetwork;
                        // Reset all internal block number guards and caches
                        this._lastBlockNumber = -2;
                        this._fastBlockNumber = null;
                        this._fastBlockNumberPromise = null;
                        this._fastQueryDate = 0;
                        this._emitted.block = -2;
                        this._maxInternalBlockNumber = -1024;
                        this._internalBlockNumber = null;
                        // The "network" event MUST happen before this method resolves
                        // so any events have a chance to unregister, so we stall an
                        // additional event loop before returning from /this/ call
                        this.emit("network", currentNetwork, network);
                        return [4 /*yield*/, stall(0)];
                    case 3:
                        _a.sent();
                        return [2 /*return*/, this._network];
                    case 4:
                        error = logger.makeError("underlying network changed", logger_1.Logger.errors.NETWORK_ERROR, {
                            event: "changed",
                            network: network,
                            detectedNetwork: currentNetwork
                        });
                        this.emit("error", error);
                        throw error;
                    case 5: return [2 /*return*/, network];
                }
            });
        });
    };
    Object.defineProperty(BaseProvider.prototype, "blockNumber", {
        get: function () {
            var _this = this;
            this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(function (blockNumber) {
                _this._setFastBlockNumber(blockNumber);
            }, function (error) { });
            return (this._fastBlockNumber != null) ? this._fastBlockNumber : -1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseProvider.prototype, "polling", {
        get: function () {
            return (this._poller != null);
        },
        set: function (value) {
            var _this = this;
            if (value && !this._poller) {
                this._poller = setInterval(function () { _this.poll(); }, this.pollingInterval);
                if (!this._bootstrapPoll) {
                    this._bootstrapPoll = setTimeout(function () {
                        _this.poll();
                        // We block additional polls until the polling interval
                        // is done, to prevent overwhelming the poll function
                        _this._bootstrapPoll = setTimeout(function () {
                            // If polling was disabled, something may require a poke
                            // since starting the bootstrap poll and it was disabled
                            if (!_this._poller) {
                                _this.poll();
                            }
                            // Clear out the bootstrap so we can do another
                            _this._bootstrapPoll = null;
                        }, _this.pollingInterval);
                    }, 0);
                }
            }
            else if (!value && this._poller) {
                clearInterval(this._poller);
                this._poller = null;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseProvider.prototype, "pollingInterval", {
        get: function () {
            return this._pollingInterval;
        },
        set: function (value) {
            var _this = this;
            if (typeof (value) !== "number" || value <= 0 || parseInt(String(value)) != value) {
                throw new Error("invalid polling interval");
            }
            this._pollingInterval = value;
            if (this._poller) {
                clearInterval(this._poller);
                this._poller = setInterval(function () { _this.poll(); }, this._pollingInterval);
            }
        },
        enumerable: false,
        configurable: true
    });
    BaseProvider.prototype._getFastBlockNumber = function () {
        var _this = this;
        var now = getTime();
        // Stale block number, request a newer value
        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {
            this._fastQueryDate = now;
            this._fastBlockNumberPromise = this.getBlockNumber().then(function (blockNumber) {
                if (_this._fastBlockNumber == null || blockNumber > _this._fastBlockNumber) {
                    _this._fastBlockNumber = blockNumber;
                }
                return _this._fastBlockNumber;
            });
        }
        return this._fastBlockNumberPromise;
    };
    BaseProvider.prototype._setFastBlockNumber = function (blockNumber) {
        // Older block, maybe a stale request
        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
            return;
        }
        // Update the time we updated the blocknumber
        this._fastQueryDate = getTime();
        // Newer block number, use  it
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
            this._fastBlockNumber = blockNumber;
            this._fastBlockNumberPromise = Promise.resolve(blockNumber);
        }
    };
    BaseProvider.prototype.waitForTransaction = function (transactionHash, confirmations, timeout) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this._waitForTransaction(transactionHash, (confirmations == null) ? 1 : confirmations, timeout || 0, null)];
            });
        });
    };
    BaseProvider.prototype._waitForTransaction = function (transactionHash, confirmations, timeout, replaceable) {
        return __awaiter(this, void 0, void 0, function () {
            var receipt;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getTransactionReceipt(transactionHash)];
                    case 1:
                        receipt = _a.sent();
                        // Receipt is already good
                        if ((receipt ? receipt.confirmations : 0) >= confirmations) {
                            return [2 /*return*/, receipt];
                        }
                        // Poll until the receipt is good...
                        return [2 /*return*/, new Promise(function (resolve, reject) {
                                var cancelFuncs = [];
                                var done = false;
                                var alreadyDone = function () {
                                    if (done) {
                                        return true;
                                    }
                                    done = true;
                                    cancelFuncs.forEach(function (func) { func(); });
                                    return false;
                                };
                                var minedHandler = function (receipt) {
                                    if (receipt.confirmations < confirmations) {
                                        return;
                                    }
                                    if (alreadyDone()) {
                                        return;
                                    }
                                    resolve(receipt);
                                };
                                _this.on(transactionHash, minedHandler);
                                cancelFuncs.push(function () { _this.removeListener(transactionHash, minedHandler); });
                                if (replaceable) {
                                    var lastBlockNumber_1 = replaceable.startBlock;
                                    var scannedBlock_1 = null;
                                    var replaceHandler_1 = function (blockNumber) { return __awaiter(_this, void 0, void 0, function () {
                                        var _this = this;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    if (done) {
                                                        return [2 /*return*/];
                                                    }
                                                    // Wait 1 second; this is only used in the case of a fault, so
                                                    // we will trade off a little bit of latency for more consistent
                                                    // results and fewer JSON-RPC calls
                                                    return [4 /*yield*/, stall(1000)];
                                                case 1:
                                                    // Wait 1 second; this is only used in the case of a fault, so
                                                    // we will trade off a little bit of latency for more consistent
                                                    // results and fewer JSON-RPC calls
                                                    _a.sent();
                                                    this.getTransactionCount(replaceable.from).then(function (nonce) { return __awaiter(_this, void 0, void 0, function () {
                                                        var mined, block, ti, tx, receipt_1, reason;
                                                        return __generator(this, function (_a) {
                                                            switch (_a.label) {
                                                                case 0:
                                                                    if (done) {
                                                                        return [2 /*return*/];
                                                                    }
                                                                    if (!(nonce <= replaceable.nonce)) return [3 /*break*/, 1];
                                                                    lastBlockNumber_1 = blockNumber;
                                                                    return [3 /*break*/, 9];
                                                                case 1: return [4 /*yield*/, this.getTransaction(transactionHash)];
                                                                case 2:
                                                                    mined = _a.sent();
                                                                    if (mined && mined.blockNumber != null) {
                                                                        return [2 /*return*/];
                                                                    }
                                                                    // First time scanning. We start a little earlier for some
                                                                    // wiggle room here to handle the eventually consistent nature
                                                                    // of blockchain (e.g. the getTransactionCount was for a
                                                                    // different block)
                                                                    if (scannedBlock_1 == null) {
                                                                        scannedBlock_1 = lastBlockNumber_1 - 3;
                                                                        if (scannedBlock_1 < replaceable.startBlock) {
                                                                            scannedBlock_1 = replaceable.startBlock;
                                                                        }
                                                                    }
                                                                    _a.label = 3;
                                                                case 3:
                                                                    if (!(scannedBlock_1 <= blockNumber)) return [3 /*break*/, 9];
                                                                    if (done) {
                                                                        return [2 /*return*/];
                                                                    }
                                                                    return [4 /*yield*/, this.getBlockWithTransactions(scannedBlock_1)];
                                                                case 4:
                                                                    block = _a.sent();
                                                                    ti = 0;
                                                                    _a.label = 5;
                                                                case 5:
                                                                    if (!(ti < block.transactions.length)) return [3 /*break*/, 8];
                                                                    tx = block.transactions[ti];
                                                                    // Successfully mined!
                                                                    if (tx.hash === transactionHash) {
                                                                        return [2 /*return*/];
                                                                    }
                                                                    if (!(tx.from === replaceable.from && tx.nonce === replaceable.nonce)) return [3 /*break*/, 7];
                                                                    if (done) {
                                                                        return [2 /*return*/];
                                                                    }
                                                                    return [4 /*yield*/, this.waitForTransaction(tx.hash, confirmations)];
                                                                case 6:
                                                                    receipt_1 = _a.sent();
                                                                    // Already resolved or rejected (prolly a timeout)
                                                                    if (alreadyDone()) {
                                                                        return [2 /*return*/];
                                                                    }
                                                                    reason = "replaced";
                                                                    if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                                                                        reason = "repriced";
                                                                    }
                                                                    else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                                                                        reason = "cancelled";
                                                                    }
                                                                    // Explain why we were replaced
                                                                    reject(logger.makeError("transaction was replaced", logger_1.Logger.errors.TRANSACTION_REPLACED, {
                                                                        cancelled: (reason === "replaced" || reason === "cancelled"),
                                                                        reason: reason,
                                                                        replacement: this._wrapTransaction(tx),
                                                                        hash: transactionHash,
                                                                        receipt: receipt_1
                                                                    }));
                                                                    return [2 /*return*/];
                                                                case 7:
                                                                    ti++;
                                                                    return [3 /*break*/, 5];
                                                                case 8:
                                                                    scannedBlock_1++;
                                                                    return [3 /*break*/, 3];
                                                                case 9:
                                                                    if (done) {
                                                                        return [2 /*return*/];
                                                                    }
                                                                    this.once("block", replaceHandler_1);
                                                                    return [2 /*return*/];
                                                            }
                                                        });
                                                    }); }, function (error) {
                                                        if (done) {
                                                            return;
                                                        }
                                                        _this.once("block", replaceHandler_1);
                                                    });
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); };
                                    if (done) {
                                        return;
                                    }
                                    _this.once("block", replaceHandler_1);
                                    cancelFuncs.push(function () {
                                        _this.removeListener("block", replaceHandler_1);
                                    });
                                }
                                if (typeof (timeout) === "number" && timeout > 0) {
                                    var timer_1 = setTimeout(function () {
                                        if (alreadyDone()) {
                                            return;
                                        }
                                        reject(logger.makeError("timeout exceeded", logger_1.Logger.errors.TIMEOUT, { timeout: timeout }));
                                    }, timeout);
                                    if (timer_1.unref) {
                                        timer_1.unref();
                                    }
                                    cancelFuncs.push(function () { clearTimeout(timer_1); });
                                }
                            })];
                }
            });
        });
    };
    BaseProvider.prototype.getBlockNumber = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this._getInternalBlockNumber(0)];
            });
        });
    };
    BaseProvider.prototype.getGasPrice = function () {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getNetwork()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.perform("getGasPrice", {})];
                    case 2:
                        result = _a.sent();
                        try {
                            return [2 /*return*/, bignumber_1.BigNumber.from(result)];
                        }
                        catch (error) {
                            return [2 /*return*/, logger.throwError("bad result from backend", logger_1.Logger.errors.SERVER_ERROR, {
                                    method: "getGasPrice",
                                    result: result,
                                    error: error
                                })];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    BaseProvider.prototype.getBalance = function (addressOrName, blockTag) {
        return __awaiter(this, void 0, void 0, function () {
            var params, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getNetwork()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, (0, properties_1.resolveProperties)({
                                address: this._getAddress(addressOrName),
                                blockTag: this._getBlockTag(blockTag)
                            })];
                    case 2:
                        params = _a.sent();
                        return [4 /*yield*/, this.perform("getBalance", params)];
                    case 3:
                        result = _a.sent();
                        try {
                            return [2 /*return*/, bignumber_1.BigNumber.from(result)];
                        }
                        catch (error) {
                            return [2 /*return*/, logger.throwError("bad result from backend", logger_1.Logger.errors.SERVER_ERROR, {
                                    method: "getBalance",
                                    params: params,
                                    result: result,
                                    error: error
                                })];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    BaseProvider.prototype.getTransactionCount = function (addressOrName, blockTag) {
        return __awaiter(this, void 0, void 0, function () {
            var params, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getNetwork()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, (0, properties_1.resolveProperties)({
                                address: this._getAddress(addressOrName),
                                blockTag: this._getBlockTag(blockTag)
                            })];
                    case 2:
                        params = _a.sent();
                        return [4 /*yield*/, this.perform("getTransactionCount", params)];
                    case 3:
                        result = _a.sent();
                        try {
                            return [2 /*return*/, bignumber_1.BigNumber.from(result).toNumber()];
                        }
                        catch (error) {
                            return [2 /*return*/, logger.throwError("bad result from backend", logger_1.Logger.errors.SERVER_ERROR, {
                                    method: "getTransactionCount",
                                    params: params,
                                    result: result,
                                    error: error
                                })];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    BaseProvider.prototype.getCode = function (addressOrName, blockTag) {
        return __awaiter(this, void 0, void 0, function () {
            var params, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getNetwork()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, (0, properties_1.resolveProperties)({
                                address: this._getAddress(addressOrName),
                                blockTag: this._getBlockTag(blockTag)
                            })];
                    case 2:
                        params = _a.sent();
                        return [4 /*yield*/, this.perform("getCode", params)];
                    case 3:
                        result = _a.sent();
                        try {
                            return [2 /*return*/, (0, bytes_1.hexlify)(result)];
                        }
                        catch (error) {
                            return [2 /*return*/, logger.throwError("bad result from backend", logger_1.Logger.errors.SERVER_ERROR, {
                                    method: "getCode",
                                    params: params,
                                    result: result,
                                    error: error
                                })];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    BaseProvider.prototype.getStorageAt = function (addressOrName, position, blockTag) {
        return __awaiter(this, void 0, void 0, function () {
            var params, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getNetwork()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, (0, properties_1.resolveProperties)({
                                address: this._getAddress(addressOrName),
                                blockTag: this._getBlockTag(blockTag),
                                position: Promise.resolve(position).then(function (p) { return (0, bytes_1.hexValue)(p); })
                            })];
                    case 2:
                        params = _a.sent();
                        return [4 /*yield*/, this.perform("getStorageAt", params)];
                    case 3:
                        result = _a.sent();
                        try {
                            return [2 /*return*/, (0, bytes_1.hexlify)(result)];
                        }
                        catch (error) {
                            return [2 /*return*/, logger.throwError("bad result from backend", logger_1.Logger.errors.SERVER_ERROR, {
                                    method: "getStorageAt",
                                    params: params,
                                    result: result,
                                    error: error
                                })];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    // This should be called by any subclass wrapping a TransactionResponse
    BaseProvider.prototype._wrapTransaction = function (tx, hash, startBlock) {
        var _this = this;
        if (hash != null && (0, bytes_1.hexDataLength)(hash) !== 32) {
            throw new Error("invalid response - sendTransaction");
        }
        var result = tx;
        // Check the hash we expect is the same as the hash the server reported
        if (hash != null && tx.hash !== hash) {
            logger.throwError("Transaction hash mismatch from Provider.sendTransaction.", logger_1.Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });
        }
        result.wait = function (confirms, timeout) { return __awaiter(_this, void 0, void 0, function () {
            var replacement, receipt;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (confirms == null) {
                            confirms = 1;
                        }
                        if (timeout == null) {
                            timeout = 0;
                        }
                        replacement = undefined;
                        if (confirms !== 0 && startBlock != null) {
                            replacement = {
                                data: tx.data,
                                from: tx.from,
                                nonce: tx.nonce,
                                to: tx.to,
                                value: tx.value,
                                startBlock: startBlock
                            };
                        }
                        return [4 /*yield*/, this._waitForTransaction(tx.hash, confirms, timeout, replacement)];
                    case 1:
                        receipt = _a.sent();
                        if (receipt == null && confirms === 0) {
                            return [2 /*return*/, null];
                        }
                        // No longer pending, allow the polling loop to garbage collect this
                        this._emitted["t:" + tx.hash] = receipt.blockNumber;
                        if (receipt.status === 0) {
                            logger.throwError("transaction failed", logger_1.Logger.errors.CALL_EXCEPTION, {
                                transactionHash: tx.hash,
                                transaction: tx,
                                receipt: receipt
                            });
                        }
                        return [2 /*return*/, receipt];
                }
            });
        }); };
        return result;
    };
    BaseProvider.prototype.sendTransaction = function (signedTransaction) {
        return __awaiter(this, void 0, void 0, function () {
            var hexTx, tx, blockNumber, hash, error_7;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getNetwork()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, Promise.resolve(signedTransaction).then(function (t) { return (0, bytes_1.hexlify)(t); })];
                    case 2:
                        hexTx = _a.sent();
                        tx = this.formatter.transaction(signedTransaction);
                        if (tx.confirmations == null) {
                            tx.confirmations = 0;
                        }
                        return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];
                    case 3:
                        blockNumber = _a.sent();
                        _a.label = 4;
                    case 4:
                        _a.trys.push([4, 6, , 7]);
                        return [4 /*yield*/, this.perform("sendTransaction", { signedTransaction: hexTx })];
                    case 5:
                        hash = _a.sent();
                        return [2 /*return*/, this._wrapTransaction(tx, hash, blockNumber)];
                    case 6:
                        error_7 = _a.sent();
                        error_7.transaction = tx;
                        error_7.transactionHash = tx.hash;
                        throw error_7;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    BaseProvider.prototype._getTransactionRequest = function (transaction) {
        return __awaiter(this, void 0, void 0, function () {
            var values, tx, _a, _b;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, transaction];
                    case 1:
                        values = _c.sent();
                        tx = {};
                        ["from", "to"].forEach(function (key) {
                            if (values[key] == null) {
                                return;
                            }
                            tx[key] = Promise.resolve(values[key]).then(function (v) { return (v ? _this._getAddress(v) : null); });
                        });
                        ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach(function (key) {
                            if (values[key] == null) {
                                return;
                            }
                            tx[key] = Promise.resolve(values[key]).then(function (v) { return (v ? bignumber_1.BigNumber.from(v) : null); });
                        });
                        ["type"].forEach(function (key) {
                            if (values[key] == null) {
                                return;
                            }
                            tx[key] = Promise.resolve(values[key]).then(function (v) { return ((v != null) ? v : null); });
                        });
                        if (values.accessList) {
                            tx.accessList = this.formatter.accessList(values.accessList);
                        }
                        ["data"].forEach(function (key) {
                            if (values[key] == null) {
                                return;
                            }
                            tx[key] = Promise.resolve(values[key]).then(function (v) { return (v ? (0, bytes_1.hexlify)(v) : null); });
                        });
                        _b = (_a = this.formatter).transactionRequest;
                        return [4 /*yield*/, (0, properties_1.resolveProperties)(tx)];
                    case 2: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    BaseProvider.prototype._getFilter = function (filter) {
        return __awaiter(this, void 0, void 0, function () {
            var result, _a, _b;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, filter];
                    case 1:
                        filter = _c.sent();
                        result = {};
                        if (filter.address != null) {
                            result.address = this._getAddress(filter.address);
                        }
                        ["blockHash", "topics"].forEach(function (key) {
                            if (filter[key] == null) {
                                return;
                            }
                            result[key] = filter[key];
                        });
                        ["fromBlock", "toBlock"].forEach(function (key) {
                            if (filter[key] == null) {
                                return;
                            }
                            result[key] = _this._getBlockTag(filter[key]);
                        });
                        _b = (_a = this.formatter).filter;
                        return [4 /*yield*/, (0, properties_1.resolveProperties)(result)];
                    case 2: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    BaseProvider.prototype._call = function (transaction, blockTag, attempt) {
        return __awaiter(this, void 0, void 0, function () {
            var txSender, result, data, sender, urls, urlsOffset, urlsLength, urlsData, u, url, calldata, callbackSelector, extraData, ccipResult, tx, error_8;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (attempt >= MAX_CCIP_REDIRECTS) {
                            logger.throwError("CCIP read exceeded maximum redirections", logger_1.Logger.errors.SERVER_ERROR, {
                                redirects: attempt,
                                transaction: transaction
                            });
                        }
                        txSender = transaction.to;
                        return [4 /*yield*/, this.perform("call", { transaction: transaction, blockTag: blockTag })];
                    case 1:
                        result = _a.sent();
                        if (!(attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && ((0, bytes_1.hexDataLength)(result) % 32 === 4))) return [3 /*break*/, 5];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        data = (0, bytes_1.hexDataSlice)(result, 4);
                        sender = (0, bytes_1.hexDataSlice)(data, 0, 32);
                        if (!bignumber_1.BigNumber.from(sender).eq(txSender)) {
                            logger.throwError("CCIP Read sender did not match", logger_1.Logger.errors.CALL_EXCEPTION, {
                                name: "OffchainLookup",
                                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                                transaction: transaction,
                                data: result
                            });
                        }
                        urls = [];
                        urlsOffset = bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(data, 32, 64)).toNumber();
                        urlsLength = bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(data, urlsOffset, urlsOffset + 32)).toNumber();
                        urlsData = (0, bytes_1.hexDataSlice)(data, urlsOffset + 32);
                        for (u = 0; u < urlsLength; u++) {
                            url = _parseString(urlsData, u * 32);
                            if (url == null) {
                                logger.throwError("CCIP Read contained corrupt URL string", logger_1.Logger.errors.CALL_EXCEPTION, {
                                    name: "OffchainLookup",
                                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                                    transaction: transaction,
                                    data: result
                                });
                            }
                            urls.push(url);
                        }
                        calldata = _parseBytes(data, 64);
                        // Get the callbackSelector (bytes4)
                        if (!bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(data, 100, 128)).isZero()) {
                            logger.throwError("CCIP Read callback selector included junk", logger_1.Logger.errors.CALL_EXCEPTION, {
                                name: "OffchainLookup",
                                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                                transaction: transaction,
                                data: result
                            });
                        }
                        callbackSelector = (0, bytes_1.hexDataSlice)(data, 96, 100);
                        extraData = _parseBytes(data, 128);
                        return [4 /*yield*/, this.ccipReadFetch(transaction, calldata, urls)];
                    case 3:
                        ccipResult = _a.sent();
                        if (ccipResult == null) {
                            logger.throwError("CCIP Read disabled or provided no URLs", logger_1.Logger.errors.CALL_EXCEPTION, {
                                name: "OffchainLookup",
                                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                                transaction: transaction,
                                data: result
                            });
                        }
                        tx = {
                            to: txSender,
                            data: (0, bytes_1.hexConcat)([callbackSelector, encodeBytes([ccipResult, extraData])])
                        };
                        return [2 /*return*/, this._call(tx, blockTag, attempt + 1)];
                    case 4:
                        error_8 = _a.sent();
                        if (error_8.code === logger_1.Logger.errors.SERVER_ERROR) {
                            throw error_8;
                        }
                        return [3 /*break*/, 5];
                    case 5:
                        try {
                            return [2 /*return*/, (0, bytes_1.hexlify)(result)];
                        }
                        catch (error) {
                            return [2 /*return*/, logger.throwError("bad result from backend", logger_1.Logger.errors.SERVER_ERROR, {
                                    method: "call",
                                    params: { transaction: transaction, blockTag: blockTag },
                                    result: result,
                                    error: error
                                })];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    BaseProvider.prototype.call = function (transaction, blockTag) {
        return __awaiter(this, void 0, void 0, function () {
            var resolved;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getNetwork()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, (0, properties_1.resolveProperties)({
                                transaction: this._getTransactionRequest(transaction),
                                blockTag: this._getBlockTag(blockTag),
                                ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
                            })];
                    case 2:
                        resolved = _a.sent();
                        return [2 /*return*/, this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1)];
                }
            });
        });
    };
    BaseProvider.prototype.estimateGas = function (transaction) {
        return __awaiter(this, void 0, void 0, function () {
            var params, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getNetwork()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, (0, properties_1.resolveProperties)({
                                transaction: this._getTransactionRequest(transaction)
                            })];
                    case 2:
                        params = _a.sent();
                        return [4 /*yield*/, this.perform("estimateGas", params)];
                    case 3:
                        result = _a.sent();
                        try {
                            return [2 /*return*/, bignumber_1.BigNumber.from(result)];
                        }
                        catch (error) {
                            return [2 /*return*/, logger.throwError("bad result from backend", logger_1.Logger.errors.SERVER_ERROR, {
                                    method: "estimateGas",
                                    params: params,
                                    result: result,
                                    error: error
                                })];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    BaseProvider.prototype._getAddress = function (addressOrName) {
        return __awaiter(this, void 0, void 0, function () {
            var address;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, addressOrName];
                    case 1:
                        addressOrName = _a.sent();
                        if (typeof (addressOrName) !== "string") {
                            logger.throwArgumentError("invalid address or ENS name", "name", addressOrName);
                        }
                        return [4 /*yield*/, this.resolveName(addressOrName)];
                    case 2:
                        address = _a.sent();
                        if (address == null) {
                            logger.throwError("ENS name not configured", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                                operation: "resolveName(" + JSON.stringify(addressOrName) + ")"
                            });
                        }
                        return [2 /*return*/, address];
                }
            });
        });
    };
    BaseProvider.prototype._getBlock = function (blockHashOrBlockTag, includeTransactions) {
        return __awaiter(this, void 0, void 0, function () {
            var blockNumber, params, _a, error_9;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getNetwork()];
                    case 1:
                        _b.sent();
                        return [4 /*yield*/, blockHashOrBlockTag];
                    case 2:
                        blockHashOrBlockTag = _b.sent();
                        blockNumber = -128;
                        params = {
                            includeTransactions: !!includeTransactions
                        };
                        if (!(0, bytes_1.isHexString)(blockHashOrBlockTag, 32)) return [3 /*break*/, 3];
                        params.blockHash = blockHashOrBlockTag;
                        return [3 /*break*/, 6];
                    case 3:
                        _b.trys.push([3, 5, , 6]);
                        _a = params;
                        return [4 /*yield*/, this._getBlockTag(blockHashOrBlockTag)];
                    case 4:
                        _a.blockTag = _b.sent();
                        if ((0, bytes_1.isHexString)(params.blockTag)) {
                            blockNumber = parseInt(params.blockTag.substring(2), 16);
                        }
                        return [3 /*break*/, 6];
                    case 5:
                        error_9 = _b.sent();
                        logger.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
                        return [3 /*break*/, 6];
                    case 6: return [2 /*return*/, (0, web_1.poll)(function () { return __awaiter(_this, void 0, void 0, function () {
                            var block, blockNumber_1, i, tx, confirmations, blockWithTxs;
                            var _this = this;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this.perform("getBlock", params)];
                                    case 1:
                                        block = _a.sent();
                                        // Block was not found
                                        if (block == null) {
                                            // For blockhashes, if we didn't say it existed, that blockhash may
                                            // not exist. If we did see it though, perhaps from a log, we know
                                            // it exists, and this node is just not caught up yet.
                                            if (params.blockHash != null) {
                                                if (this._emitted["b:" + params.blockHash] == null) {
                                                    return [2 /*return*/, null];
                                                }
                                            }
                                            // For block tags, if we are asking for a future block, we return null
                                            if (params.blockTag != null) {
                                                if (blockNumber > this._emitted.block) {
                                                    return [2 /*return*/, null];
                                                }
                                            }
                                            // Retry on the next block
                                            return [2 /*return*/, undefined];
                                        }
                                        if (!includeTransactions) return [3 /*break*/, 8];
                                        blockNumber_1 = null;
                                        i = 0;
                                        _a.label = 2;
                                    case 2:
                                        if (!(i < block.transactions.length)) return [3 /*break*/, 7];
                                        tx = block.transactions[i];
                                        if (!(tx.blockNumber == null)) return [3 /*break*/, 3];
                                        tx.confirmations = 0;
                                        return [3 /*break*/, 6];
                                    case 3:
                                        if (!(tx.confirmations == null)) return [3 /*break*/, 6];
                                        if (!(blockNumber_1 == null)) return [3 /*break*/, 5];
                                        return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];
                                    case 4:
                                        blockNumber_1 = _a.sent();
                                        _a.label = 5;
                                    case 5:
                                        confirmations = (blockNumber_1 - tx.blockNumber) + 1;
                                        if (confirmations <= 0) {
                                            confirmations = 1;
                                        }
                                        tx.confirmations = confirmations;
                                        _a.label = 6;
                                    case 6:
                                        i++;
                                        return [3 /*break*/, 2];
                                    case 7:
                                        blockWithTxs = this.formatter.blockWithTransactions(block);
                                        blockWithTxs.transactions = blockWithTxs.transactions.map(function (tx) { return _this._wrapTransaction(tx); });
                                        return [2 /*return*/, blockWithTxs];
                                    case 8: return [2 /*return*/, this.formatter.block(block)];
                                }
                            });
                        }); }, { oncePoll: this })];
                }
            });
        });
    };
    BaseProvider.prototype.getBlock = function (blockHashOrBlockTag) {
        return (this._getBlock(blockHashOrBlockTag, false));
    };
    BaseProvider.prototype.getBlockWithTransactions = function (blockHashOrBlockTag) {
        return (this._getBlock(blockHashOrBlockTag, true));
    };
    BaseProvider.prototype.getTransaction = function (transactionHash) {
        return __awaiter(this, void 0, void 0, function () {
            var params;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getNetwork()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, transactionHash];
                    case 2:
                        transactionHash = _a.sent();
                        params = { transactionHash: this.formatter.hash(transactionHash, true) };
                        return [2 /*return*/, (0, web_1.poll)(function () { return __awaiter(_this, void 0, void 0, function () {
                                var result, tx, blockNumber, confirmations;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.perform("getTransaction", params)];
                                        case 1:
                                            result = _a.sent();
                                            if (result == null) {
                                                if (this._emitted["t:" + transactionHash] == null) {
                                                    return [2 /*return*/, null];
                                                }
                                                return [2 /*return*/, undefined];
                                            }
                                            tx = this.formatter.transactionResponse(result);
                                            if (!(tx.blockNumber == null)) return [3 /*break*/, 2];
                                            tx.confirmations = 0;
                                            return [3 /*break*/, 4];
                                        case 2:
                                            if (!(tx.confirmations == null)) return [3 /*break*/, 4];
                                            return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];
                                        case 3:
                                            blockNumber = _a.sent();
                                            confirmations = (blockNumber - tx.blockNumber) + 1;
                                            if (confirmations <= 0) {
                                                confirmations = 1;
                                            }
                                            tx.confirmations = confirmations;
                                            _a.label = 4;
                                        case 4: return [2 /*return*/, this._wrapTransaction(tx)];
                                    }
                                });
                            }); }, { oncePoll: this })];
                }
            });
        });
    };
    BaseProvider.prototype.getTransactionReceipt = function (transactionHash) {
        return __awaiter(this, void 0, void 0, function () {
            var params;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getNetwork()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, transactionHash];
                    case 2:
                        transactionHash = _a.sent();
                        params = { transactionHash: this.formatter.hash(transactionHash, true) };
                        return [2 /*return*/, (0, web_1.poll)(function () { return __awaiter(_this, void 0, void 0, function () {
                                var result, receipt, blockNumber, confirmations;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.perform("getTransactionReceipt", params)];
                                        case 1:
                                            result = _a.sent();
                                            if (result == null) {
                                                if (this._emitted["t:" + transactionHash] == null) {
                                                    return [2 /*return*/, null];
                                                }
                                                return [2 /*return*/, undefined];
                                            }
                                            // "geth-etc" returns receipts before they are ready
                                            if (result.blockHash == null) {
                                                return [2 /*return*/, undefined];
                                            }
                                            receipt = this.formatter.receipt(result);
                                            if (!(receipt.blockNumber == null)) return [3 /*break*/, 2];
                                            receipt.confirmations = 0;
                                            return [3 /*break*/, 4];
                                        case 2:
                                            if (!(receipt.confirmations == null)) return [3 /*break*/, 4];
                                            return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];
                                        case 3:
                                            blockNumber = _a.sent();
                                            confirmations = (blockNumber - receipt.blockNumber) + 1;
                                            if (confirmations <= 0) {
                                                confirmations = 1;
                                            }
                                            receipt.confirmations = confirmations;
                                            _a.label = 4;
                                        case 4: return [2 /*return*/, receipt];
                                    }
                                });
                            }); }, { oncePoll: this })];
                }
            });
        });
    };
    BaseProvider.prototype.getLogs = function (filter) {
        return __awaiter(this, void 0, void 0, function () {
            var params, logs;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getNetwork()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, (0, properties_1.resolveProperties)({ filter: this._getFilter(filter) })];
                    case 2:
                        params = _a.sent();
                        return [4 /*yield*/, this.perform("getLogs", params)];
                    case 3:
                        logs = _a.sent();
                        logs.forEach(function (log) {
                            if (log.removed == null) {
                                log.removed = false;
                            }
                        });
                        return [2 /*return*/, formatter_1.Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs)];
                }
            });
        });
    };
    BaseProvider.prototype.getEtherPrice = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getNetwork()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this.perform("getEtherPrice", {})];
                }
            });
        });
    };
    BaseProvider.prototype._getBlockTag = function (blockTag) {
        return __awaiter(this, void 0, void 0, function () {
            var blockNumber;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, blockTag];
                    case 1:
                        blockTag = _a.sent();
                        if (!(typeof (blockTag) === "number" && blockTag < 0)) return [3 /*break*/, 3];
                        if (blockTag % 1) {
                            logger.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
                        }
                        return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];
                    case 2:
                        blockNumber = _a.sent();
                        blockNumber += blockTag;
                        if (blockNumber < 0) {
                            blockNumber = 0;
                        }
                        return [2 /*return*/, this.formatter.blockTag(blockNumber)];
                    case 3: return [2 /*return*/, this.formatter.blockTag(blockTag)];
                }
            });
        });
    };
    BaseProvider.prototype.getResolver = function (name) {
        return __awaiter(this, void 0, void 0, function () {
            var currentName, addr, resolver, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        currentName = name;
                        _b.label = 1;
                    case 1:
                        if (false) {}
                        if (currentName === "" || currentName === ".") {
                            return [2 /*return*/, null];
                        }
                        // Optimization since the eth node cannot change and does
                        // not have a wildcard resolver
                        if (name !== "eth" && currentName === "eth") {
                            return [2 /*return*/, null];
                        }
                        return [4 /*yield*/, this._getResolver(currentName, "getResolver")];
                    case 2:
                        addr = _b.sent();
                        if (!(addr != null)) return [3 /*break*/, 5];
                        resolver = new Resolver(this, addr, name);
                        _a = currentName !== name;
                        if (!_a) return [3 /*break*/, 4];
                        return [4 /*yield*/, resolver.supportsWildcard()];
                    case 3:
                        _a = !(_b.sent());
                        _b.label = 4;
                    case 4:
                        // Legacy resolver found, using EIP-2544 so it isn't safe to use
                        if (_a) {
                            return [2 /*return*/, null];
                        }
                        return [2 /*return*/, resolver];
                    case 5:
                        // Get the parent node
                        currentName = currentName.split(".").slice(1).join(".");
                        return [3 /*break*/, 1];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    BaseProvider.prototype._getResolver = function (name, operation) {
        return __awaiter(this, void 0, void 0, function () {
            var network, addrData, error_10;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (operation == null) {
                            operation = "ENS";
                        }
                        return [4 /*yield*/, this.getNetwork()];
                    case 1:
                        network = _a.sent();
                        // No ENS...
                        if (!network.ensAddress) {
                            logger.throwError("network does not support ENS", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { operation: operation, network: network.name });
                        }
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, this.call({
                                to: network.ensAddress,
                                data: ("0x0178b8bf" + (0, hash_1.namehash)(name).substring(2))
                            })];
                    case 3:
                        addrData = _a.sent();
                        return [2 /*return*/, this.formatter.callAddress(addrData)];
                    case 4:
                        error_10 = _a.sent();
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/, null];
                }
            });
        });
    };
    BaseProvider.prototype.resolveName = function (name) {
        return __awaiter(this, void 0, void 0, function () {
            var resolver;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, name];
                    case 1:
                        name = _a.sent();
                        // If it is already an address, nothing to resolve
                        try {
                            return [2 /*return*/, Promise.resolve(this.formatter.address(name))];
                        }
                        catch (error) {
                            // If is is a hexstring, the address is bad (See #694)
                            if ((0, bytes_1.isHexString)(name)) {
                                throw error;
                            }
                        }
                        if (typeof (name) !== "string") {
                            logger.throwArgumentError("invalid ENS name", "name", name);
                        }
                        return [4 /*yield*/, this.getResolver(name)];
                    case 2:
                        resolver = _a.sent();
                        if (!resolver) {
                            return [2 /*return*/, null];
                        }
                        return [4 /*yield*/, resolver.getAddress()];
                    case 3: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    BaseProvider.prototype.lookupAddress = function (address) {
        return __awaiter(this, void 0, void 0, function () {
            var node, resolverAddr, name, _a, addr;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, address];
                    case 1:
                        address = _b.sent();
                        address = this.formatter.address(address);
                        node = address.substring(2).toLowerCase() + ".addr.reverse";
                        return [4 /*yield*/, this._getResolver(node, "lookupAddress")];
                    case 2:
                        resolverAddr = _b.sent();
                        if (resolverAddr == null) {
                            return [2 /*return*/, null];
                        }
                        _a = _parseString;
                        return [4 /*yield*/, this.call({
                                to: resolverAddr,
                                data: ("0x691f3431" + (0, hash_1.namehash)(node).substring(2))
                            })];
                    case 3:
                        name = _a.apply(void 0, [_b.sent(), 0]);
                        return [4 /*yield*/, this.resolveName(name)];
                    case 4:
                        addr = _b.sent();
                        if (addr != address) {
                            return [2 /*return*/, null];
                        }
                        return [2 /*return*/, name];
                }
            });
        });
    };
    BaseProvider.prototype.getAvatar = function (nameOrAddress) {
        return __awaiter(this, void 0, void 0, function () {
            var resolver, address, node, resolverAddress, avatar_1, error_11, name_1, _a, error_12, avatar;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        resolver = null;
                        if (!(0, bytes_1.isHexString)(nameOrAddress)) return [3 /*break*/, 10];
                        address = this.formatter.address(nameOrAddress);
                        node = address.substring(2).toLowerCase() + ".addr.reverse";
                        return [4 /*yield*/, this._getResolver(node, "getAvatar")];
                    case 1:
                        resolverAddress = _b.sent();
                        if (!resolverAddress) {
                            return [2 /*return*/, null];
                        }
                        // Try resolving the avatar against the addr.reverse resolver
                        resolver = new Resolver(this, resolverAddress, node);
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, resolver.getAvatar()];
                    case 3:
                        avatar_1 = _b.sent();
                        if (avatar_1) {
                            return [2 /*return*/, avatar_1.url];
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        error_11 = _b.sent();
                        if (error_11.code !== logger_1.Logger.errors.CALL_EXCEPTION) {
                            throw error_11;
                        }
                        return [3 /*break*/, 5];
                    case 5:
                        _b.trys.push([5, 8, , 9]);
                        _a = _parseString;
                        return [4 /*yield*/, this.call({
                                to: resolverAddress,
                                data: ("0x691f3431" + (0, hash_1.namehash)(node).substring(2))
                            })];
                    case 6:
                        name_1 = _a.apply(void 0, [_b.sent(), 0]);
                        return [4 /*yield*/, this.getResolver(name_1)];
                    case 7:
                        resolver = _b.sent();
                        return [3 /*break*/, 9];
                    case 8:
                        error_12 = _b.sent();
                        if (error_12.code !== logger_1.Logger.errors.CALL_EXCEPTION) {
                            throw error_12;
                        }
                        return [2 /*return*/, null];
                    case 9: return [3 /*break*/, 12];
                    case 10: return [4 /*yield*/, this.getResolver(nameOrAddress)];
                    case 11:
                        // ENS name; forward lookup with wildcard
                        resolver = _b.sent();
                        if (!resolver) {
                            return [2 /*return*/, null];
                        }
                        _b.label = 12;
                    case 12: return [4 /*yield*/, resolver.getAvatar()];
                    case 13:
                        avatar = _b.sent();
                        if (avatar == null) {
                            return [2 /*return*/, null];
                        }
                        return [2 /*return*/, avatar.url];
                }
            });
        });
    };
    BaseProvider.prototype.perform = function (method, params) {
        return logger.throwError(method + " not implemented", logger_1.Logger.errors.NOT_IMPLEMENTED, { operation: method });
    };
    BaseProvider.prototype._startEvent = function (event) {
        this.polling = (this._events.filter(function (e) { return e.pollable(); }).length > 0);
    };
    BaseProvider.prototype._stopEvent = function (event) {
        this.polling = (this._events.filter(function (e) { return e.pollable(); }).length > 0);
    };
    BaseProvider.prototype._addEventListener = function (eventName, listener, once) {
        var event = new Event(getEventTag(eventName), listener, once);
        this._events.push(event);
        this._startEvent(event);
        return this;
    };
    BaseProvider.prototype.on = function (eventName, listener) {
        return this._addEventListener(eventName, listener, false);
    };
    BaseProvider.prototype.once = function (eventName, listener) {
        return this._addEventListener(eventName, listener, true);
    };
    BaseProvider.prototype.emit = function (eventName) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var result = false;
        var stopped = [];
        var eventTag = getEventTag(eventName);
        this._events = this._events.filter(function (event) {
            if (event.tag !== eventTag) {
                return true;
            }
            setTimeout(function () {
                event.listener.apply(_this, args);
            }, 0);
            result = true;
            if (event.once) {
                stopped.push(event);
                return false;
            }
            return true;
        });
        stopped.forEach(function (event) { _this._stopEvent(event); });
        return result;
    };
    BaseProvider.prototype.listenerCount = function (eventName) {
        if (!eventName) {
            return this._events.length;
        }
        var eventTag = getEventTag(eventName);
        return this._events.filter(function (event) {
            return (event.tag === eventTag);
        }).length;
    };
    BaseProvider.prototype.listeners = function (eventName) {
        if (eventName == null) {
            return this._events.map(function (event) { return event.listener; });
        }
        var eventTag = getEventTag(eventName);
        return this._events
            .filter(function (event) { return (event.tag === eventTag); })
            .map(function (event) { return event.listener; });
    };
    BaseProvider.prototype.off = function (eventName, listener) {
        var _this = this;
        if (listener == null) {
            return this.removeAllListeners(eventName);
        }
        var stopped = [];
        var found = false;
        var eventTag = getEventTag(eventName);
        this._events = this._events.filter(function (event) {
            if (event.tag !== eventTag || event.listener != listener) {
                return true;
            }
            if (found) {
                return true;
            }
            found = true;
            stopped.push(event);
            return false;
        });
        stopped.forEach(function (event) { _this._stopEvent(event); });
        return this;
    };
    BaseProvider.prototype.removeAllListeners = function (eventName) {
        var _this = this;
        var stopped = [];
        if (eventName == null) {
            stopped = this._events;
            this._events = [];
        }
        else {
            var eventTag_1 = getEventTag(eventName);
            this._events = this._events.filter(function (event) {
                if (event.tag !== eventTag_1) {
                    return true;
                }
                stopped.push(event);
                return false;
            });
        }
        stopped.forEach(function (event) { _this._stopEvent(event); });
        return this;
    };
    return BaseProvider;
}(abstract_provider_1.Provider));
exports.BaseProvider = BaseProvider;
//# sourceMappingURL=base-provider.js.map

/***/ }),

/***/ 1382:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudflareProvider = void 0;
var url_json_rpc_provider_1 = __nccwpck_require__(3480);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(1594);
var logger = new logger_1.Logger(_version_1.version);
var CloudflareProvider = /** @class */ (function (_super) {
    __extends(CloudflareProvider, _super);
    function CloudflareProvider() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CloudflareProvider.getApiKey = function (apiKey) {
        if (apiKey != null) {
            logger.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
        }
        return null;
    };
    CloudflareProvider.getUrl = function (network, apiKey) {
        var host = null;
        switch (network.name) {
            case "homestead":
                host = "https://cloudflare-eth.com/";
                break;
            default:
                logger.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return host;
    };
    CloudflareProvider.prototype.perform = function (method, params) {
        return __awaiter(this, void 0, void 0, function () {
            var block;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(method === "getBlockNumber")) return [3 /*break*/, 2];
                        return [4 /*yield*/, _super.prototype.perform.call(this, "getBlock", { blockTag: "latest" })];
                    case 1:
                        block = _a.sent();
                        return [2 /*return*/, block.number];
                    case 2: return [2 /*return*/, _super.prototype.perform.call(this, method, params)];
                }
            });
        });
    };
    return CloudflareProvider;
}(url_json_rpc_provider_1.UrlJsonRpcProvider));
exports.CloudflareProvider = CloudflareProvider;
//# sourceMappingURL=cloudflare-provider.js.map

/***/ }),

/***/ 304:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EtherscanProvider = void 0;
var bytes_1 = __nccwpck_require__(2056);
var properties_1 = __nccwpck_require__(8078);
var transactions_1 = __nccwpck_require__(2449);
var web_1 = __nccwpck_require__(3138);
var formatter_1 = __nccwpck_require__(3995);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(1594);
var logger = new logger_1.Logger(_version_1.version);
var base_provider_1 = __nccwpck_require__(3387);
// The transaction has already been sanitized by the calls in Provider
function getTransactionPostData(transaction) {
    var result = {};
    for (var key in transaction) {
        if (transaction[key] == null) {
            continue;
        }
        var value = transaction[key];
        if (key === "type" && value === 0) {
            continue;
        }
        // Quantity-types require no leading zero, unless 0
        if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {
            value = (0, bytes_1.hexValue)((0, bytes_1.hexlify)(value));
        }
        else if (key === "accessList") {
            value = "[" + (0, transactions_1.accessListify)(value).map(function (set) {
                return "{address:\"" + set.address + "\",storageKeys:[\"" + set.storageKeys.join('","') + "\"]}";
            }).join(",") + "]";
        }
        else {
            value = (0, bytes_1.hexlify)(value);
        }
        result[key] = value;
    }
    return result;
}
function getResult(result) {
    // getLogs, getHistory have weird success responses
    if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
        return result.result;
    }
    if (result.status != 1 || typeof (result.message) !== "string" || !result.message.match(/^OK/)) {
        var error = new Error("invalid response");
        error.result = JSON.stringify(result);
        if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
            error.throttleRetry = true;
        }
        throw error;
    }
    return result.result;
}
function getJsonResult(result) {
    // This response indicates we are being throttled
    if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
        var error = new Error("throttled response");
        error.result = JSON.stringify(result);
        error.throttleRetry = true;
        throw error;
    }
    if (result.jsonrpc != "2.0") {
        // @TODO: not any
        var error = new Error("invalid response");
        error.result = JSON.stringify(result);
        throw error;
    }
    if (result.error) {
        // @TODO: not any
        var error = new Error(result.error.message || "unknown error");
        if (result.error.code) {
            error.code = result.error.code;
        }
        if (result.error.data) {
            error.data = result.error.data;
        }
        throw error;
    }
    return result.result;
}
// The blockTag was normalized as a string by the Provider pre-perform operations
function checkLogTag(blockTag) {
    if (blockTag === "pending") {
        throw new Error("pending not supported");
    }
    if (blockTag === "latest") {
        return blockTag;
    }
    return parseInt(blockTag.substring(2), 16);
}
function checkError(method, error, transaction) {
    // Undo the "convenience" some nodes are attempting to prevent backwards
    // incompatibility; maybe for v6 consider forwarding reverts as errors
    if (method === "call" && error.code === logger_1.Logger.errors.SERVER_ERROR) {
        var e = error.error;
        // Etherscan keeps changing their string
        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {
            // Etherscan prefixes the data like "Reverted 0x1234"
            var data = e.data;
            if (data) {
                data = "0x" + data.replace(/^.*0x/i, "");
            }
            if ((0, bytes_1.isHexString)(data)) {
                return data;
            }
            logger.throwError("missing revert data in call exception", logger_1.Logger.errors.CALL_EXCEPTION, {
                error: error,
                data: "0x"
            });
        }
    }
    // Get the message from any nested error structure
    var message = error.message;
    if (error.code === logger_1.Logger.errors.SERVER_ERROR) {
        if (error.error && typeof (error.error.message) === "string") {
            message = error.error.message;
        }
        else if (typeof (error.body) === "string") {
            message = error.body;
        }
        else if (typeof (error.responseText) === "string") {
            message = error.responseText;
        }
    }
    message = (message || "").toLowerCase();
    // "Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0"
    if (message.match(/insufficient funds/)) {
        logger.throwError("insufficient funds for intrinsic transaction cost", logger_1.Logger.errors.INSUFFICIENT_FUNDS, {
            error: error,
            method: method,
            transaction: transaction
        });
    }
    // "Transaction with the same hash was already imported."
    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
        logger.throwError("nonce has already been used", logger_1.Logger.errors.NONCE_EXPIRED, {
            error: error,
            method: method,
            transaction: transaction
        });
    }
    // "Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce."
    if (message.match(/another transaction with same nonce/)) {
        logger.throwError("replacement fee too low", logger_1.Logger.errors.REPLACEMENT_UNDERPRICED, {
            error: error,
            method: method,
            transaction: transaction
        });
    }
    if (message.match(/execution failed due to an exception|execution reverted/)) {
        logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
            error: error,
            method: method,
            transaction: transaction
        });
    }
    throw error;
}
var EtherscanProvider = /** @class */ (function (_super) {
    __extends(EtherscanProvider, _super);
    function EtherscanProvider(network, apiKey) {
        var _this = _super.call(this, network) || this;
        (0, properties_1.defineReadOnly)(_this, "baseUrl", _this.getBaseUrl());
        (0, properties_1.defineReadOnly)(_this, "apiKey", apiKey || null);
        return _this;
    }
    EtherscanProvider.prototype.getBaseUrl = function () {
        switch (this.network ? this.network.name : "invalid") {
            case "homestead":
                return "https:/\/api.etherscan.io";
            case "goerli":
                return "https:/\/api-goerli.etherscan.io";
            case "sepolia":
                return "https:/\/api-sepolia.etherscan.io";
            case "matic":
                return "https:/\/api.polygonscan.com";
            case "maticmum":
                return "https:/\/api-testnet.polygonscan.com";
            case "arbitrum":
                return "https:/\/api.arbiscan.io";
            case "arbitrum-goerli":
                return "https:/\/api-goerli.arbiscan.io";
            case "optimism":
                return "https:/\/api-optimistic.etherscan.io";
            case "optimism-goerli":
                return "https:/\/api-goerli-optimistic.etherscan.io";
            default:
        }
        return logger.throwArgumentError("unsupported network", "network", this.network.name);
    };
    EtherscanProvider.prototype.getUrl = function (module, params) {
        var query = Object.keys(params).reduce(function (accum, key) {
            var value = params[key];
            if (value != null) {
                accum += "&" + key + "=" + value;
            }
            return accum;
        }, "");
        var apiKey = ((this.apiKey) ? "&apikey=" + this.apiKey : "");
        return this.baseUrl + "/api?module=" + module + query + apiKey;
    };
    EtherscanProvider.prototype.getPostUrl = function () {
        return this.baseUrl + "/api";
    };
    EtherscanProvider.prototype.getPostData = function (module, params) {
        params.module = module;
        params.apikey = this.apiKey;
        return params;
    };
    EtherscanProvider.prototype.fetch = function (module, params, post) {
        return __awaiter(this, void 0, void 0, function () {
            var url, payload, procFunc, connection, payloadStr, result;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = (post ? this.getPostUrl() : this.getUrl(module, params));
                        payload = (post ? this.getPostData(module, params) : null);
                        procFunc = (module === "proxy") ? getJsonResult : getResult;
                        this.emit("debug", {
                            action: "request",
                            request: url,
                            provider: this
                        });
                        connection = {
                            url: url,
                            throttleSlotInterval: 1000,
                            throttleCallback: function (attempt, url) {
                                if (_this.isCommunityResource()) {
                                    (0, formatter_1.showThrottleMessage)();
                                }
                                return Promise.resolve(true);
                            }
                        };
                        payloadStr = null;
                        if (payload) {
                            connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
                            payloadStr = Object.keys(payload).map(function (key) {
                                return key + "=" + payload[key];
                            }).join("&");
                        }
                        return [4 /*yield*/, (0, web_1.fetchJson)(connection, payloadStr, procFunc || getJsonResult)];
                    case 1:
                        result = _a.sent();
                        this.emit("debug", {
                            action: "response",
                            request: url,
                            response: (0, properties_1.deepCopy)(result),
                            provider: this
                        });
                        return [2 /*return*/, result];
                }
            });
        });
    };
    EtherscanProvider.prototype.detectNetwork = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.network];
            });
        });
    };
    EtherscanProvider.prototype.perform = function (method, params) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, postData, error_1, postData, error_2, args, topic0, logs, blocks, i, log, block, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = method;
                        switch (_a) {
                            case "getBlockNumber": return [3 /*break*/, 1];
                            case "getGasPrice": return [3 /*break*/, 2];
                            case "getBalance": return [3 /*break*/, 3];
                            case "getTransactionCount": return [3 /*break*/, 4];
                            case "getCode": return [3 /*break*/, 5];
                            case "getStorageAt": return [3 /*break*/, 6];
                            case "sendTransaction": return [3 /*break*/, 7];
                            case "getBlock": return [3 /*break*/, 8];
                            case "getTransaction": return [3 /*break*/, 9];
                            case "getTransactionReceipt": return [3 /*break*/, 10];
                            case "call": return [3 /*break*/, 11];
                            case "estimateGas": return [3 /*break*/, 15];
                            case "getLogs": return [3 /*break*/, 19];
                            case "getEtherPrice": return [3 /*break*/, 26];
                        }
                        return [3 /*break*/, 28];
                    case 1: return [2 /*return*/, this.fetch("proxy", { action: "eth_blockNumber" })];
                    case 2: return [2 /*return*/, this.fetch("proxy", { action: "eth_gasPrice" })];
                    case 3: 
                    // Returns base-10 result
                    return [2 /*return*/, this.fetch("account", {
                            action: "balance",
                            address: params.address,
                            tag: params.blockTag
                        })];
                    case 4: return [2 /*return*/, this.fetch("proxy", {
                            action: "eth_getTransactionCount",
                            address: params.address,
                            tag: params.blockTag
                        })];
                    case 5: return [2 /*return*/, this.fetch("proxy", {
                            action: "eth_getCode",
                            address: params.address,
                            tag: params.blockTag
                        })];
                    case 6: return [2 /*return*/, this.fetch("proxy", {
                            action: "eth_getStorageAt",
                            address: params.address,
                            position: params.position,
                            tag: params.blockTag
                        })];
                    case 7: return [2 /*return*/, this.fetch("proxy", {
                            action: "eth_sendRawTransaction",
                            hex: params.signedTransaction
                        }, true).catch(function (error) {
                            return checkError("sendTransaction", error, params.signedTransaction);
                        })];
                    case 8:
                        if (params.blockTag) {
                            return [2 /*return*/, this.fetch("proxy", {
                                    action: "eth_getBlockByNumber",
                                    tag: params.blockTag,
                                    boolean: (params.includeTransactions ? "true" : "false")
                                })];
                        }
                        throw new Error("getBlock by blockHash not implemented");
                    case 9: return [2 /*return*/, this.fetch("proxy", {
                            action: "eth_getTransactionByHash",
                            txhash: params.transactionHash
                        })];
                    case 10: return [2 /*return*/, this.fetch("proxy", {
                            action: "eth_getTransactionReceipt",
                            txhash: params.transactionHash
                        })];
                    case 11:
                        if (params.blockTag !== "latest") {
                            throw new Error("EtherscanProvider does not support blockTag for call");
                        }
                        postData = getTransactionPostData(params.transaction);
                        postData.module = "proxy";
                        postData.action = "eth_call";
                        _c.label = 12;
                    case 12:
                        _c.trys.push([12, 14, , 15]);
                        return [4 /*yield*/, this.fetch("proxy", postData, true)];
                    case 13: return [2 /*return*/, _c.sent()];
                    case 14:
                        error_1 = _c.sent();
                        return [2 /*return*/, checkError("call", error_1, params.transaction)];
                    case 15:
                        postData = getTransactionPostData(params.transaction);
                        postData.module = "proxy";
                        postData.action = "eth_estimateGas";
                        _c.label = 16;
                    case 16:
                        _c.trys.push([16, 18, , 19]);
                        return [4 /*yield*/, this.fetch("proxy", postData, true)];
                    case 17: return [2 /*return*/, _c.sent()];
                    case 18:
                        error_2 = _c.sent();
                        return [2 /*return*/, checkError("estimateGas", error_2, params.transaction)];
                    case 19:
                        args = { action: "getLogs" };
                        if (params.filter.fromBlock) {
                            args.fromBlock = checkLogTag(params.filter.fromBlock);
                        }
                        if (params.filter.toBlock) {
                            args.toBlock = checkLogTag(params.filter.toBlock);
                        }
                        if (params.filter.address) {
                            args.address = params.filter.address;
                        }
                        // @TODO: We can handle slightly more complicated logs using the logs API
                        if (params.filter.topics && params.filter.topics.length > 0) {
                            if (params.filter.topics.length > 1) {
                                logger.throwError("unsupported topic count", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
                            }
                            if (params.filter.topics.length === 1) {
                                topic0 = params.filter.topics[0];
                                if (typeof (topic0) !== "string" || topic0.length !== 66) {
                                    logger.throwError("unsupported topic format", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });
                                }
                                args.topic0 = topic0;
                            }
                        }
                        return [4 /*yield*/, this.fetch("logs", args)];
                    case 20:
                        logs = _c.sent();
                        blocks = {};
                        i = 0;
                        _c.label = 21;
                    case 21:
                        if (!(i < logs.length)) return [3 /*break*/, 25];
                        log = logs[i];
                        if (log.blockHash != null) {
                            return [3 /*break*/, 24];
                        }
                        if (!(blocks[log.blockNumber] == null)) return [3 /*break*/, 23];
                        return [4 /*yield*/, this.getBlock(log.blockNumber)];
                    case 22:
                        block = _c.sent();
                        if (block) {
                            blocks[log.blockNumber] = block.hash;
                        }
                        _c.label = 23;
                    case 23:
                        log.blockHash = blocks[log.blockNumber];
                        _c.label = 24;
                    case 24:
                        i++;
                        return [3 /*break*/, 21];
                    case 25: return [2 /*return*/, logs];
                    case 26:
                        if (this.network.name !== "homestead") {
                            return [2 /*return*/, 0.0];
                        }
                        _b = parseFloat;
                        return [4 /*yield*/, this.fetch("stats", { action: "ethprice" })];
                    case 27: return [2 /*return*/, _b.apply(void 0, [(_c.sent()).ethusd])];
                    case 28: return [3 /*break*/, 29];
                    case 29: return [2 /*return*/, _super.prototype.perform.call(this, method, params)];
                }
            });
        });
    };
    // Note: The `page` page parameter only allows pagination within the
    //       10,000 window available without a page and offset parameter
    //       Error: Result window is too large, PageNo x Offset size must
    //              be less than or equal to 10000
    EtherscanProvider.prototype.getHistory = function (addressOrName, startBlock, endBlock) {
        return __awaiter(this, void 0, void 0, function () {
            var params, result;
            var _a;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = {
                            action: "txlist"
                        };
                        return [4 /*yield*/, this.resolveName(addressOrName)];
                    case 1:
                        params = (_a.address = (_b.sent()),
                            _a.startblock = ((startBlock == null) ? 0 : startBlock),
                            _a.endblock = ((endBlock == null) ? 99999999 : endBlock),
                            _a.sort = "asc",
                            _a);
                        return [4 /*yield*/, this.fetch("account", params)];
                    case 2:
                        result = _b.sent();
                        return [2 /*return*/, result.map(function (tx) {
                                ["contractAddress", "to"].forEach(function (key) {
                                    if (tx[key] == "") {
                                        delete tx[key];
                                    }
                                });
                                if (tx.creates == null && tx.contractAddress != null) {
                                    tx.creates = tx.contractAddress;
                                }
                                var item = _this.formatter.transactionResponse(tx);
                                if (tx.timeStamp) {
                                    item.timestamp = parseInt(tx.timeStamp);
                                }
                                return item;
                            })];
                }
            });
        });
    };
    EtherscanProvider.prototype.isCommunityResource = function () {
        return (this.apiKey == null);
    };
    return EtherscanProvider;
}(base_provider_1.BaseProvider));
exports.EtherscanProvider = EtherscanProvider;
//# sourceMappingURL=etherscan-provider.js.map

/***/ }),

/***/ 3702:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FallbackProvider = void 0;
var abstract_provider_1 = __nccwpck_require__(1698);
var bignumber_1 = __nccwpck_require__(1267);
var bytes_1 = __nccwpck_require__(2056);
var properties_1 = __nccwpck_require__(8078);
var random_1 = __nccwpck_require__(4977);
var web_1 = __nccwpck_require__(3138);
var base_provider_1 = __nccwpck_require__(3387);
var formatter_1 = __nccwpck_require__(3995);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(1594);
var logger = new logger_1.Logger(_version_1.version);
function now() { return (new Date()).getTime(); }
// Returns to network as long as all agree, or null if any is null.
// Throws an error if any two networks do not match.
function checkNetworks(networks) {
    var result = null;
    for (var i = 0; i < networks.length; i++) {
        var network = networks[i];
        // Null! We do not know our network; bail.
        if (network == null) {
            return null;
        }
        if (result) {
            // Make sure the network matches the previous networks
            if (!(result.name === network.name && result.chainId === network.chainId &&
                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {
                logger.throwArgumentError("provider mismatch", "networks", networks);
            }
        }
        else {
            result = network;
        }
    }
    return result;
}
function median(values, maxDelta) {
    values = values.slice().sort();
    var middle = Math.floor(values.length / 2);
    // Odd length; take the middle
    if (values.length % 2) {
        return values[middle];
    }
    // Even length; take the average of the two middle
    var a = values[middle - 1], b = values[middle];
    if (maxDelta != null && Math.abs(a - b) > maxDelta) {
        return null;
    }
    return (a + b) / 2;
}
function serialize(value) {
    if (value === null) {
        return "null";
    }
    else if (typeof (value) === "number" || typeof (value) === "boolean") {
        return JSON.stringify(value);
    }
    else if (typeof (value) === "string") {
        return value;
    }
    else if (bignumber_1.BigNumber.isBigNumber(value)) {
        return value.toString();
    }
    else if (Array.isArray(value)) {
        return JSON.stringify(value.map(function (i) { return serialize(i); }));
    }
    else if (typeof (value) === "object") {
        var keys = Object.keys(value);
        keys.sort();
        return "{" + keys.map(function (key) {
            var v = value[key];
            if (typeof (v) === "function") {
                v = "[function]";
            }
            else {
                v = serialize(v);
            }
            return JSON.stringify(key) + ":" + v;
        }).join(",") + "}";
    }
    throw new Error("unknown value type: " + typeof (value));
}
// Next request ID to use for emitting debug info
var nextRid = 1;
;
function stall(duration) {
    var cancel = null;
    var timer = null;
    var promise = (new Promise(function (resolve) {
        cancel = function () {
            if (timer) {
                clearTimeout(timer);
                timer = null;
            }
            resolve();
        };
        timer = setTimeout(cancel, duration);
    }));
    var wait = function (func) {
        promise = promise.then(func);
        return promise;
    };
    function getPromise() {
        return promise;
    }
    return { cancel: cancel, getPromise: getPromise, wait: wait };
}
var ForwardErrors = [
    logger_1.Logger.errors.CALL_EXCEPTION,
    logger_1.Logger.errors.INSUFFICIENT_FUNDS,
    logger_1.Logger.errors.NONCE_EXPIRED,
    logger_1.Logger.errors.REPLACEMENT_UNDERPRICED,
    logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT
];
var ForwardProperties = [
    "address",
    "args",
    "errorArgs",
    "errorSignature",
    "method",
    "transaction",
];
;
function exposeDebugConfig(config, now) {
    var result = {
        weight: config.weight
    };
    Object.defineProperty(result, "provider", { get: function () { return config.provider; } });
    if (config.start) {
        result.start = config.start;
    }
    if (now) {
        result.duration = (now - config.start);
    }
    if (config.done) {
        if (config.error) {
            result.error = config.error;
        }
        else {
            result.result = config.result || null;
        }
    }
    return result;
}
function normalizedTally(normalize, quorum) {
    return function (configs) {
        // Count the votes for each result
        var tally = {};
        configs.forEach(function (c) {
            var value = normalize(c.result);
            if (!tally[value]) {
                tally[value] = { count: 0, result: c.result };
            }
            tally[value].count++;
        });
        // Check for a quorum on any given result
        var keys = Object.keys(tally);
        for (var i = 0; i < keys.length; i++) {
            var check = tally[keys[i]];
            if (check.count >= quorum) {
                return check.result;
            }
        }
        // No quroum
        return undefined;
    };
}
function getProcessFunc(provider, method, params) {
    var normalize = serialize;
    switch (method) {
        case "getBlockNumber":
            // Return the median value, unless there is (median + 1) is also
            // present, in which case that is probably true and the median
            // is going to be stale soon. In the event of a malicious node,
            // the lie will be true soon enough.
            return function (configs) {
                var values = configs.map(function (c) { return c.result; });
                // Get the median block number
                var blockNumber = median(configs.map(function (c) { return c.result; }), 2);
                if (blockNumber == null) {
                    return undefined;
                }
                blockNumber = Math.ceil(blockNumber);
                // If the next block height is present, its prolly safe to use
                if (values.indexOf(blockNumber + 1) >= 0) {
                    blockNumber++;
                }
                // Don't ever roll back the blockNumber
                if (blockNumber >= provider._highestBlockNumber) {
                    provider._highestBlockNumber = blockNumber;
                }
                return provider._highestBlockNumber;
            };
        case "getGasPrice":
            // Return the middle (round index up) value, similar to median
            // but do not average even entries and choose the higher.
            // Malicious actors must compromise 50% of the nodes to lie.
            return function (configs) {
                var values = configs.map(function (c) { return c.result; });
                values.sort();
                return values[Math.floor(values.length / 2)];
            };
        case "getEtherPrice":
            // Returns the median price. Malicious actors must compromise at
            // least 50% of the nodes to lie (in a meaningful way).
            return function (configs) {
                return median(configs.map(function (c) { return c.result; }));
            };
        // No additional normalizing required; serialize is enough
        case "getBalance":
        case "getTransactionCount":
        case "getCode":
        case "getStorageAt":
        case "call":
        case "estimateGas":
        case "getLogs":
            break;
        // We drop the confirmations from transactions as it is approximate
        case "getTransaction":
        case "getTransactionReceipt":
            normalize = function (tx) {
                if (tx == null) {
                    return null;
                }
                tx = (0, properties_1.shallowCopy)(tx);
                tx.confirmations = -1;
                return serialize(tx);
            };
            break;
        // We drop the confirmations from transactions as it is approximate
        case "getBlock":
            // We drop the confirmations from transactions as it is approximate
            if (params.includeTransactions) {
                normalize = function (block) {
                    if (block == null) {
                        return null;
                    }
                    block = (0, properties_1.shallowCopy)(block);
                    block.transactions = block.transactions.map(function (tx) {
                        tx = (0, properties_1.shallowCopy)(tx);
                        tx.confirmations = -1;
                        return tx;
                    });
                    return serialize(block);
                };
            }
            else {
                normalize = function (block) {
                    if (block == null) {
                        return null;
                    }
                    return serialize(block);
                };
            }
            break;
        default:
            throw new Error("unknown method: " + method);
    }
    // Return the result if and only if the expected quorum is
    // satisfied and agreed upon for the final result.
    return normalizedTally(normalize, provider.quorum);
}
// If we are doing a blockTag query, we need to make sure the backend is
// caught up to the FallbackProvider, before sending a request to it.
function waitForSync(config, blockNumber) {
    return __awaiter(this, void 0, void 0, function () {
        var provider;
        return __generator(this, function (_a) {
            provider = (config.provider);
            if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {
                return [2 /*return*/, provider];
            }
            return [2 /*return*/, (0, web_1.poll)(function () {
                    return new Promise(function (resolve, reject) {
                        setTimeout(function () {
                            // We are synced
                            if (provider.blockNumber >= blockNumber) {
                                return resolve(provider);
                            }
                            // We're done; just quit
                            if (config.cancelled) {
                                return resolve(null);
                            }
                            // Try again, next block
                            return resolve(undefined);
                        }, 0);
                    });
                }, { oncePoll: provider })];
        });
    });
}
function getRunner(config, currentBlockNumber, method, params) {
    return __awaiter(this, void 0, void 0, function () {
        var provider, _a, filter;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    provider = config.provider;
                    _a = method;
                    switch (_a) {
                        case "getBlockNumber": return [3 /*break*/, 1];
                        case "getGasPrice": return [3 /*break*/, 1];
                        case "getEtherPrice": return [3 /*break*/, 2];
                        case "getBalance": return [3 /*break*/, 3];
                        case "getTransactionCount": return [3 /*break*/, 3];
                        case "getCode": return [3 /*break*/, 3];
                        case "getStorageAt": return [3 /*break*/, 6];
                        case "getBlock": return [3 /*break*/, 9];
                        case "call": return [3 /*break*/, 12];
                        case "estimateGas": return [3 /*break*/, 12];
                        case "getTransaction": return [3 /*break*/, 15];
                        case "getTransactionReceipt": return [3 /*break*/, 15];
                        case "getLogs": return [3 /*break*/, 16];
                    }
                    return [3 /*break*/, 19];
                case 1: return [2 /*return*/, provider[method]()];
                case 2:
                    if (provider.getEtherPrice) {
                        return [2 /*return*/, provider.getEtherPrice()];
                    }
                    return [3 /*break*/, 19];
                case 3:
                    if (!(params.blockTag && (0, bytes_1.isHexString)(params.blockTag))) return [3 /*break*/, 5];
                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];
                case 4:
                    provider = _b.sent();
                    _b.label = 5;
                case 5: return [2 /*return*/, provider[method](params.address, params.blockTag || "latest")];
                case 6:
                    if (!(params.blockTag && (0, bytes_1.isHexString)(params.blockTag))) return [3 /*break*/, 8];
                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];
                case 7:
                    provider = _b.sent();
                    _b.label = 8;
                case 8: return [2 /*return*/, provider.getStorageAt(params.address, params.position, params.blockTag || "latest")];
                case 9:
                    if (!(params.blockTag && (0, bytes_1.isHexString)(params.blockTag))) return [3 /*break*/, 11];
                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];
                case 10:
                    provider = _b.sent();
                    _b.label = 11;
                case 11: return [2 /*return*/, provider[(params.includeTransactions ? "getBlockWithTransactions" : "getBlock")](params.blockTag || params.blockHash)];
                case 12:
                    if (!(params.blockTag && (0, bytes_1.isHexString)(params.blockTag))) return [3 /*break*/, 14];
                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];
                case 13:
                    provider = _b.sent();
                    _b.label = 14;
                case 14:
                    if (method === "call" && params.blockTag) {
                        return [2 /*return*/, provider[method](params.transaction, params.blockTag)];
                    }
                    return [2 /*return*/, provider[method](params.transaction)];
                case 15: return [2 /*return*/, provider[method](params.transactionHash)];
                case 16:
                    filter = params.filter;
                    if (!((filter.fromBlock && (0, bytes_1.isHexString)(filter.fromBlock)) || (filter.toBlock && (0, bytes_1.isHexString)(filter.toBlock)))) return [3 /*break*/, 18];
                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];
                case 17:
                    provider = _b.sent();
                    _b.label = 18;
                case 18: return [2 /*return*/, provider.getLogs(filter)];
                case 19: return [2 /*return*/, logger.throwError("unknown method error", logger_1.Logger.errors.UNKNOWN_ERROR, {
                        method: method,
                        params: params
                    })];
            }
        });
    });
}
var FallbackProvider = /** @class */ (function (_super) {
    __extends(FallbackProvider, _super);
    function FallbackProvider(providers, quorum) {
        var _this = this;
        if (providers.length === 0) {
            logger.throwArgumentError("missing providers", "providers", providers);
        }
        var providerConfigs = providers.map(function (configOrProvider, index) {
            if (abstract_provider_1.Provider.isProvider(configOrProvider)) {
                var stallTimeout = (0, formatter_1.isCommunityResource)(configOrProvider) ? 2000 : 750;
                var priority = 1;
                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout: stallTimeout, priority: priority });
            }
            var config = (0, properties_1.shallowCopy)(configOrProvider);
            if (config.priority == null) {
                config.priority = 1;
            }
            if (config.stallTimeout == null) {
                config.stallTimeout = (0, formatter_1.isCommunityResource)(configOrProvider) ? 2000 : 750;
            }
            if (config.weight == null) {
                config.weight = 1;
            }
            var weight = config.weight;
            if (weight % 1 || weight > 512 || weight < 1) {
                logger.throwArgumentError("invalid weight; must be integer in [1, 512]", "providers[" + index + "].weight", weight);
            }
            return Object.freeze(config);
        });
        var total = providerConfigs.reduce(function (accum, c) { return (accum + c.weight); }, 0);
        if (quorum == null) {
            quorum = total / 2;
        }
        else if (quorum > total) {
            logger.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
        }
        // Are all providers' networks are known
        var networkOrReady = checkNetworks(providerConfigs.map(function (c) { return (c.provider).network; }));
        // Not all networks are known; we must stall
        if (networkOrReady == null) {
            networkOrReady = new Promise(function (resolve, reject) {
                setTimeout(function () {
                    _this.detectNetwork().then(resolve, reject);
                }, 0);
            });
        }
        _this = _super.call(this, networkOrReady) || this;
        // Preserve a copy, so we do not get mutated
        (0, properties_1.defineReadOnly)(_this, "providerConfigs", Object.freeze(providerConfigs));
        (0, properties_1.defineReadOnly)(_this, "quorum", quorum);
        _this._highestBlockNumber = -1;
        return _this;
    }
    FallbackProvider.prototype.detectNetwork = function () {
        return __awaiter(this, void 0, void 0, function () {
            var networks;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.all(this.providerConfigs.map(function (c) { return c.provider.getNetwork(); }))];
                    case 1:
                        networks = _a.sent();
                        return [2 /*return*/, checkNetworks(networks)];
                }
            });
        });
    };
    FallbackProvider.prototype.perform = function (method, params) {
        return __awaiter(this, void 0, void 0, function () {
            var results, i_1, result, processFunc, configs, currentBlockNumber, i, first, _loop_1, this_1, state_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(method === "sendTransaction")) return [3 /*break*/, 2];
                        return [4 /*yield*/, Promise.all(this.providerConfigs.map(function (c) {
                                return c.provider.sendTransaction(params.signedTransaction).then(function (result) {
                                    return result.hash;
                                }, function (error) {
                                    return error;
                                });
                            }))];
                    case 1:
                        results = _a.sent();
                        // Any success is good enough (other errors are likely "already seen" errors
                        for (i_1 = 0; i_1 < results.length; i_1++) {
                            result = results[i_1];
                            if (typeof (result) === "string") {
                                return [2 /*return*/, result];
                            }
                        }
                        // They were all an error; pick the first error
                        throw results[0];
                    case 2:
                        if (!(this._highestBlockNumber === -1 && method !== "getBlockNumber")) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.getBlockNumber()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        processFunc = getProcessFunc(this, method, params);
                        configs = (0, random_1.shuffled)(this.providerConfigs.map(properties_1.shallowCopy));
                        configs.sort(function (a, b) { return (a.priority - b.priority); });
                        currentBlockNumber = this._highestBlockNumber;
                        i = 0;
                        first = true;
                        _loop_1 = function () {
                            var t0, inflightWeight, _loop_2, waiting, results, result, errors;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        t0 = now();
                                        inflightWeight = configs.filter(function (c) { return (c.runner && ((t0 - c.start) < c.stallTimeout)); })
                                            .reduce(function (accum, c) { return (accum + c.weight); }, 0);
                                        _loop_2 = function () {
                                            var config = configs[i++];
                                            var rid = nextRid++;
                                            config.start = now();
                                            config.staller = stall(config.stallTimeout);
                                            config.staller.wait(function () { config.staller = null; });
                                            config.runner = getRunner(config, currentBlockNumber, method, params).then(function (result) {
                                                config.done = true;
                                                config.result = result;
                                                if (_this.listenerCount("debug")) {
                                                    _this.emit("debug", {
                                                        action: "request",
                                                        rid: rid,
                                                        backend: exposeDebugConfig(config, now()),
                                                        request: { method: method, params: (0, properties_1.deepCopy)(params) },
                                                        provider: _this
                                                    });
                                                }
                                            }, function (error) {
                                                config.done = true;
                                                config.error = error;
                                                if (_this.listenerCount("debug")) {
                                                    _this.emit("debug", {
                                                        action: "request",
                                                        rid: rid,
                                                        backend: exposeDebugConfig(config, now()),
                                                        request: { method: method, params: (0, properties_1.deepCopy)(params) },
                                                        provider: _this
                                                    });
                                                }
                                            });
                                            if (this_1.listenerCount("debug")) {
                                                this_1.emit("debug", {
                                                    action: "request",
                                                    rid: rid,
                                                    backend: exposeDebugConfig(config, null),
                                                    request: { method: method, params: (0, properties_1.deepCopy)(params) },
                                                    provider: this_1
                                                });
                                            }
                                            inflightWeight += config.weight;
                                        };
                                        // Start running enough to meet quorum
                                        while (inflightWeight < this_1.quorum && i < configs.length) {
                                            _loop_2();
                                        }
                                        waiting = [];
                                        configs.forEach(function (c) {
                                            if (c.done || !c.runner) {
                                                return;
                                            }
                                            waiting.push(c.runner);
                                            if (c.staller) {
                                                waiting.push(c.staller.getPromise());
                                            }
                                        });
                                        if (!waiting.length) return [3 /*break*/, 2];
                                        return [4 /*yield*/, Promise.race(waiting)];
                                    case 1:
                                        _b.sent();
                                        _b.label = 2;
                                    case 2:
                                        results = configs.filter(function (c) { return (c.done && c.error == null); });
                                        if (!(results.length >= this_1.quorum)) return [3 /*break*/, 5];
                                        result = processFunc(results);
                                        if (result !== undefined) {
                                            // Shut down any stallers
                                            configs.forEach(function (c) {
                                                if (c.staller) {
                                                    c.staller.cancel();
                                                }
                                                c.cancelled = true;
                                            });
                                            return [2 /*return*/, { value: result }];
                                        }
                                        if (!!first) return [3 /*break*/, 4];
                                        return [4 /*yield*/, stall(100).getPromise()];
                                    case 3:
                                        _b.sent();
                                        _b.label = 4;
                                    case 4:
                                        first = false;
                                        _b.label = 5;
                                    case 5:
                                        errors = configs.reduce(function (accum, c) {
                                            if (!c.done || c.error == null) {
                                                return accum;
                                            }
                                            var code = (c.error).code;
                                            if (ForwardErrors.indexOf(code) >= 0) {
                                                if (!accum[code]) {
                                                    accum[code] = { error: c.error, weight: 0 };
                                                }
                                                accum[code].weight += c.weight;
                                            }
                                            return accum;
                                        }, ({}));
                                        Object.keys(errors).forEach(function (errorCode) {
                                            var tally = errors[errorCode];
                                            if (tally.weight < _this.quorum) {
                                                return;
                                            }
                                            // Shut down any stallers
                                            configs.forEach(function (c) {
                                                if (c.staller) {
                                                    c.staller.cancel();
                                                }
                                                c.cancelled = true;
                                            });
                                            var e = (tally.error);
                                            var props = {};
                                            ForwardProperties.forEach(function (name) {
                                                if (e[name] == null) {
                                                    return;
                                                }
                                                props[name] = e[name];
                                            });
                                            logger.throwError(e.reason || e.message, errorCode, props);
                                        });
                                        // All configs have run to completion; we will never get more data
                                        if (configs.filter(function (c) { return !c.done; }).length === 0) {
                                            return [2 /*return*/, "break"];
                                        }
                                        return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        _a.label = 5;
                    case 5:
                        if (false) {}
                        return [5 /*yield**/, _loop_1()];
                    case 6:
                        state_1 = _a.sent();
                        if (typeof state_1 === "object")
                            return [2 /*return*/, state_1.value];
                        if (state_1 === "break")
                            return [3 /*break*/, 7];
                        return [3 /*break*/, 5];
                    case 7:
                        // Shut down any stallers; shouldn't be any
                        configs.forEach(function (c) {
                            if (c.staller) {
                                c.staller.cancel();
                            }
                            c.cancelled = true;
                        });
                        return [2 /*return*/, logger.throwError("failed to meet quorum", logger_1.Logger.errors.SERVER_ERROR, {
                                method: method,
                                params: params,
                                //results: configs.map((c) => c.result),
                                //errors: configs.map((c) => c.error),
                                results: configs.map(function (c) { return exposeDebugConfig(c); }),
                                provider: this
                            })];
                }
            });
        });
    };
    return FallbackProvider;
}(base_provider_1.BaseProvider));
exports.FallbackProvider = FallbackProvider;
//# sourceMappingURL=fallback-provider.js.map

/***/ }),

/***/ 3995:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.showThrottleMessage = exports.isCommunityResource = exports.isCommunityResourcable = exports.Formatter = void 0;
var address_1 = __nccwpck_require__(8957);
var bignumber_1 = __nccwpck_require__(1267);
var bytes_1 = __nccwpck_require__(2056);
var constants_1 = __nccwpck_require__(1309);
var properties_1 = __nccwpck_require__(8078);
var transactions_1 = __nccwpck_require__(2449);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(1594);
var logger = new logger_1.Logger(_version_1.version);
var Formatter = /** @class */ (function () {
    function Formatter() {
        this.formats = this.getDefaultFormats();
    }
    Formatter.prototype.getDefaultFormats = function () {
        var _this = this;
        var formats = ({});
        var address = this.address.bind(this);
        var bigNumber = this.bigNumber.bind(this);
        var blockTag = this.blockTag.bind(this);
        var data = this.data.bind(this);
        var hash = this.hash.bind(this);
        var hex = this.hex.bind(this);
        var number = this.number.bind(this);
        var type = this.type.bind(this);
        var strictData = function (v) { return _this.data(v, true); };
        formats.transaction = {
            hash: hash,
            type: type,
            accessList: Formatter.allowNull(this.accessList.bind(this), null),
            blockHash: Formatter.allowNull(hash, null),
            blockNumber: Formatter.allowNull(number, null),
            transactionIndex: Formatter.allowNull(number, null),
            confirmations: Formatter.allowNull(number, null),
            from: address,
            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
            // must be set
            gasPrice: Formatter.allowNull(bigNumber),
            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
            maxFeePerGas: Formatter.allowNull(bigNumber),
            gasLimit: bigNumber,
            to: Formatter.allowNull(address, null),
            value: bigNumber,
            nonce: number,
            data: data,
            r: Formatter.allowNull(this.uint256),
            s: Formatter.allowNull(this.uint256),
            v: Formatter.allowNull(number),
            creates: Formatter.allowNull(address, null),
            raw: Formatter.allowNull(data),
        };
        formats.transactionRequest = {
            from: Formatter.allowNull(address),
            nonce: Formatter.allowNull(number),
            gasLimit: Formatter.allowNull(bigNumber),
            gasPrice: Formatter.allowNull(bigNumber),
            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
            maxFeePerGas: Formatter.allowNull(bigNumber),
            to: Formatter.allowNull(address),
            value: Formatter.allowNull(bigNumber),
            data: Formatter.allowNull(strictData),
            type: Formatter.allowNull(number),
            accessList: Formatter.allowNull(this.accessList.bind(this), null),
        };
        formats.receiptLog = {
            transactionIndex: number,
            blockNumber: number,
            transactionHash: hash,
            address: address,
            topics: Formatter.arrayOf(hash),
            data: data,
            logIndex: number,
            blockHash: hash,
        };
        formats.receipt = {
            to: Formatter.allowNull(this.address, null),
            from: Formatter.allowNull(this.address, null),
            contractAddress: Formatter.allowNull(address, null),
            transactionIndex: number,
            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
            root: Formatter.allowNull(hex),
            gasUsed: bigNumber,
            logsBloom: Formatter.allowNull(data),
            blockHash: hash,
            transactionHash: hash,
            logs: Formatter.arrayOf(this.receiptLog.bind(this)),
            blockNumber: number,
            confirmations: Formatter.allowNull(number, null),
            cumulativeGasUsed: bigNumber,
            effectiveGasPrice: Formatter.allowNull(bigNumber),
            status: Formatter.allowNull(number),
            type: type
        };
        formats.block = {
            hash: Formatter.allowNull(hash),
            parentHash: hash,
            number: number,
            timestamp: number,
            nonce: Formatter.allowNull(hex),
            difficulty: this.difficulty.bind(this),
            gasLimit: bigNumber,
            gasUsed: bigNumber,
            miner: Formatter.allowNull(address),
            extraData: data,
            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),
            baseFeePerGas: Formatter.allowNull(bigNumber)
        };
        formats.blockWithTransactions = (0, properties_1.shallowCopy)(formats.block);
        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
        formats.filter = {
            fromBlock: Formatter.allowNull(blockTag, undefined),
            toBlock: Formatter.allowNull(blockTag, undefined),
            blockHash: Formatter.allowNull(hash, undefined),
            address: Formatter.allowNull(address, undefined),
            topics: Formatter.allowNull(this.topics.bind(this), undefined),
        };
        formats.filterLog = {
            blockNumber: Formatter.allowNull(number),
            blockHash: Formatter.allowNull(hash),
            transactionIndex: number,
            removed: Formatter.allowNull(this.boolean.bind(this)),
            address: address,
            data: Formatter.allowFalsish(data, "0x"),
            topics: Formatter.arrayOf(hash),
            transactionHash: hash,
            logIndex: number,
        };
        return formats;
    };
    Formatter.prototype.accessList = function (accessList) {
        return (0, transactions_1.accessListify)(accessList || []);
    };
    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
    // Strict! Used on input.
    Formatter.prototype.number = function (number) {
        if (number === "0x") {
            return 0;
        }
        return bignumber_1.BigNumber.from(number).toNumber();
    };
    Formatter.prototype.type = function (number) {
        if (number === "0x" || number == null) {
            return 0;
        }
        return bignumber_1.BigNumber.from(number).toNumber();
    };
    // Strict! Used on input.
    Formatter.prototype.bigNumber = function (value) {
        return bignumber_1.BigNumber.from(value);
    };
    // Requires a boolean, "true" or  "false"; returns a boolean
    Formatter.prototype.boolean = function (value) {
        if (typeof (value) === "boolean") {
            return value;
        }
        if (typeof (value) === "string") {
            value = value.toLowerCase();
            if (value === "true") {
                return true;
            }
            if (value === "false") {
                return false;
            }
        }
        throw new Error("invalid boolean - " + value);
    };
    Formatter.prototype.hex = function (value, strict) {
        if (typeof (value) === "string") {
            if (!strict && value.substring(0, 2) !== "0x") {
                value = "0x" + value;
            }
            if ((0, bytes_1.isHexString)(value)) {
                return value.toLowerCase();
            }
        }
        return logger.throwArgumentError("invalid hash", "value", value);
    };
    Formatter.prototype.data = function (value, strict) {
        var result = this.hex(value, strict);
        if ((result.length % 2) !== 0) {
            throw new Error("invalid data; odd-length - " + value);
        }
        return result;
    };
    // Requires an address
    // Strict! Used on input.
    Formatter.prototype.address = function (value) {
        return (0, address_1.getAddress)(value);
    };
    Formatter.prototype.callAddress = function (value) {
        if (!(0, bytes_1.isHexString)(value, 32)) {
            return null;
        }
        var address = (0, address_1.getAddress)((0, bytes_1.hexDataSlice)(value, 12));
        return (address === constants_1.AddressZero) ? null : address;
    };
    Formatter.prototype.contractAddress = function (value) {
        return (0, address_1.getContractAddress)(value);
    };
    // Strict! Used on input.
    Formatter.prototype.blockTag = function (blockTag) {
        if (blockTag == null) {
            return "latest";
        }
        if (blockTag === "earliest") {
            return "0x0";
        }
        switch (blockTag) {
            case "earliest": return "0x0";
            case "latest":
            case "pending":
            case "safe":
            case "finalized":
                return blockTag;
        }
        if (typeof (blockTag) === "number" || (0, bytes_1.isHexString)(blockTag)) {
            return (0, bytes_1.hexValue)(blockTag);
        }
        throw new Error("invalid blockTag");
    };
    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
    Formatter.prototype.hash = function (value, strict) {
        var result = this.hex(value, strict);
        if ((0, bytes_1.hexDataLength)(result) !== 32) {
            return logger.throwArgumentError("invalid hash", "value", value);
        }
        return result;
    };
    // Returns the difficulty as a number, or if too large (i.e. PoA network) null
    Formatter.prototype.difficulty = function (value) {
        if (value == null) {
            return null;
        }
        var v = bignumber_1.BigNumber.from(value);
        try {
            return v.toNumber();
        }
        catch (error) { }
        return null;
    };
    Formatter.prototype.uint256 = function (value) {
        if (!(0, bytes_1.isHexString)(value)) {
            throw new Error("invalid uint256");
        }
        return (0, bytes_1.hexZeroPad)(value, 32);
    };
    Formatter.prototype._block = function (value, format) {
        if (value.author != null && value.miner == null) {
            value.miner = value.author;
        }
        // The difficulty may need to come from _difficulty in recursed blocks
        var difficulty = (value._difficulty != null) ? value._difficulty : value.difficulty;
        var result = Formatter.check(format, value);
        result._difficulty = ((difficulty == null) ? null : bignumber_1.BigNumber.from(difficulty));
        return result;
    };
    Formatter.prototype.block = function (value) {
        return this._block(value, this.formats.block);
    };
    Formatter.prototype.blockWithTransactions = function (value) {
        return this._block(value, this.formats.blockWithTransactions);
    };
    // Strict! Used on input.
    Formatter.prototype.transactionRequest = function (value) {
        return Formatter.check(this.formats.transactionRequest, value);
    };
    Formatter.prototype.transactionResponse = function (transaction) {
        // Rename gas to gasLimit
        if (transaction.gas != null && transaction.gasLimit == null) {
            transaction.gasLimit = transaction.gas;
        }
        // Some clients (TestRPC) do strange things like return 0x0 for the
        // 0 address; correct this to be a real address
        if (transaction.to && bignumber_1.BigNumber.from(transaction.to).isZero()) {
            transaction.to = "0x0000000000000000000000000000000000000000";
        }
        // Rename input to data
        if (transaction.input != null && transaction.data == null) {
            transaction.data = transaction.input;
        }
        // If to and creates are empty, populate the creates from the transaction
        if (transaction.to == null && transaction.creates == null) {
            transaction.creates = this.contractAddress(transaction);
        }
        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
            transaction.accessList = [];
        }
        var result = Formatter.check(this.formats.transaction, transaction);
        if (transaction.chainId != null) {
            var chainId = transaction.chainId;
            if ((0, bytes_1.isHexString)(chainId)) {
                chainId = bignumber_1.BigNumber.from(chainId).toNumber();
            }
            result.chainId = chainId;
        }
        else {
            var chainId = transaction.networkId;
            // geth-etc returns chainId
            if (chainId == null && result.v == null) {
                chainId = transaction.chainId;
            }
            if ((0, bytes_1.isHexString)(chainId)) {
                chainId = bignumber_1.BigNumber.from(chainId).toNumber();
            }
            if (typeof (chainId) !== "number" && result.v != null) {
                chainId = (result.v - 35) / 2;
                if (chainId < 0) {
                    chainId = 0;
                }
                chainId = parseInt(chainId);
            }
            if (typeof (chainId) !== "number") {
                chainId = 0;
            }
            result.chainId = chainId;
        }
        // 0x0000... should actually be null
        if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
            result.blockHash = null;
        }
        return result;
    };
    Formatter.prototype.transaction = function (value) {
        return (0, transactions_1.parse)(value);
    };
    Formatter.prototype.receiptLog = function (value) {
        return Formatter.check(this.formats.receiptLog, value);
    };
    Formatter.prototype.receipt = function (value) {
        var result = Formatter.check(this.formats.receipt, value);
        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it
        if (result.root != null) {
            if (result.root.length <= 4) {
                // Could be 0x00, 0x0, 0x01 or 0x1
                var value_1 = bignumber_1.BigNumber.from(result.root).toNumber();
                if (value_1 === 0 || value_1 === 1) {
                    // Make sure if both are specified, they match
                    if (result.status != null && (result.status !== value_1)) {
                        logger.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
                    }
                    result.status = value_1;
                    delete result.root;
                }
                else {
                    logger.throwArgumentError("invalid alt-root-status", "value.root", result.root);
                }
            }
            else if (result.root.length !== 66) {
                // Must be a valid bytes32
                logger.throwArgumentError("invalid root hash", "value.root", result.root);
            }
        }
        if (result.status != null) {
            result.byzantium = true;
        }
        return result;
    };
    Formatter.prototype.topics = function (value) {
        var _this = this;
        if (Array.isArray(value)) {
            return value.map(function (v) { return _this.topics(v); });
        }
        else if (value != null) {
            return this.hash(value, true);
        }
        return null;
    };
    Formatter.prototype.filter = function (value) {
        return Formatter.check(this.formats.filter, value);
    };
    Formatter.prototype.filterLog = function (value) {
        return Formatter.check(this.formats.filterLog, value);
    };
    Formatter.check = function (format, object) {
        var result = {};
        for (var key in format) {
            try {
                var value = format[key](object[key]);
                if (value !== undefined) {
                    result[key] = value;
                }
            }
            catch (error) {
                error.checkKey = key;
                error.checkValue = object[key];
                throw error;
            }
        }
        return result;
    };
    // if value is null-ish, nullValue is returned
    Formatter.allowNull = function (format, nullValue) {
        return (function (value) {
            if (value == null) {
                return nullValue;
            }
            return format(value);
        });
    };
    // If value is false-ish, replaceValue is returned
    Formatter.allowFalsish = function (format, replaceValue) {
        return (function (value) {
            if (!value) {
                return replaceValue;
            }
            return format(value);
        });
    };
    // Requires an Array satisfying check
    Formatter.arrayOf = function (format) {
        return (function (array) {
            if (!Array.isArray(array)) {
                throw new Error("not an array");
            }
            var result = [];
            array.forEach(function (value) {
                result.push(format(value));
            });
            return result;
        });
    };
    return Formatter;
}());
exports.Formatter = Formatter;
function isCommunityResourcable(value) {
    return (value && typeof (value.isCommunityResource) === "function");
}
exports.isCommunityResourcable = isCommunityResourcable;
function isCommunityResource(value) {
    return (isCommunityResourcable(value) && value.isCommunityResource());
}
exports.isCommunityResource = isCommunityResource;
// Show the throttle message only once
var throttleMessage = false;
function showThrottleMessage() {
    if (throttleMessage) {
        return;
    }
    throttleMessage = true;
    console.log("========= NOTICE =========");
    console.log("Request-Rate Exceeded  (this message will not be repeated)");
    console.log("");
    console.log("The default API keys for each service are provided as a highly-throttled,");
    console.log("community resource for low-traffic projects and early prototyping.");
    console.log("");
    console.log("While your application will continue to function, we highly recommended");
    console.log("signing up for your own API keys to improve performance, increase your");
    console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
    console.log("");
    console.log("For more details: https:/\/docs.ethers.io/api-keys/");
    console.log("==========================");
}
exports.showThrottleMessage = showThrottleMessage;
//# sourceMappingURL=formatter.js.map

/***/ }),

/***/ 529:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Formatter = exports.showThrottleMessage = exports.isCommunityResourcable = exports.isCommunityResource = exports.getNetwork = exports.getDefaultProvider = exports.JsonRpcSigner = exports.IpcProvider = exports.WebSocketProvider = exports.Web3Provider = exports.StaticJsonRpcProvider = exports.PocketProvider = exports.NodesmithProvider = exports.JsonRpcBatchProvider = exports.JsonRpcProvider = exports.InfuraWebSocketProvider = exports.InfuraProvider = exports.EtherscanProvider = exports.CloudflareProvider = exports.AnkrProvider = exports.AlchemyWebSocketProvider = exports.AlchemyProvider = exports.FallbackProvider = exports.UrlJsonRpcProvider = exports.Resolver = exports.BaseProvider = exports.Provider = void 0;
var abstract_provider_1 = __nccwpck_require__(1698);
Object.defineProperty(exports, "Provider", ({ enumerable: true, get: function () { return abstract_provider_1.Provider; } }));
var networks_1 = __nccwpck_require__(1888);
Object.defineProperty(exports, "getNetwork", ({ enumerable: true, get: function () { return networks_1.getNetwork; } }));
var base_provider_1 = __nccwpck_require__(3387);
Object.defineProperty(exports, "BaseProvider", ({ enumerable: true, get: function () { return base_provider_1.BaseProvider; } }));
Object.defineProperty(exports, "Resolver", ({ enumerable: true, get: function () { return base_provider_1.Resolver; } }));
var alchemy_provider_1 = __nccwpck_require__(3738);
Object.defineProperty(exports, "AlchemyProvider", ({ enumerable: true, get: function () { return alchemy_provider_1.AlchemyProvider; } }));
Object.defineProperty(exports, "AlchemyWebSocketProvider", ({ enumerable: true, get: function () { return alchemy_provider_1.AlchemyWebSocketProvider; } }));
var ankr_provider_1 = __nccwpck_require__(841);
Object.defineProperty(exports, "AnkrProvider", ({ enumerable: true, get: function () { return ankr_provider_1.AnkrProvider; } }));
var cloudflare_provider_1 = __nccwpck_require__(1382);
Object.defineProperty(exports, "CloudflareProvider", ({ enumerable: true, get: function () { return cloudflare_provider_1.CloudflareProvider; } }));
var etherscan_provider_1 = __nccwpck_require__(304);
Object.defineProperty(exports, "EtherscanProvider", ({ enumerable: true, get: function () { return etherscan_provider_1.EtherscanProvider; } }));
var fallback_provider_1 = __nccwpck_require__(3702);
Object.defineProperty(exports, "FallbackProvider", ({ enumerable: true, get: function () { return fallback_provider_1.FallbackProvider; } }));
var ipc_provider_1 = __nccwpck_require__(1524);
Object.defineProperty(exports, "IpcProvider", ({ enumerable: true, get: function () { return ipc_provider_1.IpcProvider; } }));
var infura_provider_1 = __nccwpck_require__(211);
Object.defineProperty(exports, "InfuraProvider", ({ enumerable: true, get: function () { return infura_provider_1.InfuraProvider; } }));
Object.defineProperty(exports, "InfuraWebSocketProvider", ({ enumerable: true, get: function () { return infura_provider_1.InfuraWebSocketProvider; } }));
var json_rpc_provider_1 = __nccwpck_require__(1550);
Object.defineProperty(exports, "JsonRpcProvider", ({ enumerable: true, get: function () { return json_rpc_provider_1.JsonRpcProvider; } }));
Object.defineProperty(exports, "JsonRpcSigner", ({ enumerable: true, get: function () { return json_rpc_provider_1.JsonRpcSigner; } }));
var json_rpc_batch_provider_1 = __nccwpck_require__(2393);
Object.defineProperty(exports, "JsonRpcBatchProvider", ({ enumerable: true, get: function () { return json_rpc_batch_provider_1.JsonRpcBatchProvider; } }));
var nodesmith_provider_1 = __nccwpck_require__(5084);
Object.defineProperty(exports, "NodesmithProvider", ({ enumerable: true, get: function () { return nodesmith_provider_1.NodesmithProvider; } }));
var pocket_provider_1 = __nccwpck_require__(9939);
Object.defineProperty(exports, "PocketProvider", ({ enumerable: true, get: function () { return pocket_provider_1.PocketProvider; } }));
var url_json_rpc_provider_1 = __nccwpck_require__(3480);
Object.defineProperty(exports, "StaticJsonRpcProvider", ({ enumerable: true, get: function () { return url_json_rpc_provider_1.StaticJsonRpcProvider; } }));
Object.defineProperty(exports, "UrlJsonRpcProvider", ({ enumerable: true, get: function () { return url_json_rpc_provider_1.UrlJsonRpcProvider; } }));
var web3_provider_1 = __nccwpck_require__(6881);
Object.defineProperty(exports, "Web3Provider", ({ enumerable: true, get: function () { return web3_provider_1.Web3Provider; } }));
var websocket_provider_1 = __nccwpck_require__(4405);
Object.defineProperty(exports, "WebSocketProvider", ({ enumerable: true, get: function () { return websocket_provider_1.WebSocketProvider; } }));
var formatter_1 = __nccwpck_require__(3995);
Object.defineProperty(exports, "Formatter", ({ enumerable: true, get: function () { return formatter_1.Formatter; } }));
Object.defineProperty(exports, "isCommunityResourcable", ({ enumerable: true, get: function () { return formatter_1.isCommunityResourcable; } }));
Object.defineProperty(exports, "isCommunityResource", ({ enumerable: true, get: function () { return formatter_1.isCommunityResource; } }));
Object.defineProperty(exports, "showThrottleMessage", ({ enumerable: true, get: function () { return formatter_1.showThrottleMessage; } }));
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(1594);
var logger = new logger_1.Logger(_version_1.version);
////////////////////////
// Helper Functions
function getDefaultProvider(network, options) {
    if (network == null) {
        network = "homestead";
    }
    // If passed a URL, figure out the right type of provider based on the scheme
    if (typeof (network) === "string") {
        // @TODO: Add support for IpcProvider; maybe if it ends in ".ipc"?
        // Handle http and ws (and their secure variants)
        var match = network.match(/^(ws|http)s?:/i);
        if (match) {
            switch (match[1].toLowerCase()) {
                case "http":
                case "https":
                    return new json_rpc_provider_1.JsonRpcProvider(network);
                case "ws":
                case "wss":
                    return new websocket_provider_1.WebSocketProvider(network);
                default:
                    logger.throwArgumentError("unsupported URL scheme", "network", network);
            }
        }
    }
    var n = (0, networks_1.getNetwork)(network);
    if (!n || !n._defaultProvider) {
        logger.throwError("unsupported getDefaultProvider network", logger_1.Logger.errors.NETWORK_ERROR, {
            operation: "getDefaultProvider",
            network: network
        });
    }
    return n._defaultProvider({
        FallbackProvider: fallback_provider_1.FallbackProvider,
        AlchemyProvider: alchemy_provider_1.AlchemyProvider,
        AnkrProvider: ankr_provider_1.AnkrProvider,
        CloudflareProvider: cloudflare_provider_1.CloudflareProvider,
        EtherscanProvider: etherscan_provider_1.EtherscanProvider,
        InfuraProvider: infura_provider_1.InfuraProvider,
        JsonRpcProvider: json_rpc_provider_1.JsonRpcProvider,
        NodesmithProvider: nodesmith_provider_1.NodesmithProvider,
        PocketProvider: pocket_provider_1.PocketProvider,
        Web3Provider: web3_provider_1.Web3Provider,
        IpcProvider: ipc_provider_1.IpcProvider,
    }, options);
}
exports.getDefaultProvider = getDefaultProvider;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 211:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InfuraProvider = exports.InfuraWebSocketProvider = void 0;
var properties_1 = __nccwpck_require__(8078);
var websocket_provider_1 = __nccwpck_require__(4405);
var formatter_1 = __nccwpck_require__(3995);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(1594);
var logger = new logger_1.Logger(_version_1.version);
var url_json_rpc_provider_1 = __nccwpck_require__(3480);
var defaultProjectId = "84842078b09946638c03157f83405213";
var InfuraWebSocketProvider = /** @class */ (function (_super) {
    __extends(InfuraWebSocketProvider, _super);
    function InfuraWebSocketProvider(network, apiKey) {
        var _this = this;
        var provider = new InfuraProvider(network, apiKey);
        var connection = provider.connection;
        if (connection.password) {
            logger.throwError("INFURA WebSocket project secrets unsupported", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "InfuraProvider.getWebSocketProvider()"
            });
        }
        var url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
        _this = _super.call(this, url, network) || this;
        (0, properties_1.defineReadOnly)(_this, "apiKey", provider.projectId);
        (0, properties_1.defineReadOnly)(_this, "projectId", provider.projectId);
        (0, properties_1.defineReadOnly)(_this, "projectSecret", provider.projectSecret);
        return _this;
    }
    InfuraWebSocketProvider.prototype.isCommunityResource = function () {
        return (this.projectId === defaultProjectId);
    };
    return InfuraWebSocketProvider;
}(websocket_provider_1.WebSocketProvider));
exports.InfuraWebSocketProvider = InfuraWebSocketProvider;
var InfuraProvider = /** @class */ (function (_super) {
    __extends(InfuraProvider, _super);
    function InfuraProvider() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InfuraProvider.getWebSocketProvider = function (network, apiKey) {
        return new InfuraWebSocketProvider(network, apiKey);
    };
    InfuraProvider.getApiKey = function (apiKey) {
        var apiKeyObj = {
            apiKey: defaultProjectId,
            projectId: defaultProjectId,
            projectSecret: null
        };
        if (apiKey == null) {
            return apiKeyObj;
        }
        if (typeof (apiKey) === "string") {
            apiKeyObj.projectId = apiKey;
        }
        else if (apiKey.projectSecret != null) {
            logger.assertArgument((typeof (apiKey.projectId) === "string"), "projectSecret requires a projectId", "projectId", apiKey.projectId);
            logger.assertArgument((typeof (apiKey.projectSecret) === "string"), "invalid projectSecret", "projectSecret", "[REDACTED]");
            apiKeyObj.projectId = apiKey.projectId;
            apiKeyObj.projectSecret = apiKey.projectSecret;
        }
        else if (apiKey.projectId) {
            apiKeyObj.projectId = apiKey.projectId;
        }
        apiKeyObj.apiKey = apiKeyObj.projectId;
        return apiKeyObj;
    };
    InfuraProvider.getUrl = function (network, apiKey) {
        var host = null;
        switch (network ? network.name : "unknown") {
            case "homestead":
                host = "mainnet.infura.io";
                break;
            case "goerli":
                host = "goerli.infura.io";
                break;
            case "sepolia":
                host = "sepolia.infura.io";
                break;
            case "matic":
                host = "polygon-mainnet.infura.io";
                break;
            case "maticmum":
                host = "polygon-mumbai.infura.io";
                break;
            case "optimism":
                host = "optimism-mainnet.infura.io";
                break;
            case "optimism-goerli":
                host = "optimism-goerli.infura.io";
                break;
            case "arbitrum":
                host = "arbitrum-mainnet.infura.io";
                break;
            case "arbitrum-goerli":
                host = "arbitrum-goerli.infura.io";
                break;
            default:
                logger.throwError("unsupported network", logger_1.Logger.errors.INVALID_ARGUMENT, {
                    argument: "network",
                    value: network
                });
        }
        var connection = {
            allowGzip: true,
            url: ("https:/" + "/" + host + "/v3/" + apiKey.projectId),
            throttleCallback: function (attempt, url) {
                if (apiKey.projectId === defaultProjectId) {
                    (0, formatter_1.showThrottleMessage)();
                }
                return Promise.resolve(true);
            }
        };
        if (apiKey.projectSecret != null) {
            connection.user = "";
            connection.password = apiKey.projectSecret;
        }
        return connection;
    };
    InfuraProvider.prototype.isCommunityResource = function () {
        return (this.projectId === defaultProjectId);
    };
    return InfuraProvider;
}(url_json_rpc_provider_1.UrlJsonRpcProvider));
exports.InfuraProvider = InfuraProvider;
//# sourceMappingURL=infura-provider.js.map

/***/ }),

/***/ 1524:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IpcProvider = void 0;
var net_1 = __nccwpck_require__(1808);
var properties_1 = __nccwpck_require__(8078);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(1594);
var logger = new logger_1.Logger(_version_1.version);
var json_rpc_provider_1 = __nccwpck_require__(1550);
var IpcProvider = /** @class */ (function (_super) {
    __extends(IpcProvider, _super);
    function IpcProvider(path, network) {
        var _this = this;
        if (path == null) {
            logger.throwError("missing path", logger_1.Logger.errors.MISSING_ARGUMENT, { arg: "path" });
        }
        _this = _super.call(this, "ipc://" + path, network) || this;
        (0, properties_1.defineReadOnly)(_this, "path", path);
        return _this;
    }
    // @TODO: Create a connection to the IPC path and use filters instead of polling for block
    IpcProvider.prototype.send = function (method, params) {
        // This method is very simple right now. We create a new socket
        // connection each time, which may be slower, but the main
        // advantage we are aiming for now is security. This simplifies
        // multiplexing requests (since we do not need to multiplex).
        var _this = this;
        var payload = JSON.stringify({
            method: method,
            params: params,
            id: 42,
            jsonrpc: "2.0"
        });
        return new Promise(function (resolve, reject) {
            var response = Buffer.alloc(0);
            var stream = (0, net_1.connect)(_this.path);
            stream.on("data", function (data) {
                response = Buffer.concat([response, data]);
            });
            stream.on("end", function () {
                try {
                    resolve(JSON.parse(response.toString()).result);
                    // @TODO: Better pull apart the error
                    stream.destroy();
                }
                catch (error) {
                    reject(error);
                    stream.destroy();
                }
            });
            stream.on("error", function (error) {
                reject(error);
                stream.destroy();
            });
            stream.write(payload);
            stream.end();
        });
    };
    return IpcProvider;
}(json_rpc_provider_1.JsonRpcProvider));
exports.IpcProvider = IpcProvider;
//# sourceMappingURL=ipc-provider.js.map

/***/ }),

/***/ 2393:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonRpcBatchProvider = void 0;
var properties_1 = __nccwpck_require__(8078);
var web_1 = __nccwpck_require__(3138);
var json_rpc_provider_1 = __nccwpck_require__(1550);
// Experimental
var JsonRpcBatchProvider = /** @class */ (function (_super) {
    __extends(JsonRpcBatchProvider, _super);
    function JsonRpcBatchProvider() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    JsonRpcBatchProvider.prototype.send = function (method, params) {
        var _this = this;
        var request = {
            method: method,
            params: params,
            id: (this._nextId++),
            jsonrpc: "2.0"
        };
        if (this._pendingBatch == null) {
            this._pendingBatch = [];
        }
        var inflightRequest = { request: request, resolve: null, reject: null };
        var promise = new Promise(function (resolve, reject) {
            inflightRequest.resolve = resolve;
            inflightRequest.reject = reject;
        });
        this._pendingBatch.push(inflightRequest);
        if (!this._pendingBatchAggregator) {
            // Schedule batch for next event loop + short duration
            this._pendingBatchAggregator = setTimeout(function () {
                // Get teh current batch and clear it, so new requests
                // go into the next batch
                var batch = _this._pendingBatch;
                _this._pendingBatch = null;
                _this._pendingBatchAggregator = null;
                // Get the request as an array of requests
                var request = batch.map(function (inflight) { return inflight.request; });
                _this.emit("debug", {
                    action: "requestBatch",
                    request: (0, properties_1.deepCopy)(request),
                    provider: _this
                });
                return (0, web_1.fetchJson)(_this.connection, JSON.stringify(request)).then(function (result) {
                    _this.emit("debug", {
                        action: "response",
                        request: request,
                        response: result,
                        provider: _this
                    });
                    // For each result, feed it to the correct Promise, depending
                    // on whether it was a success or error
                    batch.forEach(function (inflightRequest, index) {
                        var payload = result[index];
                        if (payload.error) {
                            var error = new Error(payload.error.message);
                            error.code = payload.error.code;
                            error.data = payload.error.data;
                            inflightRequest.reject(error);
                        }
                        else {
                            inflightRequest.resolve(payload.result);
                        }
                    });
                }, function (error) {
                    _this.emit("debug", {
                        action: "response",
                        error: error,
                        request: request,
                        provider: _this
                    });
                    batch.forEach(function (inflightRequest) {
                        inflightRequest.reject(error);
                    });
                });
            }, 10);
        }
        return promise;
    };
    return JsonRpcBatchProvider;
}(json_rpc_provider_1.JsonRpcProvider));
exports.JsonRpcBatchProvider = JsonRpcBatchProvider;
//# sourceMappingURL=json-rpc-batch-provider.js.map

/***/ }),

/***/ 1550:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonRpcProvider = exports.JsonRpcSigner = void 0;
var abstract_signer_1 = __nccwpck_require__(6324);
var bignumber_1 = __nccwpck_require__(1267);
var bytes_1 = __nccwpck_require__(2056);
var hash_1 = __nccwpck_require__(7866);
var properties_1 = __nccwpck_require__(8078);
var strings_1 = __nccwpck_require__(9115);
var transactions_1 = __nccwpck_require__(2449);
var web_1 = __nccwpck_require__(3138);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(1594);
var logger = new logger_1.Logger(_version_1.version);
var base_provider_1 = __nccwpck_require__(3387);
var errorGas = ["call", "estimateGas"];
function spelunk(value, requireData) {
    if (value == null) {
        return null;
    }
    // These *are* the droids we're looking for.
    if (typeof (value.message) === "string" && value.message.match("reverted")) {
        var data = (0, bytes_1.isHexString)(value.data) ? value.data : null;
        if (!requireData || data) {
            return { message: value.message, data: data };
        }
    }
    // Spelunk further...
    if (typeof (value) === "object") {
        for (var key in value) {
            var result = spelunk(value[key], requireData);
            if (result) {
                return result;
            }
        }
        return null;
    }
    // Might be a JSON string we can further descend...
    if (typeof (value) === "string") {
        try {
            return spelunk(JSON.parse(value), requireData);
        }
        catch (error) { }
    }
    return null;
}
function checkError(method, error, params) {
    var transaction = params.transaction || params.signedTransaction;
    // Undo the "convenience" some nodes are attempting to prevent backwards
    // incompatibility; maybe for v6 consider forwarding reverts as errors
    if (method === "call") {
        var result = spelunk(error, true);
        if (result) {
            return result.data;
        }
        // Nothing descriptive..
        logger.throwError("missing revert data in call exception; Transaction reverted without a reason string", logger_1.Logger.errors.CALL_EXCEPTION, {
            data: "0x",
            transaction: transaction,
            error: error
        });
    }
    if (method === "estimateGas") {
        // Try to find something, with a preference on SERVER_ERROR body
        var result = spelunk(error.body, false);
        if (result == null) {
            result = spelunk(error, false);
        }
        // Found "reverted", this is a CALL_EXCEPTION
        if (result) {
            logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
                reason: result.message,
                method: method,
                transaction: transaction,
                error: error
            });
        }
    }
    // @TODO: Should we spelunk for message too?
    var message = error.message;
    if (error.code === logger_1.Logger.errors.SERVER_ERROR && error.error && typeof (error.error.message) === "string") {
        message = error.error.message;
    }
    else if (typeof (error.body) === "string") {
        message = error.body;
    }
    else if (typeof (error.responseText) === "string") {
        message = error.responseText;
    }
    message = (message || "").toLowerCase();
    // "insufficient funds for gas * price + value + cost(data)"
    if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {
        logger.throwError("insufficient funds for intrinsic transaction cost", logger_1.Logger.errors.INSUFFICIENT_FUNDS, {
            error: error,
            method: method,
            transaction: transaction
        });
    }
    // "nonce too low"
    if (message.match(/nonce (is )?too low/i)) {
        logger.throwError("nonce has already been used", logger_1.Logger.errors.NONCE_EXPIRED, {
            error: error,
            method: method,
            transaction: transaction
        });
    }
    // "replacement transaction underpriced"
    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
        logger.throwError("replacement fee too low", logger_1.Logger.errors.REPLACEMENT_UNDERPRICED, {
            error: error,
            method: method,
            transaction: transaction
        });
    }
    // "replacement transaction underpriced"
    if (message.match(/only replay-protected/i)) {
        logger.throwError("legacy pre-eip-155 transactions not supported", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            error: error,
            method: method,
            transaction: transaction
        });
    }
    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {
        logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
            error: error,
            method: method,
            transaction: transaction
        });
    }
    throw error;
}
function timer(timeout) {
    return new Promise(function (resolve) {
        setTimeout(resolve, timeout);
    });
}
function getResult(payload) {
    if (payload.error) {
        // @TODO: not any
        var error = new Error(payload.error.message);
        error.code = payload.error.code;
        error.data = payload.error.data;
        throw error;
    }
    return payload.result;
}
function getLowerCase(value) {
    if (value) {
        return value.toLowerCase();
    }
    return value;
}
var _constructorGuard = {};
var JsonRpcSigner = /** @class */ (function (_super) {
    __extends(JsonRpcSigner, _super);
    function JsonRpcSigner(constructorGuard, provider, addressOrIndex) {
        var _this = _super.call(this) || this;
        if (constructorGuard !== _constructorGuard) {
            throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
        }
        (0, properties_1.defineReadOnly)(_this, "provider", provider);
        if (addressOrIndex == null) {
            addressOrIndex = 0;
        }
        if (typeof (addressOrIndex) === "string") {
            (0, properties_1.defineReadOnly)(_this, "_address", _this.provider.formatter.address(addressOrIndex));
            (0, properties_1.defineReadOnly)(_this, "_index", null);
        }
        else if (typeof (addressOrIndex) === "number") {
            (0, properties_1.defineReadOnly)(_this, "_index", addressOrIndex);
            (0, properties_1.defineReadOnly)(_this, "_address", null);
        }
        else {
            logger.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
        }
        return _this;
    }
    JsonRpcSigner.prototype.connect = function (provider) {
        return logger.throwError("cannot alter JSON-RPC Signer connection", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "connect"
        });
    };
    JsonRpcSigner.prototype.connectUnchecked = function () {
        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
    };
    JsonRpcSigner.prototype.getAddress = function () {
        var _this = this;
        if (this._address) {
            return Promise.resolve(this._address);
        }
        return this.provider.send("eth_accounts", []).then(function (accounts) {
            if (accounts.length <= _this._index) {
                logger.throwError("unknown account #" + _this._index, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "getAddress"
                });
            }
            return _this.provider.formatter.address(accounts[_this._index]);
        });
    };
    JsonRpcSigner.prototype.sendUncheckedTransaction = function (transaction) {
        var _this = this;
        transaction = (0, properties_1.shallowCopy)(transaction);
        var fromAddress = this.getAddress().then(function (address) {
            if (address) {
                address = address.toLowerCase();
            }
            return address;
        });
        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user
        // wishes to use this, it is easy to specify explicitly, otherwise
        // we look it up for them.
        if (transaction.gasLimit == null) {
            var estimate = (0, properties_1.shallowCopy)(transaction);
            estimate.from = fromAddress;
            transaction.gasLimit = this.provider.estimateGas(estimate);
        }
        if (transaction.to != null) {
            transaction.to = Promise.resolve(transaction.to).then(function (to) { return __awaiter(_this, void 0, void 0, function () {
                var address;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (to == null) {
                                return [2 /*return*/, null];
                            }
                            return [4 /*yield*/, this.provider.resolveName(to)];
                        case 1:
                            address = _a.sent();
                            if (address == null) {
                                logger.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
                            }
                            return [2 /*return*/, address];
                    }
                });
            }); });
        }
        return (0, properties_1.resolveProperties)({
            tx: (0, properties_1.resolveProperties)(transaction),
            sender: fromAddress
        }).then(function (_a) {
            var tx = _a.tx, sender = _a.sender;
            if (tx.from != null) {
                if (tx.from.toLowerCase() !== sender) {
                    logger.throwArgumentError("from address mismatch", "transaction", transaction);
                }
            }
            else {
                tx.from = sender;
            }
            var hexTx = _this.provider.constructor.hexlifyTransaction(tx, { from: true });
            return _this.provider.send("eth_sendTransaction", [hexTx]).then(function (hash) {
                return hash;
            }, function (error) {
                if (typeof (error.message) === "string" && error.message.match(/user denied/i)) {
                    logger.throwError("user rejected transaction", logger_1.Logger.errors.ACTION_REJECTED, {
                        action: "sendTransaction",
                        transaction: tx
                    });
                }
                return checkError("sendTransaction", error, hexTx);
            });
        });
    };
    JsonRpcSigner.prototype.signTransaction = function (transaction) {
        return logger.throwError("signing transactions is unsupported", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "signTransaction"
        });
    };
    JsonRpcSigner.prototype.sendTransaction = function (transaction) {
        return __awaiter(this, void 0, void 0, function () {
            var blockNumber, hash, error_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval)];
                    case 1:
                        blockNumber = _a.sent();
                        return [4 /*yield*/, this.sendUncheckedTransaction(transaction)];
                    case 2:
                        hash = _a.sent();
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, (0, web_1.poll)(function () { return __awaiter(_this, void 0, void 0, function () {
                                var tx;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.provider.getTransaction(hash)];
                                        case 1:
                                            tx = _a.sent();
                                            if (tx === null) {
                                                return [2 /*return*/, undefined];
                                            }
                                            return [2 /*return*/, this.provider._wrapTransaction(tx, hash, blockNumber)];
                                    }
                                });
                            }); }, { oncePoll: this.provider })];
                    case 4: 
                    // Unfortunately, JSON-RPC only provides and opaque transaction hash
                    // for a response, and we need the actual transaction, so we poll
                    // for it; it should show up very quickly
                    return [2 /*return*/, _a.sent()];
                    case 5:
                        error_1 = _a.sent();
                        error_1.transactionHash = hash;
                        throw error_1;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    JsonRpcSigner.prototype.signMessage = function (message) {
        return __awaiter(this, void 0, void 0, function () {
            var data, address, error_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        data = ((typeof (message) === "string") ? (0, strings_1.toUtf8Bytes)(message) : message);
                        return [4 /*yield*/, this.getAddress()];
                    case 1:
                        address = _a.sent();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, this.provider.send("personal_sign", [(0, bytes_1.hexlify)(data), address.toLowerCase()])];
                    case 3: return [2 /*return*/, _a.sent()];
                    case 4:
                        error_2 = _a.sent();
                        if (typeof (error_2.message) === "string" && error_2.message.match(/user denied/i)) {
                            logger.throwError("user rejected signing", logger_1.Logger.errors.ACTION_REJECTED, {
                                action: "signMessage",
                                from: address,
                                messageData: message
                            });
                        }
                        throw error_2;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    JsonRpcSigner.prototype._legacySignMessage = function (message) {
        return __awaiter(this, void 0, void 0, function () {
            var data, address, error_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        data = ((typeof (message) === "string") ? (0, strings_1.toUtf8Bytes)(message) : message);
                        return [4 /*yield*/, this.getAddress()];
                    case 1:
                        address = _a.sent();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, this.provider.send("eth_sign", [address.toLowerCase(), (0, bytes_1.hexlify)(data)])];
                    case 3: 
                    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
                    return [2 /*return*/, _a.sent()];
                    case 4:
                        error_3 = _a.sent();
                        if (typeof (error_3.message) === "string" && error_3.message.match(/user denied/i)) {
                            logger.throwError("user rejected signing", logger_1.Logger.errors.ACTION_REJECTED, {
                                action: "_legacySignMessage",
                                from: address,
                                messageData: message
                            });
                        }
                        throw error_3;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    JsonRpcSigner.prototype._signTypedData = function (domain, types, value) {
        return __awaiter(this, void 0, void 0, function () {
            var populated, address, error_4;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, hash_1._TypedDataEncoder.resolveNames(domain, types, value, function (name) {
                            return _this.provider.resolveName(name);
                        })];
                    case 1:
                        populated = _a.sent();
                        return [4 /*yield*/, this.getAddress()];
                    case 2:
                        address = _a.sent();
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, this.provider.send("eth_signTypedData_v4", [
                                address.toLowerCase(),
                                JSON.stringify(hash_1._TypedDataEncoder.getPayload(populated.domain, types, populated.value))
                            ])];
                    case 4: return [2 /*return*/, _a.sent()];
                    case 5:
                        error_4 = _a.sent();
                        if (typeof (error_4.message) === "string" && error_4.message.match(/user denied/i)) {
                            logger.throwError("user rejected signing", logger_1.Logger.errors.ACTION_REJECTED, {
                                action: "_signTypedData",
                                from: address,
                                messageData: { domain: populated.domain, types: types, value: populated.value }
                            });
                        }
                        throw error_4;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    JsonRpcSigner.prototype.unlock = function (password) {
        return __awaiter(this, void 0, void 0, function () {
            var provider, address;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        provider = this.provider;
                        return [4 /*yield*/, this.getAddress()];
                    case 1:
                        address = _a.sent();
                        return [2 /*return*/, provider.send("personal_unlockAccount", [address.toLowerCase(), password, null])];
                }
            });
        });
    };
    return JsonRpcSigner;
}(abstract_signer_1.Signer));
exports.JsonRpcSigner = JsonRpcSigner;
var UncheckedJsonRpcSigner = /** @class */ (function (_super) {
    __extends(UncheckedJsonRpcSigner, _super);
    function UncheckedJsonRpcSigner() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UncheckedJsonRpcSigner.prototype.sendTransaction = function (transaction) {
        var _this = this;
        return this.sendUncheckedTransaction(transaction).then(function (hash) {
            return {
                hash: hash,
                nonce: null,
                gasLimit: null,
                gasPrice: null,
                data: null,
                value: null,
                chainId: null,
                confirmations: 0,
                from: null,
                wait: function (confirmations) { return _this.provider.waitForTransaction(hash, confirmations); }
            };
        });
    };
    return UncheckedJsonRpcSigner;
}(JsonRpcSigner));
var allowedTransactionKeys = {
    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,
    type: true, accessList: true,
    maxFeePerGas: true, maxPriorityFeePerGas: true
};
var JsonRpcProvider = /** @class */ (function (_super) {
    __extends(JsonRpcProvider, _super);
    function JsonRpcProvider(url, network) {
        var _this = this;
        var networkOrReady = network;
        // The network is unknown, query the JSON-RPC for it
        if (networkOrReady == null) {
            networkOrReady = new Promise(function (resolve, reject) {
                setTimeout(function () {
                    _this.detectNetwork().then(function (network) {
                        resolve(network);
                    }, function (error) {
                        reject(error);
                    });
                }, 0);
            });
        }
        _this = _super.call(this, networkOrReady) || this;
        // Default URL
        if (!url) {
            url = (0, properties_1.getStatic)(_this.constructor, "defaultUrl")();
        }
        if (typeof (url) === "string") {
            (0, properties_1.defineReadOnly)(_this, "connection", Object.freeze({
                url: url
            }));
        }
        else {
            (0, properties_1.defineReadOnly)(_this, "connection", Object.freeze((0, properties_1.shallowCopy)(url)));
        }
        _this._nextId = 42;
        return _this;
    }
    Object.defineProperty(JsonRpcProvider.prototype, "_cache", {
        get: function () {
            if (this._eventLoopCache == null) {
                this._eventLoopCache = {};
            }
            return this._eventLoopCache;
        },
        enumerable: false,
        configurable: true
    });
    JsonRpcProvider.defaultUrl = function () {
        return "http:/\/localhost:8545";
    };
    JsonRpcProvider.prototype.detectNetwork = function () {
        var _this = this;
        if (!this._cache["detectNetwork"]) {
            this._cache["detectNetwork"] = this._uncachedDetectNetwork();
            // Clear this cache at the beginning of the next event loop
            setTimeout(function () {
                _this._cache["detectNetwork"] = null;
            }, 0);
        }
        return this._cache["detectNetwork"];
    };
    JsonRpcProvider.prototype._uncachedDetectNetwork = function () {
        return __awaiter(this, void 0, void 0, function () {
            var chainId, error_5, error_6, getNetwork;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, timer(0)];
                    case 1:
                        _a.sent();
                        chainId = null;
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 9]);
                        return [4 /*yield*/, this.send("eth_chainId", [])];
                    case 3:
                        chainId = _a.sent();
                        return [3 /*break*/, 9];
                    case 4:
                        error_5 = _a.sent();
                        _a.label = 5;
                    case 5:
                        _a.trys.push([5, 7, , 8]);
                        return [4 /*yield*/, this.send("net_version", [])];
                    case 6:
                        chainId = _a.sent();
                        return [3 /*break*/, 8];
                    case 7:
                        error_6 = _a.sent();
                        return [3 /*break*/, 8];
                    case 8: return [3 /*break*/, 9];
                    case 9:
                        if (chainId != null) {
                            getNetwork = (0, properties_1.getStatic)(this.constructor, "getNetwork");
                            try {
                                return [2 /*return*/, getNetwork(bignumber_1.BigNumber.from(chainId).toNumber())];
                            }
                            catch (error) {
                                return [2 /*return*/, logger.throwError("could not detect network", logger_1.Logger.errors.NETWORK_ERROR, {
                                        chainId: chainId,
                                        event: "invalidNetwork",
                                        serverError: error
                                    })];
                            }
                        }
                        return [2 /*return*/, logger.throwError("could not detect network", logger_1.Logger.errors.NETWORK_ERROR, {
                                event: "noNetwork"
                            })];
                }
            });
        });
    };
    JsonRpcProvider.prototype.getSigner = function (addressOrIndex) {
        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);
    };
    JsonRpcProvider.prototype.getUncheckedSigner = function (addressOrIndex) {
        return this.getSigner(addressOrIndex).connectUnchecked();
    };
    JsonRpcProvider.prototype.listAccounts = function () {
        var _this = this;
        return this.send("eth_accounts", []).then(function (accounts) {
            return accounts.map(function (a) { return _this.formatter.address(a); });
        });
    };
    JsonRpcProvider.prototype.send = function (method, params) {
        var _this = this;
        var request = {
            method: method,
            params: params,
            id: (this._nextId++),
            jsonrpc: "2.0"
        };
        this.emit("debug", {
            action: "request",
            request: (0, properties_1.deepCopy)(request),
            provider: this
        });
        // We can expand this in the future to any call, but for now these
        // are the biggest wins and do not require any serializing parameters.
        var cache = (["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0);
        if (cache && this._cache[method]) {
            return this._cache[method];
        }
        var result = (0, web_1.fetchJson)(this.connection, JSON.stringify(request), getResult).then(function (result) {
            _this.emit("debug", {
                action: "response",
                request: request,
                response: result,
                provider: _this
            });
            return result;
        }, function (error) {
            _this.emit("debug", {
                action: "response",
                error: error,
                request: request,
                provider: _this
            });
            throw error;
        });
        // Cache the fetch, but clear it on the next event loop
        if (cache) {
            this._cache[method] = result;
            setTimeout(function () {
                _this._cache[method] = null;
            }, 0);
        }
        return result;
    };
    JsonRpcProvider.prototype.prepareRequest = function (method, params) {
        switch (method) {
            case "getBlockNumber":
                return ["eth_blockNumber", []];
            case "getGasPrice":
                return ["eth_gasPrice", []];
            case "getBalance":
                return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
            case "getTransactionCount":
                return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
            case "getCode":
                return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
            case "getStorageAt":
                return ["eth_getStorageAt", [getLowerCase(params.address), (0, bytes_1.hexZeroPad)(params.position, 32), params.blockTag]];
            case "sendTransaction":
                return ["eth_sendRawTransaction", [params.signedTransaction]];
            case "getBlock":
                if (params.blockTag) {
                    return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
                }
                else if (params.blockHash) {
                    return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
                }
                return null;
            case "getTransaction":
                return ["eth_getTransactionByHash", [params.transactionHash]];
            case "getTransactionReceipt":
                return ["eth_getTransactionReceipt", [params.transactionHash]];
            case "call": {
                var hexlifyTransaction = (0, properties_1.getStatic)(this.constructor, "hexlifyTransaction");
                return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
            }
            case "estimateGas": {
                var hexlifyTransaction = (0, properties_1.getStatic)(this.constructor, "hexlifyTransaction");
                return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
            }
            case "getLogs":
                if (params.filter && params.filter.address != null) {
                    params.filter.address = getLowerCase(params.filter.address);
                }
                return ["eth_getLogs", [params.filter]];
            default:
                break;
        }
        return null;
    };
    JsonRpcProvider.prototype.perform = function (method, params) {
        return __awaiter(this, void 0, void 0, function () {
            var tx, feeData, args, error_7;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(method === "call" || method === "estimateGas")) return [3 /*break*/, 2];
                        tx = params.transaction;
                        if (!(tx && tx.type != null && bignumber_1.BigNumber.from(tx.type).isZero())) return [3 /*break*/, 2];
                        if (!(tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getFeeData()];
                    case 1:
                        feeData = _a.sent();
                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                            // Network doesn't know about EIP-1559 (and hence type)
                            params = (0, properties_1.shallowCopy)(params);
                            params.transaction = (0, properties_1.shallowCopy)(tx);
                            delete params.transaction.type;
                        }
                        _a.label = 2;
                    case 2:
                        args = this.prepareRequest(method, params);
                        if (args == null) {
                            logger.throwError(method + " not implemented", logger_1.Logger.errors.NOT_IMPLEMENTED, { operation: method });
                        }
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, this.send(args[0], args[1])];
                    case 4: return [2 /*return*/, _a.sent()];
                    case 5:
                        error_7 = _a.sent();
                        return [2 /*return*/, checkError(method, error_7, params)];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    JsonRpcProvider.prototype._startEvent = function (event) {
        if (event.tag === "pending") {
            this._startPending();
        }
        _super.prototype._startEvent.call(this, event);
    };
    JsonRpcProvider.prototype._startPending = function () {
        if (this._pendingFilter != null) {
            return;
        }
        var self = this;
        var pendingFilter = this.send("eth_newPendingTransactionFilter", []);
        this._pendingFilter = pendingFilter;
        pendingFilter.then(function (filterId) {
            function poll() {
                self.send("eth_getFilterChanges", [filterId]).then(function (hashes) {
                    if (self._pendingFilter != pendingFilter) {
                        return null;
                    }
                    var seq = Promise.resolve();
                    hashes.forEach(function (hash) {
                        // @TODO: This should be garbage collected at some point... How? When?
                        self._emitted["t:" + hash.toLowerCase()] = "pending";
                        seq = seq.then(function () {
                            return self.getTransaction(hash).then(function (tx) {
                                self.emit("pending", tx);
                                return null;
                            });
                        });
                    });
                    return seq.then(function () {
                        return timer(1000);
                    });
                }).then(function () {
                    if (self._pendingFilter != pendingFilter) {
                        self.send("eth_uninstallFilter", [filterId]);
                        return;
                    }
                    setTimeout(function () { poll(); }, 0);
                    return null;
                }).catch(function (error) { });
            }
            poll();
            return filterId;
        }).catch(function (error) { });
    };
    JsonRpcProvider.prototype._stopEvent = function (event) {
        if (event.tag === "pending" && this.listenerCount("pending") === 0) {
            this._pendingFilter = null;
        }
        _super.prototype._stopEvent.call(this, event);
    };
    // Convert an ethers.js transaction into a JSON-RPC transaction
    //  - gasLimit => gas
    //  - All values hexlified
    //  - All numeric values zero-striped
    //  - All addresses are lowercased
    // NOTE: This allows a TransactionRequest, but all values should be resolved
    //       before this is called
    // @TODO: This will likely be removed in future versions and prepareRequest
    //        will be the preferred method for this.
    JsonRpcProvider.hexlifyTransaction = function (transaction, allowExtra) {
        // Check only allowed properties are given
        var allowed = (0, properties_1.shallowCopy)(allowedTransactionKeys);
        if (allowExtra) {
            for (var key in allowExtra) {
                if (allowExtra[key]) {
                    allowed[key] = true;
                }
            }
        }
        (0, properties_1.checkProperties)(transaction, allowed);
        var result = {};
        // JSON-RPC now requires numeric values to be "quantity" values
        ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function (key) {
            if (transaction[key] == null) {
                return;
            }
            var value = (0, bytes_1.hexValue)(bignumber_1.BigNumber.from(transaction[key]));
            if (key === "gasLimit") {
                key = "gas";
            }
            result[key] = value;
        });
        ["from", "to", "data"].forEach(function (key) {
            if (transaction[key] == null) {
                return;
            }
            result[key] = (0, bytes_1.hexlify)(transaction[key]);
        });
        if (transaction.accessList) {
            result["accessList"] = (0, transactions_1.accessListify)(transaction.accessList);
        }
        return result;
    };
    return JsonRpcProvider;
}(base_provider_1.BaseProvider));
exports.JsonRpcProvider = JsonRpcProvider;
//# sourceMappingURL=json-rpc-provider.js.map

/***/ }),

/***/ 5084:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";
/* istanbul ignore file */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodesmithProvider = void 0;
var url_json_rpc_provider_1 = __nccwpck_require__(3480);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(1594);
var logger = new logger_1.Logger(_version_1.version);
// Special API key provided by Nodesmith for ethers.js
var defaultApiKey = "ETHERS_JS_SHARED";
var NodesmithProvider = /** @class */ (function (_super) {
    __extends(NodesmithProvider, _super);
    function NodesmithProvider() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NodesmithProvider.getApiKey = function (apiKey) {
        if (apiKey && typeof (apiKey) !== "string") {
            logger.throwArgumentError("invalid apiKey", "apiKey", apiKey);
        }
        return apiKey || defaultApiKey;
    };
    NodesmithProvider.getUrl = function (network, apiKey) {
        logger.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
        var host = null;
        switch (network.name) {
            case "homestead":
                host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
                break;
            case "ropsten":
                host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
                break;
            case "rinkeby":
                host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
                break;
            case "goerli":
                host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
                break;
            case "kovan":
                host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
                break;
            default:
                logger.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return (host + "?apiKey=" + apiKey);
    };
    return NodesmithProvider;
}(url_json_rpc_provider_1.UrlJsonRpcProvider));
exports.NodesmithProvider = NodesmithProvider;
//# sourceMappingURL=nodesmith-provider.js.map

/***/ }),

/***/ 9939:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PocketProvider = void 0;
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(1594);
var logger = new logger_1.Logger(_version_1.version);
var url_json_rpc_provider_1 = __nccwpck_require__(3480);
var defaultApplicationId = "62e1ad51b37b8e00394bda3b";
var PocketProvider = /** @class */ (function (_super) {
    __extends(PocketProvider, _super);
    function PocketProvider() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PocketProvider.getApiKey = function (apiKey) {
        var apiKeyObj = {
            applicationId: null,
            loadBalancer: true,
            applicationSecretKey: null
        };
        // Parse applicationId and applicationSecretKey
        if (apiKey == null) {
            apiKeyObj.applicationId = defaultApplicationId;
        }
        else if (typeof (apiKey) === "string") {
            apiKeyObj.applicationId = apiKey;
        }
        else if (apiKey.applicationSecretKey != null) {
            apiKeyObj.applicationId = apiKey.applicationId;
            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
        }
        else if (apiKey.applicationId) {
            apiKeyObj.applicationId = apiKey.applicationId;
        }
        else {
            logger.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
        }
        return apiKeyObj;
    };
    PocketProvider.getUrl = function (network, apiKey) {
        var host = null;
        switch (network ? network.name : "unknown") {
            case "goerli":
                host = "eth-goerli.gateway.pokt.network";
                break;
            case "homestead":
                host = "eth-mainnet.gateway.pokt.network";
                break;
            case "kovan":
                host = "poa-kovan.gateway.pokt.network";
                break;
            case "matic":
                host = "poly-mainnet.gateway.pokt.network";
                break;
            case "maticmum":
                host = "polygon-mumbai-rpc.gateway.pokt.network";
                break;
            case "rinkeby":
                host = "eth-rinkeby.gateway.pokt.network";
                break;
            case "ropsten":
                host = "eth-ropsten.gateway.pokt.network";
                break;
            default:
                logger.throwError("unsupported network", logger_1.Logger.errors.INVALID_ARGUMENT, {
                    argument: "network",
                    value: network
                });
        }
        var url = "https://" + host + "/v1/lb/" + apiKey.applicationId;
        var connection = { headers: {}, url: url };
        if (apiKey.applicationSecretKey != null) {
            connection.user = "";
            connection.password = apiKey.applicationSecretKey;
        }
        return connection;
    };
    PocketProvider.prototype.isCommunityResource = function () {
        return (this.applicationId === defaultApplicationId);
    };
    return PocketProvider;
}(url_json_rpc_provider_1.UrlJsonRpcProvider));
exports.PocketProvider = PocketProvider;
//# sourceMappingURL=pocket-provider.js.map

/***/ }),

/***/ 3480:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UrlJsonRpcProvider = exports.StaticJsonRpcProvider = void 0;
var properties_1 = __nccwpck_require__(8078);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(1594);
var logger = new logger_1.Logger(_version_1.version);
var json_rpc_provider_1 = __nccwpck_require__(1550);
// A StaticJsonRpcProvider is useful when you *know* for certain that
// the backend will never change, as it never calls eth_chainId to
// verify its backend. However, if the backend does change, the effects
// are undefined and may include:
// - inconsistent results
// - locking up the UI
// - block skew warnings
// - wrong results
// If the network is not explicit (i.e. auto-detection is expected), the
// node MUST be running and available to respond to requests BEFORE this
// is instantiated.
var StaticJsonRpcProvider = /** @class */ (function (_super) {
    __extends(StaticJsonRpcProvider, _super);
    function StaticJsonRpcProvider() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StaticJsonRpcProvider.prototype.detectNetwork = function () {
        return __awaiter(this, void 0, void 0, function () {
            var network;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        network = this.network;
                        if (!(network == null)) return [3 /*break*/, 2];
                        return [4 /*yield*/, _super.prototype.detectNetwork.call(this)];
                    case 1:
                        network = _a.sent();
                        if (!network) {
                            logger.throwError("no network detected", logger_1.Logger.errors.UNKNOWN_ERROR, {});
                        }
                        // If still not set, set it
                        if (this._network == null) {
                            // A static network does not support "any"
                            (0, properties_1.defineReadOnly)(this, "_network", network);
                            this.emit("network", network, null);
                        }
                        _a.label = 2;
                    case 2: return [2 /*return*/, network];
                }
            });
        });
    };
    return StaticJsonRpcProvider;
}(json_rpc_provider_1.JsonRpcProvider));
exports.StaticJsonRpcProvider = StaticJsonRpcProvider;
var UrlJsonRpcProvider = /** @class */ (function (_super) {
    __extends(UrlJsonRpcProvider, _super);
    function UrlJsonRpcProvider(network, apiKey) {
        var _newTarget = this.constructor;
        var _this = this;
        logger.checkAbstract(_newTarget, UrlJsonRpcProvider);
        // Normalize the Network and API Key
        network = (0, properties_1.getStatic)(_newTarget, "getNetwork")(network);
        apiKey = (0, properties_1.getStatic)(_newTarget, "getApiKey")(apiKey);
        var connection = (0, properties_1.getStatic)(_newTarget, "getUrl")(network, apiKey);
        _this = _super.call(this, connection, network) || this;
        if (typeof (apiKey) === "string") {
            (0, properties_1.defineReadOnly)(_this, "apiKey", apiKey);
        }
        else if (apiKey != null) {
            Object.keys(apiKey).forEach(function (key) {
                (0, properties_1.defineReadOnly)(_this, key, apiKey[key]);
            });
        }
        return _this;
    }
    UrlJsonRpcProvider.prototype._startPending = function () {
        logger.warn("WARNING: API provider does not support pending filters");
    };
    UrlJsonRpcProvider.prototype.isCommunityResource = function () {
        return false;
    };
    UrlJsonRpcProvider.prototype.getSigner = function (address) {
        return logger.throwError("API provider does not support signing", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
    };
    UrlJsonRpcProvider.prototype.listAccounts = function () {
        return Promise.resolve([]);
    };
    // Return a defaultApiKey if null, otherwise validate the API key
    UrlJsonRpcProvider.getApiKey = function (apiKey) {
        return apiKey;
    };
    // Returns the url or connection for the given network and API key. The
    // API key will have been sanitized by the getApiKey first, so any validation
    // or transformations can be done there.
    UrlJsonRpcProvider.getUrl = function (network, apiKey) {
        return logger.throwError("not implemented; sub-classes must override getUrl", logger_1.Logger.errors.NOT_IMPLEMENTED, {
            operation: "getUrl"
        });
    };
    return UrlJsonRpcProvider;
}(StaticJsonRpcProvider));
exports.UrlJsonRpcProvider = UrlJsonRpcProvider;
//# sourceMappingURL=url-json-rpc-provider.js.map

/***/ }),

/***/ 6881:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Web3Provider = void 0;
var properties_1 = __nccwpck_require__(8078);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(1594);
var logger = new logger_1.Logger(_version_1.version);
var json_rpc_provider_1 = __nccwpck_require__(1550);
var _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
    var fetcher = "Web3LegacyFetcher";
    return function (method, params) {
        var _this = this;
        var request = {
            method: method,
            params: params,
            id: (_nextId++),
            jsonrpc: "2.0"
        };
        return new Promise(function (resolve, reject) {
            _this.emit("debug", {
                action: "request",
                fetcher: fetcher,
                request: (0, properties_1.deepCopy)(request),
                provider: _this
            });
            sendFunc(request, function (error, response) {
                if (error) {
                    _this.emit("debug", {
                        action: "response",
                        fetcher: fetcher,
                        error: error,
                        request: request,
                        provider: _this
                    });
                    return reject(error);
                }
                _this.emit("debug", {
                    action: "response",
                    fetcher: fetcher,
                    request: request,
                    response: response,
                    provider: _this
                });
                if (response.error) {
                    var error_1 = new Error(response.error.message);
                    error_1.code = response.error.code;
                    error_1.data = response.error.data;
                    return reject(error_1);
                }
                resolve(response.result);
            });
        });
    };
}
function buildEip1193Fetcher(provider) {
    return function (method, params) {
        var _this = this;
        if (params == null) {
            params = [];
        }
        var request = { method: method, params: params };
        this.emit("debug", {
            action: "request",
            fetcher: "Eip1193Fetcher",
            request: (0, properties_1.deepCopy)(request),
            provider: this
        });
        return provider.request(request).then(function (response) {
            _this.emit("debug", {
                action: "response",
                fetcher: "Eip1193Fetcher",
                request: request,
                response: response,
                provider: _this
            });
            return response;
        }, function (error) {
            _this.emit("debug", {
                action: "response",
                fetcher: "Eip1193Fetcher",
                request: request,
                error: error,
                provider: _this
            });
            throw error;
        });
    };
}
var Web3Provider = /** @class */ (function (_super) {
    __extends(Web3Provider, _super);
    function Web3Provider(provider, network) {
        var _this = this;
        if (provider == null) {
            logger.throwArgumentError("missing provider", "provider", provider);
        }
        var path = null;
        var jsonRpcFetchFunc = null;
        var subprovider = null;
        if (typeof (provider) === "function") {
            path = "unknown:";
            jsonRpcFetchFunc = provider;
        }
        else {
            path = provider.host || provider.path || "";
            if (!path && provider.isMetaMask) {
                path = "metamask";
            }
            subprovider = provider;
            if (provider.request) {
                if (path === "") {
                    path = "eip-1193:";
                }
                jsonRpcFetchFunc = buildEip1193Fetcher(provider);
            }
            else if (provider.sendAsync) {
                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
            }
            else if (provider.send) {
                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
            }
            else {
                logger.throwArgumentError("unsupported provider", "provider", provider);
            }
            if (!path) {
                path = "unknown:";
            }
        }
        _this = _super.call(this, path, network) || this;
        (0, properties_1.defineReadOnly)(_this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
        (0, properties_1.defineReadOnly)(_this, "provider", subprovider);
        return _this;
    }
    Web3Provider.prototype.send = function (method, params) {
        return this.jsonRpcFetchFunc(method, params);
    };
    return Web3Provider;
}(json_rpc_provider_1.JsonRpcProvider));
exports.Web3Provider = Web3Provider;
//# sourceMappingURL=web3-provider.js.map

/***/ }),

/***/ 4405:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebSocketProvider = void 0;
var bignumber_1 = __nccwpck_require__(1267);
var properties_1 = __nccwpck_require__(8078);
var json_rpc_provider_1 = __nccwpck_require__(1550);
var ws_1 = __nccwpck_require__(6674);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(1594);
var logger = new logger_1.Logger(_version_1.version);
/**
 *  Notes:
 *
 *  This provider differs a bit from the polling providers. One main
 *  difference is how it handles consistency. The polling providers
 *  will stall responses to ensure a consistent state, while this
 *  WebSocket provider assumes the connected backend will manage this.
 *
 *  For example, if a polling provider emits an event which indicates
 *  the event occurred in blockhash XXX, a call to fetch that block by
 *  its hash XXX, if not present will retry until it is present. This
 *  can occur when querying a pool of nodes that are mildly out of sync
 *  with each other.
 */
var NextId = 1;
// For more info about the Real-time Event API see:
//   https://geth.ethereum.org/docs/rpc/pubsub
var WebSocketProvider = /** @class */ (function (_super) {
    __extends(WebSocketProvider, _super);
    function WebSocketProvider(url, network) {
        var _this = this;
        // This will be added in the future; please open an issue to expedite
        if (network === "any") {
            logger.throwError("WebSocketProvider does not support 'any' network yet", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "network:any"
            });
        }
        if (typeof (url) === "string") {
            _this = _super.call(this, url, network) || this;
        }
        else {
            _this = _super.call(this, "_websocket", network) || this;
        }
        _this._pollingInterval = -1;
        _this._wsReady = false;
        if (typeof (url) === "string") {
            (0, properties_1.defineReadOnly)(_this, "_websocket", new ws_1.WebSocket(_this.connection.url));
        }
        else {
            (0, properties_1.defineReadOnly)(_this, "_websocket", url);
        }
        (0, properties_1.defineReadOnly)(_this, "_requests", {});
        (0, properties_1.defineReadOnly)(_this, "_subs", {});
        (0, properties_1.defineReadOnly)(_this, "_subIds", {});
        (0, properties_1.defineReadOnly)(_this, "_detectNetwork", _super.prototype.detectNetwork.call(_this));
        // Stall sending requests until the socket is open...
        _this.websocket.onopen = function () {
            _this._wsReady = true;
            Object.keys(_this._requests).forEach(function (id) {
                _this.websocket.send(_this._requests[id].payload);
            });
        };
        _this.websocket.onmessage = function (messageEvent) {
            var data = messageEvent.data;
            var result = JSON.parse(data);
            if (result.id != null) {
                var id = String(result.id);
                var request = _this._requests[id];
                delete _this._requests[id];
                if (result.result !== undefined) {
                    request.callback(null, result.result);
                    _this.emit("debug", {
                        action: "response",
                        request: JSON.parse(request.payload),
                        response: result.result,
                        provider: _this
                    });
                }
                else {
                    var error = null;
                    if (result.error) {
                        error = new Error(result.error.message || "unknown error");
                        (0, properties_1.defineReadOnly)(error, "code", result.error.code || null);
                        (0, properties_1.defineReadOnly)(error, "response", data);
                    }
                    else {
                        error = new Error("unknown error");
                    }
                    request.callback(error, undefined);
                    _this.emit("debug", {
                        action: "response",
                        error: error,
                        request: JSON.parse(request.payload),
                        provider: _this
                    });
                }
            }
            else if (result.method === "eth_subscription") {
                // Subscription...
                var sub = _this._subs[result.params.subscription];
                if (sub) {
                    //this.emit.apply(this,                  );
                    sub.processFunc(result.params.result);
                }
            }
            else {
                console.warn("this should not happen");
            }
        };
        // This Provider does not actually poll, but we want to trigger
        // poll events for things that depend on them (like stalling for
        // block and transaction lookups)
        var fauxPoll = setInterval(function () {
            _this.emit("poll");
        }, 1000);
        if (fauxPoll.unref) {
            fauxPoll.unref();
        }
        return _this;
    }
    Object.defineProperty(WebSocketProvider.prototype, "websocket", {
        // Cannot narrow the type of _websocket, as that is not backwards compatible
        // so we add a getter and let the WebSocket be a public API.
        get: function () { return this._websocket; },
        enumerable: false,
        configurable: true
    });
    WebSocketProvider.prototype.detectNetwork = function () {
        return this._detectNetwork;
    };
    Object.defineProperty(WebSocketProvider.prototype, "pollingInterval", {
        get: function () {
            return 0;
        },
        set: function (value) {
            logger.throwError("cannot set polling interval on WebSocketProvider", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setPollingInterval"
            });
        },
        enumerable: false,
        configurable: true
    });
    WebSocketProvider.prototype.resetEventsBlock = function (blockNumber) {
        logger.throwError("cannot reset events block on WebSocketProvider", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "resetEventBlock"
        });
    };
    WebSocketProvider.prototype.poll = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, null];
            });
        });
    };
    Object.defineProperty(WebSocketProvider.prototype, "polling", {
        set: function (value) {
            if (!value) {
                return;
            }
            logger.throwError("cannot set polling on WebSocketProvider", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setPolling"
            });
        },
        enumerable: false,
        configurable: true
    });
    WebSocketProvider.prototype.send = function (method, params) {
        var _this = this;
        var rid = NextId++;
        return new Promise(function (resolve, reject) {
            function callback(error, result) {
                if (error) {
                    return reject(error);
                }
                return resolve(result);
            }
            var payload = JSON.stringify({
                method: method,
                params: params,
                id: rid,
                jsonrpc: "2.0"
            });
            _this.emit("debug", {
                action: "request",
                request: JSON.parse(payload),
                provider: _this
            });
            _this._requests[String(rid)] = { callback: callback, payload: payload };
            if (_this._wsReady) {
                _this.websocket.send(payload);
            }
        });
    };
    WebSocketProvider.defaultUrl = function () {
        return "ws:/\/localhost:8546";
    };
    WebSocketProvider.prototype._subscribe = function (tag, param, processFunc) {
        return __awaiter(this, void 0, void 0, function () {
            var subIdPromise, subId;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        subIdPromise = this._subIds[tag];
                        if (subIdPromise == null) {
                            subIdPromise = Promise.all(param).then(function (param) {
                                return _this.send("eth_subscribe", param);
                            });
                            this._subIds[tag] = subIdPromise;
                        }
                        return [4 /*yield*/, subIdPromise];
                    case 1:
                        subId = _a.sent();
                        this._subs[subId] = { tag: tag, processFunc: processFunc };
                        return [2 /*return*/];
                }
            });
        });
    };
    WebSocketProvider.prototype._startEvent = function (event) {
        var _this = this;
        switch (event.type) {
            case "block":
                this._subscribe("block", ["newHeads"], function (result) {
                    var blockNumber = bignumber_1.BigNumber.from(result.number).toNumber();
                    _this._emitted.block = blockNumber;
                    _this.emit("block", blockNumber);
                });
                break;
            case "pending":
                this._subscribe("pending", ["newPendingTransactions"], function (result) {
                    _this.emit("pending", result);
                });
                break;
            case "filter":
                this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], function (result) {
                    if (result.removed == null) {
                        result.removed = false;
                    }
                    _this.emit(event.filter, _this.formatter.filterLog(result));
                });
                break;
            case "tx": {
                var emitReceipt_1 = function (event) {
                    var hash = event.hash;
                    _this.getTransactionReceipt(hash).then(function (receipt) {
                        if (!receipt) {
                            return;
                        }
                        _this.emit(hash, receipt);
                    });
                };
                // In case it is already mined
                emitReceipt_1(event);
                // To keep things simple, we start up a single newHeads subscription
                // to keep an eye out for transactions we are watching for.
                // Starting a subscription for an event (i.e. "tx") that is already
                // running is (basically) a nop.
                this._subscribe("tx", ["newHeads"], function (result) {
                    _this._events.filter(function (e) { return (e.type === "tx"); }).forEach(emitReceipt_1);
                });
                break;
            }
            // Nothing is needed
            case "debug":
            case "poll":
            case "willPoll":
            case "didPoll":
            case "error":
                break;
            default:
                console.log("unhandled:", event);
                break;
        }
    };
    WebSocketProvider.prototype._stopEvent = function (event) {
        var _this = this;
        var tag = event.tag;
        if (event.type === "tx") {
            // There are remaining transaction event listeners
            if (this._events.filter(function (e) { return (e.type === "tx"); }).length) {
                return;
            }
            tag = "tx";
        }
        else if (this.listenerCount(event.event)) {
            // There are remaining event listeners
            return;
        }
        var subId = this._subIds[tag];
        if (!subId) {
            return;
        }
        delete this._subIds[tag];
        subId.then(function (subId) {
            if (!_this._subs[subId]) {
                return;
            }
            delete _this._subs[subId];
            _this.send("eth_unsubscribe", [subId]);
        });
    };
    WebSocketProvider.prototype.destroy = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.websocket.readyState === ws_1.WebSocket.CONNECTING)) return [3 /*break*/, 2];
                        return [4 /*yield*/, (new Promise(function (resolve) {
                                _this.websocket.onopen = function () {
                                    resolve(true);
                                };
                                _this.websocket.onerror = function () {
                                    resolve(false);
                                };
                            }))];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        // Hangup
                        // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
                        this.websocket.close(1000);
                        return [2 /*return*/];
                }
            });
        });
    };
    return WebSocketProvider;
}(json_rpc_provider_1.JsonRpcProvider));
exports.WebSocketProvider = WebSocketProvider;
//# sourceMappingURL=websocket-provider.js.map

/***/ }),

/***/ 6674:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebSocket = void 0;
var ws_1 = __importDefault(__nccwpck_require__(8867));
exports.WebSocket = ws_1.default;
//# sourceMappingURL=ws.js.map

/***/ }),

/***/ 4977:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shuffled = exports.randomBytes = void 0;
var random_1 = __nccwpck_require__(6011);
Object.defineProperty(exports, "randomBytes", ({ enumerable: true, get: function () { return random_1.randomBytes; } }));
var shuffle_1 = __nccwpck_require__(9906);
Object.defineProperty(exports, "shuffled", ({ enumerable: true, get: function () { return shuffle_1.shuffled; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 6011:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.randomBytes = void 0;
var crypto_1 = __nccwpck_require__(6113);
var bytes_1 = __nccwpck_require__(2056);
function randomBytes(length) {
    return (0, bytes_1.arrayify)((0, crypto_1.randomBytes)(length));
}
exports.randomBytes = randomBytes;
//# sourceMappingURL=random.js.map

/***/ }),

/***/ 9906:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shuffled = void 0;
function shuffled(array) {
    array = array.slice();
    for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
    return array;
}
exports.shuffled = shuffled;
//# sourceMappingURL=shuffle.js.map

/***/ }),

/***/ 1669:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = "rlp/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ 2099:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decode = exports.encode = void 0;
//See: https://github.com/ethereum/wiki/wiki/RLP
var bytes_1 = __nccwpck_require__(2056);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(1669);
var logger = new logger_1.Logger(_version_1.version);
function arrayifyInteger(value) {
    var result = [];
    while (value) {
        result.unshift(value & 0xff);
        value >>= 8;
    }
    return result;
}
function unarrayifyInteger(data, offset, length) {
    var result = 0;
    for (var i = 0; i < length; i++) {
        result = (result * 256) + data[offset + i];
    }
    return result;
}
function _encode(object) {
    if (Array.isArray(object)) {
        var payload_1 = [];
        object.forEach(function (child) {
            payload_1 = payload_1.concat(_encode(child));
        });
        if (payload_1.length <= 55) {
            payload_1.unshift(0xc0 + payload_1.length);
            return payload_1;
        }
        var length_1 = arrayifyInteger(payload_1.length);
        length_1.unshift(0xf7 + length_1.length);
        return length_1.concat(payload_1);
    }
    if (!(0, bytes_1.isBytesLike)(object)) {
        logger.throwArgumentError("RLP object must be BytesLike", "object", object);
    }
    var data = Array.prototype.slice.call((0, bytes_1.arrayify)(object));
    if (data.length === 1 && data[0] <= 0x7f) {
        return data;
    }
    else if (data.length <= 55) {
        data.unshift(0x80 + data.length);
        return data;
    }
    var length = arrayifyInteger(data.length);
    length.unshift(0xb7 + length.length);
    return length.concat(data);
}
function encode(object) {
    return (0, bytes_1.hexlify)(_encode(object));
}
exports.encode = encode;
function _decodeChildren(data, offset, childOffset, length) {
    var result = [];
    while (childOffset < offset + 1 + length) {
        var decoded = _decode(data, childOffset);
        result.push(decoded.result);
        childOffset += decoded.consumed;
        if (childOffset > offset + 1 + length) {
            logger.throwError("child data too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
    }
    return { consumed: (1 + length), result: result };
}
// returns { consumed: number, result: Object }
function _decode(data, offset) {
    if (data.length === 0) {
        logger.throwError("data too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
    }
    // Array with extra length prefix
    if (data[offset] >= 0xf8) {
        var lengthLength = data[offset] - 0xf7;
        if (offset + 1 + lengthLength > data.length) {
            logger.throwError("data short segment too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        var length_2 = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length_2 > data.length) {
            logger.throwError("data long segment too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length_2);
    }
    else if (data[offset] >= 0xc0) {
        var length_3 = data[offset] - 0xc0;
        if (offset + 1 + length_3 > data.length) {
            logger.throwError("data array too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1, length_3);
    }
    else if (data[offset] >= 0xb8) {
        var lengthLength = data[offset] - 0xb7;
        if (offset + 1 + lengthLength > data.length) {
            logger.throwError("data array too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        var length_4 = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length_4 > data.length) {
            logger.throwError("data array too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        var result = (0, bytes_1.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length_4));
        return { consumed: (1 + lengthLength + length_4), result: result };
    }
    else if (data[offset] >= 0x80) {
        var length_5 = data[offset] - 0x80;
        if (offset + 1 + length_5 > data.length) {
            logger.throwError("data too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        var result = (0, bytes_1.hexlify)(data.slice(offset + 1, offset + 1 + length_5));
        return { consumed: (1 + length_5), result: result };
    }
    return { consumed: 1, result: (0, bytes_1.hexlify)(data[offset]) };
}
function decode(data) {
    var bytes = (0, bytes_1.arrayify)(data);
    var decoded = _decode(bytes, 0);
    if (decoded.consumed !== bytes.length) {
        logger.throwArgumentError("invalid rlp data", "data", data);
    }
    return decoded.result;
}
exports.decode = decode;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8668:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = "sha2/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ 9863:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SupportedAlgorithm = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.computeHmac = void 0;
var sha2_1 = __nccwpck_require__(8829);
Object.defineProperty(exports, "computeHmac", ({ enumerable: true, get: function () { return sha2_1.computeHmac; } }));
Object.defineProperty(exports, "ripemd160", ({ enumerable: true, get: function () { return sha2_1.ripemd160; } }));
Object.defineProperty(exports, "sha256", ({ enumerable: true, get: function () { return sha2_1.sha256; } }));
Object.defineProperty(exports, "sha512", ({ enumerable: true, get: function () { return sha2_1.sha512; } }));
var types_1 = __nccwpck_require__(9928);
Object.defineProperty(exports, "SupportedAlgorithm", ({ enumerable: true, get: function () { return types_1.SupportedAlgorithm; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8829:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.computeHmac = exports.sha512 = exports.sha256 = exports.ripemd160 = void 0;
var crypto_1 = __nccwpck_require__(6113);
var hash_js_1 = __importDefault(__nccwpck_require__(5591));
var bytes_1 = __nccwpck_require__(2056);
var types_1 = __nccwpck_require__(9928);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(8668);
var logger = new logger_1.Logger(_version_1.version);
function ripemd160(data) {
    return "0x" + (hash_js_1.default.ripemd160().update((0, bytes_1.arrayify)(data)).digest("hex"));
}
exports.ripemd160 = ripemd160;
function sha256(data) {
    return "0x" + (0, crypto_1.createHash)("sha256").update(Buffer.from((0, bytes_1.arrayify)(data))).digest("hex");
}
exports.sha256 = sha256;
function sha512(data) {
    return "0x" + (0, crypto_1.createHash)("sha512").update(Buffer.from((0, bytes_1.arrayify)(data))).digest("hex");
}
exports.sha512 = sha512;
function computeHmac(algorithm, key, data) {
    /* istanbul ignore if */
    if (!types_1.SupportedAlgorithm[algorithm]) {
        logger.throwError("unsupported algorithm - " + algorithm, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "computeHmac",
            algorithm: algorithm
        });
    }
    return "0x" + (0, crypto_1.createHmac)(algorithm, Buffer.from((0, bytes_1.arrayify)(key))).update(Buffer.from((0, bytes_1.arrayify)(data))).digest("hex");
}
exports.computeHmac = computeHmac;
//# sourceMappingURL=sha2.js.map

/***/ }),

/***/ 9928:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SupportedAlgorithm = void 0;
var SupportedAlgorithm;
(function (SupportedAlgorithm) {
    SupportedAlgorithm["sha256"] = "sha256";
    SupportedAlgorithm["sha512"] = "sha512";
})(SupportedAlgorithm = exports.SupportedAlgorithm || (exports.SupportedAlgorithm = {}));
;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 4007:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = "signing-key/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ 4113:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EC = void 0;
var elliptic_1 = __importDefault(__nccwpck_require__(9485));
var EC = elliptic_1.default.ec;
exports.EC = EC;
//# sourceMappingURL=elliptic.js.map

/***/ }),

/***/ 574:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.computePublicKey = exports.recoverPublicKey = exports.SigningKey = void 0;
var elliptic_1 = __nccwpck_require__(4113);
var bytes_1 = __nccwpck_require__(2056);
var properties_1 = __nccwpck_require__(8078);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(4007);
var logger = new logger_1.Logger(_version_1.version);
var _curve = null;
function getCurve() {
    if (!_curve) {
        _curve = new elliptic_1.EC("secp256k1");
    }
    return _curve;
}
var SigningKey = /** @class */ (function () {
    function SigningKey(privateKey) {
        (0, properties_1.defineReadOnly)(this, "curve", "secp256k1");
        (0, properties_1.defineReadOnly)(this, "privateKey", (0, bytes_1.hexlify)(privateKey));
        if ((0, bytes_1.hexDataLength)(this.privateKey) !== 32) {
            logger.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
        }
        var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));
        (0, properties_1.defineReadOnly)(this, "publicKey", "0x" + keyPair.getPublic(false, "hex"));
        (0, properties_1.defineReadOnly)(this, "compressedPublicKey", "0x" + keyPair.getPublic(true, "hex"));
        (0, properties_1.defineReadOnly)(this, "_isSigningKey", true);
    }
    SigningKey.prototype._addPoint = function (other) {
        var p0 = getCurve().keyFromPublic((0, bytes_1.arrayify)(this.publicKey));
        var p1 = getCurve().keyFromPublic((0, bytes_1.arrayify)(other));
        return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
    };
    SigningKey.prototype.signDigest = function (digest) {
        var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));
        var digestBytes = (0, bytes_1.arrayify)(digest);
        if (digestBytes.length !== 32) {
            logger.throwArgumentError("bad digest length", "digest", digest);
        }
        var signature = keyPair.sign(digestBytes, { canonical: true });
        return (0, bytes_1.splitSignature)({
            recoveryParam: signature.recoveryParam,
            r: (0, bytes_1.hexZeroPad)("0x" + signature.r.toString(16), 32),
            s: (0, bytes_1.hexZeroPad)("0x" + signature.s.toString(16), 32),
        });
    };
    SigningKey.prototype.computeSharedSecret = function (otherKey) {
        var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));
        var otherKeyPair = getCurve().keyFromPublic((0, bytes_1.arrayify)(computePublicKey(otherKey)));
        return (0, bytes_1.hexZeroPad)("0x" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);
    };
    SigningKey.isSigningKey = function (value) {
        return !!(value && value._isSigningKey);
    };
    return SigningKey;
}());
exports.SigningKey = SigningKey;
function recoverPublicKey(digest, signature) {
    var sig = (0, bytes_1.splitSignature)(signature);
    var rs = { r: (0, bytes_1.arrayify)(sig.r), s: (0, bytes_1.arrayify)(sig.s) };
    return "0x" + getCurve().recoverPubKey((0, bytes_1.arrayify)(digest), rs, sig.recoveryParam).encode("hex", false);
}
exports.recoverPublicKey = recoverPublicKey;
function computePublicKey(key, compressed) {
    var bytes = (0, bytes_1.arrayify)(key);
    if (bytes.length === 32) {
        var signingKey = new SigningKey(bytes);
        if (compressed) {
            return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
        }
        return signingKey.publicKey;
    }
    else if (bytes.length === 33) {
        if (compressed) {
            return (0, bytes_1.hexlify)(bytes);
        }
        return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
    }
    else if (bytes.length === 65) {
        if (!compressed) {
            return (0, bytes_1.hexlify)(bytes);
        }
        return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
    }
    return logger.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
exports.computePublicKey = computePublicKey;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 5945:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = "solidity/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ 4516:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha256 = exports.keccak256 = exports.pack = void 0;
var bignumber_1 = __nccwpck_require__(1267);
var bytes_1 = __nccwpck_require__(2056);
var keccak256_1 = __nccwpck_require__(3100);
var sha2_1 = __nccwpck_require__(9863);
var strings_1 = __nccwpck_require__(9115);
var regexBytes = new RegExp("^bytes([0-9]+)$");
var regexNumber = new RegExp("^(u?int)([0-9]*)$");
var regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
var Zeros = "0000000000000000000000000000000000000000000000000000000000000000";
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(5945);
var logger = new logger_1.Logger(_version_1.version);
function _pack(type, value, isArray) {
    switch (type) {
        case "address":
            if (isArray) {
                return (0, bytes_1.zeroPad)(value, 32);
            }
            return (0, bytes_1.arrayify)(value);
        case "string":
            return (0, strings_1.toUtf8Bytes)(value);
        case "bytes":
            return (0, bytes_1.arrayify)(value);
        case "bool":
            value = (value ? "0x01" : "0x00");
            if (isArray) {
                return (0, bytes_1.zeroPad)(value, 32);
            }
            return (0, bytes_1.arrayify)(value);
    }
    var match = type.match(regexNumber);
    if (match) {
        //let signed = (match[1] === "int")
        var size = parseInt(match[2] || "256");
        if ((match[2] && String(size) !== match[2]) || (size % 8 !== 0) || size === 0 || size > 256) {
            logger.throwArgumentError("invalid number type", "type", type);
        }
        if (isArray) {
            size = 256;
        }
        value = bignumber_1.BigNumber.from(value).toTwos(size);
        return (0, bytes_1.zeroPad)(value, size / 8);
    }
    match = type.match(regexBytes);
    if (match) {
        var size = parseInt(match[1]);
        if (String(size) !== match[1] || size === 0 || size > 32) {
            logger.throwArgumentError("invalid bytes type", "type", type);
        }
        if ((0, bytes_1.arrayify)(value).byteLength !== size) {
            logger.throwArgumentError("invalid value for " + type, "value", value);
        }
        if (isArray) {
            return (0, bytes_1.arrayify)((value + Zeros).substring(0, 66));
        }
        return value;
    }
    match = type.match(regexArray);
    if (match && Array.isArray(value)) {
        var baseType_1 = match[1];
        var count = parseInt(match[2] || String(value.length));
        if (count != value.length) {
            logger.throwArgumentError("invalid array length for " + type, "value", value);
        }
        var result_1 = [];
        value.forEach(function (value) {
            result_1.push(_pack(baseType_1, value, true));
        });
        return (0, bytes_1.concat)(result_1);
    }
    return logger.throwArgumentError("invalid type", "type", type);
}
// @TODO: Array Enum
function pack(types, values) {
    if (types.length != values.length) {
        logger.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
    }
    var tight = [];
    types.forEach(function (type, index) {
        tight.push(_pack(type, values[index]));
    });
    return (0, bytes_1.hexlify)((0, bytes_1.concat)(tight));
}
exports.pack = pack;
function keccak256(types, values) {
    return (0, keccak256_1.keccak256)(pack(types, values));
}
exports.keccak256 = keccak256;
function sha256(types, values) {
    return (0, sha2_1.sha256)(pack(types, values));
}
exports.sha256 = sha256;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 4499:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = "strings/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ 4194:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseBytes32String = exports.formatBytes32String = void 0;
var constants_1 = __nccwpck_require__(1309);
var bytes_1 = __nccwpck_require__(2056);
var utf8_1 = __nccwpck_require__(50);
function formatBytes32String(text) {
    // Get the bytes
    var bytes = (0, utf8_1.toUtf8Bytes)(text);
    // Check we have room for null-termination
    if (bytes.length > 31) {
        throw new Error("bytes32 string must be less than 32 bytes");
    }
    // Zero-pad (implicitly null-terminates)
    return (0, bytes_1.hexlify)((0, bytes_1.concat)([bytes, constants_1.HashZero]).slice(0, 32));
}
exports.formatBytes32String = formatBytes32String;
function parseBytes32String(bytes) {
    var data = (0, bytes_1.arrayify)(bytes);
    // Must be 32 bytes with a null-termination
    if (data.length !== 32) {
        throw new Error("invalid bytes32 - not 32 bytes long");
    }
    if (data[31] !== 0) {
        throw new Error("invalid bytes32 string - no null terminator");
    }
    // Find the null termination
    var length = 31;
    while (data[length - 1] === 0) {
        length--;
    }
    // Determine the string value
    return (0, utf8_1.toUtf8String)(data.slice(0, length));
}
exports.parseBytes32String = parseBytes32String;
//# sourceMappingURL=bytes32.js.map

/***/ }),

/***/ 6403:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nameprep = exports._nameprepTableC = exports._nameprepTableB2 = exports._nameprepTableA1 = void 0;
var utf8_1 = __nccwpck_require__(50);
function bytes2(data) {
    if ((data.length % 4) !== 0) {
        throw new Error("bad data");
    }
    var result = [];
    for (var i = 0; i < data.length; i += 4) {
        result.push(parseInt(data.substring(i, i + 4), 16));
    }
    return result;
}
function createTable(data, func) {
    if (!func) {
        func = function (value) { return [parseInt(value, 16)]; };
    }
    var lo = 0;
    var result = {};
    data.split(",").forEach(function (pair) {
        var comps = pair.split(":");
        lo += parseInt(comps[0], 16);
        result[lo] = func(comps[1]);
    });
    return result;
}
function createRangeTable(data) {
    var hi = 0;
    return data.split(",").map(function (v) {
        var comps = v.split("-");
        if (comps.length === 1) {
            comps[1] = "0";
        }
        else if (comps[1] === "") {
            comps[1] = "1";
        }
        var lo = hi + parseInt(comps[0], 16);
        hi = parseInt(comps[1], 16);
        return { l: lo, h: hi };
    });
}
function matchMap(value, ranges) {
    var lo = 0;
    for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        lo += range.l;
        if (value >= lo && value <= lo + range.h && ((value - lo) % (range.d || 1)) === 0) {
            if (range.e && range.e.indexOf(value - lo) !== -1) {
                continue;
            }
            return range;
        }
    }
    return null;
}
var Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
// @TODO: Make this relative...
var Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map(function (v) { return parseInt(v, 16); });
var Table_B_2_ranges = [
    { h: 25, s: 32, l: 65 },
    { h: 30, s: 32, e: [23], l: 127 },
    { h: 54, s: 1, e: [48], l: 64, d: 2 },
    { h: 14, s: 1, l: 57, d: 2 },
    { h: 44, s: 1, l: 17, d: 2 },
    { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
    { h: 16, s: 1, l: 68, d: 2 },
    { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
    { h: 26, s: 32, e: [17], l: 435 },
    { h: 22, s: 1, l: 71, d: 2 },
    { h: 15, s: 80, l: 40 },
    { h: 31, s: 32, l: 16 },
    { h: 32, s: 1, l: 80, d: 2 },
    { h: 52, s: 1, l: 42, d: 2 },
    { h: 12, s: 1, l: 55, d: 2 },
    { h: 40, s: 1, e: [38], l: 15, d: 2 },
    { h: 14, s: 1, l: 48, d: 2 },
    { h: 37, s: 48, l: 49 },
    { h: 148, s: 1, l: 6351, d: 2 },
    { h: 88, s: 1, l: 160, d: 2 },
    { h: 15, s: 16, l: 704 },
    { h: 25, s: 26, l: 854 },
    { h: 25, s: 32, l: 55915 },
    { h: 37, s: 40, l: 1247 },
    { h: 25, s: -119711, l: 53248 },
    { h: 25, s: -119763, l: 52 },
    { h: 25, s: -119815, l: 52 },
    { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
    { h: 25, s: -119919, l: 52 },
    { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
    { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
    { h: 25, s: -120075, l: 52 },
    { h: 25, s: -120127, l: 52 },
    { h: 25, s: -120179, l: 52 },
    { h: 25, s: -120231, l: 52 },
    { h: 25, s: -120283, l: 52 },
    { h: 25, s: -120335, l: 52 },
    { h: 24, s: -119543, e: [17], l: 56 },
    { h: 24, s: -119601, e: [17], l: 58 },
    { h: 24, s: -119659, e: [17], l: 58 },
    { h: 24, s: -119717, e: [17], l: 58 },
    { h: 24, s: -119775, e: [17], l: 58 }
];
var Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
var Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten(values) {
    return values.reduce(function (accum, value) {
        value.forEach(function (value) { accum.push(value); });
        return accum;
    }, []);
}
function _nameprepTableA1(codepoint) {
    return !!matchMap(codepoint, Table_A_1_ranges);
}
exports._nameprepTableA1 = _nameprepTableA1;
function _nameprepTableB2(codepoint) {
    var range = matchMap(codepoint, Table_B_2_ranges);
    if (range) {
        return [codepoint + range.s];
    }
    var codes = Table_B_2_lut_abs[codepoint];
    if (codes) {
        return codes;
    }
    var shift = Table_B_2_lut_rel[codepoint];
    if (shift) {
        return [codepoint + shift[0]];
    }
    var complex = Table_B_2_complex[codepoint];
    if (complex) {
        return complex;
    }
    return null;
}
exports._nameprepTableB2 = _nameprepTableB2;
function _nameprepTableC(codepoint) {
    return !!matchMap(codepoint, Table_C_ranges);
}
exports._nameprepTableC = _nameprepTableC;
function nameprep(value) {
    // This allows platforms with incomplete normalize to bypass
    // it for very basic names which the built-in toLowerCase
    // will certainly handle correctly
    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
        return value.toLowerCase();
    }
    // Get the code points (keeping the current normalization)
    var codes = (0, utf8_1.toUtf8CodePoints)(value);
    codes = flatten(codes.map(function (code) {
        // Substitute Table B.1 (Maps to Nothing)
        if (Table_B_1_flags.indexOf(code) >= 0) {
            return [];
        }
        if (code >= 0xfe00 && code <= 0xfe0f) {
            return [];
        }
        // Substitute Table B.2 (Case Folding)
        var codesTableB2 = _nameprepTableB2(code);
        if (codesTableB2) {
            return codesTableB2;
        }
        // No Substitution
        return [code];
    }));
    // Normalize using form KC
    codes = (0, utf8_1.toUtf8CodePoints)((0, utf8_1._toUtf8String)(codes), utf8_1.UnicodeNormalizationForm.NFKC);
    // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9
    codes.forEach(function (code) {
        if (_nameprepTableC(code)) {
            throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
        }
    });
    // Prohibit Unassigned Code Points (Table A.1)
    codes.forEach(function (code) {
        if (_nameprepTableA1(code)) {
            throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
        }
    });
    // IDNA extras
    var name = (0, utf8_1._toUtf8String)(codes);
    // IDNA: 4.2.3.1
    if (name.substring(0, 1) === "-" || name.substring(2, 4) === "--" || name.substring(name.length - 1) === "-") {
        throw new Error("invalid hyphen");
    }
    return name;
}
exports.nameprep = nameprep;
//# sourceMappingURL=idna.js.map

/***/ }),

/***/ 9115:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nameprep = exports.parseBytes32String = exports.formatBytes32String = exports.UnicodeNormalizationForm = exports.Utf8ErrorReason = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = void 0;
var bytes32_1 = __nccwpck_require__(4194);
Object.defineProperty(exports, "formatBytes32String", ({ enumerable: true, get: function () { return bytes32_1.formatBytes32String; } }));
Object.defineProperty(exports, "parseBytes32String", ({ enumerable: true, get: function () { return bytes32_1.parseBytes32String; } }));
var idna_1 = __nccwpck_require__(6403);
Object.defineProperty(exports, "nameprep", ({ enumerable: true, get: function () { return idna_1.nameprep; } }));
var utf8_1 = __nccwpck_require__(50);
Object.defineProperty(exports, "_toEscapedUtf8String", ({ enumerable: true, get: function () { return utf8_1._toEscapedUtf8String; } }));
Object.defineProperty(exports, "toUtf8Bytes", ({ enumerable: true, get: function () { return utf8_1.toUtf8Bytes; } }));
Object.defineProperty(exports, "toUtf8CodePoints", ({ enumerable: true, get: function () { return utf8_1.toUtf8CodePoints; } }));
Object.defineProperty(exports, "toUtf8String", ({ enumerable: true, get: function () { return utf8_1.toUtf8String; } }));
Object.defineProperty(exports, "UnicodeNormalizationForm", ({ enumerable: true, get: function () { return utf8_1.UnicodeNormalizationForm; } }));
Object.defineProperty(exports, "Utf8ErrorFuncs", ({ enumerable: true, get: function () { return utf8_1.Utf8ErrorFuncs; } }));
Object.defineProperty(exports, "Utf8ErrorReason", ({ enumerable: true, get: function () { return utf8_1.Utf8ErrorReason; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 50:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toUtf8CodePoints = exports.toUtf8String = exports._toUtf8String = exports._toEscapedUtf8String = exports.toUtf8Bytes = exports.Utf8ErrorFuncs = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = void 0;
var bytes_1 = __nccwpck_require__(2056);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(4499);
var logger = new logger_1.Logger(_version_1.version);
///////////////////////////////
var UnicodeNormalizationForm;
(function (UnicodeNormalizationForm) {
    UnicodeNormalizationForm["current"] = "";
    UnicodeNormalizationForm["NFC"] = "NFC";
    UnicodeNormalizationForm["NFD"] = "NFD";
    UnicodeNormalizationForm["NFKC"] = "NFKC";
    UnicodeNormalizationForm["NFKD"] = "NFKD";
})(UnicodeNormalizationForm = exports.UnicodeNormalizationForm || (exports.UnicodeNormalizationForm = {}));
;
var Utf8ErrorReason;
(function (Utf8ErrorReason) {
    // A continuation byte was present where there was nothing to continue
    // - offset = the index the codepoint began in
    Utf8ErrorReason["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found
    // - offset = the index the codepoint began in
    Utf8ErrorReason["BAD_PREFIX"] = "bad codepoint prefix";
    // The string is too short to process the expected codepoint
    // - offset = the index the codepoint began in
    Utf8ErrorReason["OVERRUN"] = "string overrun";
    // A missing continuation byte was expected but not found
    // - offset = the index the continuation byte was expected at
    Utf8ErrorReason["MISSING_CONTINUE"] = "missing continuation byte";
    // The computed code point is outside the range for UTF-8
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; outside the UTF-8 range
    Utf8ErrorReason["OUT_OF_RANGE"] = "out of UTF-8 range";
    // UTF-8 strings may not contain UTF-16 surrogate pairs
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range
    Utf8ErrorReason["UTF16_SURROGATE"] = "UTF-16 surrogate";
    // The string is an overlong representation
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; already bounds checked
    Utf8ErrorReason["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason = exports.Utf8ErrorReason || (exports.Utf8ErrorReason = {}));
;
function errorFunc(reason, offset, bytes, output, badCodepoint) {
    return logger.throwArgumentError("invalid codepoint at offset " + offset + "; " + reason, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
        var i = 0;
        for (var o = offset + 1; o < bytes.length; o++) {
            if (bytes[o] >> 6 !== 0x02) {
                break;
            }
            i++;
        }
        return i;
    }
    // This byte runs us past the end of the string, so just jump to the end
    // (but the first byte was read already read and therefore skipped)
    if (reason === Utf8ErrorReason.OVERRUN) {
        return bytes.length - offset - 1;
    }
    // Nothing to skip
    return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
    // Overlong representations are otherwise "valid" code points; just non-deistingtished
    if (reason === Utf8ErrorReason.OVERLONG) {
        output.push(badCodepoint);
        return 0;
    }
    // Put the replacement character into the output
    output.push(0xfffd);
    // Otherwise, process as if ignoring errors
    return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
// Common error handing strategies
exports.Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
});
// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
function getUtf8CodePoints(bytes, onError) {
    if (onError == null) {
        onError = exports.Utf8ErrorFuncs.error;
    }
    bytes = (0, bytes_1.arrayify)(bytes);
    var result = [];
    var i = 0;
    // Invalid bytes are ignored
    while (i < bytes.length) {
        var c = bytes[i++];
        // 0xxx xxxx
        if (c >> 7 === 0) {
            result.push(c);
            continue;
        }
        // Multibyte; how many bytes left for this character?
        var extraLength = null;
        var overlongMask = null;
        // 110x xxxx 10xx xxxx
        if ((c & 0xe0) === 0xc0) {
            extraLength = 1;
            overlongMask = 0x7f;
            // 1110 xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf0) === 0xe0) {
            extraLength = 2;
            overlongMask = 0x7ff;
            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf8) === 0xf0) {
            extraLength = 3;
            overlongMask = 0xffff;
        }
        else {
            if ((c & 0xc0) === 0x80) {
                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);
            }
            else {
                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);
            }
            continue;
        }
        // Do we have enough bytes in our data?
        if (i - 1 + extraLength >= bytes.length) {
            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);
            continue;
        }
        // Remove the length prefix from the char
        var res = c & ((1 << (8 - extraLength - 1)) - 1);
        for (var j = 0; j < extraLength; j++) {
            var nextChar = bytes[i];
            // Invalid continuation byte
            if ((nextChar & 0xc0) != 0x80) {
                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);
                res = null;
                break;
            }
            ;
            res = (res << 6) | (nextChar & 0x3f);
            i++;
        }
        // See above loop for invalid continuation byte
        if (res === null) {
            continue;
        }
        // Maximum code point
        if (res > 0x10ffff) {
            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Reserved for UTF-16 surrogate halves
        if (res >= 0xd800 && res <= 0xdfff) {
            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Check for overlong sequences (more bytes than needed)
        if (res <= overlongMask) {
            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        result.push(res);
    }
    return result;
}
// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
function toUtf8Bytes(str, form) {
    if (form === void 0) { form = UnicodeNormalizationForm.current; }
    if (form != UnicodeNormalizationForm.current) {
        logger.checkNormalize();
        str = str.normalize(form);
    }
    var result = [];
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c < 0x80) {
            result.push(c);
        }
        else if (c < 0x800) {
            result.push((c >> 6) | 0xc0);
            result.push((c & 0x3f) | 0x80);
        }
        else if ((c & 0xfc00) == 0xd800) {
            i++;
            var c2 = str.charCodeAt(i);
            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {
                throw new Error("invalid utf-8 string");
            }
            // Surrogate Pair
            var pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
            result.push((pair >> 18) | 0xf0);
            result.push(((pair >> 12) & 0x3f) | 0x80);
            result.push(((pair >> 6) & 0x3f) | 0x80);
            result.push((pair & 0x3f) | 0x80);
        }
        else {
            result.push((c >> 12) | 0xe0);
            result.push(((c >> 6) & 0x3f) | 0x80);
            result.push((c & 0x3f) | 0x80);
        }
    }
    return (0, bytes_1.arrayify)(result);
}
exports.toUtf8Bytes = toUtf8Bytes;
;
function escapeChar(value) {
    var hex = ("0000" + value.toString(16));
    return "\\u" + hex.substring(hex.length - 4);
}
function _toEscapedUtf8String(bytes, onError) {
    return '"' + getUtf8CodePoints(bytes, onError).map(function (codePoint) {
        if (codePoint < 256) {
            switch (codePoint) {
                case 8: return "\\b";
                case 9: return "\\t";
                case 10: return "\\n";
                case 13: return "\\r";
                case 34: return "\\\"";
                case 92: return "\\\\";
            }
            if (codePoint >= 32 && codePoint < 127) {
                return String.fromCharCode(codePoint);
            }
        }
        if (codePoint <= 0xffff) {
            return escapeChar(codePoint);
        }
        codePoint -= 0x10000;
        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);
    }).join("") + '"';
}
exports._toEscapedUtf8String = _toEscapedUtf8String;
function _toUtf8String(codePoints) {
    return codePoints.map(function (codePoint) {
        if (codePoint <= 0xffff) {
            return String.fromCharCode(codePoint);
        }
        codePoint -= 0x10000;
        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));
    }).join("");
}
exports._toUtf8String = _toUtf8String;
function toUtf8String(bytes, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
exports.toUtf8String = toUtf8String;
function toUtf8CodePoints(str, form) {
    if (form === void 0) { form = UnicodeNormalizationForm.current; }
    return getUtf8CodePoints(toUtf8Bytes(str, form));
}
exports.toUtf8CodePoints = toUtf8CodePoints;
//# sourceMappingURL=utf8.js.map

/***/ }),

/***/ 2539:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = "transactions/5.7.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ 2449:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parse = exports.serialize = exports.accessListify = exports.recoverAddress = exports.computeAddress = exports.TransactionTypes = void 0;
var address_1 = __nccwpck_require__(8957);
var bignumber_1 = __nccwpck_require__(1267);
var bytes_1 = __nccwpck_require__(2056);
var constants_1 = __nccwpck_require__(1309);
var keccak256_1 = __nccwpck_require__(3100);
var properties_1 = __nccwpck_require__(8078);
var RLP = __importStar(__nccwpck_require__(2099));
var signing_key_1 = __nccwpck_require__(574);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(2539);
var logger = new logger_1.Logger(_version_1.version);
var TransactionTypes;
(function (TransactionTypes) {
    TransactionTypes[TransactionTypes["legacy"] = 0] = "legacy";
    TransactionTypes[TransactionTypes["eip2930"] = 1] = "eip2930";
    TransactionTypes[TransactionTypes["eip1559"] = 2] = "eip1559";
})(TransactionTypes = exports.TransactionTypes || (exports.TransactionTypes = {}));
;
///////////////////////////////
function handleAddress(value) {
    if (value === "0x") {
        return null;
    }
    return (0, address_1.getAddress)(value);
}
function handleNumber(value) {
    if (value === "0x") {
        return constants_1.Zero;
    }
    return bignumber_1.BigNumber.from(value);
}
// Legacy Transaction Fields
var transactionFields = [
    { name: "nonce", maxLength: 32, numeric: true },
    { name: "gasPrice", maxLength: 32, numeric: true },
    { name: "gasLimit", maxLength: 32, numeric: true },
    { name: "to", length: 20 },
    { name: "value", maxLength: 32, numeric: true },
    { name: "data" },
];
var allowedTransactionKeys = {
    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, type: true, value: true
};
function computeAddress(key) {
    var publicKey = (0, signing_key_1.computePublicKey)(key);
    return (0, address_1.getAddress)((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.hexDataSlice)(publicKey, 1)), 12));
}
exports.computeAddress = computeAddress;
function recoverAddress(digest, signature) {
    return computeAddress((0, signing_key_1.recoverPublicKey)((0, bytes_1.arrayify)(digest), signature));
}
exports.recoverAddress = recoverAddress;
function formatNumber(value, name) {
    var result = (0, bytes_1.stripZeros)(bignumber_1.BigNumber.from(value).toHexString());
    if (result.length > 32) {
        logger.throwArgumentError("invalid length for " + name, ("transaction:" + name), value);
    }
    return result;
}
function accessSetify(addr, storageKeys) {
    return {
        address: (0, address_1.getAddress)(addr),
        storageKeys: (storageKeys || []).map(function (storageKey, index) {
            if ((0, bytes_1.hexDataLength)(storageKey) !== 32) {
                logger.throwArgumentError("invalid access list storageKey", "accessList[" + addr + ":" + index + "]", storageKey);
            }
            return storageKey.toLowerCase();
        })
    };
}
function accessListify(value) {
    if (Array.isArray(value)) {
        return value.map(function (set, index) {
            if (Array.isArray(set)) {
                if (set.length > 2) {
                    logger.throwArgumentError("access list expected to be [ address, storageKeys[] ]", "value[" + index + "]", set);
                }
                return accessSetify(set[0], set[1]);
            }
            return accessSetify(set.address, set.storageKeys);
        });
    }
    var result = Object.keys(value).map(function (addr) {
        var storageKeys = value[addr].reduce(function (accum, storageKey) {
            accum[storageKey] = true;
            return accum;
        }, {});
        return accessSetify(addr, Object.keys(storageKeys).sort());
    });
    result.sort(function (a, b) { return (a.address.localeCompare(b.address)); });
    return result;
}
exports.accessListify = accessListify;
function formatAccessList(value) {
    return accessListify(value).map(function (set) { return [set.address, set.storageKeys]; });
}
function _serializeEip1559(transaction, signature) {
    // If there is an explicit gasPrice, make sure it matches the
    // EIP-1559 fees; otherwise they may not understand what they
    // think they are setting in terms of fee.
    if (transaction.gasPrice != null) {
        var gasPrice = bignumber_1.BigNumber.from(transaction.gasPrice);
        var maxFeePerGas = bignumber_1.BigNumber.from(transaction.maxFeePerGas || 0);
        if (!gasPrice.eq(maxFeePerGas)) {
            logger.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
                gasPrice: gasPrice,
                maxFeePerGas: maxFeePerGas
            });
        }
    }
    var fields = [
        formatNumber(transaction.chainId || 0, "chainId"),
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
        formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        ((transaction.to != null) ? (0, address_1.getAddress)(transaction.to) : "0x"),
        formatNumber(transaction.value || 0, "value"),
        (transaction.data || "0x"),
        (formatAccessList(transaction.accessList || []))
    ];
    if (signature) {
        var sig = (0, bytes_1.splitSignature)(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push((0, bytes_1.stripZeros)(sig.r));
        fields.push((0, bytes_1.stripZeros)(sig.s));
    }
    return (0, bytes_1.hexConcat)(["0x02", RLP.encode(fields)]);
}
function _serializeEip2930(transaction, signature) {
    var fields = [
        formatNumber(transaction.chainId || 0, "chainId"),
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(transaction.gasPrice || 0, "gasPrice"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        ((transaction.to != null) ? (0, address_1.getAddress)(transaction.to) : "0x"),
        formatNumber(transaction.value || 0, "value"),
        (transaction.data || "0x"),
        (formatAccessList(transaction.accessList || []))
    ];
    if (signature) {
        var sig = (0, bytes_1.splitSignature)(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push((0, bytes_1.stripZeros)(sig.r));
        fields.push((0, bytes_1.stripZeros)(sig.s));
    }
    return (0, bytes_1.hexConcat)(["0x01", RLP.encode(fields)]);
}
// Legacy Transactions and EIP-155
function _serialize(transaction, signature) {
    (0, properties_1.checkProperties)(transaction, allowedTransactionKeys);
    var raw = [];
    transactionFields.forEach(function (fieldInfo) {
        var value = transaction[fieldInfo.name] || ([]);
        var options = {};
        if (fieldInfo.numeric) {
            options.hexPad = "left";
        }
        value = (0, bytes_1.arrayify)((0, bytes_1.hexlify)(value, options));
        // Fixed-width field
        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
            logger.throwArgumentError("invalid length for " + fieldInfo.name, ("transaction:" + fieldInfo.name), value);
        }
        // Variable-width (with a maximum)
        if (fieldInfo.maxLength) {
            value = (0, bytes_1.stripZeros)(value);
            if (value.length > fieldInfo.maxLength) {
                logger.throwArgumentError("invalid length for " + fieldInfo.name, ("transaction:" + fieldInfo.name), value);
            }
        }
        raw.push((0, bytes_1.hexlify)(value));
    });
    var chainId = 0;
    if (transaction.chainId != null) {
        // A chainId was provided; if non-zero we'll use EIP-155
        chainId = transaction.chainId;
        if (typeof (chainId) !== "number") {
            logger.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
        }
    }
    else if (signature && !(0, bytes_1.isBytesLike)(signature) && signature.v > 28) {
        // No chainId provided, but the signature is signing with EIP-155; derive chainId
        chainId = Math.floor((signature.v - 35) / 2);
    }
    // We have an EIP-155 transaction (chainId was specified and non-zero)
    if (chainId !== 0) {
        raw.push((0, bytes_1.hexlify)(chainId)); // @TODO: hexValue?
        raw.push("0x");
        raw.push("0x");
    }
    // Requesting an unsigned transaction
    if (!signature) {
        return RLP.encode(raw);
    }
    // The splitSignature will ensure the transaction has a recoveryParam in the
    // case that the signTransaction function only adds a v.
    var sig = (0, bytes_1.splitSignature)(signature);
    // We pushed a chainId and null r, s on for hashing only; remove those
    var v = 27 + sig.recoveryParam;
    if (chainId !== 0) {
        raw.pop();
        raw.pop();
        raw.pop();
        v += chainId * 2 + 8;
        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!
        if (sig.v > 28 && sig.v !== v) {
            logger.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
        }
    }
    else if (sig.v !== v) {
        logger.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
    }
    raw.push((0, bytes_1.hexlify)(v));
    raw.push((0, bytes_1.stripZeros)((0, bytes_1.arrayify)(sig.r)));
    raw.push((0, bytes_1.stripZeros)((0, bytes_1.arrayify)(sig.s)));
    return RLP.encode(raw);
}
function serialize(transaction, signature) {
    // Legacy and EIP-155 Transactions
    if (transaction.type == null || transaction.type === 0) {
        if (transaction.accessList != null) {
            logger.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
        }
        return _serialize(transaction, signature);
    }
    // Typed Transactions (EIP-2718)
    switch (transaction.type) {
        case 1:
            return _serializeEip2930(transaction, signature);
        case 2:
            return _serializeEip1559(transaction, signature);
        default:
            break;
    }
    return logger.throwError("unsupported transaction type: " + transaction.type, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "serializeTransaction",
        transactionType: transaction.type
    });
}
exports.serialize = serialize;
function _parseEipSignature(tx, fields, serialize) {
    try {
        var recid = handleNumber(fields[0]).toNumber();
        if (recid !== 0 && recid !== 1) {
            throw new Error("bad recid");
        }
        tx.v = recid;
    }
    catch (error) {
        logger.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
    }
    tx.r = (0, bytes_1.hexZeroPad)(fields[1], 32);
    tx.s = (0, bytes_1.hexZeroPad)(fields[2], 32);
    try {
        var digest = (0, keccak256_1.keccak256)(serialize(tx));
        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });
    }
    catch (error) { }
}
function _parseEip1559(payload) {
    var transaction = RLP.decode(payload.slice(1));
    if (transaction.length !== 9 && transaction.length !== 12) {
        logger.throwArgumentError("invalid component count for transaction type: 2", "payload", (0, bytes_1.hexlify)(payload));
    }
    var maxPriorityFeePerGas = handleNumber(transaction[2]);
    var maxFeePerGas = handleNumber(transaction[3]);
    var tx = {
        type: 2,
        chainId: handleNumber(transaction[0]).toNumber(),
        nonce: handleNumber(transaction[1]).toNumber(),
        maxPriorityFeePerGas: maxPriorityFeePerGas,
        maxFeePerGas: maxFeePerGas,
        gasPrice: null,
        gasLimit: handleNumber(transaction[4]),
        to: handleAddress(transaction[5]),
        value: handleNumber(transaction[6]),
        data: transaction[7],
        accessList: accessListify(transaction[8]),
    };
    // Unsigned EIP-1559 Transaction
    if (transaction.length === 9) {
        return tx;
    }
    tx.hash = (0, keccak256_1.keccak256)(payload);
    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
    return tx;
}
function _parseEip2930(payload) {
    var transaction = RLP.decode(payload.slice(1));
    if (transaction.length !== 8 && transaction.length !== 11) {
        logger.throwArgumentError("invalid component count for transaction type: 1", "payload", (0, bytes_1.hexlify)(payload));
    }
    var tx = {
        type: 1,
        chainId: handleNumber(transaction[0]).toNumber(),
        nonce: handleNumber(transaction[1]).toNumber(),
        gasPrice: handleNumber(transaction[2]),
        gasLimit: handleNumber(transaction[3]),
        to: handleAddress(transaction[4]),
        value: handleNumber(transaction[5]),
        data: transaction[6],
        accessList: accessListify(transaction[7])
    };
    // Unsigned EIP-2930 Transaction
    if (transaction.length === 8) {
        return tx;
    }
    tx.hash = (0, keccak256_1.keccak256)(payload);
    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
    return tx;
}
// Legacy Transactions and EIP-155
function _parse(rawTransaction) {
    var transaction = RLP.decode(rawTransaction);
    if (transaction.length !== 9 && transaction.length !== 6) {
        logger.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
    }
    var tx = {
        nonce: handleNumber(transaction[0]).toNumber(),
        gasPrice: handleNumber(transaction[1]),
        gasLimit: handleNumber(transaction[2]),
        to: handleAddress(transaction[3]),
        value: handleNumber(transaction[4]),
        data: transaction[5],
        chainId: 0
    };
    // Legacy unsigned transaction
    if (transaction.length === 6) {
        return tx;
    }
    try {
        tx.v = bignumber_1.BigNumber.from(transaction[6]).toNumber();
    }
    catch (error) {
        // @TODO: What makes snese to do? The v is too big
        return tx;
    }
    tx.r = (0, bytes_1.hexZeroPad)(transaction[7], 32);
    tx.s = (0, bytes_1.hexZeroPad)(transaction[8], 32);
    if (bignumber_1.BigNumber.from(tx.r).isZero() && bignumber_1.BigNumber.from(tx.s).isZero()) {
        // EIP-155 unsigned transaction
        tx.chainId = tx.v;
        tx.v = 0;
    }
    else {
        // Signed Transaction
        tx.chainId = Math.floor((tx.v - 35) / 2);
        if (tx.chainId < 0) {
            tx.chainId = 0;
        }
        var recoveryParam = tx.v - 27;
        var raw = transaction.slice(0, 6);
        if (tx.chainId !== 0) {
            raw.push((0, bytes_1.hexlify)(tx.chainId));
            raw.push("0x");
            raw.push("0x");
            recoveryParam -= tx.chainId * 2 + 8;
        }
        var digest = (0, keccak256_1.keccak256)(RLP.encode(raw));
        try {
            tx.from = recoverAddress(digest, { r: (0, bytes_1.hexlify)(tx.r), s: (0, bytes_1.hexlify)(tx.s), recoveryParam: recoveryParam });
        }
        catch (error) { }
        tx.hash = (0, keccak256_1.keccak256)(rawTransaction);
    }
    tx.type = null;
    return tx;
}
function parse(rawTransaction) {
    var payload = (0, bytes_1.arrayify)(rawTransaction);
    // Legacy and EIP-155 Transactions
    if (payload[0] > 0x7f) {
        return _parse(payload);
    }
    // Typed Transaction (EIP-2718)
    switch (payload[0]) {
        case 1:
            return _parseEip2930(payload);
        case 2:
            return _parseEip1559(payload);
        default:
            break;
    }
    return logger.throwError("unsupported transaction type: " + payload[0], logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "parseTransaction",
        transactionType: payload[0]
    });
}
exports.parse = parse;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1635:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = "web/5.7.1";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ 5822:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUrl = void 0;
var http_1 = __importDefault(__nccwpck_require__(3685));
var https_1 = __importDefault(__nccwpck_require__(5687));
var zlib_1 = __nccwpck_require__(9796);
var url_1 = __nccwpck_require__(7310);
var bytes_1 = __nccwpck_require__(2056);
var properties_1 = __nccwpck_require__(8078);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(1635);
var logger = new logger_1.Logger(_version_1.version);
function getResponse(request) {
    return new Promise(function (resolve, reject) {
        request.once("response", function (resp) {
            var response = {
                statusCode: resp.statusCode,
                statusMessage: resp.statusMessage,
                headers: Object.keys(resp.headers).reduce(function (accum, name) {
                    var value = resp.headers[name];
                    if (Array.isArray(value)) {
                        value = value.join(", ");
                    }
                    accum[name] = value;
                    return accum;
                }, {}),
                body: null
            };
            //resp.setEncoding("utf8");
            resp.on("data", function (chunk) {
                if (response.body == null) {
                    response.body = new Uint8Array(0);
                }
                response.body = (0, bytes_1.concat)([response.body, chunk]);
            });
            resp.on("end", function () {
                if (response.headers["content-encoding"] === "gzip") {
                    //const size = response.body.length;
                    response.body = (0, bytes_1.arrayify)((0, zlib_1.gunzipSync)(response.body));
                    //console.log("Delta:", response.body.length - size, Buffer.from(response.body).toString());
                }
                resolve(response);
            });
            resp.on("error", function (error) {
                /* istanbul ignore next */
                error.response = response;
                reject(error);
            });
        });
        request.on("error", function (error) { reject(error); });
    });
}
// The URL.parse uses null instead of the empty string
function nonnull(value) {
    if (value == null) {
        return "";
    }
    return value;
}
function getUrl(href, options) {
    return __awaiter(this, void 0, void 0, function () {
        var url, request, req, response;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (options == null) {
                        options = {};
                    }
                    url = (0, url_1.parse)(href);
                    request = {
                        protocol: nonnull(url.protocol),
                        hostname: nonnull(url.hostname),
                        port: nonnull(url.port),
                        path: (nonnull(url.pathname) + nonnull(url.search)),
                        method: (options.method || "GET"),
                        headers: (0, properties_1.shallowCopy)(options.headers || {}),
                    };
                    if (options.allowGzip) {
                        request.headers["accept-encoding"] = "gzip";
                    }
                    req = null;
                    switch (nonnull(url.protocol)) {
                        case "http:":
                            req = http_1.default.request(request);
                            break;
                        case "https:":
                            req = https_1.default.request(request);
                            break;
                        default:
                            /* istanbul ignore next */
                            logger.throwError("unsupported protocol " + url.protocol, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                                protocol: url.protocol,
                                operation: "request"
                            });
                    }
                    if (options.body) {
                        req.write(Buffer.from(options.body));
                    }
                    req.end();
                    return [4 /*yield*/, getResponse(req)];
                case 1:
                    response = _a.sent();
                    return [2 /*return*/, response];
            }
        });
    });
}
exports.getUrl = getUrl;
//# sourceMappingURL=geturl.js.map

/***/ }),

/***/ 3138:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.poll = exports.fetchJson = exports._fetchData = void 0;
var base64_1 = __nccwpck_require__(8144);
var bytes_1 = __nccwpck_require__(2056);
var properties_1 = __nccwpck_require__(8078);
var strings_1 = __nccwpck_require__(9115);
var logger_1 = __nccwpck_require__(2975);
var _version_1 = __nccwpck_require__(1635);
var logger = new logger_1.Logger(_version_1.version);
var geturl_1 = __nccwpck_require__(5822);
function staller(duration) {
    return new Promise(function (resolve) {
        setTimeout(resolve, duration);
    });
}
function bodyify(value, type) {
    if (value == null) {
        return null;
    }
    if (typeof (value) === "string") {
        return value;
    }
    if ((0, bytes_1.isBytesLike)(value)) {
        if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
            try {
                return (0, strings_1.toUtf8String)(value);
            }
            catch (error) { }
            ;
        }
        return (0, bytes_1.hexlify)(value);
    }
    return value;
}
function unpercent(value) {
    return (0, strings_1.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, function (all, code) {
        return String.fromCharCode(parseInt(code, 16));
    }));
}
// This API is still a work in progress; the future changes will likely be:
// - ConnectionInfo => FetchDataRequest<T = any>
// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }
//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)
// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T
// For this reason, it should be considered internal until the API is finalized
function _fetchData(connection, body, processFunc) {
    // How many times to retry in the event of a throttle
    var attemptLimit = (typeof (connection) === "object" && connection.throttleLimit != null) ? connection.throttleLimit : 12;
    logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0), "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
    var throttleCallback = ((typeof (connection) === "object") ? connection.throttleCallback : null);
    var throttleSlotInterval = ((typeof (connection) === "object" && typeof (connection.throttleSlotInterval) === "number") ? connection.throttleSlotInterval : 100);
    logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0), "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
    var errorPassThrough = ((typeof (connection) === "object") ? !!(connection.errorPassThrough) : false);
    var headers = {};
    var url = null;
    // @TODO: Allow ConnectionInfo to override some of these values
    var options = {
        method: "GET",
    };
    var allow304 = false;
    var timeout = 2 * 60 * 1000;
    if (typeof (connection) === "string") {
        url = connection;
    }
    else if (typeof (connection) === "object") {
        if (connection == null || connection.url == null) {
            logger.throwArgumentError("missing URL", "connection.url", connection);
        }
        url = connection.url;
        if (typeof (connection.timeout) === "number" && connection.timeout > 0) {
            timeout = connection.timeout;
        }
        if (connection.headers) {
            for (var key in connection.headers) {
                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };
                if (["if-none-match", "if-modified-since"].indexOf(key.toLowerCase()) >= 0) {
                    allow304 = true;
                }
            }
        }
        options.allowGzip = !!connection.allowGzip;
        if (connection.user != null && connection.password != null) {
            if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
                logger.throwError("basic authentication requires a secure https url", logger_1.Logger.errors.INVALID_ARGUMENT, { argument: "url", url: url, user: connection.user, password: "[REDACTED]" });
            }
            var authorization = connection.user + ":" + connection.password;
            headers["authorization"] = {
                key: "Authorization",
                value: "Basic " + (0, base64_1.encode)((0, strings_1.toUtf8Bytes)(authorization))
            };
        }
        if (connection.skipFetchSetup != null) {
            options.skipFetchSetup = !!connection.skipFetchSetup;
        }
        if (connection.fetchOptions != null) {
            options.fetchOptions = (0, properties_1.shallowCopy)(connection.fetchOptions);
        }
    }
    var reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
    var dataMatch = ((url) ? url.match(reData) : null);
    if (dataMatch) {
        try {
            var response = {
                statusCode: 200,
                statusMessage: "OK",
                headers: { "content-type": (dataMatch[1] || "text/plain") },
                body: (dataMatch[2] ? (0, base64_1.decode)(dataMatch[3]) : unpercent(dataMatch[3]))
            };
            var result = response.body;
            if (processFunc) {
                result = processFunc(response.body, response);
            }
            return Promise.resolve(result);
        }
        catch (error) {
            logger.throwError("processing response error", logger_1.Logger.errors.SERVER_ERROR, {
                body: bodyify(dataMatch[1], dataMatch[2]),
                error: error,
                requestBody: null,
                requestMethod: "GET",
                url: url
            });
        }
    }
    if (body) {
        options.method = "POST";
        options.body = body;
        if (headers["content-type"] == null) {
            headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
        }
        if (headers["content-length"] == null) {
            headers["content-length"] = { key: "Content-Length", value: String(body.length) };
        }
    }
    var flatHeaders = {};
    Object.keys(headers).forEach(function (key) {
        var header = headers[key];
        flatHeaders[header.key] = header.value;
    });
    options.headers = flatHeaders;
    var runningTimeout = (function () {
        var timer = null;
        var promise = new Promise(function (resolve, reject) {
            if (timeout) {
                timer = setTimeout(function () {
                    if (timer == null) {
                        return;
                    }
                    timer = null;
                    reject(logger.makeError("timeout", logger_1.Logger.errors.TIMEOUT, {
                        requestBody: bodyify(options.body, flatHeaders["content-type"]),
                        requestMethod: options.method,
                        timeout: timeout,
                        url: url
                    }));
                }, timeout);
            }
        });
        var cancel = function () {
            if (timer == null) {
                return;
            }
            clearTimeout(timer);
            timer = null;
        };
        return { promise: promise, cancel: cancel };
    })();
    var runningFetch = (function () {
        return __awaiter(this, void 0, void 0, function () {
            var attempt, response, location_1, tryAgain, stall, retryAfter, error_1, body_1, result, error_2, tryAgain, timeout_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        attempt = 0;
                        _a.label = 1;
                    case 1:
                        if (!(attempt < attemptLimit)) return [3 /*break*/, 20];
                        response = null;
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 9, , 10]);
                        return [4 /*yield*/, (0, geturl_1.getUrl)(url, options)];
                    case 3:
                        response = _a.sent();
                        if (!(attempt < attemptLimit)) return [3 /*break*/, 8];
                        if (!(response.statusCode === 301 || response.statusCode === 302)) return [3 /*break*/, 4];
                        location_1 = response.headers.location || "";
                        if (options.method === "GET" && location_1.match(/^https:/)) {
                            url = response.headers.location;
                            return [3 /*break*/, 19];
                        }
                        return [3 /*break*/, 8];
                    case 4:
                        if (!(response.statusCode === 429)) return [3 /*break*/, 8];
                        tryAgain = true;
                        if (!throttleCallback) return [3 /*break*/, 6];
                        return [4 /*yield*/, throttleCallback(attempt, url)];
                    case 5:
                        tryAgain = _a.sent();
                        _a.label = 6;
                    case 6:
                        if (!tryAgain) return [3 /*break*/, 8];
                        stall = 0;
                        retryAfter = response.headers["retry-after"];
                        if (typeof (retryAfter) === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                            stall = parseInt(retryAfter) * 1000;
                        }
                        else {
                            stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                        }
                        //console.log("Stalling 429");
                        return [4 /*yield*/, staller(stall)];
                    case 7:
                        //console.log("Stalling 429");
                        _a.sent();
                        return [3 /*break*/, 19];
                    case 8: return [3 /*break*/, 10];
                    case 9:
                        error_1 = _a.sent();
                        response = error_1.response;
                        if (response == null) {
                            runningTimeout.cancel();
                            logger.throwError("missing response", logger_1.Logger.errors.SERVER_ERROR, {
                                requestBody: bodyify(options.body, flatHeaders["content-type"]),
                                requestMethod: options.method,
                                serverError: error_1,
                                url: url
                            });
                        }
                        return [3 /*break*/, 10];
                    case 10:
                        body_1 = response.body;
                        if (allow304 && response.statusCode === 304) {
                            body_1 = null;
                        }
                        else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
                            runningTimeout.cancel();
                            logger.throwError("bad response", logger_1.Logger.errors.SERVER_ERROR, {
                                status: response.statusCode,
                                headers: response.headers,
                                body: bodyify(body_1, ((response.headers) ? response.headers["content-type"] : null)),
                                requestBody: bodyify(options.body, flatHeaders["content-type"]),
                                requestMethod: options.method,
                                url: url
                            });
                        }
                        if (!processFunc) return [3 /*break*/, 18];
                        _a.label = 11;
                    case 11:
                        _a.trys.push([11, 13, , 18]);
                        return [4 /*yield*/, processFunc(body_1, response)];
                    case 12:
                        result = _a.sent();
                        runningTimeout.cancel();
                        return [2 /*return*/, result];
                    case 13:
                        error_2 = _a.sent();
                        if (!(error_2.throttleRetry && attempt < attemptLimit)) return [3 /*break*/, 17];
                        tryAgain = true;
                        if (!throttleCallback) return [3 /*break*/, 15];
                        return [4 /*yield*/, throttleCallback(attempt, url)];
                    case 14:
                        tryAgain = _a.sent();
                        _a.label = 15;
                    case 15:
                        if (!tryAgain) return [3 /*break*/, 17];
                        timeout_1 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                        //console.log("Stalling callback");
                        return [4 /*yield*/, staller(timeout_1)];
                    case 16:
                        //console.log("Stalling callback");
                        _a.sent();
                        return [3 /*break*/, 19];
                    case 17:
                        runningTimeout.cancel();
                        logger.throwError("processing response error", logger_1.Logger.errors.SERVER_ERROR, {
                            body: bodyify(body_1, ((response.headers) ? response.headers["content-type"] : null)),
                            error: error_2,
                            requestBody: bodyify(options.body, flatHeaders["content-type"]),
                            requestMethod: options.method,
                            url: url
                        });
                        return [3 /*break*/, 18];
                    case 18:
                        runningTimeout.cancel();
                        // If we had a processFunc, it either returned a T or threw above.
                        // The "body" is now a Uint8Array.
                        return [2 /*return*/, body_1];
                    case 19:
                        attempt++;
                        return [3 /*break*/, 1];
                    case 20: return [2 /*return*/, logger.throwError("failed response", logger_1.Logger.errors.SERVER_ERROR, {
                            requestBody: bodyify(options.body, flatHeaders["content-type"]),
                            requestMethod: options.method,
                            url: url
                        })];
                }
            });
        });
    })();
    return Promise.race([runningTimeout.promise, runningFetch]);
}
exports._fetchData = _fetchData;
function fetchJson(connection, json, processFunc) {
    var processJsonFunc = function (value, response) {
        var result = null;
        if (value != null) {
            try {
                result = JSON.parse((0, strings_1.toUtf8String)(value));
            }
            catch (error) {
                logger.throwError("invalid JSON", logger_1.Logger.errors.SERVER_ERROR, {
                    body: value,
                    error: error
                });
            }
        }
        if (processFunc) {
            result = processFunc(result, response);
        }
        return result;
    };
    // If we have json to send, we must
    // - add content-type of application/json (unless already overridden)
    // - convert the json to bytes
    var body = null;
    if (json != null) {
        body = (0, strings_1.toUtf8Bytes)(json);
        // Create a connection with the content-type set for JSON
        var updated = (typeof (connection) === "string") ? ({ url: connection }) : (0, properties_1.shallowCopy)(connection);
        if (updated.headers) {
            var hasContentType = (Object.keys(updated.headers).filter(function (k) { return (k.toLowerCase() === "content-type"); }).length) !== 0;
            if (!hasContentType) {
                updated.headers = (0, properties_1.shallowCopy)(updated.headers);
                updated.headers["content-type"] = "application/json";
            }
        }
        else {
            updated.headers = { "content-type": "application/json" };
        }
        connection = updated;
    }
    return _fetchData(connection, body, processJsonFunc);
}
exports.fetchJson = fetchJson;
function poll(func, options) {
    if (!options) {
        options = {};
    }
    options = (0, properties_1.shallowCopy)(options);
    if (options.floor == null) {
        options.floor = 0;
    }
    if (options.ceiling == null) {
        options.ceiling = 10000;
    }
    if (options.interval == null) {
        options.interval = 250;
    }
    return new Promise(function (resolve, reject) {
        var timer = null;
        var done = false;
        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.
        var cancel = function () {
            if (done) {
                return false;
            }
            done = true;
            if (timer) {
                clearTimeout(timer);
            }
            return true;
        };
        if (options.timeout) {
            timer = setTimeout(function () {
                if (cancel()) {
                    reject(new Error("timeout"));
                }
            }, options.timeout);
        }
        var retryLimit = options.retryLimit;
        var attempt = 0;
        function check() {
            return func().then(function (result) {
                // If we have a result, or are allowed null then we're done
                if (result !== undefined) {
                    if (cancel()) {
                        resolve(result);
                    }
                }
                else if (options.oncePoll) {
                    options.oncePoll.once("poll", check);
                }
                else if (options.onceBlock) {
                    options.onceBlock.once("block", check);
                    // Otherwise, exponential back-off (up to 10s) our next request
                }
                else if (!done) {
                    attempt++;
                    if (attempt > retryLimit) {
                        if (cancel()) {
                            reject(new Error("retry limit reached"));
                        }
                        return;
                    }
                    var timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                    if (timeout < options.floor) {
                        timeout = options.floor;
                    }
                    if (timeout > options.ceiling) {
                        timeout = options.ceiling;
                    }
                    setTimeout(check, timeout);
                }
                return null;
            }, function (error) {
                if (cancel()) {
                    reject(error);
                }
            });
        }
        check();
    });
}
exports.poll = poll;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9440:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var isPlainObject = __nccwpck_require__(3287);
var universalUserAgent = __nccwpck_require__(5030);

function lowercaseKeys(object) {
  if (!object) {
    return {};
  }

  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}

function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach(key => {
    if (isPlainObject.isPlainObject(options[key])) {
      if (!(key in defaults)) Object.assign(result, {
        [key]: options[key]
      });else result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, {
        [key]: options[key]
      });
    }
  });
  return result;
}

function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === undefined) {
      delete obj[key];
    }
  }

  return obj;
}

function merge(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? {
      method,
      url
    } : {
      url: method
    }, options);
  } else {
    options = Object.assign({}, route);
  } // lowercase header names before merging with defaults to avoid duplicates


  options.headers = lowercaseKeys(options.headers); // remove properties with undefined values before merging

  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options); // mediaType.previews arrays are merged, instead of overwritten

  if (defaults && defaults.mediaType.previews.length) {
    mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(preview => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
  }

  mergedOptions.mediaType.previews = mergedOptions.mediaType.previews.map(preview => preview.replace(/-preview/, ""));
  return mergedOptions;
}

function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);

  if (names.length === 0) {
    return url;
  }

  return url + separator + names.map(name => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }

    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}

const urlVariableRegex = /\{[^}]+\}/g;

function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}

function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);

  if (!matches) {
    return [];
  }

  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}

function omit(object, keysToOmit) {
  return Object.keys(object).filter(option => !keysToOmit.includes(option)).reduce((obj, key) => {
    obj[key] = object[key];
    return obj;
  }, {});
}

// Based on https://github.com/bramstein/url-template, licensed under BSD
// TODO: create separate package.
//
// Copyright (c) 2012-2014, Bram Stein
// All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
// EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* istanbul ignore file */
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }

    return part;
  }).join("");
}

function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);

  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}

function isDefined(value) {
  return value !== undefined && value !== null;
}

function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}

function getValues(context, operator, key, modifier) {
  var value = context[key],
      result = [];

  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();

      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }

      result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function (value) {
            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
          });
        } else {
          Object.keys(value).forEach(function (k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];

        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function (value) {
            tmp.push(encodeValue(operator, value));
          });
        } else {
          Object.keys(value).forEach(function (k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }

        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }

  return result;
}

function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}

function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
    if (expression) {
      let operator = "";
      const values = [];

      if (operators.indexOf(expression.charAt(0)) !== -1) {
        operator = expression.charAt(0);
        expression = expression.substr(1);
      }

      expression.split(/,/g).forEach(function (variable) {
        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
        values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
      });

      if (operator && operator !== "+") {
        var separator = ",";

        if (operator === "?") {
          separator = "&";
        } else if (operator !== "#") {
          separator = operator;
        }

        return (values.length !== 0 ? operator : "") + values.join(separator);
      } else {
        return values.join(",");
      }
    } else {
      return encodeReserved(literal);
    }
  });
}

function parse(options) {
  // https://fetch.spec.whatwg.org/#methods
  let method = options.method.toUpperCase(); // replace :varname with {varname} to make it RFC 6570 compatible

  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, ["method", "baseUrl", "url", "headers", "request", "mediaType"]); // extract variable names from URL to calculate remaining variables later

  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);

  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }

  const omittedParameters = Object.keys(options).filter(option => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);

  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      // e.g. application/vnd.github.v3+json => application/vnd.github.v3.raw
      headers.accept = headers.accept.split(/,/).map(preview => preview.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
    }

    if (options.mediaType.previews.length) {
      const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
      headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map(preview => {
        const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
        return `application/vnd.github.${preview}-preview${format}`;
      }).join(",");
    }
  } // for GET/HEAD requests, set URL query parameters from remaining parameters
  // for PATCH/POST/PUT/DELETE requests, set request body from remaining parameters


  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      } else {
        headers["content-length"] = 0;
      }
    }
  } // default content-type for JSON if body is set


  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  } // GitHub expects 'content-length: 0' header for PUT/PATCH requests without body.
  // fetch does not allow to set `content-length` header, but we can set body to an empty string


  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  } // Only return body/request keys if present


  return Object.assign({
    method,
    url,
    headers
  }, typeof body !== "undefined" ? {
    body
  } : null, options.request ? {
    request: options.request
  } : null);
}

function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}

function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS = merge(oldDefaults, newDefaults);
  const endpoint = endpointWithDefaults.bind(null, DEFAULTS);
  return Object.assign(endpoint, {
    DEFAULTS,
    defaults: withDefaults.bind(null, DEFAULTS),
    merge: merge.bind(null, DEFAULTS),
    parse
  });
}

const VERSION = "6.0.12";

const userAgent = `octokit-endpoint.js/${VERSION} ${universalUserAgent.getUserAgent()}`; // DEFAULTS has all properties set that EndpointOptions has, except url.
// So we use RequestParameters and add method as additional required property.

const DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: "",
    previews: []
  }
};

const endpoint = withDefaults(null, DEFAULTS);

exports.endpoint = endpoint;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 537:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var deprecation = __nccwpck_require__(8932);
var once = _interopDefault(__nccwpck_require__(1223));

const logOnceCode = once(deprecation => console.warn(deprecation));
const logOnceHeaders = once(deprecation => console.warn(deprecation));
/**
 * Error with extra properties to help with debugging
 */

class RequestError extends Error {
  constructor(message, statusCode, options) {
    super(message); // Maintains proper stack trace (only available on V8)

    /* istanbul ignore next */

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    this.name = "HttpError";
    this.status = statusCode;
    let headers;

    if ("headers" in options && typeof options.headers !== "undefined") {
      headers = options.headers;
    }

    if ("response" in options) {
      this.response = options.response;
      headers = options.response.headers;
    } // redact request credentials without mutating original request options


    const requestCopy = Object.assign({}, options.request);

    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(/ .*$/, " [REDACTED]")
      });
    }

    requestCopy.url = requestCopy.url // client_id & client_secret can be passed as URL query parameters to increase rate limit
    // see https://developer.github.com/v3/#increasing-the-unauthenticated-rate-limit-for-oauth-applications
    .replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]") // OAuth tokens can be passed as URL query parameters, although it is not recommended
    // see https://developer.github.com/v3/#oauth2-token-sent-in-a-header
    .replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy; // deprecations

    Object.defineProperty(this, "code", {
      get() {
        logOnceCode(new deprecation.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
        return statusCode;
      }

    });
    Object.defineProperty(this, "headers", {
      get() {
        logOnceHeaders(new deprecation.Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."));
        return headers || {};
      }

    });
  }

}

exports.RequestError = RequestError;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 6234:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var endpoint = __nccwpck_require__(9440);
var universalUserAgent = __nccwpck_require__(5030);
var isPlainObject = __nccwpck_require__(3287);
var nodeFetch = _interopDefault(__nccwpck_require__(467));
var requestError = __nccwpck_require__(537);

const VERSION = "5.6.3";

function getBufferResponse(response) {
  return response.arrayBuffer();
}

function fetchWrapper(requestOptions) {
  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;

  if (isPlainObject.isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }

  let headers = {};
  let status;
  let url;
  const fetch = requestOptions.request && requestOptions.request.fetch || nodeFetch;
  return fetch(requestOptions.url, Object.assign({
    method: requestOptions.method,
    body: requestOptions.body,
    headers: requestOptions.headers,
    redirect: requestOptions.redirect
  }, // `requestOptions.request.agent` type is incompatible
  // see https://github.com/octokit/types.ts/pull/264
  requestOptions.request)).then(async response => {
    url = response.url;
    status = response.status;

    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }

    if ("deprecation" in headers) {
      const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
      const deprecationLink = matches && matches.pop();
      log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
    }

    if (status === 204 || status === 205) {
      return;
    } // GitHub API returns 200 for HEAD requests


    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }

      throw new requestError.RequestError(response.statusText, status, {
        response: {
          url,
          status,
          headers,
          data: undefined
        },
        request: requestOptions
      });
    }

    if (status === 304) {
      throw new requestError.RequestError("Not modified", status, {
        response: {
          url,
          status,
          headers,
          data: await getResponseData(response)
        },
        request: requestOptions
      });
    }

    if (status >= 400) {
      const data = await getResponseData(response);
      const error = new requestError.RequestError(toErrorMessage(data), status, {
        response: {
          url,
          status,
          headers,
          data
        },
        request: requestOptions
      });
      throw error;
    }

    return getResponseData(response);
  }).then(data => {
    return {
      status,
      url,
      headers,
      data
    };
  }).catch(error => {
    if (error instanceof requestError.RequestError) throw error;
    throw new requestError.RequestError(error.message, 500, {
      request: requestOptions
    });
  });
}

async function getResponseData(response) {
  const contentType = response.headers.get("content-type");

  if (/application\/json/.test(contentType)) {
    return response.json();
  }

  if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
    return response.text();
  }

  return getBufferResponse(response);
}

function toErrorMessage(data) {
  if (typeof data === "string") return data; // istanbul ignore else - just in case

  if ("message" in data) {
    if (Array.isArray(data.errors)) {
      return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}`;
    }

    return data.message;
  } // istanbul ignore next - just in case


  return `Unknown error: ${JSON.stringify(data)}`;
}

function withDefaults(oldEndpoint, newDefaults) {
  const endpoint = oldEndpoint.defaults(newDefaults);

  const newApi = function (route, parameters) {
    const endpointOptions = endpoint.merge(route, parameters);

    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint.parse(endpointOptions));
    }

    const request = (route, parameters) => {
      return fetchWrapper(endpoint.parse(endpoint.merge(route, parameters)));
    };

    Object.assign(request, {
      endpoint,
      defaults: withDefaults.bind(null, endpoint)
    });
    return endpointOptions.request.hook(request, endpointOptions);
  };

  return Object.assign(newApi, {
    endpoint,
    defaults: withDefaults.bind(null, endpoint)
  });
}

const request = withDefaults(endpoint.endpoint, {
  headers: {
    "user-agent": `octokit-request.js/${VERSION} ${universalUserAgent.getUserAgent()}`
  }
});

exports.request = request;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 4834:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __objSpread = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (cb, mod) => () => (mod || cb((mod = {exports: {}}).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// node_modules/antlr4ts/ANTLRErrorListener.js
var require_ANTLRErrorListener = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
});

// node_modules/antlr4ts/ANTLRErrorStrategy.js
var require_ANTLRErrorStrategy = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
});

// node_modules/antlr4ts/Decorators.js
var require_Decorators = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.SuppressWarnings = exports.Override = exports.Nullable = exports.NotNull = void 0;
  function NotNull(target, propertyKey, propertyDescriptor) {
  }
  exports.NotNull = NotNull;
  function Nullable(target, propertyKey, propertyDescriptor) {
  }
  exports.Nullable = Nullable;
  function Override(target, propertyKey, propertyDescriptor) {
  }
  exports.Override = Override;
  function SuppressWarnings(options) {
    return (target, propertyKey, descriptor) => {
    };
  }
  exports.SuppressWarnings = SuppressWarnings;
});

// node_modules/antlr4ts/IntStream.js
var require_IntStream = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.IntStream = void 0;
  var IntStream;
  (function(IntStream2) {
    IntStream2.EOF = -1;
    IntStream2.UNKNOWN_SOURCE_NAME = "<unknown>";
  })(IntStream = exports.IntStream || (exports.IntStream = {}));
});

// node_modules/antlr4ts/ANTLRInputStream.js
var require_ANTLRInputStream = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ANTLRInputStream = void 0;
  var assert = __nccwpck_require__(9491);
  var Decorators_1 = require_Decorators();
  var IntStream_1 = require_IntStream();
  var ANTLRInputStream2 = class {
    constructor(input) {
      this.p = 0;
      this.data = input;
      this.n = input.length;
    }
    reset() {
      this.p = 0;
    }
    consume() {
      if (this.p >= this.n) {
        assert(this.LA(1) === IntStream_1.IntStream.EOF);
        throw new Error("cannot consume EOF");
      }
      if (this.p < this.n) {
        this.p++;
      }
    }
    LA(i) {
      if (i === 0) {
        return 0;
      }
      if (i < 0) {
        i++;
        if (this.p + i - 1 < 0) {
          return IntStream_1.IntStream.EOF;
        }
      }
      if (this.p + i - 1 >= this.n) {
        return IntStream_1.IntStream.EOF;
      }
      return this.data.charCodeAt(this.p + i - 1);
    }
    LT(i) {
      return this.LA(i);
    }
    get index() {
      return this.p;
    }
    get size() {
      return this.n;
    }
    mark() {
      return -1;
    }
    release(marker) {
    }
    seek(index) {
      if (index <= this.p) {
        this.p = index;
        return;
      }
      index = Math.min(index, this.n);
      while (this.p < index) {
        this.consume();
      }
    }
    getText(interval) {
      let start = interval.a;
      let stop = interval.b;
      if (stop >= this.n) {
        stop = this.n - 1;
      }
      let count = stop - start + 1;
      if (start >= this.n) {
        return "";
      }
      return this.data.substr(start, count);
    }
    get sourceName() {
      if (!this.name) {
        return IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
      }
      return this.name;
    }
    toString() {
      return this.data;
    }
  };
  __decorate([
    Decorators_1.Override
  ], ANTLRInputStream2.prototype, "consume", null);
  __decorate([
    Decorators_1.Override
  ], ANTLRInputStream2.prototype, "LA", null);
  __decorate([
    Decorators_1.Override
  ], ANTLRInputStream2.prototype, "index", null);
  __decorate([
    Decorators_1.Override
  ], ANTLRInputStream2.prototype, "size", null);
  __decorate([
    Decorators_1.Override
  ], ANTLRInputStream2.prototype, "mark", null);
  __decorate([
    Decorators_1.Override
  ], ANTLRInputStream2.prototype, "release", null);
  __decorate([
    Decorators_1.Override
  ], ANTLRInputStream2.prototype, "seek", null);
  __decorate([
    Decorators_1.Override
  ], ANTLRInputStream2.prototype, "getText", null);
  __decorate([
    Decorators_1.Override
  ], ANTLRInputStream2.prototype, "sourceName", null);
  __decorate([
    Decorators_1.Override
  ], ANTLRInputStream2.prototype, "toString", null);
  exports.ANTLRInputStream = ANTLRInputStream2;
});

// node_modules/antlr4ts/atn/ATNState.js
var require_ATNState = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ATNState = void 0;
  var Decorators_1 = require_Decorators();
  var ATNState = class {
    constructor() {
      this.stateNumber = ATNState.INVALID_STATE_NUMBER;
      this.ruleIndex = 0;
      this.epsilonOnlyTransitions = false;
      this.transitions = [];
      this.optimizedTransitions = this.transitions;
    }
    getStateNumber() {
      return this.stateNumber;
    }
    get nonStopStateNumber() {
      return this.getStateNumber();
    }
    hashCode() {
      return this.stateNumber;
    }
    equals(o) {
      if (o instanceof ATNState) {
        return this.stateNumber === o.stateNumber;
      }
      return false;
    }
    get isNonGreedyExitState() {
      return false;
    }
    toString() {
      return String(this.stateNumber);
    }
    getTransitions() {
      return this.transitions.slice(0);
    }
    get numberOfTransitions() {
      return this.transitions.length;
    }
    addTransition(e, index) {
      if (this.transitions.length === 0) {
        this.epsilonOnlyTransitions = e.isEpsilon;
      } else if (this.epsilonOnlyTransitions !== e.isEpsilon) {
        this.epsilonOnlyTransitions = false;
        throw new Error("ATN state " + this.stateNumber + " has both epsilon and non-epsilon transitions.");
      }
      this.transitions.splice(index !== void 0 ? index : this.transitions.length, 0, e);
    }
    transition(i) {
      return this.transitions[i];
    }
    setTransition(i, e) {
      this.transitions[i] = e;
    }
    removeTransition(index) {
      return this.transitions.splice(index, 1)[0];
    }
    get onlyHasEpsilonTransitions() {
      return this.epsilonOnlyTransitions;
    }
    setRuleIndex(ruleIndex) {
      this.ruleIndex = ruleIndex;
    }
    get isOptimized() {
      return this.optimizedTransitions !== this.transitions;
    }
    get numberOfOptimizedTransitions() {
      return this.optimizedTransitions.length;
    }
    getOptimizedTransition(i) {
      return this.optimizedTransitions[i];
    }
    addOptimizedTransition(e) {
      if (!this.isOptimized) {
        this.optimizedTransitions = new Array();
      }
      this.optimizedTransitions.push(e);
    }
    setOptimizedTransition(i, e) {
      if (!this.isOptimized) {
        throw new Error("This ATNState is not optimized.");
      }
      this.optimizedTransitions[i] = e;
    }
    removeOptimizedTransition(i) {
      if (!this.isOptimized) {
        throw new Error("This ATNState is not optimized.");
      }
      this.optimizedTransitions.splice(i, 1);
    }
  };
  __decorate([
    Decorators_1.Override
  ], ATNState.prototype, "hashCode", null);
  __decorate([
    Decorators_1.Override
  ], ATNState.prototype, "equals", null);
  __decorate([
    Decorators_1.Override
  ], ATNState.prototype, "toString", null);
  exports.ATNState = ATNState;
  (function(ATNState2) {
    ATNState2.INVALID_STATE_NUMBER = -1;
  })(ATNState = exports.ATNState || (exports.ATNState = {}));
});

// node_modules/antlr4ts/atn/ATNStateType.js
var require_ATNStateType = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ATNStateType = void 0;
  var ATNStateType;
  (function(ATNStateType2) {
    ATNStateType2[ATNStateType2["INVALID_TYPE"] = 0] = "INVALID_TYPE";
    ATNStateType2[ATNStateType2["BASIC"] = 1] = "BASIC";
    ATNStateType2[ATNStateType2["RULE_START"] = 2] = "RULE_START";
    ATNStateType2[ATNStateType2["BLOCK_START"] = 3] = "BLOCK_START";
    ATNStateType2[ATNStateType2["PLUS_BLOCK_START"] = 4] = "PLUS_BLOCK_START";
    ATNStateType2[ATNStateType2["STAR_BLOCK_START"] = 5] = "STAR_BLOCK_START";
    ATNStateType2[ATNStateType2["TOKEN_START"] = 6] = "TOKEN_START";
    ATNStateType2[ATNStateType2["RULE_STOP"] = 7] = "RULE_STOP";
    ATNStateType2[ATNStateType2["BLOCK_END"] = 8] = "BLOCK_END";
    ATNStateType2[ATNStateType2["STAR_LOOP_BACK"] = 9] = "STAR_LOOP_BACK";
    ATNStateType2[ATNStateType2["STAR_LOOP_ENTRY"] = 10] = "STAR_LOOP_ENTRY";
    ATNStateType2[ATNStateType2["PLUS_LOOP_BACK"] = 11] = "PLUS_LOOP_BACK";
    ATNStateType2[ATNStateType2["LOOP_END"] = 12] = "LOOP_END";
  })(ATNStateType = exports.ATNStateType || (exports.ATNStateType = {}));
});

// node_modules/antlr4ts/RecognitionException.js
var require_RecognitionException = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.RecognitionException = void 0;
  var RecognitionException2 = class extends Error {
    constructor(recognizer, input, ctx, message) {
      super(message);
      this._offendingState = -1;
      this._recognizer = recognizer;
      this.input = input;
      this.ctx = ctx;
      if (recognizer) {
        this._offendingState = recognizer.state;
      }
    }
    get offendingState() {
      return this._offendingState;
    }
    setOffendingState(offendingState) {
      this._offendingState = offendingState;
    }
    get expectedTokens() {
      if (this._recognizer) {
        return this._recognizer.atn.getExpectedTokens(this._offendingState, this.ctx);
      }
      return void 0;
    }
    get context() {
      return this.ctx;
    }
    get inputStream() {
      return this.input;
    }
    getOffendingToken(recognizer) {
      if (recognizer && recognizer !== this._recognizer) {
        return void 0;
      }
      return this.offendingToken;
    }
    setOffendingToken(recognizer, offendingToken) {
      if (recognizer === this._recognizer) {
        this.offendingToken = offendingToken;
      }
    }
    get recognizer() {
      return this._recognizer;
    }
  };
  exports.RecognitionException = RecognitionException2;
});

// node_modules/antlr4ts/atn/Transition.js
var require_Transition = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.Transition = void 0;
  var Decorators_1 = require_Decorators();
  var Transition = class Transition {
    constructor(target) {
      if (target == null) {
        throw new Error("target cannot be null.");
      }
      this.target = target;
    }
    get isEpsilon() {
      return false;
    }
    get label() {
      return void 0;
    }
  };
  Transition.serializationNames = [
    "INVALID",
    "EPSILON",
    "RANGE",
    "RULE",
    "PREDICATE",
    "ATOM",
    "ACTION",
    "SET",
    "NOT_SET",
    "WILDCARD",
    "PRECEDENCE"
  ];
  __decorate([
    Decorators_1.NotNull
  ], Transition.prototype, "target", void 0);
  Transition = __decorate([
    __param(0, Decorators_1.NotNull)
  ], Transition);
  exports.Transition = Transition;
});

// node_modules/antlr4ts/atn/AbstractPredicateTransition.js
var require_AbstractPredicateTransition = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.AbstractPredicateTransition = void 0;
  var Transition_1 = require_Transition();
  var AbstractPredicateTransition = class extends Transition_1.Transition {
    constructor(target) {
      super(target);
    }
  };
  exports.AbstractPredicateTransition = AbstractPredicateTransition;
});

// node_modules/antlr4ts/misc/MurmurHash.js
var require_MurmurHash = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.MurmurHash = void 0;
  var MurmurHash;
  (function(MurmurHash2) {
    const DEFAULT_SEED = 0;
    function initialize(seed = DEFAULT_SEED) {
      return seed;
    }
    MurmurHash2.initialize = initialize;
    function update(hash, value) {
      const c1 = 3432918353;
      const c2 = 461845907;
      const r1 = 15;
      const r2 = 13;
      const m = 5;
      const n = 3864292196;
      if (value == null) {
        value = 0;
      } else if (typeof value === "string") {
        value = hashString(value);
      } else if (typeof value === "object") {
        value = value.hashCode();
      }
      let k = value;
      k = Math.imul(k, c1);
      k = k << r1 | k >>> 32 - r1;
      k = Math.imul(k, c2);
      hash = hash ^ k;
      hash = hash << r2 | hash >>> 32 - r2;
      hash = Math.imul(hash, m) + n;
      return hash & 4294967295;
    }
    MurmurHash2.update = update;
    function finish(hash, numberOfWords) {
      hash = hash ^ numberOfWords * 4;
      hash = hash ^ hash >>> 16;
      hash = Math.imul(hash, 2246822507);
      hash = hash ^ hash >>> 13;
      hash = Math.imul(hash, 3266489909);
      hash = hash ^ hash >>> 16;
      return hash;
    }
    MurmurHash2.finish = finish;
    function hashCode(data, seed = DEFAULT_SEED) {
      let hash = initialize(seed);
      let length = 0;
      for (let value of data) {
        hash = update(hash, value);
        length++;
      }
      hash = finish(hash, length);
      return hash;
    }
    MurmurHash2.hashCode = hashCode;
    function hashString(str) {
      let len = str.length;
      if (len === 0) {
        return 0;
      }
      let hash = 0;
      for (let i = 0; i < len; i++) {
        let c = str.charCodeAt(i);
        hash = (hash << 5 >>> 0) - hash + c;
        hash |= 0;
      }
      return hash;
    }
  })(MurmurHash = exports.MurmurHash || (exports.MurmurHash = {}));
});

// node_modules/antlr4ts/misc/ObjectEqualityComparator.js
var require_ObjectEqualityComparator = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ObjectEqualityComparator = void 0;
  var Decorators_1 = require_Decorators();
  var ObjectEqualityComparator = class {
    hashCode(obj) {
      if (obj == null) {
        return 0;
      }
      return obj.hashCode();
    }
    equals(a, b) {
      if (a == null) {
        return b == null;
      }
      return a.equals(b);
    }
  };
  ObjectEqualityComparator.INSTANCE = new ObjectEqualityComparator();
  __decorate([
    Decorators_1.Override
  ], ObjectEqualityComparator.prototype, "hashCode", null);
  __decorate([
    Decorators_1.Override
  ], ObjectEqualityComparator.prototype, "equals", null);
  exports.ObjectEqualityComparator = ObjectEqualityComparator;
});

// node_modules/antlr4ts/misc/DefaultEqualityComparator.js
var require_DefaultEqualityComparator = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.DefaultEqualityComparator = void 0;
  var Decorators_1 = require_Decorators();
  var MurmurHash_1 = require_MurmurHash();
  var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
  var DefaultEqualityComparator = class {
    hashCode(obj) {
      if (obj == null) {
        return 0;
      } else if (typeof obj === "string" || typeof obj === "number") {
        return MurmurHash_1.MurmurHash.hashCode([obj]);
      } else {
        return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.hashCode(obj);
      }
    }
    equals(a, b) {
      if (a == null) {
        return b == null;
      } else if (typeof a === "string" || typeof a === "number") {
        return a === b;
      } else {
        return ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a, b);
      }
    }
  };
  DefaultEqualityComparator.INSTANCE = new DefaultEqualityComparator();
  __decorate([
    Decorators_1.Override
  ], DefaultEqualityComparator.prototype, "hashCode", null);
  __decorate([
    Decorators_1.Override
  ], DefaultEqualityComparator.prototype, "equals", null);
  exports.DefaultEqualityComparator = DefaultEqualityComparator;
});

// node_modules/antlr4ts/misc/Array2DHashSet.js
var require_Array2DHashSet = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.Array2DHashSet = void 0;
  var assert = __nccwpck_require__(9491);
  var DefaultEqualityComparator_1 = require_DefaultEqualityComparator();
  var Decorators_1 = require_Decorators();
  var MurmurHash_1 = require_MurmurHash();
  var INITAL_CAPACITY = 16;
  var LOAD_FACTOR = 0.75;
  var Array2DHashSet = class {
    constructor(comparatorOrSet, initialCapacity = INITAL_CAPACITY) {
      this.n = 0;
      this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);
      if (comparatorOrSet instanceof Array2DHashSet) {
        this.comparator = comparatorOrSet.comparator;
        this.buckets = comparatorOrSet.buckets.slice(0);
        for (let i = 0; i < this.buckets.length; i++) {
          let bucket = this.buckets[i];
          if (bucket) {
            this.buckets[i] = bucket.slice(0);
          }
        }
        this.n = comparatorOrSet.n;
        this.threshold = comparatorOrSet.threshold;
      } else {
        this.comparator = comparatorOrSet || DefaultEqualityComparator_1.DefaultEqualityComparator.INSTANCE;
        this.buckets = this.createBuckets(initialCapacity);
      }
    }
    getOrAdd(o) {
      if (this.n > this.threshold) {
        this.expand();
      }
      return this.getOrAddImpl(o);
    }
    getOrAddImpl(o) {
      let b = this.getBucket(o);
      let bucket = this.buckets[b];
      if (!bucket) {
        bucket = [o];
        this.buckets[b] = bucket;
        this.n++;
        return o;
      }
      for (let existing of bucket) {
        if (this.comparator.equals(existing, o)) {
          return existing;
        }
      }
      bucket.push(o);
      this.n++;
      return o;
    }
    get(o) {
      if (o == null) {
        return o;
      }
      let b = this.getBucket(o);
      let bucket = this.buckets[b];
      if (!bucket) {
        return void 0;
      }
      for (let e of bucket) {
        if (this.comparator.equals(e, o)) {
          return e;
        }
      }
      return void 0;
    }
    getBucket(o) {
      let hash = this.comparator.hashCode(o);
      let b = hash & this.buckets.length - 1;
      return b;
    }
    hashCode() {
      let hash = MurmurHash_1.MurmurHash.initialize();
      for (let bucket of this.buckets) {
        if (bucket == null) {
          continue;
        }
        for (let o of bucket) {
          if (o == null) {
            break;
          }
          hash = MurmurHash_1.MurmurHash.update(hash, this.comparator.hashCode(o));
        }
      }
      hash = MurmurHash_1.MurmurHash.finish(hash, this.size);
      return hash;
    }
    equals(o) {
      if (o === this) {
        return true;
      }
      if (!(o instanceof Array2DHashSet)) {
        return false;
      }
      if (o.size !== this.size) {
        return false;
      }
      let same = this.containsAll(o);
      return same;
    }
    expand() {
      let old = this.buckets;
      let newCapacity = this.buckets.length * 2;
      let newTable = this.createBuckets(newCapacity);
      this.buckets = newTable;
      this.threshold = Math.floor(newCapacity * LOAD_FACTOR);
      let oldSize = this.size;
      for (let bucket of old) {
        if (!bucket) {
          continue;
        }
        for (let o of bucket) {
          let b = this.getBucket(o);
          let newBucket = this.buckets[b];
          if (!newBucket) {
            newBucket = [];
            this.buckets[b] = newBucket;
          }
          newBucket.push(o);
        }
      }
      assert(this.n === oldSize);
    }
    add(t) {
      let existing = this.getOrAdd(t);
      return existing === t;
    }
    get size() {
      return this.n;
    }
    get isEmpty() {
      return this.n === 0;
    }
    contains(o) {
      return this.containsFast(this.asElementType(o));
    }
    containsFast(obj) {
      if (obj == null) {
        return false;
      }
      return this.get(obj) != null;
    }
    *[Symbol.iterator]() {
      yield* this.toArray();
    }
    toArray() {
      const a = new Array(this.size);
      let i = 0;
      for (let bucket of this.buckets) {
        if (bucket == null) {
          continue;
        }
        for (let o of bucket) {
          if (o == null) {
            break;
          }
          a[i++] = o;
        }
      }
      return a;
    }
    containsAll(collection) {
      if (collection instanceof Array2DHashSet) {
        let s = collection;
        for (let bucket of s.buckets) {
          if (bucket == null) {
            continue;
          }
          for (let o of bucket) {
            if (o == null) {
              break;
            }
            if (!this.containsFast(this.asElementType(o))) {
              return false;
            }
          }
        }
      } else {
        for (let o of collection) {
          if (!this.containsFast(this.asElementType(o))) {
            return false;
          }
        }
      }
      return true;
    }
    addAll(c) {
      let changed = false;
      for (let o of c) {
        let existing = this.getOrAdd(o);
        if (existing !== o) {
          changed = true;
        }
      }
      return changed;
    }
    clear() {
      this.buckets = this.createBuckets(INITAL_CAPACITY);
      this.n = 0;
      this.threshold = Math.floor(INITAL_CAPACITY * LOAD_FACTOR);
    }
    toString() {
      if (this.size === 0) {
        return "{}";
      }
      let buf = "{";
      let first = true;
      for (let bucket of this.buckets) {
        if (bucket == null) {
          continue;
        }
        for (let o of bucket) {
          if (o == null) {
            break;
          }
          if (first) {
            first = false;
          } else {
            buf += ", ";
          }
          buf += o.toString();
        }
      }
      buf += "}";
      return buf;
    }
    toTableString() {
      let buf = "";
      for (let bucket of this.buckets) {
        if (bucket == null) {
          buf += "null\n";
          continue;
        }
        buf += "[";
        let first = true;
        for (let o of bucket) {
          if (first) {
            first = false;
          } else {
            buf += " ";
          }
          if (o == null) {
            buf += "_";
          } else {
            buf += o.toString();
          }
        }
        buf += "]\n";
      }
      return buf;
    }
    asElementType(o) {
      return o;
    }
    createBuckets(capacity) {
      return new Array(capacity);
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], Array2DHashSet.prototype, "comparator", void 0);
  __decorate([
    Decorators_1.Override
  ], Array2DHashSet.prototype, "hashCode", null);
  __decorate([
    Decorators_1.Override
  ], Array2DHashSet.prototype, "equals", null);
  __decorate([
    Decorators_1.Override
  ], Array2DHashSet.prototype, "add", null);
  __decorate([
    Decorators_1.Override
  ], Array2DHashSet.prototype, "size", null);
  __decorate([
    Decorators_1.Override
  ], Array2DHashSet.prototype, "isEmpty", null);
  __decorate([
    Decorators_1.Override
  ], Array2DHashSet.prototype, "contains", null);
  __decorate([
    __param(0, Decorators_1.Nullable)
  ], Array2DHashSet.prototype, "containsFast", null);
  __decorate([
    Decorators_1.Override
  ], Array2DHashSet.prototype, Symbol.iterator, null);
  __decorate([
    Decorators_1.Override
  ], Array2DHashSet.prototype, "toArray", null);
  __decorate([
    Decorators_1.Override
  ], Array2DHashSet.prototype, "containsAll", null);
  __decorate([
    Decorators_1.Override
  ], Array2DHashSet.prototype, "addAll", null);
  __decorate([
    Decorators_1.Override
  ], Array2DHashSet.prototype, "clear", null);
  __decorate([
    Decorators_1.Override
  ], Array2DHashSet.prototype, "toString", null);
  __decorate([
    Decorators_1.SuppressWarnings("unchecked")
  ], Array2DHashSet.prototype, "asElementType", null);
  __decorate([
    Decorators_1.SuppressWarnings("unchecked")
  ], Array2DHashSet.prototype, "createBuckets", null);
  exports.Array2DHashSet = Array2DHashSet;
});

// node_modules/antlr4ts/misc/ArrayEqualityComparator.js
var require_ArrayEqualityComparator = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ArrayEqualityComparator = void 0;
  var Decorators_1 = require_Decorators();
  var MurmurHash_1 = require_MurmurHash();
  var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
  var ArrayEqualityComparator = class {
    hashCode(obj) {
      if (obj == null) {
        return 0;
      }
      return MurmurHash_1.MurmurHash.hashCode(obj, 0);
    }
    equals(a, b) {
      if (a == null) {
        return b == null;
      } else if (b == null) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (!ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
  };
  ArrayEqualityComparator.INSTANCE = new ArrayEqualityComparator();
  __decorate([
    Decorators_1.Override
  ], ArrayEqualityComparator.prototype, "hashCode", null);
  __decorate([
    Decorators_1.Override
  ], ArrayEqualityComparator.prototype, "equals", null);
  exports.ArrayEqualityComparator = ArrayEqualityComparator;
});

// node_modules/antlr4ts/misc/Utils.js
var require_Utils = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.toCharArray = exports.toMap = exports.equals = exports.join = exports.escapeWhitespace = void 0;
  function escapeWhitespace(s, escapeSpaces) {
    return escapeSpaces ? s.replace(/ /, "\xB7") : s.replace(/\t/, "\\t").replace(/\n/, "\\n").replace(/\r/, "\\r");
  }
  exports.escapeWhitespace = escapeWhitespace;
  function join3(collection, separator) {
    let buf = "";
    let first = true;
    for (let current of collection) {
      if (first) {
        first = false;
      } else {
        buf += separator;
      }
      buf += current;
    }
    return buf;
  }
  exports.join = join3;
  function equals(x, y) {
    if (x === y) {
      return true;
    }
    if (x === void 0 || y === void 0) {
      return false;
    }
    return x.equals(y);
  }
  exports.equals = equals;
  function toMap(keys) {
    let m = new Map();
    for (let i = 0; i < keys.length; i++) {
      m.set(keys[i], i);
    }
    return m;
  }
  exports.toMap = toMap;
  function toCharArray3(str) {
    if (typeof str === "string") {
      let result = new Uint16Array(str.length);
      for (let i = 0; i < str.length; i++) {
        result[i] = str.charCodeAt(i);
      }
      return result;
    } else {
      return str.toCharArray();
    }
  }
  exports.toCharArray = toCharArray3;
});

// node_modules/antlr4ts/atn/SemanticContext.js
var require_SemanticContext = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.SemanticContext = void 0;
  var Array2DHashSet_1 = require_Array2DHashSet();
  var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
  var MurmurHash_1 = require_MurmurHash();
  var Decorators_1 = require_Decorators();
  var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
  var Utils3 = require_Utils();
  function max(items) {
    let result;
    for (let current of items) {
      if (result === void 0) {
        result = current;
        continue;
      }
      let comparison = result.compareTo(current);
      if (comparison < 0) {
        result = current;
      }
    }
    return result;
  }
  function min(items) {
    let result;
    for (let current of items) {
      if (result === void 0) {
        result = current;
        continue;
      }
      let comparison = result.compareTo(current);
      if (comparison > 0) {
        result = current;
      }
    }
    return result;
  }
  var SemanticContext = class {
    static get NONE() {
      if (SemanticContext._NONE === void 0) {
        SemanticContext._NONE = new SemanticContext.Predicate();
      }
      return SemanticContext._NONE;
    }
    evalPrecedence(parser, parserCallStack) {
      return this;
    }
    static and(a, b) {
      if (!a || a === SemanticContext.NONE) {
        return b;
      }
      if (b === SemanticContext.NONE) {
        return a;
      }
      let result = new SemanticContext.AND(a, b);
      if (result.opnds.length === 1) {
        return result.opnds[0];
      }
      return result;
    }
    static or(a, b) {
      if (!a) {
        return b;
      }
      if (a === SemanticContext.NONE || b === SemanticContext.NONE) {
        return SemanticContext.NONE;
      }
      let result = new SemanticContext.OR(a, b);
      if (result.opnds.length === 1) {
        return result.opnds[0];
      }
      return result;
    }
  };
  exports.SemanticContext = SemanticContext;
  (function(SemanticContext2) {
    const AND_HASHCODE = 40363613;
    const OR_HASHCODE = 486279973;
    function filterPrecedencePredicates(collection) {
      let result = [];
      for (let i = 0; i < collection.length; i++) {
        let context = collection[i];
        if (context instanceof SemanticContext2.PrecedencePredicate) {
          result.push(context);
          collection.splice(i, 1);
          i--;
        }
      }
      return result;
    }
    class Predicate extends SemanticContext2 {
      constructor(ruleIndex = -1, predIndex = -1, isCtxDependent = false) {
        super();
        this.ruleIndex = ruleIndex;
        this.predIndex = predIndex;
        this.isCtxDependent = isCtxDependent;
      }
      eval(parser, parserCallStack) {
        let localctx = this.isCtxDependent ? parserCallStack : void 0;
        return parser.sempred(localctx, this.ruleIndex, this.predIndex);
      }
      hashCode() {
        let hashCode = MurmurHash_1.MurmurHash.initialize();
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.ruleIndex);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.predIndex);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.isCtxDependent ? 1 : 0);
        hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 3);
        return hashCode;
      }
      equals(obj) {
        if (!(obj instanceof Predicate)) {
          return false;
        }
        if (this === obj) {
          return true;
        }
        return this.ruleIndex === obj.ruleIndex && this.predIndex === obj.predIndex && this.isCtxDependent === obj.isCtxDependent;
      }
      toString() {
        return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
      }
    }
    __decorate([
      Decorators_1.Override
    ], Predicate.prototype, "eval", null);
    __decorate([
      Decorators_1.Override
    ], Predicate.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], Predicate.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], Predicate.prototype, "toString", null);
    SemanticContext2.Predicate = Predicate;
    class PrecedencePredicate extends SemanticContext2 {
      constructor(precedence) {
        super();
        this.precedence = precedence;
      }
      eval(parser, parserCallStack) {
        return parser.precpred(parserCallStack, this.precedence);
      }
      evalPrecedence(parser, parserCallStack) {
        if (parser.precpred(parserCallStack, this.precedence)) {
          return SemanticContext2.NONE;
        } else {
          return void 0;
        }
      }
      compareTo(o) {
        return this.precedence - o.precedence;
      }
      hashCode() {
        let hashCode = 1;
        hashCode = 31 * hashCode + this.precedence;
        return hashCode;
      }
      equals(obj) {
        if (!(obj instanceof PrecedencePredicate)) {
          return false;
        }
        if (this === obj) {
          return true;
        }
        return this.precedence === obj.precedence;
      }
      toString() {
        return "{" + this.precedence + ">=prec}?";
      }
    }
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicate.prototype, "eval", null);
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicate.prototype, "evalPrecedence", null);
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicate.prototype, "compareTo", null);
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicate.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicate.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], PrecedencePredicate.prototype, "toString", null);
    SemanticContext2.PrecedencePredicate = PrecedencePredicate;
    class Operator extends SemanticContext2 {
    }
    SemanticContext2.Operator = Operator;
    let AND = class AND2 extends Operator {
      constructor(a, b) {
        super();
        let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        if (a instanceof AND2) {
          operands.addAll(a.opnds);
        } else {
          operands.add(a);
        }
        if (b instanceof AND2) {
          operands.addAll(b.opnds);
        } else {
          operands.add(b);
        }
        this.opnds = operands.toArray();
        let precedencePredicates = filterPrecedencePredicates(this.opnds);
        let reduced = min(precedencePredicates);
        if (reduced) {
          this.opnds.push(reduced);
        }
      }
      get operands() {
        return this.opnds;
      }
      equals(obj) {
        if (this === obj) {
          return true;
        }
        if (!(obj instanceof AND2)) {
          return false;
        }
        return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);
      }
      hashCode() {
        return MurmurHash_1.MurmurHash.hashCode(this.opnds, AND_HASHCODE);
      }
      eval(parser, parserCallStack) {
        for (let opnd of this.opnds) {
          if (!opnd.eval(parser, parserCallStack)) {
            return false;
          }
        }
        return true;
      }
      evalPrecedence(parser, parserCallStack) {
        let differs = false;
        let operands = [];
        for (let context of this.opnds) {
          let evaluated = context.evalPrecedence(parser, parserCallStack);
          differs = differs || evaluated !== context;
          if (evaluated == null) {
            return void 0;
          } else if (evaluated !== SemanticContext2.NONE) {
            operands.push(evaluated);
          }
        }
        if (!differs) {
          return this;
        }
        if (operands.length === 0) {
          return SemanticContext2.NONE;
        }
        let result = operands[0];
        for (let i = 1; i < operands.length; i++) {
          result = SemanticContext2.and(result, operands[i]);
        }
        return result;
      }
      toString() {
        return Utils3.join(this.opnds, "&&");
      }
    };
    __decorate([
      Decorators_1.Override
    ], AND.prototype, "operands", null);
    __decorate([
      Decorators_1.Override
    ], AND.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], AND.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], AND.prototype, "eval", null);
    __decorate([
      Decorators_1.Override
    ], AND.prototype, "evalPrecedence", null);
    __decorate([
      Decorators_1.Override
    ], AND.prototype, "toString", null);
    AND = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], AND);
    SemanticContext2.AND = AND;
    let OR = class OR2 extends Operator {
      constructor(a, b) {
        super();
        let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        if (a instanceof OR2) {
          operands.addAll(a.opnds);
        } else {
          operands.add(a);
        }
        if (b instanceof OR2) {
          operands.addAll(b.opnds);
        } else {
          operands.add(b);
        }
        this.opnds = operands.toArray();
        let precedencePredicates = filterPrecedencePredicates(this.opnds);
        let reduced = max(precedencePredicates);
        if (reduced) {
          this.opnds.push(reduced);
        }
      }
      get operands() {
        return this.opnds;
      }
      equals(obj) {
        if (this === obj) {
          return true;
        }
        if (!(obj instanceof OR2)) {
          return false;
        }
        return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);
      }
      hashCode() {
        return MurmurHash_1.MurmurHash.hashCode(this.opnds, OR_HASHCODE);
      }
      eval(parser, parserCallStack) {
        for (let opnd of this.opnds) {
          if (opnd.eval(parser, parserCallStack)) {
            return true;
          }
        }
        return false;
      }
      evalPrecedence(parser, parserCallStack) {
        let differs = false;
        let operands = [];
        for (let context of this.opnds) {
          let evaluated = context.evalPrecedence(parser, parserCallStack);
          differs = differs || evaluated !== context;
          if (evaluated === SemanticContext2.NONE) {
            return SemanticContext2.NONE;
          } else if (evaluated) {
            operands.push(evaluated);
          }
        }
        if (!differs) {
          return this;
        }
        if (operands.length === 0) {
          return void 0;
        }
        let result = operands[0];
        for (let i = 1; i < operands.length; i++) {
          result = SemanticContext2.or(result, operands[i]);
        }
        return result;
      }
      toString() {
        return Utils3.join(this.opnds, "||");
      }
    };
    __decorate([
      Decorators_1.Override
    ], OR.prototype, "operands", null);
    __decorate([
      Decorators_1.Override
    ], OR.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], OR.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], OR.prototype, "eval", null);
    __decorate([
      Decorators_1.Override
    ], OR.prototype, "evalPrecedence", null);
    __decorate([
      Decorators_1.Override
    ], OR.prototype, "toString", null);
    OR = __decorate([
      __param(0, Decorators_1.NotNull),
      __param(1, Decorators_1.NotNull)
    ], OR);
    SemanticContext2.OR = OR;
  })(SemanticContext = exports.SemanticContext || (exports.SemanticContext = {}));
});

// node_modules/antlr4ts/atn/PredicateTransition.js
var require_PredicateTransition = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.PredicateTransition = void 0;
  var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
  var Decorators_1 = require_Decorators();
  var SemanticContext_1 = require_SemanticContext();
  var PredicateTransition = class PredicateTransition extends AbstractPredicateTransition_1.AbstractPredicateTransition {
    constructor(target, ruleIndex, predIndex, isCtxDependent) {
      super(target);
      this.ruleIndex = ruleIndex;
      this.predIndex = predIndex;
      this.isCtxDependent = isCtxDependent;
    }
    get serializationType() {
      return 4;
    }
    get isEpsilon() {
      return true;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return false;
    }
    get predicate() {
      return new SemanticContext_1.SemanticContext.Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
    }
    toString() {
      return "pred_" + this.ruleIndex + ":" + this.predIndex;
    }
  };
  __decorate([
    Decorators_1.Override
  ], PredicateTransition.prototype, "serializationType", null);
  __decorate([
    Decorators_1.Override
  ], PredicateTransition.prototype, "isEpsilon", null);
  __decorate([
    Decorators_1.Override
  ], PredicateTransition.prototype, "matches", null);
  __decorate([
    Decorators_1.Override,
    Decorators_1.NotNull
  ], PredicateTransition.prototype, "toString", null);
  PredicateTransition = __decorate([
    __param(0, Decorators_1.NotNull)
  ], PredicateTransition);
  exports.PredicateTransition = PredicateTransition;
});

// node_modules/antlr4ts/FailedPredicateException.js
var require_FailedPredicateException = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.FailedPredicateException = void 0;
  var RecognitionException_1 = require_RecognitionException();
  var Decorators_1 = require_Decorators();
  var PredicateTransition_1 = require_PredicateTransition();
  var FailedPredicateException2 = class FailedPredicateException3 extends RecognitionException_1.RecognitionException {
    constructor(recognizer, predicate, message) {
      super(recognizer, recognizer.inputStream, recognizer.context, FailedPredicateException3.formatMessage(predicate, message));
      let s = recognizer.interpreter.atn.states[recognizer.state];
      let trans = s.transition(0);
      if (trans instanceof PredicateTransition_1.PredicateTransition) {
        this._ruleIndex = trans.ruleIndex;
        this._predicateIndex = trans.predIndex;
      } else {
        this._ruleIndex = 0;
        this._predicateIndex = 0;
      }
      this._predicate = predicate;
      super.setOffendingToken(recognizer, recognizer.currentToken);
    }
    get ruleIndex() {
      return this._ruleIndex;
    }
    get predicateIndex() {
      return this._predicateIndex;
    }
    get predicate() {
      return this._predicate;
    }
    static formatMessage(predicate, message) {
      if (message) {
        return message;
      }
      return `failed predicate: {${predicate}}?`;
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], FailedPredicateException2, "formatMessage", null);
  FailedPredicateException2 = __decorate([
    __param(0, Decorators_1.NotNull)
  ], FailedPredicateException2);
  exports.FailedPredicateException = FailedPredicateException2;
});

// node_modules/antlr4ts/InputMismatchException.js
var require_InputMismatchException = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.InputMismatchException = void 0;
  var RecognitionException_1 = require_RecognitionException();
  var Decorators_1 = require_Decorators();
  var InputMismatchException = class InputMismatchException extends RecognitionException_1.RecognitionException {
    constructor(recognizer, state, context) {
      if (context === void 0) {
        context = recognizer.context;
      }
      super(recognizer, recognizer.inputStream, context);
      if (state !== void 0) {
        this.setOffendingState(state);
      }
      this.setOffendingToken(recognizer, recognizer.currentToken);
    }
  };
  InputMismatchException = __decorate([
    __param(0, Decorators_1.NotNull)
  ], InputMismatchException);
  exports.InputMismatchException = InputMismatchException;
});

// node_modules/antlr4ts/misc/Arrays.js
var require_Arrays = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.Arrays = void 0;
  var Arrays;
  (function(Arrays2) {
    function binarySearch(array, key, fromIndex, toIndex) {
      return binarySearch0(array, fromIndex !== void 0 ? fromIndex : 0, toIndex !== void 0 ? toIndex : array.length, key);
    }
    Arrays2.binarySearch = binarySearch;
    function binarySearch0(array, fromIndex, toIndex, key) {
      let low = fromIndex;
      let high = toIndex - 1;
      while (low <= high) {
        let mid = low + high >>> 1;
        let midVal = array[mid];
        if (midVal < key) {
          low = mid + 1;
        } else if (midVal > key) {
          high = mid - 1;
        } else {
          return mid;
        }
      }
      return -(low + 1);
    }
    function toString(array) {
      let result = "[";
      let first = true;
      for (let element of array) {
        if (first) {
          first = false;
        } else {
          result += ", ";
        }
        if (element === null) {
          result += "null";
        } else if (element === void 0) {
          result += "undefined";
        } else {
          result += element;
        }
      }
      result += "]";
      return result;
    }
    Arrays2.toString = toString;
  })(Arrays = exports.Arrays || (exports.Arrays = {}));
});

// node_modules/antlr4ts/misc/IntegerList.js
var require_IntegerList = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.IntegerList = void 0;
  var Arrays_1 = require_Arrays();
  var Decorators_1 = require_Decorators();
  var EMPTY_DATA = new Int32Array(0);
  var INITIAL_SIZE = 4;
  var MAX_ARRAY_SIZE = (1 << 31 >>> 0) - 1 - 8;
  var IntegerList = class {
    constructor(arg) {
      if (!arg) {
        this._data = EMPTY_DATA;
        this._size = 0;
      } else if (arg instanceof IntegerList) {
        this._data = arg._data.slice(0);
        this._size = arg._size;
      } else if (typeof arg === "number") {
        if (arg === 0) {
          this._data = EMPTY_DATA;
          this._size = 0;
        } else {
          this._data = new Int32Array(arg);
          this._size = 0;
        }
      } else {
        this._data = EMPTY_DATA;
        this._size = 0;
        for (let value of arg) {
          this.add(value);
        }
      }
    }
    add(value) {
      if (this._data.length === this._size) {
        this.ensureCapacity(this._size + 1);
      }
      this._data[this._size] = value;
      this._size++;
    }
    addAll(list) {
      if (Array.isArray(list)) {
        this.ensureCapacity(this._size + list.length);
        this._data.subarray(this._size, this._size + list.length).set(list);
        this._size += list.length;
      } else if (list instanceof IntegerList) {
        this.ensureCapacity(this._size + list._size);
        this._data.subarray(this._size, this._size + list.size).set(list._data);
        this._size += list._size;
      } else {
        this.ensureCapacity(this._size + list.size);
        let current = 0;
        for (let xi of list) {
          this._data[this._size + current] = xi;
          current++;
        }
        this._size += list.size;
      }
    }
    get(index) {
      if (index < 0 || index >= this._size) {
        throw RangeError();
      }
      return this._data[index];
    }
    contains(value) {
      for (let i = 0; i < this._size; i++) {
        if (this._data[i] === value) {
          return true;
        }
      }
      return false;
    }
    set(index, value) {
      if (index < 0 || index >= this._size) {
        throw RangeError();
      }
      let previous = this._data[index];
      this._data[index] = value;
      return previous;
    }
    removeAt(index) {
      let value = this.get(index);
      this._data.copyWithin(index, index + 1, this._size);
      this._data[this._size - 1] = 0;
      this._size--;
      return value;
    }
    removeRange(fromIndex, toIndex) {
      if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {
        throw RangeError();
      }
      if (fromIndex > toIndex) {
        throw RangeError();
      }
      this._data.copyWithin(toIndex, fromIndex, this._size);
      this._data.fill(0, this._size - (toIndex - fromIndex), this._size);
      this._size -= toIndex - fromIndex;
    }
    get isEmpty() {
      return this._size === 0;
    }
    get size() {
      return this._size;
    }
    trimToSize() {
      if (this._data.length === this._size) {
        return;
      }
      this._data = this._data.slice(0, this._size);
    }
    clear() {
      this._data.fill(0, 0, this._size);
      this._size = 0;
    }
    toArray() {
      if (this._size === 0) {
        return [];
      }
      return Array.from(this._data.subarray(0, this._size));
    }
    sort() {
      this._data.subarray(0, this._size).sort();
    }
    equals(o) {
      if (o === this) {
        return true;
      }
      if (!(o instanceof IntegerList)) {
        return false;
      }
      if (this._size !== o._size) {
        return false;
      }
      for (let i = 0; i < this._size; i++) {
        if (this._data[i] !== o._data[i]) {
          return false;
        }
      }
      return true;
    }
    hashCode() {
      let hashCode = 1;
      for (let i = 0; i < this._size; i++) {
        hashCode = 31 * hashCode + this._data[i];
      }
      return hashCode;
    }
    toString() {
      return this._data.toString();
    }
    binarySearch(key, fromIndex, toIndex) {
      if (fromIndex === void 0) {
        fromIndex = 0;
      }
      if (toIndex === void 0) {
        toIndex = this._size;
      }
      if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {
        throw new RangeError();
      }
      if (fromIndex > toIndex) {
        throw new RangeError();
      }
      return Arrays_1.Arrays.binarySearch(this._data, key, fromIndex, toIndex);
    }
    ensureCapacity(capacity) {
      if (capacity < 0 || capacity > MAX_ARRAY_SIZE) {
        throw new RangeError();
      }
      let newLength;
      if (this._data.length === 0) {
        newLength = INITIAL_SIZE;
      } else {
        newLength = this._data.length;
      }
      while (newLength < capacity) {
        newLength = newLength * 2;
        if (newLength < 0 || newLength > MAX_ARRAY_SIZE) {
          newLength = MAX_ARRAY_SIZE;
        }
      }
      let tmp = new Int32Array(newLength);
      tmp.set(this._data);
      this._data = tmp;
    }
    toCharArray() {
      let resultArray = new Uint16Array(this._size);
      let resultIdx = 0;
      let calculatedPreciseResultSize = false;
      for (let i = 0; i < this._size; i++) {
        let codePoint = this._data[i];
        if (codePoint >= 0 && codePoint < 65536) {
          resultArray[resultIdx] = codePoint;
          resultIdx++;
          continue;
        }
        if (!calculatedPreciseResultSize) {
          let newResultArray = new Uint16Array(this.charArraySize());
          newResultArray.set(resultArray, 0);
          resultArray = newResultArray;
          calculatedPreciseResultSize = true;
        }
        let pair = String.fromCodePoint(codePoint);
        resultArray[resultIdx] = pair.charCodeAt(0);
        resultArray[resultIdx + 1] = pair.charCodeAt(1);
        resultIdx += 2;
      }
      return resultArray;
    }
    charArraySize() {
      let result = 0;
      for (let i = 0; i < this._size; i++) {
        result += this._data[i] >= 65536 ? 2 : 1;
      }
      return result;
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], IntegerList.prototype, "_data", void 0);
  __decorate([
    Decorators_1.Override
  ], IntegerList.prototype, "equals", null);
  __decorate([
    Decorators_1.Override
  ], IntegerList.prototype, "hashCode", null);
  __decorate([
    Decorators_1.Override
  ], IntegerList.prototype, "toString", null);
  exports.IntegerList = IntegerList;
});

// node_modules/antlr4ts/misc/Interval.js
var require_Interval = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.Interval = void 0;
  var Decorators_1 = require_Decorators();
  var INTERVAL_POOL_MAX_VALUE = 1e3;
  var Interval = class {
    constructor(a, b) {
      this.a = a;
      this.b = b;
    }
    static get INVALID() {
      return Interval._INVALID;
    }
    static of(a, b) {
      if (a !== b || a < 0 || a > INTERVAL_POOL_MAX_VALUE) {
        return new Interval(a, b);
      }
      if (Interval.cache[a] == null) {
        Interval.cache[a] = new Interval(a, a);
      }
      return Interval.cache[a];
    }
    get length() {
      if (this.b < this.a) {
        return 0;
      }
      return this.b - this.a + 1;
    }
    equals(o) {
      if (o === this) {
        return true;
      } else if (!(o instanceof Interval)) {
        return false;
      }
      return this.a === o.a && this.b === o.b;
    }
    hashCode() {
      let hash = 23;
      hash = hash * 31 + this.a;
      hash = hash * 31 + this.b;
      return hash;
    }
    startsBeforeDisjoint(other) {
      return this.a < other.a && this.b < other.a;
    }
    startsBeforeNonDisjoint(other) {
      return this.a <= other.a && this.b >= other.a;
    }
    startsAfter(other) {
      return this.a > other.a;
    }
    startsAfterDisjoint(other) {
      return this.a > other.b;
    }
    startsAfterNonDisjoint(other) {
      return this.a > other.a && this.a <= other.b;
    }
    disjoint(other) {
      return this.startsBeforeDisjoint(other) || this.startsAfterDisjoint(other);
    }
    adjacent(other) {
      return this.a === other.b + 1 || this.b === other.a - 1;
    }
    properlyContains(other) {
      return other.a >= this.a && other.b <= this.b;
    }
    union(other) {
      return Interval.of(Math.min(this.a, other.a), Math.max(this.b, other.b));
    }
    intersection(other) {
      return Interval.of(Math.max(this.a, other.a), Math.min(this.b, other.b));
    }
    differenceNotProperlyContained(other) {
      let diff;
      if (other.startsBeforeNonDisjoint(this)) {
        diff = Interval.of(Math.max(this.a, other.b + 1), this.b);
      } else if (other.startsAfterNonDisjoint(this)) {
        diff = Interval.of(this.a, other.a - 1);
      }
      return diff;
    }
    toString() {
      return this.a + ".." + this.b;
    }
  };
  Interval._INVALID = new Interval(-1, -2);
  Interval.cache = new Array(INTERVAL_POOL_MAX_VALUE + 1);
  __decorate([
    Decorators_1.Override
  ], Interval.prototype, "equals", null);
  __decorate([
    Decorators_1.Override
  ], Interval.prototype, "hashCode", null);
  __decorate([
    Decorators_1.Override
  ], Interval.prototype, "toString", null);
  exports.Interval = Interval;
});

// node_modules/antlr4ts/Token.js
var require_Token = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.Token = void 0;
  var IntStream_1 = require_IntStream();
  var Token2;
  (function(Token3) {
    Token3.INVALID_TYPE = 0;
    Token3.EPSILON = -2;
    Token3.MIN_USER_TOKEN_TYPE = 1;
    Token3.EOF = IntStream_1.IntStream.EOF;
    Token3.DEFAULT_CHANNEL = 0;
    Token3.HIDDEN_CHANNEL = 1;
    Token3.MIN_USER_CHANNEL_VALUE = 2;
  })(Token2 = exports.Token || (exports.Token = {}));
});

// node_modules/antlr4ts/CommonToken.js
var require_CommonToken = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.CommonToken = void 0;
  var Interval_1 = require_Interval();
  var Decorators_1 = require_Decorators();
  var Token_1 = require_Token();
  var CommonToken = class CommonToken2 {
    constructor(type, text, source = CommonToken2.EMPTY_SOURCE, channel = Token_1.Token.DEFAULT_CHANNEL, start = 0, stop = 0) {
      this._line = 0;
      this._charPositionInLine = -1;
      this._channel = Token_1.Token.DEFAULT_CHANNEL;
      this.index = -1;
      this._text = text;
      this._type = type;
      this.source = source;
      this._channel = channel;
      this.start = start;
      this.stop = stop;
      if (source.source != null) {
        this._line = source.source.line;
        this._charPositionInLine = source.source.charPositionInLine;
      }
    }
    static fromToken(oldToken) {
      let result = new CommonToken2(oldToken.type, void 0, CommonToken2.EMPTY_SOURCE, oldToken.channel, oldToken.startIndex, oldToken.stopIndex);
      result._line = oldToken.line;
      result.index = oldToken.tokenIndex;
      result._charPositionInLine = oldToken.charPositionInLine;
      if (oldToken instanceof CommonToken2) {
        result._text = oldToken._text;
        result.source = oldToken.source;
      } else {
        result._text = oldToken.text;
        result.source = {source: oldToken.tokenSource, stream: oldToken.inputStream};
      }
      return result;
    }
    get type() {
      return this._type;
    }
    set type(type) {
      this._type = type;
    }
    get line() {
      return this._line;
    }
    set line(line) {
      this._line = line;
    }
    get text() {
      if (this._text != null) {
        return this._text;
      }
      let input = this.inputStream;
      if (input == null) {
        return void 0;
      }
      let n = input.size;
      if (this.start < n && this.stop < n) {
        return input.getText(Interval_1.Interval.of(this.start, this.stop));
      } else {
        return "<EOF>";
      }
    }
    set text(text) {
      this._text = text;
    }
    get charPositionInLine() {
      return this._charPositionInLine;
    }
    set charPositionInLine(charPositionInLine) {
      this._charPositionInLine = charPositionInLine;
    }
    get channel() {
      return this._channel;
    }
    set channel(channel) {
      this._channel = channel;
    }
    get startIndex() {
      return this.start;
    }
    set startIndex(start) {
      this.start = start;
    }
    get stopIndex() {
      return this.stop;
    }
    set stopIndex(stop) {
      this.stop = stop;
    }
    get tokenIndex() {
      return this.index;
    }
    set tokenIndex(index) {
      this.index = index;
    }
    get tokenSource() {
      return this.source.source;
    }
    get inputStream() {
      return this.source.stream;
    }
    toString(recognizer) {
      let channelStr = "";
      if (this._channel > 0) {
        channelStr = ",channel=" + this._channel;
      }
      let txt = this.text;
      if (txt != null) {
        txt = txt.replace(/\n/g, "\\n");
        txt = txt.replace(/\r/g, "\\r");
        txt = txt.replace(/\t/g, "\\t");
      } else {
        txt = "<no text>";
      }
      let typeString = String(this._type);
      if (recognizer) {
        typeString = recognizer.vocabulary.getDisplayName(this._type);
      }
      return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + txt + "',<" + typeString + ">" + channelStr + "," + this._line + ":" + this.charPositionInLine + "]";
    }
  };
  CommonToken.EMPTY_SOURCE = {source: void 0, stream: void 0};
  __decorate([
    Decorators_1.NotNull
  ], CommonToken.prototype, "source", void 0);
  __decorate([
    Decorators_1.Override
  ], CommonToken.prototype, "type", null);
  __decorate([
    Decorators_1.Override
  ], CommonToken.prototype, "line", null);
  __decorate([
    Decorators_1.Override
  ], CommonToken.prototype, "text", null);
  __decorate([
    Decorators_1.Override
  ], CommonToken.prototype, "charPositionInLine", null);
  __decorate([
    Decorators_1.Override
  ], CommonToken.prototype, "channel", null);
  __decorate([
    Decorators_1.Override
  ], CommonToken.prototype, "startIndex", null);
  __decorate([
    Decorators_1.Override
  ], CommonToken.prototype, "stopIndex", null);
  __decorate([
    Decorators_1.Override
  ], CommonToken.prototype, "tokenIndex", null);
  __decorate([
    Decorators_1.Override
  ], CommonToken.prototype, "tokenSource", null);
  __decorate([
    Decorators_1.Override
  ], CommonToken.prototype, "inputStream", null);
  __decorate([
    Decorators_1.Override
  ], CommonToken.prototype, "toString", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], CommonToken, "fromToken", null);
  CommonToken = __decorate([
    __param(2, Decorators_1.NotNull)
  ], CommonToken);
  exports.CommonToken = CommonToken;
});

// node_modules/antlr4ts/CommonTokenFactory.js
var require_CommonTokenFactory = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.CommonTokenFactory = void 0;
  var CommonToken_1 = require_CommonToken();
  var Interval_1 = require_Interval();
  var Decorators_1 = require_Decorators();
  var CommonTokenFactory = class {
    constructor(copyText = false) {
      this.copyText = copyText;
    }
    create(source, type, text, channel, start, stop, line, charPositionInLine) {
      let t = new CommonToken_1.CommonToken(type, text, source, channel, start, stop);
      t.line = line;
      t.charPositionInLine = charPositionInLine;
      if (text == null && this.copyText && source.stream != null) {
        t.text = source.stream.getText(Interval_1.Interval.of(start, stop));
      }
      return t;
    }
    createSimple(type, text) {
      return new CommonToken_1.CommonToken(type, text);
    }
  };
  __decorate([
    Decorators_1.Override
  ], CommonTokenFactory.prototype, "create", null);
  __decorate([
    Decorators_1.Override
  ], CommonTokenFactory.prototype, "createSimple", null);
  exports.CommonTokenFactory = CommonTokenFactory;
  (function(CommonTokenFactory2) {
    CommonTokenFactory2.DEFAULT = new CommonTokenFactory2();
  })(CommonTokenFactory = exports.CommonTokenFactory || (exports.CommonTokenFactory = {}));
});

// node_modules/antlr4ts/misc/IntegerStack.js
var require_IntegerStack = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.IntegerStack = void 0;
  var IntegerList_1 = require_IntegerList();
  var IntegerStack = class extends IntegerList_1.IntegerList {
    constructor(arg) {
      super(arg);
    }
    push(value) {
      this.add(value);
    }
    pop() {
      return this.removeAt(this.size - 1);
    }
    peek() {
      return this.get(this.size - 1);
    }
  };
  exports.IntegerStack = IntegerStack;
});

// node_modules/antlr4ts/dfa/AcceptStateInfo.js
var require_AcceptStateInfo = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.AcceptStateInfo = void 0;
  var AcceptStateInfo = class {
    constructor(prediction, lexerActionExecutor) {
      this._prediction = prediction;
      this._lexerActionExecutor = lexerActionExecutor;
    }
    get prediction() {
      return this._prediction;
    }
    get lexerActionExecutor() {
      return this._lexerActionExecutor;
    }
  };
  exports.AcceptStateInfo = AcceptStateInfo;
});

// node_modules/antlr4ts/misc/Array2DHashMap.js
var require_Array2DHashMap = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.Array2DHashMap = void 0;
  var Array2DHashSet_1 = require_Array2DHashSet();
  var MapKeyEqualityComparator = class {
    constructor(keyComparator) {
      this.keyComparator = keyComparator;
    }
    hashCode(obj) {
      return this.keyComparator.hashCode(obj.key);
    }
    equals(a, b) {
      return this.keyComparator.equals(a.key, b.key);
    }
  };
  var Array2DHashMap = class {
    constructor(keyComparer) {
      if (keyComparer instanceof Array2DHashMap) {
        this.backingStore = new Array2DHashSet_1.Array2DHashSet(keyComparer.backingStore);
      } else {
        this.backingStore = new Array2DHashSet_1.Array2DHashSet(new MapKeyEqualityComparator(keyComparer));
      }
    }
    clear() {
      this.backingStore.clear();
    }
    containsKey(key) {
      return this.backingStore.contains({key});
    }
    get(key) {
      let bucket = this.backingStore.get({key});
      if (!bucket) {
        return void 0;
      }
      return bucket.value;
    }
    get isEmpty() {
      return this.backingStore.isEmpty;
    }
    put(key, value) {
      let element = this.backingStore.get({key, value});
      let result;
      if (!element) {
        this.backingStore.add({key, value});
      } else {
        result = element.value;
        element.value = value;
      }
      return result;
    }
    putIfAbsent(key, value) {
      let element = this.backingStore.get({key, value});
      let result;
      if (!element) {
        this.backingStore.add({key, value});
      } else {
        result = element.value;
      }
      return result;
    }
    get size() {
      return this.backingStore.size;
    }
    hashCode() {
      return this.backingStore.hashCode();
    }
    equals(o) {
      if (!(o instanceof Array2DHashMap)) {
        return false;
      }
      return this.backingStore.equals(o.backingStore);
    }
  };
  exports.Array2DHashMap = Array2DHashMap;
});

// node_modules/antlr4ts/atn/DecisionState.js
var require_DecisionState = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.DecisionState = void 0;
  var ATNState_1 = require_ATNState();
  var DecisionState = class extends ATNState_1.ATNState {
    constructor() {
      super(...arguments);
      this.decision = -1;
      this.nonGreedy = false;
      this.sll = false;
    }
  };
  exports.DecisionState = DecisionState;
});

// node_modules/antlr4ts/atn/PredictionContextCache.js
var require_PredictionContextCache = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.PredictionContextCache = void 0;
  var Array2DHashMap_1 = require_Array2DHashMap();
  var Decorators_1 = require_Decorators();
  var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
  var PredictionContext_1 = require_PredictionContext();
  var assert = __nccwpck_require__(9491);
  var PredictionContextCache = class {
    constructor(enableCache = true) {
      this.contexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
      this.childContexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
      this.joinContexts = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
      this.enableCache = enableCache;
    }
    getAsCached(context) {
      if (!this.enableCache) {
        return context;
      }
      let result = this.contexts.get(context);
      if (!result) {
        result = context;
        this.contexts.put(context, context);
      }
      return result;
    }
    getChild(context, invokingState) {
      if (!this.enableCache) {
        return context.getChild(invokingState);
      }
      let operands = new PredictionContextCache.PredictionContextAndInt(context, invokingState);
      let result = this.childContexts.get(operands);
      if (!result) {
        result = context.getChild(invokingState);
        result = this.getAsCached(result);
        this.childContexts.put(operands, result);
      }
      return result;
    }
    join(x, y) {
      if (!this.enableCache) {
        return PredictionContext_1.PredictionContext.join(x, y, this);
      }
      let operands = new PredictionContextCache.IdentityCommutativePredictionContextOperands(x, y);
      let result = this.joinContexts.get(operands);
      if (result) {
        return result;
      }
      result = PredictionContext_1.PredictionContext.join(x, y, this);
      result = this.getAsCached(result);
      this.joinContexts.put(operands, result);
      return result;
    }
  };
  exports.PredictionContextCache = PredictionContextCache;
  PredictionContextCache.UNCACHED = new PredictionContextCache(false);
  (function(PredictionContextCache2) {
    class PredictionContextAndInt {
      constructor(obj, value) {
        this.obj = obj;
        this.value = value;
      }
      equals(obj) {
        if (!(obj instanceof PredictionContextAndInt)) {
          return false;
        } else if (obj === this) {
          return true;
        }
        let other = obj;
        return this.value === other.value && (this.obj === other.obj || this.obj != null && this.obj.equals(other.obj));
      }
      hashCode() {
        let hashCode = 5;
        hashCode = 7 * hashCode + (this.obj != null ? this.obj.hashCode() : 0);
        hashCode = 7 * hashCode + this.value;
        return hashCode;
      }
    }
    __decorate([
      Decorators_1.Override
    ], PredictionContextAndInt.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], PredictionContextAndInt.prototype, "hashCode", null);
    PredictionContextCache2.PredictionContextAndInt = PredictionContextAndInt;
    class IdentityCommutativePredictionContextOperands {
      constructor(x, y) {
        assert(x != null);
        assert(y != null);
        this._x = x;
        this._y = y;
      }
      get x() {
        return this._x;
      }
      get y() {
        return this._y;
      }
      equals(o) {
        if (!(o instanceof IdentityCommutativePredictionContextOperands)) {
          return false;
        } else if (this === o) {
          return true;
        }
        let other = o;
        return this._x === other._x && this._y === other._y || this._x === other._y && this._y === other._x;
      }
      hashCode() {
        return this._x.hashCode() ^ this._y.hashCode();
      }
    }
    __decorate([
      Decorators_1.Override
    ], IdentityCommutativePredictionContextOperands.prototype, "equals", null);
    __decorate([
      Decorators_1.Override
    ], IdentityCommutativePredictionContextOperands.prototype, "hashCode", null);
    PredictionContextCache2.IdentityCommutativePredictionContextOperands = IdentityCommutativePredictionContextOperands;
  })(PredictionContextCache = exports.PredictionContextCache || (exports.PredictionContextCache = {}));
});

// node_modules/antlr4ts/atn/PredictionContext.js
var require_PredictionContext = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.SingletonPredictionContext = exports.PredictionContext = void 0;
  var Array2DHashMap_1 = require_Array2DHashMap();
  var Array2DHashSet_1 = require_Array2DHashSet();
  var Arrays_1 = require_Arrays();
  var MurmurHash_1 = require_MurmurHash();
  var Decorators_1 = require_Decorators();
  var PredictionContextCache_1 = require_PredictionContextCache();
  var assert = __nccwpck_require__(9491);
  var INITIAL_HASH = 1;
  var PredictionContext = class {
    constructor(cachedHashCode) {
      this.cachedHashCode = cachedHashCode;
    }
    static calculateEmptyHashCode() {
      let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
      hash = MurmurHash_1.MurmurHash.finish(hash, 0);
      return hash;
    }
    static calculateSingleHashCode(parent, returnState) {
      let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
      hash = MurmurHash_1.MurmurHash.update(hash, parent);
      hash = MurmurHash_1.MurmurHash.update(hash, returnState);
      hash = MurmurHash_1.MurmurHash.finish(hash, 2);
      return hash;
    }
    static calculateHashCode(parents, returnStates) {
      let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);
      for (let parent of parents) {
        hash = MurmurHash_1.MurmurHash.update(hash, parent);
      }
      for (let returnState of returnStates) {
        hash = MurmurHash_1.MurmurHash.update(hash, returnState);
      }
      hash = MurmurHash_1.MurmurHash.finish(hash, 2 * parents.length);
      return hash;
    }
    static fromRuleContext(atn, outerContext, fullContext = true) {
      if (outerContext.isEmpty) {
        return fullContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL;
      }
      let parent;
      if (outerContext._parent) {
        parent = PredictionContext.fromRuleContext(atn, outerContext._parent, fullContext);
      } else {
        parent = fullContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL;
      }
      let state = atn.states[outerContext.invokingState];
      let transition = state.transition(0);
      return parent.getChild(transition.followState.stateNumber);
    }
    static addEmptyContext(context) {
      return context.addEmptyContext();
    }
    static removeEmptyContext(context) {
      return context.removeEmptyContext();
    }
    static join(context0, context1, contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED) {
      if (context0 === context1) {
        return context0;
      }
      if (context0.isEmpty) {
        return PredictionContext.isEmptyLocal(context0) ? context0 : PredictionContext.addEmptyContext(context1);
      } else if (context1.isEmpty) {
        return PredictionContext.isEmptyLocal(context1) ? context1 : PredictionContext.addEmptyContext(context0);
      }
      let context0size = context0.size;
      let context1size = context1.size;
      if (context0size === 1 && context1size === 1 && context0.getReturnState(0) === context1.getReturnState(0)) {
        let merged = contextCache.join(context0.getParent(0), context1.getParent(0));
        if (merged === context0.getParent(0)) {
          return context0;
        } else if (merged === context1.getParent(0)) {
          return context1;
        } else {
          return merged.getChild(context0.getReturnState(0));
        }
      }
      let count = 0;
      let parentsList = new Array(context0size + context1size);
      let returnStatesList = new Array(parentsList.length);
      let leftIndex = 0;
      let rightIndex = 0;
      let canReturnLeft = true;
      let canReturnRight = true;
      while (leftIndex < context0size && rightIndex < context1size) {
        if (context0.getReturnState(leftIndex) === context1.getReturnState(rightIndex)) {
          parentsList[count] = contextCache.join(context0.getParent(leftIndex), context1.getParent(rightIndex));
          returnStatesList[count] = context0.getReturnState(leftIndex);
          canReturnLeft = canReturnLeft && parentsList[count] === context0.getParent(leftIndex);
          canReturnRight = canReturnRight && parentsList[count] === context1.getParent(rightIndex);
          leftIndex++;
          rightIndex++;
        } else if (context0.getReturnState(leftIndex) < context1.getReturnState(rightIndex)) {
          parentsList[count] = context0.getParent(leftIndex);
          returnStatesList[count] = context0.getReturnState(leftIndex);
          canReturnRight = false;
          leftIndex++;
        } else {
          assert(context1.getReturnState(rightIndex) < context0.getReturnState(leftIndex));
          parentsList[count] = context1.getParent(rightIndex);
          returnStatesList[count] = context1.getReturnState(rightIndex);
          canReturnLeft = false;
          rightIndex++;
        }
        count++;
      }
      while (leftIndex < context0size) {
        parentsList[count] = context0.getParent(leftIndex);
        returnStatesList[count] = context0.getReturnState(leftIndex);
        leftIndex++;
        canReturnRight = false;
        count++;
      }
      while (rightIndex < context1size) {
        parentsList[count] = context1.getParent(rightIndex);
        returnStatesList[count] = context1.getReturnState(rightIndex);
        rightIndex++;
        canReturnLeft = false;
        count++;
      }
      if (canReturnLeft) {
        return context0;
      } else if (canReturnRight) {
        return context1;
      }
      if (count < parentsList.length) {
        parentsList = parentsList.slice(0, count);
        returnStatesList = returnStatesList.slice(0, count);
      }
      if (parentsList.length === 0) {
        return PredictionContext.EMPTY_FULL;
      } else if (parentsList.length === 1) {
        return new SingletonPredictionContext(parentsList[0], returnStatesList[0]);
      } else {
        return new ArrayPredictionContext(parentsList, returnStatesList);
      }
    }
    static isEmptyLocal(context) {
      return context === PredictionContext.EMPTY_LOCAL;
    }
    static getCachedContext(context, contextCache, visited) {
      if (context.isEmpty) {
        return context;
      }
      let existing = visited.get(context);
      if (existing) {
        return existing;
      }
      existing = contextCache.get(context);
      if (existing) {
        visited.put(context, existing);
        return existing;
      }
      let changed = false;
      let parents = new Array(context.size);
      for (let i = 0; i < parents.length; i++) {
        let parent = PredictionContext.getCachedContext(context.getParent(i), contextCache, visited);
        if (changed || parent !== context.getParent(i)) {
          if (!changed) {
            parents = new Array(context.size);
            for (let j = 0; j < context.size; j++) {
              parents[j] = context.getParent(j);
            }
            changed = true;
          }
          parents[i] = parent;
        }
      }
      if (!changed) {
        existing = contextCache.putIfAbsent(context, context);
        visited.put(context, existing != null ? existing : context);
        return context;
      }
      let updated;
      if (parents.length === 1) {
        updated = new SingletonPredictionContext(parents[0], context.getReturnState(0));
      } else {
        let returnStates = new Array(context.size);
        for (let i = 0; i < context.size; i++) {
          returnStates[i] = context.getReturnState(i);
        }
        updated = new ArrayPredictionContext(parents, returnStates, context.hashCode());
      }
      existing = contextCache.putIfAbsent(updated, updated);
      visited.put(updated, existing || updated);
      visited.put(context, existing || updated);
      return updated;
    }
    appendSingleContext(returnContext, contextCache) {
      return this.appendContext(PredictionContext.EMPTY_FULL.getChild(returnContext), contextCache);
    }
    getChild(returnState) {
      return new SingletonPredictionContext(this, returnState);
    }
    hashCode() {
      return this.cachedHashCode;
    }
    toStrings(recognizer, currentState, stop = PredictionContext.EMPTY_FULL) {
      let result = [];
      outer:
        for (let perm = 0; ; perm++) {
          let offset = 0;
          let last = true;
          let p = this;
          let stateNumber = currentState;
          let localBuffer = "";
          localBuffer += "[";
          while (!p.isEmpty && p !== stop) {
            let index = 0;
            if (p.size > 0) {
              let bits = 1;
              while (1 << bits >>> 0 < p.size) {
                bits++;
              }
              let mask = (1 << bits >>> 0) - 1;
              index = perm >> offset & mask;
              last = last && index >= p.size - 1;
              if (index >= p.size) {
                continue outer;
              }
              offset += bits;
            }
            if (recognizer) {
              if (localBuffer.length > 1) {
                localBuffer += " ";
              }
              let atn = recognizer.atn;
              let s = atn.states[stateNumber];
              let ruleName = recognizer.ruleNames[s.ruleIndex];
              localBuffer += ruleName;
            } else if (p.getReturnState(index) !== PredictionContext.EMPTY_FULL_STATE_KEY) {
              if (!p.isEmpty) {
                if (localBuffer.length > 1) {
                  localBuffer += " ";
                }
                localBuffer += p.getReturnState(index);
              }
            }
            stateNumber = p.getReturnState(index);
            p = p.getParent(index);
          }
          localBuffer += "]";
          result.push(localBuffer);
          if (last) {
            break;
          }
        }
      return result;
    }
  };
  __decorate([
    Decorators_1.Override
  ], PredictionContext.prototype, "hashCode", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull)
  ], PredictionContext, "join", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull)
  ], PredictionContext, "getCachedContext", null);
  exports.PredictionContext = PredictionContext;
  var EmptyPredictionContext = class extends PredictionContext {
    constructor(fullContext) {
      super(PredictionContext.calculateEmptyHashCode());
      this.fullContext = fullContext;
    }
    get isFullContext() {
      return this.fullContext;
    }
    addEmptyContext() {
      return this;
    }
    removeEmptyContext() {
      throw new Error("Cannot remove the empty context from itself.");
    }
    getParent(index) {
      throw new Error("index out of bounds");
    }
    getReturnState(index) {
      throw new Error("index out of bounds");
    }
    findReturnState(returnState) {
      return -1;
    }
    get size() {
      return 0;
    }
    appendSingleContext(returnContext, contextCache) {
      return contextCache.getChild(this, returnContext);
    }
    appendContext(suffix, contextCache) {
      return suffix;
    }
    get isEmpty() {
      return true;
    }
    get hasEmpty() {
      return true;
    }
    equals(o) {
      return this === o;
    }
    toStrings(recognizer, currentState, stop) {
      return ["[]"];
    }
  };
  __decorate([
    Decorators_1.Override
  ], EmptyPredictionContext.prototype, "addEmptyContext", null);
  __decorate([
    Decorators_1.Override
  ], EmptyPredictionContext.prototype, "removeEmptyContext", null);
  __decorate([
    Decorators_1.Override
  ], EmptyPredictionContext.prototype, "getParent", null);
  __decorate([
    Decorators_1.Override
  ], EmptyPredictionContext.prototype, "getReturnState", null);
  __decorate([
    Decorators_1.Override
  ], EmptyPredictionContext.prototype, "findReturnState", null);
  __decorate([
    Decorators_1.Override
  ], EmptyPredictionContext.prototype, "size", null);
  __decorate([
    Decorators_1.Override
  ], EmptyPredictionContext.prototype, "appendSingleContext", null);
  __decorate([
    Decorators_1.Override
  ], EmptyPredictionContext.prototype, "appendContext", null);
  __decorate([
    Decorators_1.Override
  ], EmptyPredictionContext.prototype, "isEmpty", null);
  __decorate([
    Decorators_1.Override
  ], EmptyPredictionContext.prototype, "hasEmpty", null);
  __decorate([
    Decorators_1.Override
  ], EmptyPredictionContext.prototype, "equals", null);
  __decorate([
    Decorators_1.Override
  ], EmptyPredictionContext.prototype, "toStrings", null);
  var ArrayPredictionContext = class ArrayPredictionContext2 extends PredictionContext {
    constructor(parents, returnStates, hashCode) {
      super(hashCode || PredictionContext.calculateHashCode(parents, returnStates));
      assert(parents.length === returnStates.length);
      assert(returnStates.length > 1 || returnStates[0] !== PredictionContext.EMPTY_FULL_STATE_KEY, "Should be using PredictionContext.EMPTY instead.");
      this.parents = parents;
      this.returnStates = returnStates;
    }
    getParent(index) {
      return this.parents[index];
    }
    getReturnState(index) {
      return this.returnStates[index];
    }
    findReturnState(returnState) {
      return Arrays_1.Arrays.binarySearch(this.returnStates, returnState);
    }
    get size() {
      return this.returnStates.length;
    }
    get isEmpty() {
      return false;
    }
    get hasEmpty() {
      return this.returnStates[this.returnStates.length - 1] === PredictionContext.EMPTY_FULL_STATE_KEY;
    }
    addEmptyContext() {
      if (this.hasEmpty) {
        return this;
      }
      let parents2 = this.parents.slice(0);
      let returnStates2 = this.returnStates.slice(0);
      parents2.push(PredictionContext.EMPTY_FULL);
      returnStates2.push(PredictionContext.EMPTY_FULL_STATE_KEY);
      return new ArrayPredictionContext2(parents2, returnStates2);
    }
    removeEmptyContext() {
      if (!this.hasEmpty) {
        return this;
      }
      if (this.returnStates.length === 2) {
        return new SingletonPredictionContext(this.parents[0], this.returnStates[0]);
      } else {
        let parents2 = this.parents.slice(0, this.parents.length - 1);
        let returnStates2 = this.returnStates.slice(0, this.returnStates.length - 1);
        return new ArrayPredictionContext2(parents2, returnStates2);
      }
    }
    appendContext(suffix, contextCache) {
      return ArrayPredictionContext2.appendContextImpl(this, suffix, new PredictionContext.IdentityHashMap());
    }
    static appendContextImpl(context, suffix, visited) {
      if (suffix.isEmpty) {
        if (PredictionContext.isEmptyLocal(suffix)) {
          if (context.hasEmpty) {
            return PredictionContext.EMPTY_LOCAL;
          }
          throw new Error("what to do here?");
        }
        return context;
      }
      if (suffix.size !== 1) {
        throw new Error("Appending a tree suffix is not yet supported.");
      }
      let result = visited.get(context);
      if (!result) {
        if (context.isEmpty) {
          result = suffix;
        } else {
          let parentCount = context.size;
          if (context.hasEmpty) {
            parentCount--;
          }
          let updatedParents = new Array(parentCount);
          let updatedReturnStates = new Array(parentCount);
          for (let i = 0; i < parentCount; i++) {
            updatedReturnStates[i] = context.getReturnState(i);
          }
          for (let i = 0; i < parentCount; i++) {
            updatedParents[i] = ArrayPredictionContext2.appendContextImpl(context.getParent(i), suffix, visited);
          }
          if (updatedParents.length === 1) {
            result = new SingletonPredictionContext(updatedParents[0], updatedReturnStates[0]);
          } else {
            assert(updatedParents.length > 1);
            result = new ArrayPredictionContext2(updatedParents, updatedReturnStates);
          }
          if (context.hasEmpty) {
            result = PredictionContext.join(result, suffix);
          }
        }
        visited.put(context, result);
      }
      return result;
    }
    equals(o) {
      if (this === o) {
        return true;
      } else if (!(o instanceof ArrayPredictionContext2)) {
        return false;
      }
      if (this.hashCode() !== o.hashCode()) {
        return false;
      }
      let other = o;
      return this.equalsImpl(other, new Array2DHashSet_1.Array2DHashSet());
    }
    equalsImpl(other, visited) {
      let selfWorkList = [];
      let otherWorkList = [];
      selfWorkList.push(this);
      otherWorkList.push(other);
      while (true) {
        let currentSelf = selfWorkList.pop();
        let currentOther = otherWorkList.pop();
        if (!currentSelf || !currentOther) {
          break;
        }
        let operands = new PredictionContextCache_1.PredictionContextCache.IdentityCommutativePredictionContextOperands(currentSelf, currentOther);
        if (!visited.add(operands)) {
          continue;
        }
        let selfSize = operands.x.size;
        if (selfSize === 0) {
          if (!operands.x.equals(operands.y)) {
            return false;
          }
          continue;
        }
        let otherSize = operands.y.size;
        if (selfSize !== otherSize) {
          return false;
        }
        for (let i = 0; i < selfSize; i++) {
          if (operands.x.getReturnState(i) !== operands.y.getReturnState(i)) {
            return false;
          }
          let selfParent = operands.x.getParent(i);
          let otherParent = operands.y.getParent(i);
          if (selfParent.hashCode() !== otherParent.hashCode()) {
            return false;
          }
          if (selfParent !== otherParent) {
            selfWorkList.push(selfParent);
            otherWorkList.push(otherParent);
          }
        }
      }
      return true;
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], ArrayPredictionContext.prototype, "parents", void 0);
  __decorate([
    Decorators_1.NotNull
  ], ArrayPredictionContext.prototype, "returnStates", void 0);
  __decorate([
    Decorators_1.Override
  ], ArrayPredictionContext.prototype, "getParent", null);
  __decorate([
    Decorators_1.Override
  ], ArrayPredictionContext.prototype, "getReturnState", null);
  __decorate([
    Decorators_1.Override
  ], ArrayPredictionContext.prototype, "findReturnState", null);
  __decorate([
    Decorators_1.Override
  ], ArrayPredictionContext.prototype, "size", null);
  __decorate([
    Decorators_1.Override
  ], ArrayPredictionContext.prototype, "isEmpty", null);
  __decorate([
    Decorators_1.Override
  ], ArrayPredictionContext.prototype, "hasEmpty", null);
  __decorate([
    Decorators_1.Override
  ], ArrayPredictionContext.prototype, "addEmptyContext", null);
  __decorate([
    Decorators_1.Override
  ], ArrayPredictionContext.prototype, "removeEmptyContext", null);
  __decorate([
    Decorators_1.Override
  ], ArrayPredictionContext.prototype, "appendContext", null);
  __decorate([
    Decorators_1.Override
  ], ArrayPredictionContext.prototype, "equals", null);
  ArrayPredictionContext = __decorate([
    __param(0, Decorators_1.NotNull)
  ], ArrayPredictionContext);
  var SingletonPredictionContext = class SingletonPredictionContext2 extends PredictionContext {
    constructor(parent, returnState) {
      super(PredictionContext.calculateSingleHashCode(parent, returnState));
      this.parent = parent;
      this.returnState = returnState;
    }
    getParent(index) {
      return this.parent;
    }
    getReturnState(index) {
      return this.returnState;
    }
    findReturnState(returnState) {
      return this.returnState === returnState ? 0 : -1;
    }
    get size() {
      return 1;
    }
    get isEmpty() {
      return false;
    }
    get hasEmpty() {
      return false;
    }
    appendContext(suffix, contextCache) {
      return contextCache.getChild(this.parent.appendContext(suffix, contextCache), this.returnState);
    }
    addEmptyContext() {
      let parents = [this.parent, PredictionContext.EMPTY_FULL];
      let returnStates = [this.returnState, PredictionContext.EMPTY_FULL_STATE_KEY];
      return new ArrayPredictionContext(parents, returnStates);
    }
    removeEmptyContext() {
      return this;
    }
    equals(o) {
      if (o === this) {
        return true;
      } else if (!(o instanceof SingletonPredictionContext2)) {
        return false;
      }
      let other = o;
      if (this.hashCode() !== other.hashCode()) {
        return false;
      }
      return this.returnState === other.returnState && this.parent.equals(other.parent);
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], SingletonPredictionContext.prototype, "parent", void 0);
  __decorate([
    Decorators_1.Override
  ], SingletonPredictionContext.prototype, "getParent", null);
  __decorate([
    Decorators_1.Override
  ], SingletonPredictionContext.prototype, "getReturnState", null);
  __decorate([
    Decorators_1.Override
  ], SingletonPredictionContext.prototype, "findReturnState", null);
  __decorate([
    Decorators_1.Override
  ], SingletonPredictionContext.prototype, "size", null);
  __decorate([
    Decorators_1.Override
  ], SingletonPredictionContext.prototype, "isEmpty", null);
  __decorate([
    Decorators_1.Override
  ], SingletonPredictionContext.prototype, "hasEmpty", null);
  __decorate([
    Decorators_1.Override
  ], SingletonPredictionContext.prototype, "appendContext", null);
  __decorate([
    Decorators_1.Override
  ], SingletonPredictionContext.prototype, "addEmptyContext", null);
  __decorate([
    Decorators_1.Override
  ], SingletonPredictionContext.prototype, "removeEmptyContext", null);
  __decorate([
    Decorators_1.Override
  ], SingletonPredictionContext.prototype, "equals", null);
  SingletonPredictionContext = __decorate([
    __param(0, Decorators_1.NotNull)
  ], SingletonPredictionContext);
  exports.SingletonPredictionContext = SingletonPredictionContext;
  (function(PredictionContext2) {
    PredictionContext2.EMPTY_LOCAL = new EmptyPredictionContext(false);
    PredictionContext2.EMPTY_FULL = new EmptyPredictionContext(true);
    PredictionContext2.EMPTY_LOCAL_STATE_KEY = -(1 << 31 >>> 0);
    PredictionContext2.EMPTY_FULL_STATE_KEY = (1 << 31 >>> 0) - 1;
    class IdentityHashMap extends Array2DHashMap_1.Array2DHashMap {
      constructor() {
        super(IdentityEqualityComparator.INSTANCE);
      }
    }
    PredictionContext2.IdentityHashMap = IdentityHashMap;
    class IdentityEqualityComparator {
      IdentityEqualityComparator() {
      }
      hashCode(obj) {
        return obj.hashCode();
      }
      equals(a, b) {
        return a === b;
      }
    }
    IdentityEqualityComparator.INSTANCE = new IdentityEqualityComparator();
    __decorate([
      Decorators_1.Override
    ], IdentityEqualityComparator.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], IdentityEqualityComparator.prototype, "equals", null);
    PredictionContext2.IdentityEqualityComparator = IdentityEqualityComparator;
  })(PredictionContext = exports.PredictionContext || (exports.PredictionContext = {}));
});

// node_modules/antlr4ts/atn/ATNConfig.js
var require_ATNConfig = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ATNConfig = void 0;
  var Array2DHashMap_1 = require_Array2DHashMap();
  var DecisionState_1 = require_DecisionState();
  var MurmurHash_1 = require_MurmurHash();
  var Decorators_1 = require_Decorators();
  var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
  var PredictionContext_1 = require_PredictionContext();
  var SemanticContext_1 = require_SemanticContext();
  var assert = __nccwpck_require__(9491);
  var SUPPRESS_PRECEDENCE_FILTER = 2147483648;
  var ATNConfig = class ATNConfig2 {
    constructor(state, altOrConfig, context) {
      if (typeof altOrConfig === "number") {
        assert((altOrConfig & 16777215) === altOrConfig);
        this._state = state;
        this.altAndOuterContextDepth = altOrConfig;
        this._context = context;
      } else {
        this._state = state;
        this.altAndOuterContextDepth = altOrConfig.altAndOuterContextDepth;
        this._context = context;
      }
    }
    static create(state, alt, context, semanticContext = SemanticContext_1.SemanticContext.NONE, lexerActionExecutor) {
      if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {
        if (lexerActionExecutor != null) {
          return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, alt, context, false);
        } else {
          return new SemanticContextATNConfig(semanticContext, state, alt, context);
        }
      } else if (lexerActionExecutor != null) {
        return new ActionATNConfig(lexerActionExecutor, state, alt, context, false);
      } else {
        return new ATNConfig2(state, alt, context);
      }
    }
    get state() {
      return this._state;
    }
    get alt() {
      return this.altAndOuterContextDepth & 16777215;
    }
    get context() {
      return this._context;
    }
    set context(context) {
      this._context = context;
    }
    get reachesIntoOuterContext() {
      return this.outerContextDepth !== 0;
    }
    get outerContextDepth() {
      return this.altAndOuterContextDepth >>> 24 & 127;
    }
    set outerContextDepth(outerContextDepth) {
      assert(outerContextDepth >= 0);
      outerContextDepth = Math.min(outerContextDepth, 127);
      this.altAndOuterContextDepth = outerContextDepth << 24 | (this.altAndOuterContextDepth & ~2130706432) >>> 0;
    }
    get lexerActionExecutor() {
      return void 0;
    }
    get semanticContext() {
      return SemanticContext_1.SemanticContext.NONE;
    }
    get hasPassedThroughNonGreedyDecision() {
      return false;
    }
    clone() {
      return this.transform(this.state, false);
    }
    transform(state, checkNonGreedy, arg2) {
      if (arg2 == null) {
        return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);
      } else if (arg2 instanceof PredictionContext_1.PredictionContext) {
        return this.transformImpl(state, arg2, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);
      } else if (arg2 instanceof SemanticContext_1.SemanticContext) {
        return this.transformImpl(state, this._context, arg2, checkNonGreedy, this.lexerActionExecutor);
      } else {
        return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, arg2);
      }
    }
    transformImpl(state, context, semanticContext, checkNonGreedy, lexerActionExecutor) {
      let passedThroughNonGreedy = checkNonGreedy && ATNConfig2.checkNonGreedyDecision(this, state);
      if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {
        if (lexerActionExecutor != null || passedThroughNonGreedy) {
          return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, this, context, passedThroughNonGreedy);
        } else {
          return new SemanticContextATNConfig(semanticContext, state, this, context);
        }
      } else if (lexerActionExecutor != null || passedThroughNonGreedy) {
        return new ActionATNConfig(lexerActionExecutor, state, this, context, passedThroughNonGreedy);
      } else {
        return new ATNConfig2(state, this, context);
      }
    }
    static checkNonGreedyDecision(source, target) {
      return source.hasPassedThroughNonGreedyDecision || target instanceof DecisionState_1.DecisionState && target.nonGreedy;
    }
    appendContext(context, contextCache) {
      if (typeof context === "number") {
        let appendedContext = this.context.appendSingleContext(context, contextCache);
        let result = this.transform(this.state, false, appendedContext);
        return result;
      } else {
        let appendedContext = this.context.appendContext(context, contextCache);
        let result = this.transform(this.state, false, appendedContext);
        return result;
      }
    }
    contains(subconfig) {
      if (this.state.stateNumber !== subconfig.state.stateNumber || this.alt !== subconfig.alt || !this.semanticContext.equals(subconfig.semanticContext)) {
        return false;
      }
      let leftWorkList = [];
      let rightWorkList = [];
      leftWorkList.push(this.context);
      rightWorkList.push(subconfig.context);
      while (true) {
        let left = leftWorkList.pop();
        let right = rightWorkList.pop();
        if (!left || !right) {
          break;
        }
        if (left === right) {
          return true;
        }
        if (left.size < right.size) {
          return false;
        }
        if (right.isEmpty) {
          return left.hasEmpty;
        } else {
          for (let i = 0; i < right.size; i++) {
            let index = left.findReturnState(right.getReturnState(i));
            if (index < 0) {
              return false;
            }
            leftWorkList.push(left.getParent(index));
            rightWorkList.push(right.getParent(i));
          }
        }
      }
      return false;
    }
    get isPrecedenceFilterSuppressed() {
      return (this.altAndOuterContextDepth & SUPPRESS_PRECEDENCE_FILTER) !== 0;
    }
    set isPrecedenceFilterSuppressed(value) {
      if (value) {
        this.altAndOuterContextDepth |= SUPPRESS_PRECEDENCE_FILTER;
      } else {
        this.altAndOuterContextDepth &= ~SUPPRESS_PRECEDENCE_FILTER;
      }
    }
    equals(o) {
      if (this === o) {
        return true;
      } else if (!(o instanceof ATNConfig2)) {
        return false;
      }
      return this.state.stateNumber === o.state.stateNumber && this.alt === o.alt && this.reachesIntoOuterContext === o.reachesIntoOuterContext && this.context.equals(o.context) && this.semanticContext.equals(o.semanticContext) && this.isPrecedenceFilterSuppressed === o.isPrecedenceFilterSuppressed && this.hasPassedThroughNonGreedyDecision === o.hasPassedThroughNonGreedyDecision && ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(this.lexerActionExecutor, o.lexerActionExecutor);
    }
    hashCode() {
      let hashCode = MurmurHash_1.MurmurHash.initialize(7);
      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.state.stateNumber);
      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.alt);
      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.reachesIntoOuterContext ? 1 : 0);
      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.context);
      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.semanticContext);
      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.hasPassedThroughNonGreedyDecision ? 1 : 0);
      hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.lexerActionExecutor);
      hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 7);
      return hashCode;
    }
    toDotString() {
      let builder = "";
      builder += "digraph G {\n";
      builder += "rankdir=LR;\n";
      let visited = new Array2DHashMap_1.Array2DHashMap(PredictionContext_1.PredictionContext.IdentityEqualityComparator.INSTANCE);
      let workList = [];
      function getOrAddContext(context) {
        let newNumber = visited.size;
        let result = visited.putIfAbsent(context, newNumber);
        if (result != null) {
          return result;
        }
        workList.push(context);
        return newNumber;
      }
      workList.push(this.context);
      visited.put(this.context, 0);
      while (true) {
        let current = workList.pop();
        if (!current) {
          break;
        }
        for (let i = 0; i < current.size; i++) {
          builder += "  s" + getOrAddContext(current);
          builder += "->";
          builder += "s" + getOrAddContext(current.getParent(i));
          builder += '[label="' + current.getReturnState(i) + '"];\n';
        }
      }
      builder += "}\n";
      return builder.toString();
    }
    toString(recog, showAlt, showContext) {
      if (showContext == null) {
        showContext = showAlt != null;
      }
      if (showAlt == null) {
        showAlt = true;
      }
      let buf = "";
      let contexts;
      if (showContext) {
        contexts = this.context.toStrings(recog, this.state.stateNumber);
      } else {
        contexts = ["?"];
      }
      let first = true;
      for (let contextDesc of contexts) {
        if (first) {
          first = false;
        } else {
          buf += ", ";
        }
        buf += "(";
        buf += this.state;
        if (showAlt) {
          buf += ",";
          buf += this.alt;
        }
        if (this.context) {
          buf += ",";
          buf += contextDesc;
        }
        if (this.semanticContext !== SemanticContext_1.SemanticContext.NONE) {
          buf += ",";
          buf += this.semanticContext;
        }
        if (this.reachesIntoOuterContext) {
          buf += ",up=" + this.outerContextDepth;
        }
        buf += ")";
      }
      return buf.toString();
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], ATNConfig.prototype, "_state", void 0);
  __decorate([
    Decorators_1.NotNull
  ], ATNConfig.prototype, "_context", void 0);
  __decorate([
    Decorators_1.NotNull
  ], ATNConfig.prototype, "state", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull)
  ], ATNConfig.prototype, "context", null);
  __decorate([
    Decorators_1.NotNull
  ], ATNConfig.prototype, "semanticContext", null);
  __decorate([
    Decorators_1.Override
  ], ATNConfig.prototype, "clone", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull)
  ], ATNConfig.prototype, "transformImpl", null);
  __decorate([
    Decorators_1.Override
  ], ATNConfig.prototype, "equals", null);
  __decorate([
    Decorators_1.Override
  ], ATNConfig.prototype, "hashCode", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(3, Decorators_1.NotNull)
  ], ATNConfig, "create", null);
  ATNConfig = __decorate([
    __param(0, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull)
  ], ATNConfig);
  exports.ATNConfig = ATNConfig;
  var SemanticContextATNConfig = class SemanticContextATNConfig extends ATNConfig {
    constructor(semanticContext, state, altOrConfig, context) {
      if (typeof altOrConfig === "number") {
        super(state, altOrConfig, context);
      } else {
        super(state, altOrConfig, context);
      }
      this._semanticContext = semanticContext;
    }
    get semanticContext() {
      return this._semanticContext;
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], SemanticContextATNConfig.prototype, "_semanticContext", void 0);
  __decorate([
    Decorators_1.Override
  ], SemanticContextATNConfig.prototype, "semanticContext", null);
  SemanticContextATNConfig = __decorate([
    __param(1, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull)
  ], SemanticContextATNConfig);
  var ActionATNConfig = class ActionATNConfig extends ATNConfig {
    constructor(lexerActionExecutor, state, altOrConfig, context, passedThroughNonGreedyDecision) {
      if (typeof altOrConfig === "number") {
        super(state, altOrConfig, context);
      } else {
        super(state, altOrConfig, context);
        if (altOrConfig.semanticContext !== SemanticContext_1.SemanticContext.NONE) {
          throw new Error("Not supported");
        }
      }
      this._lexerActionExecutor = lexerActionExecutor;
      this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
    }
    get lexerActionExecutor() {
      return this._lexerActionExecutor;
    }
    get hasPassedThroughNonGreedyDecision() {
      return this.passedThroughNonGreedyDecision;
    }
  };
  __decorate([
    Decorators_1.Override
  ], ActionATNConfig.prototype, "lexerActionExecutor", null);
  __decorate([
    Decorators_1.Override
  ], ActionATNConfig.prototype, "hasPassedThroughNonGreedyDecision", null);
  ActionATNConfig = __decorate([
    __param(1, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull)
  ], ActionATNConfig);
  var ActionSemanticContextATNConfig = class ActionSemanticContextATNConfig extends SemanticContextATNConfig {
    constructor(lexerActionExecutor, semanticContext, state, altOrConfig, context, passedThroughNonGreedyDecision) {
      if (typeof altOrConfig === "number") {
        super(semanticContext, state, altOrConfig, context);
      } else {
        super(semanticContext, state, altOrConfig, context);
      }
      this._lexerActionExecutor = lexerActionExecutor;
      this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;
    }
    get lexerActionExecutor() {
      return this._lexerActionExecutor;
    }
    get hasPassedThroughNonGreedyDecision() {
      return this.passedThroughNonGreedyDecision;
    }
  };
  __decorate([
    Decorators_1.Override
  ], ActionSemanticContextATNConfig.prototype, "lexerActionExecutor", null);
  __decorate([
    Decorators_1.Override
  ], ActionSemanticContextATNConfig.prototype, "hasPassedThroughNonGreedyDecision", null);
  ActionSemanticContextATNConfig = __decorate([
    __param(1, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull)
  ], ActionSemanticContextATNConfig);
});

// node_modules/antlr4ts/misc/BitSet.js
var require_BitSet = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.BitSet = void 0;
  var util = __nccwpck_require__(3837);
  var MurmurHash_1 = require_MurmurHash();
  var EMPTY_DATA = new Uint16Array(0);
  function getIndex(bitNumber) {
    return bitNumber >>> 4;
  }
  function unIndex(n) {
    return n * 16;
  }
  function findLSBSet(word) {
    let bit = 1;
    for (let i = 0; i < 16; i++) {
      if ((word & bit) !== 0) {
        return i;
      }
      bit = bit << 1 >>> 0;
    }
    throw new RangeError("No specified bit found");
  }
  function findMSBSet(word) {
    let bit = 1 << 15 >>> 0;
    for (let i = 15; i >= 0; i--) {
      if ((word & bit) !== 0) {
        return i;
      }
      bit = bit >>> 1;
    }
    throw new RangeError("No specified bit found");
  }
  function bitsFor(fromBit, toBit) {
    fromBit &= 15;
    toBit &= 15;
    if (fromBit === toBit) {
      return 1 << fromBit >>> 0;
    }
    return 65535 >>> 15 - toBit ^ 65535 >>> 16 - fromBit;
  }
  var POP_CNT = new Uint8Array(65536);
  for (let i = 0; i < 16; i++) {
    const stride = 1 << i >>> 0;
    let index = 0;
    while (index < POP_CNT.length) {
      index += stride;
      for (let j = 0; j < stride; j++) {
        POP_CNT[index]++;
        index++;
      }
    }
  }
  var BitSet = class {
    constructor(arg) {
      if (!arg) {
        this.data = EMPTY_DATA;
      } else if (typeof arg === "number") {
        if (arg < 0) {
          throw new RangeError("nbits cannot be negative");
        } else {
          this.data = new Uint16Array(getIndex(arg - 1) + 1);
        }
      } else {
        if (arg instanceof BitSet) {
          this.data = arg.data.slice(0);
        } else {
          let max = -1;
          for (let v of arg) {
            if (max < v) {
              max = v;
            }
          }
          this.data = new Uint16Array(getIndex(max - 1) + 1);
          for (let v of arg) {
            this.set(v);
          }
        }
      }
    }
    and(set) {
      const data = this.data;
      const other = set.data;
      const words = Math.min(data.length, other.length);
      let lastWord = -1;
      for (let i = 0; i < words; i++) {
        let value = data[i] &= other[i];
        if (value !== 0) {
          lastWord = i;
        }
      }
      if (lastWord === -1) {
        this.data = EMPTY_DATA;
      }
      if (lastWord < data.length - 1) {
        this.data = data.slice(0, lastWord + 1);
      }
    }
    andNot(set) {
      const data = this.data;
      const other = set.data;
      const words = Math.min(data.length, other.length);
      let lastWord = -1;
      for (let i = 0; i < words; i++) {
        let value = data[i] &= other[i] ^ 65535;
        if (value !== 0) {
          lastWord = i;
        }
      }
      if (lastWord === -1) {
        this.data = EMPTY_DATA;
      }
      if (lastWord < data.length - 1) {
        this.data = data.slice(0, lastWord + 1);
      }
    }
    cardinality() {
      if (this.isEmpty) {
        return 0;
      }
      const data = this.data;
      const length = data.length;
      let result = 0;
      for (let i = 0; i < length; i++) {
        result += POP_CNT[data[i]];
      }
      return result;
    }
    clear(fromIndex, toIndex) {
      if (fromIndex == null) {
        this.data.fill(0);
      } else if (toIndex == null) {
        this.set(fromIndex, false);
      } else {
        this.set(fromIndex, toIndex, false);
      }
    }
    flip(fromIndex, toIndex) {
      if (toIndex == null) {
        toIndex = fromIndex;
      }
      if (fromIndex < 0 || toIndex < fromIndex) {
        throw new RangeError();
      }
      let word = getIndex(fromIndex);
      const lastWord = getIndex(toIndex);
      if (word === lastWord) {
        this.data[word] ^= bitsFor(fromIndex, toIndex);
      } else {
        this.data[word++] ^= bitsFor(fromIndex, 15);
        while (word < lastWord) {
          this.data[word++] ^= 65535;
        }
        this.data[word++] ^= bitsFor(0, toIndex);
      }
    }
    get(fromIndex, toIndex) {
      if (toIndex === void 0) {
        return !!(this.data[getIndex(fromIndex)] & bitsFor(fromIndex, fromIndex));
      } else {
        let result = new BitSet(toIndex + 1);
        for (let i = fromIndex; i <= toIndex; i++) {
          result.set(i, this.get(i));
        }
        return result;
      }
    }
    intersects(set) {
      let smallerLength = Math.min(this.length(), set.length());
      if (smallerLength === 0) {
        return false;
      }
      let bound = getIndex(smallerLength - 1);
      for (let i = 0; i <= bound; i++) {
        if ((this.data[i] & set.data[i]) !== 0) {
          return true;
        }
      }
      return false;
    }
    get isEmpty() {
      return this.length() === 0;
    }
    length() {
      if (!this.data.length) {
        return 0;
      }
      return this.previousSetBit(unIndex(this.data.length) - 1) + 1;
    }
    nextClearBit(fromIndex) {
      if (fromIndex < 0) {
        throw new RangeError("fromIndex cannot be negative");
      }
      const data = this.data;
      const length = data.length;
      let word = getIndex(fromIndex);
      if (word > length) {
        return -1;
      }
      let ignore = 65535 ^ bitsFor(fromIndex, 15);
      if ((data[word] | ignore) === 65535) {
        word++;
        ignore = 0;
        for (; word < length; word++) {
          if (data[word] !== 65535) {
            break;
          }
        }
        if (word === length) {
          return -1;
        }
      }
      return unIndex(word) + findLSBSet((data[word] | ignore) ^ 65535);
    }
    nextSetBit(fromIndex) {
      if (fromIndex < 0) {
        throw new RangeError("fromIndex cannot be negative");
      }
      const data = this.data;
      const length = data.length;
      let word = getIndex(fromIndex);
      if (word > length) {
        return -1;
      }
      let mask = bitsFor(fromIndex, 15);
      if ((data[word] & mask) === 0) {
        word++;
        mask = 65535;
        for (; word < length; word++) {
          if (data[word] !== 0) {
            break;
          }
        }
        if (word >= length) {
          return -1;
        }
      }
      return unIndex(word) + findLSBSet(data[word] & mask);
    }
    or(set) {
      const data = this.data;
      const other = set.data;
      const minWords = Math.min(data.length, other.length);
      const words = Math.max(data.length, other.length);
      const dest = data.length === words ? data : new Uint16Array(words);
      let lastWord = -1;
      for (let i = 0; i < minWords; i++) {
        let value = dest[i] = data[i] | other[i];
        if (value !== 0) {
          lastWord = i;
        }
      }
      const longer = data.length > other.length ? data : other;
      for (let i = minWords; i < words; i++) {
        let value = dest[i] = longer[i];
        if (value !== 0) {
          lastWord = i;
        }
      }
      if (lastWord === -1) {
        this.data = EMPTY_DATA;
      } else if (dest.length === lastWord + 1) {
        this.data = dest;
      } else {
        this.data = dest.slice(0, lastWord);
      }
    }
    previousClearBit(fromIndex) {
      if (fromIndex < 0) {
        throw new RangeError("fromIndex cannot be negative");
      }
      const data = this.data;
      const length = data.length;
      let word = getIndex(fromIndex);
      if (word >= length) {
        word = length - 1;
      }
      let ignore = 65535 ^ bitsFor(0, fromIndex);
      if ((data[word] | ignore) === 65535) {
        ignore = 0;
        word--;
        for (; word >= 0; word--) {
          if (data[word] !== 65535) {
            break;
          }
        }
        if (word < 0) {
          return -1;
        }
      }
      return unIndex(word) + findMSBSet((data[word] | ignore) ^ 65535);
    }
    previousSetBit(fromIndex) {
      if (fromIndex < 0) {
        throw new RangeError("fromIndex cannot be negative");
      }
      const data = this.data;
      const length = data.length;
      let word = getIndex(fromIndex);
      if (word >= length) {
        word = length - 1;
      }
      let mask = bitsFor(0, fromIndex);
      if ((data[word] & mask) === 0) {
        word--;
        mask = 65535;
        for (; word >= 0; word--) {
          if (data[word] !== 0) {
            break;
          }
        }
        if (word < 0) {
          return -1;
        }
      }
      return unIndex(word) + findMSBSet(data[word] & mask);
    }
    set(fromIndex, toIndex, value) {
      if (toIndex === void 0) {
        toIndex = fromIndex;
        value = true;
      } else if (typeof toIndex === "boolean") {
        value = toIndex;
        toIndex = fromIndex;
      }
      if (value === void 0) {
        value = true;
      }
      if (fromIndex < 0 || fromIndex > toIndex) {
        throw new RangeError();
      }
      let word = getIndex(fromIndex);
      let lastWord = getIndex(toIndex);
      if (value && lastWord >= this.data.length) {
        let temp = new Uint16Array(lastWord + 1);
        this.data.forEach((value2, index) => temp[index] = value2);
        this.data = temp;
      } else if (!value) {
        if (word >= this.data.length) {
          return;
        }
        if (lastWord >= this.data.length) {
          lastWord = this.data.length - 1;
          toIndex = this.data.length * 16 - 1;
        }
      }
      if (word === lastWord) {
        this._setBits(word, value, bitsFor(fromIndex, toIndex));
      } else {
        this._setBits(word++, value, bitsFor(fromIndex, 15));
        while (word < lastWord) {
          this.data[word++] = value ? 65535 : 0;
        }
        this._setBits(word, value, bitsFor(0, toIndex));
      }
    }
    _setBits(word, value, mask) {
      if (value) {
        this.data[word] |= mask;
      } else {
        this.data[word] &= 65535 ^ mask;
      }
    }
    get size() {
      return this.data.byteLength * 8;
    }
    hashCode() {
      return MurmurHash_1.MurmurHash.hashCode(this.data, 22);
    }
    equals(obj) {
      if (obj === this) {
        return true;
      } else if (!(obj instanceof BitSet)) {
        return false;
      }
      const len = this.length();
      if (len !== obj.length()) {
        return false;
      }
      if (len === 0) {
        return true;
      }
      let bound = getIndex(len - 1);
      for (let i = 0; i <= bound; i++) {
        if (this.data[i] !== obj.data[i]) {
          return false;
        }
      }
      return true;
    }
    toString() {
      let result = "{";
      let first = true;
      for (let i = this.nextSetBit(0); i >= 0; i = this.nextSetBit(i + 1)) {
        if (first) {
          first = false;
        } else {
          result += ", ";
        }
        result += i;
      }
      result += "}";
      return result;
    }
    xor(set) {
      const data = this.data;
      const other = set.data;
      const minWords = Math.min(data.length, other.length);
      const words = Math.max(data.length, other.length);
      const dest = data.length === words ? data : new Uint16Array(words);
      let lastWord = -1;
      for (let i = 0; i < minWords; i++) {
        let value = dest[i] = data[i] ^ other[i];
        if (value !== 0) {
          lastWord = i;
        }
      }
      const longer = data.length > other.length ? data : other;
      for (let i = minWords; i < words; i++) {
        let value = dest[i] = longer[i];
        if (value !== 0) {
          lastWord = i;
        }
      }
      if (lastWord === -1) {
        this.data = EMPTY_DATA;
      } else if (dest.length === lastWord + 1) {
        this.data = dest;
      } else {
        this.data = dest.slice(0, lastWord + 1);
      }
    }
    clone() {
      return new BitSet(this);
    }
    [Symbol.iterator]() {
      return new BitSetIterator(this.data);
    }
    [util.inspect.custom]() {
      return "BitSet " + this.toString();
    }
  };
  exports.BitSet = BitSet;
  var BitSetIterator = class {
    constructor(data) {
      this.data = data;
      this.index = 0;
      this.mask = 65535;
    }
    next() {
      while (this.index < this.data.length) {
        const bits = this.data[this.index] & this.mask;
        if (bits !== 0) {
          const bitNumber = unIndex(this.index) + findLSBSet(bits);
          this.mask = bitsFor(bitNumber + 1, 15);
          return {done: false, value: bitNumber};
        }
        this.index++;
        this.mask = 65535;
      }
      return {done: true, value: -1};
    }
    [Symbol.iterator]() {
      return this;
    }
  };
});

// node_modules/antlr4ts/atn/ATNConfigSet.js
var require_ATNConfigSet = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ATNConfigSet = void 0;
  var Array2DHashMap_1 = require_Array2DHashMap();
  var Array2DHashSet_1 = require_Array2DHashSet();
  var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
  var ATN_1 = require_ATN();
  var ATNConfig_1 = require_ATNConfig();
  var BitSet_1 = require_BitSet();
  var Decorators_1 = require_Decorators();
  var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
  var PredictionContext_1 = require_PredictionContext();
  var PredictionContextCache_1 = require_PredictionContextCache();
  var SemanticContext_1 = require_SemanticContext();
  var assert = __nccwpck_require__(9491);
  var Utils3 = require_Utils();
  var KeyTypeEqualityComparer = class {
    hashCode(key) {
      return key.state ^ key.alt;
    }
    equals(a, b) {
      return a.state === b.state && a.alt === b.alt;
    }
  };
  KeyTypeEqualityComparer.INSTANCE = new KeyTypeEqualityComparer();
  function NewKeyedConfigMap(map) {
    if (map) {
      return new Array2DHashMap_1.Array2DHashMap(map);
    } else {
      return new Array2DHashMap_1.Array2DHashMap(KeyTypeEqualityComparer.INSTANCE);
    }
  }
  var ATNConfigSet = class {
    constructor(set, readonly) {
      this._uniqueAlt = 0;
      this._hasSemanticContext = false;
      this._dipsIntoOuterContext = false;
      this.outermostConfigSet = false;
      this.cachedHashCode = -1;
      if (!set) {
        this.mergedConfigs = NewKeyedConfigMap();
        this.unmerged = [];
        this.configs = [];
        this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
      } else {
        if (readonly) {
          this.mergedConfigs = void 0;
          this.unmerged = void 0;
        } else if (!set.isReadOnly) {
          this.mergedConfigs = NewKeyedConfigMap(set.mergedConfigs);
          this.unmerged = set.unmerged.slice(0);
        } else {
          this.mergedConfigs = NewKeyedConfigMap();
          this.unmerged = [];
        }
        this.configs = set.configs.slice(0);
        this._dipsIntoOuterContext = set._dipsIntoOuterContext;
        this._hasSemanticContext = set._hasSemanticContext;
        this.outermostConfigSet = set.outermostConfigSet;
        if (readonly || !set.isReadOnly) {
          this._uniqueAlt = set._uniqueAlt;
          this._conflictInfo = set._conflictInfo;
        }
      }
    }
    getRepresentedAlternatives() {
      if (this._conflictInfo != null) {
        return this._conflictInfo.conflictedAlts.clone();
      }
      let alts = new BitSet_1.BitSet();
      for (let config of this) {
        alts.set(config.alt);
      }
      return alts;
    }
    get isReadOnly() {
      return this.mergedConfigs == null;
    }
    get isOutermostConfigSet() {
      return this.outermostConfigSet;
    }
    set isOutermostConfigSet(outermostConfigSet) {
      if (this.outermostConfigSet && !outermostConfigSet) {
        throw new Error("IllegalStateException");
      }
      assert(!outermostConfigSet || !this._dipsIntoOuterContext);
      this.outermostConfigSet = outermostConfigSet;
    }
    getStates() {
      let states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
      for (let c of this.configs) {
        states.add(c.state);
      }
      return states;
    }
    optimizeConfigs(interpreter) {
      if (this.configs.length === 0) {
        return;
      }
      for (let config of this.configs) {
        config.context = interpreter.atn.getCachedContext(config.context);
      }
    }
    clone(readonly) {
      let copy = new ATNConfigSet(this, readonly);
      if (!readonly && this.isReadOnly) {
        copy.addAll(this.configs);
      }
      return copy;
    }
    get size() {
      return this.configs.length;
    }
    get isEmpty() {
      return this.configs.length === 0;
    }
    contains(o) {
      if (!(o instanceof ATNConfig_1.ATNConfig)) {
        return false;
      }
      if (this.mergedConfigs && this.unmerged) {
        let config = o;
        let configKey = this.getKey(config);
        let mergedConfig = this.mergedConfigs.get(configKey);
        if (mergedConfig != null && this.canMerge(config, configKey, mergedConfig)) {
          return mergedConfig.contains(config);
        }
        for (let c of this.unmerged) {
          if (c.contains(o)) {
            return true;
          }
        }
      } else {
        for (let c of this.configs) {
          if (c.contains(o)) {
            return true;
          }
        }
      }
      return false;
    }
    *[Symbol.iterator]() {
      yield* this.configs;
    }
    toArray() {
      return this.configs;
    }
    add(e, contextCache) {
      this.ensureWritable();
      if (!this.mergedConfigs || !this.unmerged) {
        throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");
      }
      assert(!this.outermostConfigSet || !e.reachesIntoOuterContext);
      if (contextCache == null) {
        contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;
      }
      let addKey;
      let key = this.getKey(e);
      let mergedConfig = this.mergedConfigs.get(key);
      addKey = mergedConfig == null;
      if (mergedConfig != null && this.canMerge(e, key, mergedConfig)) {
        mergedConfig.outerContextDepth = Math.max(mergedConfig.outerContextDepth, e.outerContextDepth);
        if (e.isPrecedenceFilterSuppressed) {
          mergedConfig.isPrecedenceFilterSuppressed = true;
        }
        let joined = PredictionContext_1.PredictionContext.join(mergedConfig.context, e.context, contextCache);
        this.updatePropertiesForMergedConfig(e);
        if (mergedConfig.context === joined) {
          return false;
        }
        mergedConfig.context = joined;
        return true;
      }
      for (let i = 0; i < this.unmerged.length; i++) {
        let unmergedConfig = this.unmerged[i];
        if (this.canMerge(e, key, unmergedConfig)) {
          unmergedConfig.outerContextDepth = Math.max(unmergedConfig.outerContextDepth, e.outerContextDepth);
          if (e.isPrecedenceFilterSuppressed) {
            unmergedConfig.isPrecedenceFilterSuppressed = true;
          }
          let joined = PredictionContext_1.PredictionContext.join(unmergedConfig.context, e.context, contextCache);
          this.updatePropertiesForMergedConfig(e);
          if (unmergedConfig.context === joined) {
            return false;
          }
          unmergedConfig.context = joined;
          if (addKey) {
            this.mergedConfigs.put(key, unmergedConfig);
            this.unmerged.splice(i, 1);
          }
          return true;
        }
      }
      this.configs.push(e);
      if (addKey) {
        this.mergedConfigs.put(key, e);
      } else {
        this.unmerged.push(e);
      }
      this.updatePropertiesForAddedConfig(e);
      return true;
    }
    updatePropertiesForMergedConfig(config) {
      this._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;
      assert(!this.outermostConfigSet || !this._dipsIntoOuterContext);
    }
    updatePropertiesForAddedConfig(config) {
      if (this.configs.length === 1) {
        this._uniqueAlt = config.alt;
      } else if (this._uniqueAlt !== config.alt) {
        this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
      }
      this._hasSemanticContext = this._hasSemanticContext || !SemanticContext_1.SemanticContext.NONE.equals(config.semanticContext);
      this._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;
      assert(!this.outermostConfigSet || !this._dipsIntoOuterContext);
    }
    canMerge(left, leftKey, right) {
      if (left.state.stateNumber !== right.state.stateNumber) {
        return false;
      }
      if (leftKey.alt !== right.alt) {
        return false;
      }
      return left.semanticContext.equals(right.semanticContext);
    }
    getKey(e) {
      return {state: e.state.stateNumber, alt: e.alt};
    }
    containsAll(c) {
      for (let o of c) {
        if (!(o instanceof ATNConfig_1.ATNConfig)) {
          return false;
        }
        if (!this.contains(o)) {
          return false;
        }
      }
      return true;
    }
    addAll(c, contextCache) {
      this.ensureWritable();
      let changed = false;
      for (let group of c) {
        if (this.add(group, contextCache)) {
          changed = true;
        }
      }
      return changed;
    }
    clear() {
      this.ensureWritable();
      if (!this.mergedConfigs || !this.unmerged) {
        throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation");
      }
      this.mergedConfigs.clear();
      this.unmerged.length = 0;
      this.configs.length = 0;
      this._dipsIntoOuterContext = false;
      this._hasSemanticContext = false;
      this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
      this._conflictInfo = void 0;
    }
    equals(obj) {
      if (this === obj) {
        return true;
      }
      if (!(obj instanceof ATNConfigSet)) {
        return false;
      }
      return this.outermostConfigSet === obj.outermostConfigSet && Utils3.equals(this._conflictInfo, obj._conflictInfo) && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.configs, obj.configs);
    }
    hashCode() {
      if (this.isReadOnly && this.cachedHashCode !== -1) {
        return this.cachedHashCode;
      }
      let hashCode = 1;
      hashCode = 5 * hashCode ^ (this.outermostConfigSet ? 1 : 0);
      hashCode = 5 * hashCode ^ ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.hashCode(this.configs);
      if (this.isReadOnly) {
        this.cachedHashCode = hashCode;
      }
      return hashCode;
    }
    toString(showContext) {
      if (showContext == null) {
        showContext = false;
      }
      let buf = "";
      let sortedConfigs = this.configs.slice(0);
      sortedConfigs.sort((o1, o2) => {
        if (o1.alt !== o2.alt) {
          return o1.alt - o2.alt;
        } else if (o1.state.stateNumber !== o2.state.stateNumber) {
          return o1.state.stateNumber - o2.state.stateNumber;
        } else {
          return o1.semanticContext.toString().localeCompare(o2.semanticContext.toString());
        }
      });
      buf += "[";
      for (let i = 0; i < sortedConfigs.length; i++) {
        if (i > 0) {
          buf += ", ";
        }
        buf += sortedConfigs[i].toString(void 0, true, showContext);
      }
      buf += "]";
      if (this._hasSemanticContext) {
        buf += ",hasSemanticContext=" + this._hasSemanticContext;
      }
      if (this._uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
        buf += ",uniqueAlt=" + this._uniqueAlt;
      }
      if (this._conflictInfo != null) {
        buf += ",conflictingAlts=" + this._conflictInfo.conflictedAlts;
        if (!this._conflictInfo.isExact) {
          buf += "*";
        }
      }
      if (this._dipsIntoOuterContext) {
        buf += ",dipsIntoOuterContext";
      }
      return buf.toString();
    }
    get uniqueAlt() {
      return this._uniqueAlt;
    }
    get hasSemanticContext() {
      return this._hasSemanticContext;
    }
    set hasSemanticContext(value) {
      this.ensureWritable();
      this._hasSemanticContext = value;
    }
    get conflictInfo() {
      return this._conflictInfo;
    }
    set conflictInfo(conflictInfo) {
      this.ensureWritable();
      this._conflictInfo = conflictInfo;
    }
    get conflictingAlts() {
      if (this._conflictInfo == null) {
        return void 0;
      }
      return this._conflictInfo.conflictedAlts;
    }
    get isExactConflict() {
      if (this._conflictInfo == null) {
        return false;
      }
      return this._conflictInfo.isExact;
    }
    get dipsIntoOuterContext() {
      return this._dipsIntoOuterContext;
    }
    get(index) {
      return this.configs[index];
    }
    ensureWritable() {
      if (this.isReadOnly) {
        throw new Error("This ATNConfigSet is read only.");
      }
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], ATNConfigSet.prototype, "getRepresentedAlternatives", null);
  __decorate([
    Decorators_1.Override
  ], ATNConfigSet.prototype, "size", null);
  __decorate([
    Decorators_1.Override
  ], ATNConfigSet.prototype, "isEmpty", null);
  __decorate([
    Decorators_1.Override
  ], ATNConfigSet.prototype, "contains", null);
  __decorate([
    Decorators_1.Override
  ], ATNConfigSet.prototype, Symbol.iterator, null);
  __decorate([
    Decorators_1.Override
  ], ATNConfigSet.prototype, "toArray", null);
  __decorate([
    Decorators_1.Override
  ], ATNConfigSet.prototype, "containsAll", null);
  __decorate([
    Decorators_1.Override
  ], ATNConfigSet.prototype, "clear", null);
  __decorate([
    Decorators_1.Override
  ], ATNConfigSet.prototype, "equals", null);
  __decorate([
    Decorators_1.Override
  ], ATNConfigSet.prototype, "hashCode", null);
  exports.ATNConfigSet = ATNConfigSet;
});

// node_modules/antlr4ts/dfa/DFAState.js
var require_DFAState = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.DFAState = void 0;
  var ATN_1 = require_ATN();
  var BitSet_1 = require_BitSet();
  var MurmurHash_1 = require_MurmurHash();
  var Decorators_1 = require_Decorators();
  var PredictionContext_1 = require_PredictionContext();
  var assert = __nccwpck_require__(9491);
  var DFAState = class {
    constructor(configs) {
      this.stateNumber = -1;
      this.configs = configs;
      this.edges = new Map();
      this.contextEdges = new Map();
    }
    get isContextSensitive() {
      return !!this.contextSymbols;
    }
    isContextSymbol(symbol) {
      if (!this.isContextSensitive) {
        return false;
      }
      return this.contextSymbols.get(symbol);
    }
    setContextSymbol(symbol) {
      assert(this.isContextSensitive);
      this.contextSymbols.set(symbol);
    }
    setContextSensitive(atn) {
      assert(!this.configs.isOutermostConfigSet);
      if (this.isContextSensitive) {
        return;
      }
      if (!this.contextSymbols) {
        this.contextSymbols = new BitSet_1.BitSet();
      }
    }
    get acceptStateInfo() {
      return this._acceptStateInfo;
    }
    set acceptStateInfo(acceptStateInfo) {
      this._acceptStateInfo = acceptStateInfo;
    }
    get isAcceptState() {
      return !!this._acceptStateInfo;
    }
    get prediction() {
      if (!this._acceptStateInfo) {
        return ATN_1.ATN.INVALID_ALT_NUMBER;
      }
      return this._acceptStateInfo.prediction;
    }
    get lexerActionExecutor() {
      if (!this._acceptStateInfo) {
        return void 0;
      }
      return this._acceptStateInfo.lexerActionExecutor;
    }
    getTarget(symbol) {
      return this.edges.get(symbol);
    }
    setTarget(symbol, target) {
      this.edges.set(symbol, target);
    }
    getEdgeMap() {
      return this.edges;
    }
    getContextTarget(invokingState) {
      if (invokingState === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
        invokingState = -1;
      }
      return this.contextEdges.get(invokingState);
    }
    setContextTarget(invokingState, target) {
      if (!this.isContextSensitive) {
        throw new Error("The state is not context sensitive.");
      }
      if (invokingState === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
        invokingState = -1;
      }
      this.contextEdges.set(invokingState, target);
    }
    getContextEdgeMap() {
      let map = new Map(this.contextEdges);
      let existing = map.get(-1);
      if (existing !== void 0) {
        if (map.size === 1) {
          let result = new Map();
          result.set(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY, existing);
          return result;
        } else {
          map.delete(-1);
          map.set(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY, existing);
        }
      }
      return map;
    }
    hashCode() {
      let hash = MurmurHash_1.MurmurHash.initialize(7);
      hash = MurmurHash_1.MurmurHash.update(hash, this.configs.hashCode());
      hash = MurmurHash_1.MurmurHash.finish(hash, 1);
      return hash;
    }
    equals(o) {
      if (this === o) {
        return true;
      }
      if (!(o instanceof DFAState)) {
        return false;
      }
      let other = o;
      let sameSet = this.configs.equals(other.configs);
      return sameSet;
    }
    toString() {
      let buf = "";
      buf += this.stateNumber + ":" + this.configs;
      if (this.isAcceptState) {
        buf += "=>";
        if (this.predicates) {
          buf += this.predicates;
        } else {
          buf += this.prediction;
        }
      }
      return buf.toString();
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], DFAState.prototype, "configs", void 0);
  __decorate([
    Decorators_1.NotNull
  ], DFAState.prototype, "edges", void 0);
  __decorate([
    Decorators_1.NotNull
  ], DFAState.prototype, "contextEdges", void 0);
  __decorate([
    Decorators_1.Override
  ], DFAState.prototype, "hashCode", null);
  __decorate([
    Decorators_1.Override
  ], DFAState.prototype, "equals", null);
  __decorate([
    Decorators_1.Override
  ], DFAState.prototype, "toString", null);
  exports.DFAState = DFAState;
  (function(DFAState2) {
    let PredPrediction = class PredPrediction {
      constructor(pred, alt) {
        this.alt = alt;
        this.pred = pred;
      }
      toString() {
        return "(" + this.pred + ", " + this.alt + ")";
      }
    };
    __decorate([
      Decorators_1.NotNull
    ], PredPrediction.prototype, "pred", void 0);
    __decorate([
      Decorators_1.Override
    ], PredPrediction.prototype, "toString", null);
    PredPrediction = __decorate([
      __param(0, Decorators_1.NotNull)
    ], PredPrediction);
    DFAState2.PredPrediction = PredPrediction;
  })(DFAState = exports.DFAState || (exports.DFAState = {}));
});

// node_modules/antlr4ts/atn/ATNSimulator.js
var require_ATNSimulator = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ATNSimulator = void 0;
  var ATNConfigSet_1 = require_ATNConfigSet();
  var DFAState_1 = require_DFAState();
  var Decorators_1 = require_Decorators();
  var PredictionContext_1 = require_PredictionContext();
  var ATNSimulator = class ATNSimulator2 {
    constructor(atn) {
      this.atn = atn;
    }
    static get ERROR() {
      if (!ATNSimulator2._ERROR) {
        ATNSimulator2._ERROR = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
        ATNSimulator2._ERROR.stateNumber = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
      }
      return ATNSimulator2._ERROR;
    }
    clearDFA() {
      this.atn.clearDFA();
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], ATNSimulator.prototype, "atn", void 0);
  __decorate([
    Decorators_1.NotNull
  ], ATNSimulator, "ERROR", null);
  ATNSimulator = __decorate([
    __param(0, Decorators_1.NotNull)
  ], ATNSimulator);
  exports.ATNSimulator = ATNSimulator;
  (function(ATNSimulator2) {
    const RULE_VARIANT_DELIMITER = "$";
    const RULE_LF_VARIANT_MARKER = "$lf$";
    const RULE_NOLF_VARIANT_MARKER = "$nolf$";
  })(ATNSimulator = exports.ATNSimulator || (exports.ATNSimulator = {}));
  exports.ATNSimulator = ATNSimulator;
});

// node_modules/antlr4ts/ConsoleErrorListener.js
var require_ConsoleErrorListener = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ConsoleErrorListener = void 0;
  var ConsoleErrorListener = class {
    syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
      console.error(`line ${line}:${charPositionInLine} ${msg}`);
    }
  };
  exports.ConsoleErrorListener = ConsoleErrorListener;
  ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();
});

// node_modules/antlr4ts/ProxyErrorListener.js
var require_ProxyErrorListener = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ProxyErrorListener = void 0;
  var Decorators_1 = require_Decorators();
  var ProxyErrorListener = class {
    constructor(delegates) {
      this.delegates = delegates;
      if (!delegates) {
        throw new Error("Invalid delegates");
      }
    }
    getDelegates() {
      return this.delegates;
    }
    syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
      this.delegates.forEach((listener) => {
        if (listener.syntaxError) {
          listener.syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e);
        }
      });
    }
  };
  __decorate([
    Decorators_1.Override,
    __param(0, Decorators_1.NotNull),
    __param(4, Decorators_1.NotNull)
  ], ProxyErrorListener.prototype, "syntaxError", null);
  exports.ProxyErrorListener = ProxyErrorListener;
});

// node_modules/antlr4ts/Recognizer.js
var require_Recognizer = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.Recognizer = void 0;
  var ConsoleErrorListener_1 = require_ConsoleErrorListener();
  var ProxyErrorListener_1 = require_ProxyErrorListener();
  var Decorators_1 = require_Decorators();
  var Token_1 = require_Token();
  var Utils3 = require_Utils();
  var Recognizer = class {
    constructor() {
      this._listeners = [ConsoleErrorListener_1.ConsoleErrorListener.INSTANCE];
      this._stateNumber = -1;
    }
    getTokenTypeMap() {
      let vocabulary = this.vocabulary;
      let result = Recognizer.tokenTypeMapCache.get(vocabulary);
      if (result == null) {
        let intermediateResult = new Map();
        for (let i = 0; i <= this.atn.maxTokenType; i++) {
          let literalName = vocabulary.getLiteralName(i);
          if (literalName != null) {
            intermediateResult.set(literalName, i);
          }
          let symbolicName = vocabulary.getSymbolicName(i);
          if (symbolicName != null) {
            intermediateResult.set(symbolicName, i);
          }
        }
        intermediateResult.set("EOF", Token_1.Token.EOF);
        result = intermediateResult;
        Recognizer.tokenTypeMapCache.set(vocabulary, result);
      }
      return result;
    }
    getRuleIndexMap() {
      let ruleNames = this.ruleNames;
      if (ruleNames == null) {
        throw new Error("The current recognizer does not provide a list of rule names.");
      }
      let result = Recognizer.ruleIndexMapCache.get(ruleNames);
      if (result == null) {
        result = Utils3.toMap(ruleNames);
        Recognizer.ruleIndexMapCache.set(ruleNames, result);
      }
      return result;
    }
    getTokenType(tokenName) {
      let ttype = this.getTokenTypeMap().get(tokenName);
      if (ttype != null) {
        return ttype;
      }
      return Token_1.Token.INVALID_TYPE;
    }
    get serializedATN() {
      throw new Error("there is no serialized ATN");
    }
    get atn() {
      return this._interp.atn;
    }
    get interpreter() {
      return this._interp;
    }
    set interpreter(interpreter) {
      this._interp = interpreter;
    }
    get parseInfo() {
      return Promise.resolve(void 0);
    }
    getErrorHeader(e) {
      let token = e.getOffendingToken();
      if (!token) {
        return "";
      }
      let line = token.line;
      let charPositionInLine = token.charPositionInLine;
      return "line " + line + ":" + charPositionInLine;
    }
    addErrorListener(listener) {
      if (!listener) {
        throw new TypeError("listener must not be null");
      }
      this._listeners.push(listener);
    }
    removeErrorListener(listener) {
      let position = this._listeners.indexOf(listener);
      if (position !== -1) {
        this._listeners.splice(position, 1);
      }
    }
    removeErrorListeners() {
      this._listeners.length = 0;
    }
    getErrorListeners() {
      return this._listeners.slice(0);
    }
    getErrorListenerDispatch() {
      return new ProxyErrorListener_1.ProxyErrorListener(this.getErrorListeners());
    }
    sempred(_localctx, ruleIndex, actionIndex) {
      return true;
    }
    precpred(localctx, precedence) {
      return true;
    }
    action(_localctx, ruleIndex, actionIndex) {
    }
    get state() {
      return this._stateNumber;
    }
    set state(atnState) {
      this._stateNumber = atnState;
    }
  };
  Recognizer.EOF = -1;
  Recognizer.tokenTypeMapCache = new WeakMap();
  Recognizer.ruleIndexMapCache = new WeakMap();
  __decorate([
    Decorators_1.SuppressWarnings("serial"),
    Decorators_1.NotNull
  ], Recognizer.prototype, "_listeners", void 0);
  __decorate([
    Decorators_1.NotNull
  ], Recognizer.prototype, "getTokenTypeMap", null);
  __decorate([
    Decorators_1.NotNull
  ], Recognizer.prototype, "getRuleIndexMap", null);
  __decorate([
    Decorators_1.NotNull
  ], Recognizer.prototype, "serializedATN", null);
  __decorate([
    Decorators_1.NotNull
  ], Recognizer.prototype, "atn", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull)
  ], Recognizer.prototype, "interpreter", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull)
  ], Recognizer.prototype, "getErrorHeader", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], Recognizer.prototype, "addErrorListener", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], Recognizer.prototype, "removeErrorListener", null);
  __decorate([
    Decorators_1.NotNull
  ], Recognizer.prototype, "getErrorListeners", null);
  exports.Recognizer = Recognizer;
});

// node_modules/antlr4ts/VocabularyImpl.js
var require_VocabularyImpl = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.VocabularyImpl = void 0;
  var Decorators_1 = require_Decorators();
  var Token_1 = require_Token();
  var VocabularyImpl3 = class {
    constructor(literalNames, symbolicNames, displayNames) {
      this.literalNames = literalNames;
      this.symbolicNames = symbolicNames;
      this.displayNames = displayNames;
      this._maxTokenType = Math.max(this.displayNames.length, Math.max(this.literalNames.length, this.symbolicNames.length)) - 1;
    }
    get maxTokenType() {
      return this._maxTokenType;
    }
    getLiteralName(tokenType) {
      if (tokenType >= 0 && tokenType < this.literalNames.length) {
        return this.literalNames[tokenType];
      }
      return void 0;
    }
    getSymbolicName(tokenType) {
      if (tokenType >= 0 && tokenType < this.symbolicNames.length) {
        return this.symbolicNames[tokenType];
      }
      if (tokenType === Token_1.Token.EOF) {
        return "EOF";
      }
      return void 0;
    }
    getDisplayName(tokenType) {
      if (tokenType >= 0 && tokenType < this.displayNames.length) {
        let displayName = this.displayNames[tokenType];
        if (displayName) {
          return displayName;
        }
      }
      let literalName = this.getLiteralName(tokenType);
      if (literalName) {
        return literalName;
      }
      let symbolicName = this.getSymbolicName(tokenType);
      if (symbolicName) {
        return symbolicName;
      }
      return String(tokenType);
    }
  };
  VocabularyImpl3.EMPTY_VOCABULARY = new VocabularyImpl3([], [], []);
  __decorate([
    Decorators_1.NotNull
  ], VocabularyImpl3.prototype, "literalNames", void 0);
  __decorate([
    Decorators_1.NotNull
  ], VocabularyImpl3.prototype, "symbolicNames", void 0);
  __decorate([
    Decorators_1.NotNull
  ], VocabularyImpl3.prototype, "displayNames", void 0);
  __decorate([
    Decorators_1.Override
  ], VocabularyImpl3.prototype, "maxTokenType", null);
  __decorate([
    Decorators_1.Override
  ], VocabularyImpl3.prototype, "getLiteralName", null);
  __decorate([
    Decorators_1.Override
  ], VocabularyImpl3.prototype, "getSymbolicName", null);
  __decorate([
    Decorators_1.Override,
    Decorators_1.NotNull
  ], VocabularyImpl3.prototype, "getDisplayName", null);
  __decorate([
    Decorators_1.NotNull
  ], VocabularyImpl3, "EMPTY_VOCABULARY", void 0);
  exports.VocabularyImpl = VocabularyImpl3;
});

// node_modules/antlr4ts/dfa/DFASerializer.js
var require_DFASerializer = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.DFASerializer = void 0;
  var ATNSimulator_1 = require_ATNSimulator();
  var Decorators_1 = require_Decorators();
  var PredictionContext_1 = require_PredictionContext();
  var Recognizer_1 = require_Recognizer();
  var VocabularyImpl_1 = require_VocabularyImpl();
  var DFASerializer = class {
    constructor(dfa, vocabulary, ruleNames, atn) {
      if (vocabulary instanceof Recognizer_1.Recognizer) {
        ruleNames = vocabulary.ruleNames;
        atn = vocabulary.atn;
        vocabulary = vocabulary.vocabulary;
      } else if (!vocabulary) {
        vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
      }
      this.dfa = dfa;
      this.vocabulary = vocabulary;
      this.ruleNames = ruleNames;
      this.atn = atn;
    }
    toString() {
      if (!this.dfa.s0) {
        return "";
      }
      let buf = "";
      if (this.dfa.states) {
        let states = new Array(...this.dfa.states.toArray());
        states.sort((o1, o2) => o1.stateNumber - o2.stateNumber);
        for (let s of states) {
          let edges = s.getEdgeMap();
          let edgeKeys = [...edges.keys()].sort((a, b) => a - b);
          let contextEdges = s.getContextEdgeMap();
          let contextEdgeKeys = [...contextEdges.keys()].sort((a, b) => a - b);
          for (let entry of edgeKeys) {
            let value = edges.get(entry);
            if ((value == null || value === ATNSimulator_1.ATNSimulator.ERROR) && !s.isContextSymbol(entry)) {
              continue;
            }
            let contextSymbol = false;
            buf += this.getStateString(s) + "-" + this.getEdgeLabel(entry) + "->";
            if (s.isContextSymbol(entry)) {
              buf += "!";
              contextSymbol = true;
            }
            let t = value;
            if (t && t.stateNumber !== ATNSimulator_1.ATNSimulator.ERROR.stateNumber) {
              buf += this.getStateString(t) + "\n";
            } else if (contextSymbol) {
              buf += "ctx\n";
            }
          }
          if (s.isContextSensitive) {
            for (let entry of contextEdgeKeys) {
              buf += this.getStateString(s) + "-" + this.getContextLabel(entry) + "->" + this.getStateString(contextEdges.get(entry)) + "\n";
            }
          }
        }
      }
      let output = buf;
      if (output.length === 0) {
        return "";
      }
      return output;
    }
    getContextLabel(i) {
      if (i === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
        return "ctx:EMPTY_FULL";
      } else if (i === PredictionContext_1.PredictionContext.EMPTY_LOCAL_STATE_KEY) {
        return "ctx:EMPTY_LOCAL";
      }
      if (this.atn && i > 0 && i <= this.atn.states.length) {
        let state = this.atn.states[i];
        let ruleIndex = state.ruleIndex;
        if (this.ruleNames && ruleIndex >= 0 && ruleIndex < this.ruleNames.length) {
          return "ctx:" + String(i) + "(" + this.ruleNames[ruleIndex] + ")";
        }
      }
      return "ctx:" + String(i);
    }
    getEdgeLabel(i) {
      return this.vocabulary.getDisplayName(i);
    }
    getStateString(s) {
      if (s === ATNSimulator_1.ATNSimulator.ERROR) {
        return "ERROR";
      }
      let n = s.stateNumber;
      let stateStr = "s" + n;
      if (s.isAcceptState) {
        if (s.predicates) {
          stateStr = ":s" + n + "=>" + s.predicates;
        } else {
          stateStr = ":s" + n + "=>" + s.prediction;
        }
      }
      if (s.isContextSensitive) {
        stateStr += "*";
        for (let config of s.configs) {
          if (config.reachesIntoOuterContext) {
            stateStr += "*";
            break;
          }
        }
      }
      return stateStr;
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], DFASerializer.prototype, "dfa", void 0);
  __decorate([
    Decorators_1.NotNull
  ], DFASerializer.prototype, "vocabulary", void 0);
  __decorate([
    Decorators_1.Override
  ], DFASerializer.prototype, "toString", null);
  exports.DFASerializer = DFASerializer;
});

// node_modules/antlr4ts/dfa/LexerDFASerializer.js
var require_LexerDFASerializer = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.LexerDFASerializer = void 0;
  var DFASerializer_1 = require_DFASerializer();
  var Decorators_1 = require_Decorators();
  var VocabularyImpl_1 = require_VocabularyImpl();
  var LexerDFASerializer = class LexerDFASerializer extends DFASerializer_1.DFASerializer {
    constructor(dfa) {
      super(dfa, VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY);
    }
    getEdgeLabel(i) {
      return "'" + String.fromCodePoint(i) + "'";
    }
  };
  __decorate([
    Decorators_1.Override,
    Decorators_1.NotNull
  ], LexerDFASerializer.prototype, "getEdgeLabel", null);
  LexerDFASerializer = __decorate([
    __param(0, Decorators_1.NotNull)
  ], LexerDFASerializer);
  exports.LexerDFASerializer = LexerDFASerializer;
});

// node_modules/antlr4ts/atn/StarLoopEntryState.js
var require_StarLoopEntryState = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.StarLoopEntryState = void 0;
  var ATNStateType_1 = require_ATNStateType();
  var BitSet_1 = require_BitSet();
  var DecisionState_1 = require_DecisionState();
  var Decorators_1 = require_Decorators();
  var StarLoopEntryState = class extends DecisionState_1.DecisionState {
    constructor() {
      super(...arguments);
      this.precedenceRuleDecision = false;
      this.precedenceLoopbackStates = new BitSet_1.BitSet();
    }
    get stateType() {
      return ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY;
    }
  };
  __decorate([
    Decorators_1.Override
  ], StarLoopEntryState.prototype, "stateType", null);
  exports.StarLoopEntryState = StarLoopEntryState;
});

// node_modules/antlr4ts/dfa/DFA.js
var require_DFA = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.DFA = void 0;
  var Array2DHashSet_1 = require_Array2DHashSet();
  var ATNConfigSet_1 = require_ATNConfigSet();
  var DFASerializer_1 = require_DFASerializer();
  var DFAState_1 = require_DFAState();
  var LexerDFASerializer_1 = require_LexerDFASerializer();
  var Decorators_1 = require_Decorators();
  var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
  var StarLoopEntryState_1 = require_StarLoopEntryState();
  var VocabularyImpl_1 = require_VocabularyImpl();
  var DFA = class DFA {
    constructor(atnStartState, decision = 0) {
      this.states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
      this.nextStateNumber = 0;
      if (!atnStartState.atn) {
        throw new Error("The ATNState must be associated with an ATN");
      }
      this.atnStartState = atnStartState;
      this.atn = atnStartState.atn;
      this.decision = decision;
      let isPrecedenceDfa = false;
      if (atnStartState instanceof StarLoopEntryState_1.StarLoopEntryState) {
        if (atnStartState.precedenceRuleDecision) {
          isPrecedenceDfa = true;
          this.s0 = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
          this.s0full = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());
        }
      }
      this.precedenceDfa = isPrecedenceDfa;
    }
    get isPrecedenceDfa() {
      return this.precedenceDfa;
    }
    getPrecedenceStartState(precedence, fullContext) {
      if (!this.isPrecedenceDfa) {
        throw new Error("Only precedence DFAs may contain a precedence start state.");
      }
      if (fullContext) {
        return this.s0full.getTarget(precedence);
      } else {
        return this.s0.getTarget(precedence);
      }
    }
    setPrecedenceStartState(precedence, fullContext, startState) {
      if (!this.isPrecedenceDfa) {
        throw new Error("Only precedence DFAs may contain a precedence start state.");
      }
      if (precedence < 0) {
        return;
      }
      if (fullContext) {
        this.s0full.setTarget(precedence, startState);
      } else {
        this.s0.setTarget(precedence, startState);
      }
    }
    get isEmpty() {
      if (this.isPrecedenceDfa) {
        return this.s0.getEdgeMap().size === 0 && this.s0full.getEdgeMap().size === 0;
      }
      return this.s0 == null && this.s0full == null;
    }
    get isContextSensitive() {
      if (this.isPrecedenceDfa) {
        return this.s0full.getEdgeMap().size > 0;
      }
      return this.s0full != null;
    }
    addState(state) {
      state.stateNumber = this.nextStateNumber++;
      return this.states.getOrAdd(state);
    }
    toString(vocabulary, ruleNames) {
      if (!vocabulary) {
        vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
      }
      if (!this.s0) {
        return "";
      }
      let serializer;
      if (ruleNames) {
        serializer = new DFASerializer_1.DFASerializer(this, vocabulary, ruleNames, this.atnStartState.atn);
      } else {
        serializer = new DFASerializer_1.DFASerializer(this, vocabulary);
      }
      return serializer.toString();
    }
    toLexerString() {
      if (!this.s0) {
        return "";
      }
      let serializer = new LexerDFASerializer_1.LexerDFASerializer(this);
      return serializer.toString();
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], DFA.prototype, "states", void 0);
  __decorate([
    Decorators_1.NotNull
  ], DFA.prototype, "atnStartState", void 0);
  __decorate([
    Decorators_1.NotNull
  ], DFA.prototype, "atn", void 0);
  DFA = __decorate([
    __param(0, Decorators_1.NotNull)
  ], DFA);
  exports.DFA = DFA;
});

// node_modules/antlr4ts/atn/BasicState.js
var require_BasicState = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.BasicState = void 0;
  var ATNState_1 = require_ATNState();
  var ATNStateType_1 = require_ATNStateType();
  var Decorators_1 = require_Decorators();
  var BasicState = class extends ATNState_1.ATNState {
    get stateType() {
      return ATNStateType_1.ATNStateType.BASIC;
    }
  };
  __decorate([
    Decorators_1.Override
  ], BasicState.prototype, "stateType", null);
  exports.BasicState = BasicState;
});

// node_modules/antlr4ts/atn/InvalidState.js
var require_InvalidState = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.InvalidState = void 0;
  var ATNStateType_1 = require_ATNStateType();
  var BasicState_1 = require_BasicState();
  var Decorators_1 = require_Decorators();
  var InvalidState = class extends BasicState_1.BasicState {
    get stateType() {
      return ATNStateType_1.ATNStateType.INVALID_TYPE;
    }
  };
  __decorate([
    Decorators_1.Override
  ], InvalidState.prototype, "stateType", null);
  exports.InvalidState = InvalidState;
});

// node_modules/antlr4ts/atn/SetTransition.js
var require_SetTransition = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.SetTransition = void 0;
  var IntervalSet_1 = require_IntervalSet();
  var Decorators_1 = require_Decorators();
  var Token_1 = require_Token();
  var Transition_1 = require_Transition();
  var SetTransition = class SetTransition extends Transition_1.Transition {
    constructor(target, set) {
      super(target);
      if (set == null) {
        set = IntervalSet_1.IntervalSet.of(Token_1.Token.INVALID_TYPE);
      }
      this.set = set;
    }
    get serializationType() {
      return 7;
    }
    get label() {
      return this.set;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return this.set.contains(symbol);
    }
    toString() {
      return this.set.toString();
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], SetTransition.prototype, "set", void 0);
  __decorate([
    Decorators_1.Override
  ], SetTransition.prototype, "serializationType", null);
  __decorate([
    Decorators_1.Override,
    Decorators_1.NotNull
  ], SetTransition.prototype, "label", null);
  __decorate([
    Decorators_1.Override
  ], SetTransition.prototype, "matches", null);
  __decorate([
    Decorators_1.Override,
    Decorators_1.NotNull
  ], SetTransition.prototype, "toString", null);
  SetTransition = __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.Nullable)
  ], SetTransition);
  exports.SetTransition = SetTransition;
});

// node_modules/antlr4ts/atn/NotSetTransition.js
var require_NotSetTransition = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.NotSetTransition = void 0;
  var Decorators_1 = require_Decorators();
  var SetTransition_1 = require_SetTransition();
  var NotSetTransition = class NotSetTransition extends SetTransition_1.SetTransition {
    constructor(target, set) {
      super(target, set);
    }
    get serializationType() {
      return 8;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !super.matches(symbol, minVocabSymbol, maxVocabSymbol);
    }
    toString() {
      return "~" + super.toString();
    }
  };
  __decorate([
    Decorators_1.Override
  ], NotSetTransition.prototype, "serializationType", null);
  __decorate([
    Decorators_1.Override
  ], NotSetTransition.prototype, "matches", null);
  __decorate([
    Decorators_1.Override
  ], NotSetTransition.prototype, "toString", null);
  NotSetTransition = __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.Nullable)
  ], NotSetTransition);
  exports.NotSetTransition = NotSetTransition;
});

// node_modules/antlr4ts/atn/RuleStopState.js
var require_RuleStopState = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.RuleStopState = void 0;
  var ATNState_1 = require_ATNState();
  var ATNStateType_1 = require_ATNStateType();
  var Decorators_1 = require_Decorators();
  var RuleStopState = class extends ATNState_1.ATNState {
    get nonStopStateNumber() {
      return -1;
    }
    get stateType() {
      return ATNStateType_1.ATNStateType.RULE_STOP;
    }
  };
  __decorate([
    Decorators_1.Override
  ], RuleStopState.prototype, "nonStopStateNumber", null);
  __decorate([
    Decorators_1.Override
  ], RuleStopState.prototype, "stateType", null);
  exports.RuleStopState = RuleStopState;
});

// node_modules/antlr4ts/atn/RuleTransition.js
var require_RuleTransition = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.RuleTransition = void 0;
  var Decorators_1 = require_Decorators();
  var Transition_1 = require_Transition();
  var RuleTransition = class RuleTransition extends Transition_1.Transition {
    constructor(ruleStart, ruleIndex, precedence, followState) {
      super(ruleStart);
      this.tailCall = false;
      this.optimizedTailCall = false;
      this.ruleIndex = ruleIndex;
      this.precedence = precedence;
      this.followState = followState;
    }
    get serializationType() {
      return 3;
    }
    get isEpsilon() {
      return true;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return false;
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], RuleTransition.prototype, "followState", void 0);
  __decorate([
    Decorators_1.Override
  ], RuleTransition.prototype, "serializationType", null);
  __decorate([
    Decorators_1.Override
  ], RuleTransition.prototype, "isEpsilon", null);
  __decorate([
    Decorators_1.Override
  ], RuleTransition.prototype, "matches", null);
  RuleTransition = __decorate([
    __param(0, Decorators_1.NotNull),
    __param(3, Decorators_1.NotNull)
  ], RuleTransition);
  exports.RuleTransition = RuleTransition;
});

// node_modules/antlr4ts/atn/WildcardTransition.js
var require_WildcardTransition = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.WildcardTransition = void 0;
  var Decorators_1 = require_Decorators();
  var Transition_1 = require_Transition();
  var WildcardTransition = class WildcardTransition extends Transition_1.Transition {
    constructor(target) {
      super(target);
    }
    get serializationType() {
      return 9;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
    }
    toString() {
      return ".";
    }
  };
  __decorate([
    Decorators_1.Override
  ], WildcardTransition.prototype, "serializationType", null);
  __decorate([
    Decorators_1.Override
  ], WildcardTransition.prototype, "matches", null);
  __decorate([
    Decorators_1.Override,
    Decorators_1.NotNull
  ], WildcardTransition.prototype, "toString", null);
  WildcardTransition = __decorate([
    __param(0, Decorators_1.NotNull)
  ], WildcardTransition);
  exports.WildcardTransition = WildcardTransition;
});

// node_modules/antlr4ts/atn/LL1Analyzer.js
var require_LL1Analyzer = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.LL1Analyzer = void 0;
  var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
  var Array2DHashSet_1 = require_Array2DHashSet();
  var ATNConfig_1 = require_ATNConfig();
  var BitSet_1 = require_BitSet();
  var IntervalSet_1 = require_IntervalSet();
  var Decorators_1 = require_Decorators();
  var NotSetTransition_1 = require_NotSetTransition();
  var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
  var PredictionContext_1 = require_PredictionContext();
  var RuleStopState_1 = require_RuleStopState();
  var RuleTransition_1 = require_RuleTransition();
  var Token_1 = require_Token();
  var WildcardTransition_1 = require_WildcardTransition();
  var LL1Analyzer = class LL1Analyzer2 {
    constructor(atn) {
      this.atn = atn;
    }
    getDecisionLookahead(s) {
      if (s == null) {
        return void 0;
      }
      let look = new Array(s.numberOfTransitions);
      for (let alt = 0; alt < s.numberOfTransitions; alt++) {
        let current = new IntervalSet_1.IntervalSet();
        look[alt] = current;
        let lookBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
        let seeThruPreds = false;
        this._LOOK(s.transition(alt).target, void 0, PredictionContext_1.PredictionContext.EMPTY_LOCAL, current, lookBusy, new BitSet_1.BitSet(), seeThruPreds, false);
        if (current.size === 0 || current.contains(LL1Analyzer2.HIT_PRED)) {
          current = void 0;
          look[alt] = current;
        }
      }
      return look;
    }
    LOOK(s, ctx, stopState) {
      if (stopState === void 0) {
        if (s.atn == null) {
          throw new Error("Illegal state");
        }
        stopState = s.atn.ruleToStopState[s.ruleIndex];
      } else if (stopState === null) {
        stopState = void 0;
      }
      let r = new IntervalSet_1.IntervalSet();
      let seeThruPreds = true;
      let addEOF = true;
      this._LOOK(s, stopState, ctx, r, new Array2DHashSet_1.Array2DHashSet(), new BitSet_1.BitSet(), seeThruPreds, addEOF);
      return r;
    }
    _LOOK(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
      let c = ATNConfig_1.ATNConfig.create(s, 0, ctx);
      if (!lookBusy.add(c)) {
        return;
      }
      if (s === stopState) {
        if (PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {
          look.add(Token_1.Token.EPSILON);
          return;
        } else if (ctx.isEmpty) {
          if (addEOF) {
            look.add(Token_1.Token.EOF);
          }
          return;
        }
      }
      if (s instanceof RuleStopState_1.RuleStopState) {
        if (ctx.isEmpty && !PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {
          if (addEOF) {
            look.add(Token_1.Token.EOF);
          }
          return;
        }
        let removed = calledRuleStack.get(s.ruleIndex);
        try {
          calledRuleStack.clear(s.ruleIndex);
          for (let i = 0; i < ctx.size; i++) {
            if (ctx.getReturnState(i) === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
              continue;
            }
            let returnState = this.atn.states[ctx.getReturnState(i)];
            this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
          }
        } finally {
          if (removed) {
            calledRuleStack.set(s.ruleIndex);
          }
        }
      }
      let n = s.numberOfTransitions;
      for (let i = 0; i < n; i++) {
        let t = s.transition(i);
        if (t instanceof RuleTransition_1.RuleTransition) {
          if (calledRuleStack.get(t.ruleIndex)) {
            continue;
          }
          let newContext = ctx.getChild(t.followState.stateNumber);
          try {
            calledRuleStack.set(t.ruleIndex);
            this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
          } finally {
            calledRuleStack.clear(t.ruleIndex);
          }
        } else if (t instanceof AbstractPredicateTransition_1.AbstractPredicateTransition) {
          if (seeThruPreds) {
            this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
          } else {
            look.add(LL1Analyzer2.HIT_PRED);
          }
        } else if (t.isEpsilon) {
          this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
        } else if (t instanceof WildcardTransition_1.WildcardTransition) {
          look.addAll(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));
        } else {
          let set = t.label;
          if (set != null) {
            if (t instanceof NotSetTransition_1.NotSetTransition) {
              set = set.complement(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));
            }
            look.addAll(set);
          }
        }
      }
    }
  };
  LL1Analyzer.HIT_PRED = Token_1.Token.INVALID_TYPE;
  __decorate([
    Decorators_1.NotNull
  ], LL1Analyzer.prototype, "atn", void 0);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull)
  ], LL1Analyzer.prototype, "LOOK", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull),
    __param(3, Decorators_1.NotNull),
    __param(4, Decorators_1.NotNull),
    __param(5, Decorators_1.NotNull)
  ], LL1Analyzer.prototype, "_LOOK", null);
  LL1Analyzer = __decorate([
    __param(0, Decorators_1.NotNull)
  ], LL1Analyzer);
  exports.LL1Analyzer = LL1Analyzer;
});

// node_modules/antlr4ts/atn/ATN.js
var require_ATN = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ATN = void 0;
  var Array2DHashMap_1 = require_Array2DHashMap();
  var DFA_1 = require_DFA();
  var IntervalSet_1 = require_IntervalSet();
  var InvalidState_1 = require_InvalidState();
  var LL1Analyzer_1 = require_LL1Analyzer();
  var Decorators_1 = require_Decorators();
  var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
  var PredictionContext_1 = require_PredictionContext();
  var Token_1 = require_Token();
  var assert = __nccwpck_require__(9491);
  var ATN2 = class ATN {
    constructor(grammarType, maxTokenType) {
      this.states = [];
      this.decisionToState = [];
      this.modeNameToStartState = new Map();
      this.modeToStartState = [];
      this.contextCache = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
      this.decisionToDFA = [];
      this.modeToDFA = [];
      this.LL1Table = new Map();
      this.grammarType = grammarType;
      this.maxTokenType = maxTokenType;
    }
    clearDFA() {
      this.decisionToDFA = new Array(this.decisionToState.length);
      for (let i = 0; i < this.decisionToDFA.length; i++) {
        this.decisionToDFA[i] = new DFA_1.DFA(this.decisionToState[i], i);
      }
      this.modeToDFA = new Array(this.modeToStartState.length);
      for (let i = 0; i < this.modeToDFA.length; i++) {
        this.modeToDFA[i] = new DFA_1.DFA(this.modeToStartState[i]);
      }
      this.contextCache.clear();
      this.LL1Table.clear();
    }
    get contextCacheSize() {
      return this.contextCache.size;
    }
    getCachedContext(context) {
      return PredictionContext_1.PredictionContext.getCachedContext(context, this.contextCache, new PredictionContext_1.PredictionContext.IdentityHashMap());
    }
    getDecisionToDFA() {
      assert(this.decisionToDFA != null && this.decisionToDFA.length === this.decisionToState.length);
      return this.decisionToDFA;
    }
    nextTokens(s, ctx) {
      if (ctx) {
        let anal = new LL1Analyzer_1.LL1Analyzer(this);
        let next = anal.LOOK(s, ctx);
        return next;
      } else {
        if (s.nextTokenWithinRule) {
          return s.nextTokenWithinRule;
        }
        s.nextTokenWithinRule = this.nextTokens(s, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
        s.nextTokenWithinRule.setReadonly(true);
        return s.nextTokenWithinRule;
      }
    }
    addState(state) {
      state.atn = this;
      state.stateNumber = this.states.length;
      this.states.push(state);
    }
    removeState(state) {
      let invalidState = new InvalidState_1.InvalidState();
      invalidState.atn = this;
      invalidState.stateNumber = state.stateNumber;
      this.states[state.stateNumber] = invalidState;
    }
    defineMode(name, s) {
      this.modeNameToStartState.set(name, s);
      this.modeToStartState.push(s);
      this.modeToDFA.push(new DFA_1.DFA(s));
      this.defineDecisionState(s);
    }
    defineDecisionState(s) {
      this.decisionToState.push(s);
      s.decision = this.decisionToState.length - 1;
      this.decisionToDFA.push(new DFA_1.DFA(s, s.decision));
      return s.decision;
    }
    getDecisionState(decision) {
      if (this.decisionToState.length > 0) {
        return this.decisionToState[decision];
      }
      return void 0;
    }
    get numberOfDecisions() {
      return this.decisionToState.length;
    }
    getExpectedTokens(stateNumber, context) {
      if (stateNumber < 0 || stateNumber >= this.states.length) {
        throw new RangeError("Invalid state number.");
      }
      let ctx = context;
      let s = this.states[stateNumber];
      let following = this.nextTokens(s);
      if (!following.contains(Token_1.Token.EPSILON)) {
        return following;
      }
      let expected = new IntervalSet_1.IntervalSet();
      expected.addAll(following);
      expected.remove(Token_1.Token.EPSILON);
      while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {
        let invokingState = this.states[ctx.invokingState];
        let rt = invokingState.transition(0);
        following = this.nextTokens(rt.followState);
        expected.addAll(following);
        expected.remove(Token_1.Token.EPSILON);
        ctx = ctx._parent;
      }
      if (following.contains(Token_1.Token.EPSILON)) {
        expected.add(Token_1.Token.EOF);
      }
      return expected;
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], ATN2.prototype, "states", void 0);
  __decorate([
    Decorators_1.NotNull
  ], ATN2.prototype, "decisionToState", void 0);
  __decorate([
    Decorators_1.NotNull
  ], ATN2.prototype, "modeNameToStartState", void 0);
  __decorate([
    Decorators_1.NotNull
  ], ATN2.prototype, "modeToStartState", void 0);
  __decorate([
    Decorators_1.NotNull
  ], ATN2.prototype, "decisionToDFA", void 0);
  __decorate([
    Decorators_1.NotNull
  ], ATN2.prototype, "modeToDFA", void 0);
  __decorate([
    Decorators_1.NotNull
  ], ATN2.prototype, "nextTokens", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], ATN2.prototype, "removeState", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull)
  ], ATN2.prototype, "defineMode", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], ATN2.prototype, "defineDecisionState", null);
  __decorate([
    Decorators_1.NotNull
  ], ATN2.prototype, "getExpectedTokens", null);
  ATN2 = __decorate([
    __param(0, Decorators_1.NotNull)
  ], ATN2);
  exports.ATN = ATN2;
  (function(ATN3) {
    ATN3.INVALID_ALT_NUMBER = 0;
  })(ATN2 = exports.ATN || (exports.ATN = {}));
  exports.ATN = ATN2;
});

// node_modules/antlr4ts/atn/LexerIndexedCustomAction.js
var require_LexerIndexedCustomAction = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.LexerIndexedCustomAction = void 0;
  var MurmurHash_1 = require_MurmurHash();
  var Decorators_1 = require_Decorators();
  var LexerIndexedCustomAction = class LexerIndexedCustomAction2 {
    constructor(offset, action) {
      this._offset = offset;
      this._action = action;
    }
    get offset() {
      return this._offset;
    }
    get action() {
      return this._action;
    }
    get actionType() {
      return this._action.actionType;
    }
    get isPositionDependent() {
      return true;
    }
    execute(lexer) {
      this._action.execute(lexer);
    }
    hashCode() {
      let hash = MurmurHash_1.MurmurHash.initialize();
      hash = MurmurHash_1.MurmurHash.update(hash, this._offset);
      hash = MurmurHash_1.MurmurHash.update(hash, this._action);
      return MurmurHash_1.MurmurHash.finish(hash, 2);
    }
    equals(obj) {
      if (obj === this) {
        return true;
      } else if (!(obj instanceof LexerIndexedCustomAction2)) {
        return false;
      }
      return this._offset === obj._offset && this._action.equals(obj._action);
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], LexerIndexedCustomAction.prototype, "action", null);
  __decorate([
    Decorators_1.Override
  ], LexerIndexedCustomAction.prototype, "actionType", null);
  __decorate([
    Decorators_1.Override
  ], LexerIndexedCustomAction.prototype, "isPositionDependent", null);
  __decorate([
    Decorators_1.Override
  ], LexerIndexedCustomAction.prototype, "execute", null);
  __decorate([
    Decorators_1.Override
  ], LexerIndexedCustomAction.prototype, "hashCode", null);
  __decorate([
    Decorators_1.Override
  ], LexerIndexedCustomAction.prototype, "equals", null);
  LexerIndexedCustomAction = __decorate([
    __param(1, Decorators_1.NotNull)
  ], LexerIndexedCustomAction);
  exports.LexerIndexedCustomAction = LexerIndexedCustomAction;
});

// node_modules/antlr4ts/atn/LexerActionExecutor.js
var require_LexerActionExecutor = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.LexerActionExecutor = void 0;
  var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
  var LexerIndexedCustomAction_1 = require_LexerIndexedCustomAction();
  var MurmurHash_1 = require_MurmurHash();
  var Decorators_1 = require_Decorators();
  var LexerActionExecutor = class LexerActionExecutor2 {
    constructor(lexerActions) {
      this._lexerActions = lexerActions;
      let hash = MurmurHash_1.MurmurHash.initialize();
      for (let lexerAction of lexerActions) {
        hash = MurmurHash_1.MurmurHash.update(hash, lexerAction);
      }
      this.cachedHashCode = MurmurHash_1.MurmurHash.finish(hash, lexerActions.length);
    }
    static append(lexerActionExecutor, lexerAction) {
      if (!lexerActionExecutor) {
        return new LexerActionExecutor2([lexerAction]);
      }
      let lexerActions = lexerActionExecutor._lexerActions.slice(0);
      lexerActions.push(lexerAction);
      return new LexerActionExecutor2(lexerActions);
    }
    fixOffsetBeforeMatch(offset) {
      let updatedLexerActions;
      for (let i = 0; i < this._lexerActions.length; i++) {
        if (this._lexerActions[i].isPositionDependent && !(this._lexerActions[i] instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction)) {
          if (!updatedLexerActions) {
            updatedLexerActions = this._lexerActions.slice(0);
          }
          updatedLexerActions[i] = new LexerIndexedCustomAction_1.LexerIndexedCustomAction(offset, this._lexerActions[i]);
        }
      }
      if (!updatedLexerActions) {
        return this;
      }
      return new LexerActionExecutor2(updatedLexerActions);
    }
    get lexerActions() {
      return this._lexerActions;
    }
    execute(lexer, input, startIndex) {
      let requiresSeek = false;
      let stopIndex = input.index;
      try {
        for (let lexerAction of this._lexerActions) {
          if (lexerAction instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction) {
            let offset = lexerAction.offset;
            input.seek(startIndex + offset);
            lexerAction = lexerAction.action;
            requiresSeek = startIndex + offset !== stopIndex;
          } else if (lexerAction.isPositionDependent) {
            input.seek(stopIndex);
            requiresSeek = false;
          }
          lexerAction.execute(lexer);
        }
      } finally {
        if (requiresSeek) {
          input.seek(stopIndex);
        }
      }
    }
    hashCode() {
      return this.cachedHashCode;
    }
    equals(obj) {
      if (obj === this) {
        return true;
      } else if (!(obj instanceof LexerActionExecutor2)) {
        return false;
      }
      return this.cachedHashCode === obj.cachedHashCode && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._lexerActions, obj._lexerActions);
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], LexerActionExecutor.prototype, "_lexerActions", void 0);
  __decorate([
    Decorators_1.NotNull
  ], LexerActionExecutor.prototype, "lexerActions", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], LexerActionExecutor.prototype, "execute", null);
  __decorate([
    Decorators_1.Override
  ], LexerActionExecutor.prototype, "hashCode", null);
  __decorate([
    Decorators_1.Override
  ], LexerActionExecutor.prototype, "equals", null);
  __decorate([
    Decorators_1.NotNull,
    __param(1, Decorators_1.NotNull)
  ], LexerActionExecutor, "append", null);
  LexerActionExecutor = __decorate([
    __param(0, Decorators_1.NotNull)
  ], LexerActionExecutor);
  exports.LexerActionExecutor = LexerActionExecutor;
});

// node_modules/antlr4ts/LexerNoViableAltException.js
var require_LexerNoViableAltException = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.LexerNoViableAltException = void 0;
  var RecognitionException_1 = require_RecognitionException();
  var Decorators_1 = require_Decorators();
  var Interval_1 = require_Interval();
  var Utils3 = require_Utils();
  var LexerNoViableAltException = class LexerNoViableAltException extends RecognitionException_1.RecognitionException {
    constructor(lexer, input, startIndex, deadEndConfigs) {
      super(lexer, input);
      this._startIndex = startIndex;
      this._deadEndConfigs = deadEndConfigs;
    }
    get startIndex() {
      return this._startIndex;
    }
    get deadEndConfigs() {
      return this._deadEndConfigs;
    }
    get inputStream() {
      return super.inputStream;
    }
    toString() {
      let symbol = "";
      if (this._startIndex >= 0 && this._startIndex < this.inputStream.size) {
        symbol = this.inputStream.getText(Interval_1.Interval.of(this._startIndex, this._startIndex));
        symbol = Utils3.escapeWhitespace(symbol, false);
      }
      return `LexerNoViableAltException('${symbol}')`;
    }
  };
  __decorate([
    Decorators_1.Override
  ], LexerNoViableAltException.prototype, "inputStream", null);
  __decorate([
    Decorators_1.Override
  ], LexerNoViableAltException.prototype, "toString", null);
  LexerNoViableAltException = __decorate([
    __param(1, Decorators_1.NotNull)
  ], LexerNoViableAltException);
  exports.LexerNoViableAltException = LexerNoViableAltException;
});

// node_modules/antlr4ts/atn/OrderedATNConfigSet.js
var require_OrderedATNConfigSet = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.OrderedATNConfigSet = void 0;
  var ATNConfigSet_1 = require_ATNConfigSet();
  var Decorators_1 = require_Decorators();
  var OrderedATNConfigSet = class extends ATNConfigSet_1.ATNConfigSet {
    constructor(set, readonly) {
      if (set != null && readonly != null) {
        super(set, readonly);
      } else {
        super();
      }
    }
    clone(readonly) {
      let copy = new OrderedATNConfigSet(this, readonly);
      if (!readonly && this.isReadOnly) {
        copy.addAll(this);
      }
      return copy;
    }
    getKey(e) {
      return {state: 0, alt: e.hashCode()};
    }
    canMerge(left, leftKey, right) {
      return left.equals(right);
    }
  };
  __decorate([
    Decorators_1.Override
  ], OrderedATNConfigSet.prototype, "clone", null);
  __decorate([
    Decorators_1.Override
  ], OrderedATNConfigSet.prototype, "getKey", null);
  __decorate([
    Decorators_1.Override
  ], OrderedATNConfigSet.prototype, "canMerge", null);
  exports.OrderedATNConfigSet = OrderedATNConfigSet;
});

// node_modules/antlr4ts/atn/LexerATNSimulator.js
var require_LexerATNSimulator = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.LexerATNSimulator = void 0;
  var AcceptStateInfo_1 = require_AcceptStateInfo();
  var ATN_1 = require_ATN();
  var ATNConfig_1 = require_ATNConfig();
  var ATNConfigSet_1 = require_ATNConfigSet();
  var ATNSimulator_1 = require_ATNSimulator();
  var DFAState_1 = require_DFAState();
  var Interval_1 = require_Interval();
  var IntStream_1 = require_IntStream();
  var Lexer_1 = require_Lexer();
  var LexerActionExecutor_1 = require_LexerActionExecutor();
  var LexerNoViableAltException_1 = require_LexerNoViableAltException();
  var Decorators_1 = require_Decorators();
  var OrderedATNConfigSet_1 = require_OrderedATNConfigSet();
  var PredictionContext_1 = require_PredictionContext();
  var RuleStopState_1 = require_RuleStopState();
  var Token_1 = require_Token();
  var assert = __nccwpck_require__(9491);
  var LexerATNSimulator2 = class LexerATNSimulator3 extends ATNSimulator_1.ATNSimulator {
    constructor(atn, recog) {
      super(atn);
      this.optimize_tail_calls = true;
      this.startIndex = -1;
      this._line = 1;
      this._charPositionInLine = 0;
      this.mode = Lexer_1.Lexer.DEFAULT_MODE;
      this.prevAccept = new LexerATNSimulator3.SimState();
      this.recog = recog;
    }
    copyState(simulator) {
      this._charPositionInLine = simulator.charPositionInLine;
      this._line = simulator._line;
      this.mode = simulator.mode;
      this.startIndex = simulator.startIndex;
    }
    match(input, mode) {
      this.mode = mode;
      let mark = input.mark();
      try {
        this.startIndex = input.index;
        this.prevAccept.reset();
        let s0 = this.atn.modeToDFA[mode].s0;
        if (s0 == null) {
          return this.matchATN(input);
        } else {
          return this.execATN(input, s0);
        }
      } finally {
        input.release(mark);
      }
    }
    reset() {
      this.prevAccept.reset();
      this.startIndex = -1;
      this._line = 1;
      this._charPositionInLine = 0;
      this.mode = Lexer_1.Lexer.DEFAULT_MODE;
    }
    matchATN(input) {
      let startState = this.atn.modeToStartState[this.mode];
      if (LexerATNSimulator3.debug) {
        console.log(`matchATN mode ${this.mode} start: ${startState}`);
      }
      let old_mode = this.mode;
      let s0_closure = this.computeStartState(input, startState);
      let suppressEdge = s0_closure.hasSemanticContext;
      if (suppressEdge) {
        s0_closure.hasSemanticContext = false;
      }
      let next = this.addDFAState(s0_closure);
      if (!suppressEdge) {
        let dfa = this.atn.modeToDFA[this.mode];
        if (!dfa.s0) {
          dfa.s0 = next;
        } else {
          next = dfa.s0;
        }
      }
      let predict = this.execATN(input, next);
      if (LexerATNSimulator3.debug) {
        console.log(`DFA after matchATN: ${this.atn.modeToDFA[old_mode].toLexerString()}`);
      }
      return predict;
    }
    execATN(input, ds0) {
      if (LexerATNSimulator3.debug) {
        console.log(`start state closure=${ds0.configs}`);
      }
      if (ds0.isAcceptState) {
        this.captureSimState(this.prevAccept, input, ds0);
      }
      let t = input.LA(1);
      let s = ds0;
      while (true) {
        if (LexerATNSimulator3.debug) {
          console.log(`execATN loop starting closure: ${s.configs}`);
        }
        let target = this.getExistingTargetState(s, t);
        if (target == null) {
          target = this.computeTargetState(input, s, t);
        }
        if (target === ATNSimulator_1.ATNSimulator.ERROR) {
          break;
        }
        if (t !== IntStream_1.IntStream.EOF) {
          this.consume(input);
        }
        if (target.isAcceptState) {
          this.captureSimState(this.prevAccept, input, target);
          if (t === IntStream_1.IntStream.EOF) {
            break;
          }
        }
        t = input.LA(1);
        s = target;
      }
      return this.failOrAccept(this.prevAccept, input, s.configs, t);
    }
    getExistingTargetState(s, t) {
      let target = s.getTarget(t);
      if (LexerATNSimulator3.debug && target != null) {
        console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
      }
      return target;
    }
    computeTargetState(input, s, t) {
      let reach = new OrderedATNConfigSet_1.OrderedATNConfigSet();
      this.getReachableConfigSet(input, s.configs, reach, t);
      if (reach.isEmpty) {
        if (!reach.hasSemanticContext) {
          this.addDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);
        }
        return ATNSimulator_1.ATNSimulator.ERROR;
      }
      return this.addDFAEdge(s, t, reach);
    }
    failOrAccept(prevAccept, input, reach, t) {
      if (prevAccept.dfaState != null) {
        let lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;
        this.accept(input, lexerActionExecutor, this.startIndex, prevAccept.index, prevAccept.line, prevAccept.charPos);
        return prevAccept.dfaState.prediction;
      } else {
        if (t === IntStream_1.IntStream.EOF && input.index === this.startIndex) {
          return Token_1.Token.EOF;
        }
        throw new LexerNoViableAltException_1.LexerNoViableAltException(this.recog, input, this.startIndex, reach);
      }
    }
    getReachableConfigSet(input, closure, reach, t) {
      let skipAlt = ATN_1.ATN.INVALID_ALT_NUMBER;
      for (let c of closure) {
        let currentAltReachedAcceptState = c.alt === skipAlt;
        if (currentAltReachedAcceptState && c.hasPassedThroughNonGreedyDecision) {
          continue;
        }
        if (LexerATNSimulator3.debug) {
          console.log(`testing ${this.getTokenName(t)} at ${c.toString(this.recog, true)}`);
        }
        let n = c.state.numberOfOptimizedTransitions;
        for (let ti = 0; ti < n; ti++) {
          let trans = c.state.getOptimizedTransition(ti);
          let target = this.getReachableTarget(trans, t);
          if (target != null) {
            let lexerActionExecutor = c.lexerActionExecutor;
            let config;
            if (lexerActionExecutor != null) {
              lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
              config = c.transform(target, true, lexerActionExecutor);
            } else {
              assert(c.lexerActionExecutor == null);
              config = c.transform(target, true);
            }
            let treatEofAsEpsilon = t === IntStream_1.IntStream.EOF;
            if (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {
              skipAlt = c.alt;
              break;
            }
          }
        }
      }
    }
    accept(input, lexerActionExecutor, startIndex, index, line, charPos) {
      if (LexerATNSimulator3.debug) {
        console.log(`ACTION ${lexerActionExecutor}`);
      }
      input.seek(index);
      this._line = line;
      this._charPositionInLine = charPos;
      if (lexerActionExecutor != null && this.recog != null) {
        lexerActionExecutor.execute(this.recog, input, startIndex);
      }
    }
    getReachableTarget(trans, t) {
      if (trans.matches(t, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {
        return trans.target;
      }
      return void 0;
    }
    computeStartState(input, p) {
      let initialContext = PredictionContext_1.PredictionContext.EMPTY_FULL;
      let configs = new OrderedATNConfigSet_1.OrderedATNConfigSet();
      for (let i = 0; i < p.numberOfTransitions; i++) {
        let target = p.transition(i).target;
        let c = ATNConfig_1.ATNConfig.create(target, i + 1, initialContext);
        this.closure(input, c, configs, false, false, false);
      }
      return configs;
    }
    closure(input, config, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
      if (LexerATNSimulator3.debug) {
        console.log("closure(" + config.toString(this.recog, true) + ")");
      }
      if (config.state instanceof RuleStopState_1.RuleStopState) {
        if (LexerATNSimulator3.debug) {
          if (this.recog != null) {
            console.log(`closure at ${this.recog.ruleNames[config.state.ruleIndex]} rule stop ${config}`);
          } else {
            console.log(`closure at rule stop ${config}`);
          }
        }
        let context = config.context;
        if (context.isEmpty) {
          configs.add(config);
          return true;
        } else if (context.hasEmpty) {
          configs.add(config.transform(config.state, true, PredictionContext_1.PredictionContext.EMPTY_FULL));
          currentAltReachedAcceptState = true;
        }
        for (let i = 0; i < context.size; i++) {
          let returnStateNumber = context.getReturnState(i);
          if (returnStateNumber === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
            continue;
          }
          let newContext = context.getParent(i);
          let returnState = this.atn.states[returnStateNumber];
          let c = config.transform(returnState, false, newContext);
          currentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
        }
        return currentAltReachedAcceptState;
      }
      if (!config.state.onlyHasEpsilonTransitions) {
        if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision) {
          configs.add(config);
        }
      }
      let p = config.state;
      for (let i = 0; i < p.numberOfOptimizedTransitions; i++) {
        let t = p.getOptimizedTransition(i);
        let c = this.getEpsilonTarget(input, config, t, configs, speculative, treatEofAsEpsilon);
        if (c != null) {
          currentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
        }
      }
      return currentAltReachedAcceptState;
    }
    getEpsilonTarget(input, config, t, configs, speculative, treatEofAsEpsilon) {
      let c;
      switch (t.serializationType) {
        case 3:
          let ruleTransition = t;
          if (this.optimize_tail_calls && ruleTransition.optimizedTailCall && !config.context.hasEmpty) {
            c = config.transform(t.target, true);
          } else {
            let newContext = config.context.getChild(ruleTransition.followState.stateNumber);
            c = config.transform(t.target, true, newContext);
          }
          break;
        case 10:
          throw new Error("Precedence predicates are not supported in lexers.");
        case 4:
          let pt = t;
          if (LexerATNSimulator3.debug) {
            console.log("EVAL rule " + pt.ruleIndex + ":" + pt.predIndex);
          }
          configs.hasSemanticContext = true;
          if (this.evaluatePredicate(input, pt.ruleIndex, pt.predIndex, speculative)) {
            c = config.transform(t.target, true);
          } else {
            c = void 0;
          }
          break;
        case 6:
          if (config.context.hasEmpty) {
            let lexerActionExecutor = LexerActionExecutor_1.LexerActionExecutor.append(config.lexerActionExecutor, this.atn.lexerActions[t.actionIndex]);
            c = config.transform(t.target, true, lexerActionExecutor);
            break;
          } else {
            c = config.transform(t.target, true);
            break;
          }
        case 1:
          c = config.transform(t.target, true);
          break;
        case 5:
        case 2:
        case 7:
          if (treatEofAsEpsilon) {
            if (t.matches(IntStream_1.IntStream.EOF, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {
              c = config.transform(t.target, false);
              break;
            }
          }
          c = void 0;
          break;
        default:
          c = void 0;
          break;
      }
      return c;
    }
    evaluatePredicate(input, ruleIndex, predIndex, speculative) {
      if (this.recog == null) {
        return true;
      }
      if (!speculative) {
        return this.recog.sempred(void 0, ruleIndex, predIndex);
      }
      let savedCharPositionInLine = this._charPositionInLine;
      let savedLine = this._line;
      let index = input.index;
      let marker = input.mark();
      try {
        this.consume(input);
        return this.recog.sempred(void 0, ruleIndex, predIndex);
      } finally {
        this._charPositionInLine = savedCharPositionInLine;
        this._line = savedLine;
        input.seek(index);
        input.release(marker);
      }
    }
    captureSimState(settings, input, dfaState) {
      settings.index = input.index;
      settings.line = this._line;
      settings.charPos = this._charPositionInLine;
      settings.dfaState = dfaState;
    }
    addDFAEdge(p, t, q) {
      if (q instanceof ATNConfigSet_1.ATNConfigSet) {
        let suppressEdge = q.hasSemanticContext;
        if (suppressEdge) {
          q.hasSemanticContext = false;
        }
        let to = this.addDFAState(q);
        if (suppressEdge) {
          return to;
        }
        this.addDFAEdge(p, t, to);
        return to;
      } else {
        if (LexerATNSimulator3.debug) {
          console.log("EDGE " + p + " -> " + q + " upon " + String.fromCharCode(t));
        }
        if (p != null) {
          p.setTarget(t, q);
        }
      }
    }
    addDFAState(configs) {
      assert(!configs.hasSemanticContext);
      let proposed = new DFAState_1.DFAState(configs);
      let existing = this.atn.modeToDFA[this.mode].states.get(proposed);
      if (existing != null) {
        return existing;
      }
      configs.optimizeConfigs(this);
      let newState = new DFAState_1.DFAState(configs.clone(true));
      let firstConfigWithRuleStopState;
      for (let c of configs) {
        if (c.state instanceof RuleStopState_1.RuleStopState) {
          firstConfigWithRuleStopState = c;
          break;
        }
      }
      if (firstConfigWithRuleStopState != null) {
        let prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
        let lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
        newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(prediction, lexerActionExecutor);
      }
      return this.atn.modeToDFA[this.mode].addState(newState);
    }
    getDFA(mode) {
      return this.atn.modeToDFA[mode];
    }
    getText(input) {
      return input.getText(Interval_1.Interval.of(this.startIndex, input.index - 1));
    }
    get line() {
      return this._line;
    }
    set line(line) {
      this._line = line;
    }
    get charPositionInLine() {
      return this._charPositionInLine;
    }
    set charPositionInLine(charPositionInLine) {
      this._charPositionInLine = charPositionInLine;
    }
    consume(input) {
      let curChar = input.LA(1);
      if (curChar === "\n".charCodeAt(0)) {
        this._line++;
        this._charPositionInLine = 0;
      } else {
        this._charPositionInLine++;
      }
      input.consume();
    }
    getTokenName(t) {
      if (t === -1) {
        return "EOF";
      }
      return "'" + String.fromCharCode(t) + "'";
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], LexerATNSimulator2.prototype, "prevAccept", void 0);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], LexerATNSimulator2.prototype, "copyState", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], LexerATNSimulator2.prototype, "match", null);
  __decorate([
    Decorators_1.Override
  ], LexerATNSimulator2.prototype, "reset", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], LexerATNSimulator2.prototype, "matchATN", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull)
  ], LexerATNSimulator2.prototype, "execATN", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], LexerATNSimulator2.prototype, "getExistingTargetState", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull)
  ], LexerATNSimulator2.prototype, "computeTargetState", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull)
  ], LexerATNSimulator2.prototype, "getReachableConfigSet", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], LexerATNSimulator2.prototype, "accept", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull)
  ], LexerATNSimulator2.prototype, "computeStartState", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull)
  ], LexerATNSimulator2.prototype, "closure", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull),
    __param(3, Decorators_1.NotNull)
  ], LexerATNSimulator2.prototype, "getEpsilonTarget", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], LexerATNSimulator2.prototype, "evaluatePredicate", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull)
  ], LexerATNSimulator2.prototype, "captureSimState", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull)
  ], LexerATNSimulator2.prototype, "addDFAState", null);
  __decorate([
    Decorators_1.NotNull
  ], LexerATNSimulator2.prototype, "getDFA", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull)
  ], LexerATNSimulator2.prototype, "getText", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], LexerATNSimulator2.prototype, "consume", null);
  __decorate([
    Decorators_1.NotNull
  ], LexerATNSimulator2.prototype, "getTokenName", null);
  LexerATNSimulator2 = __decorate([
    __param(0, Decorators_1.NotNull)
  ], LexerATNSimulator2);
  exports.LexerATNSimulator = LexerATNSimulator2;
  (function(LexerATNSimulator3) {
    LexerATNSimulator3.debug = false;
    LexerATNSimulator3.dfa_debug = false;
    class SimState {
      constructor() {
        this.index = -1;
        this.line = 0;
        this.charPos = -1;
      }
      reset() {
        this.index = -1;
        this.line = 0;
        this.charPos = -1;
        this.dfaState = void 0;
      }
    }
    LexerATNSimulator3.SimState = SimState;
  })(LexerATNSimulator2 = exports.LexerATNSimulator || (exports.LexerATNSimulator = {}));
  exports.LexerATNSimulator = LexerATNSimulator2;
});

// node_modules/antlr4ts/Lexer.js
var require_Lexer = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.Lexer = void 0;
  var CommonTokenFactory_1 = require_CommonTokenFactory();
  var IntegerStack_1 = require_IntegerStack();
  var Interval_1 = require_Interval();
  var IntStream_1 = require_IntStream();
  var LexerATNSimulator_1 = require_LexerATNSimulator();
  var LexerNoViableAltException_1 = require_LexerNoViableAltException();
  var Decorators_1 = require_Decorators();
  var Recognizer_1 = require_Recognizer();
  var Token_1 = require_Token();
  var Lexer2 = class extends Recognizer_1.Recognizer {
    constructor(input) {
      super();
      this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;
      this._tokenStartCharIndex = -1;
      this._tokenStartLine = 0;
      this._tokenStartCharPositionInLine = 0;
      this._hitEOF = false;
      this._channel = 0;
      this._type = 0;
      this._modeStack = new IntegerStack_1.IntegerStack();
      this._mode = Lexer2.DEFAULT_MODE;
      this._input = input;
      this._tokenFactorySourcePair = {source: this, stream: input};
    }
    static get DEFAULT_TOKEN_CHANNEL() {
      return Token_1.Token.DEFAULT_CHANNEL;
    }
    static get HIDDEN() {
      return Token_1.Token.HIDDEN_CHANNEL;
    }
    reset(resetInput) {
      if (resetInput === void 0 || resetInput) {
        this._input.seek(0);
      }
      this._token = void 0;
      this._type = Token_1.Token.INVALID_TYPE;
      this._channel = Token_1.Token.DEFAULT_CHANNEL;
      this._tokenStartCharIndex = -1;
      this._tokenStartCharPositionInLine = -1;
      this._tokenStartLine = -1;
      this._text = void 0;
      this._hitEOF = false;
      this._mode = Lexer2.DEFAULT_MODE;
      this._modeStack.clear();
      this.interpreter.reset();
    }
    nextToken() {
      if (this._input == null) {
        throw new Error("nextToken requires a non-null input stream.");
      }
      let tokenStartMarker = this._input.mark();
      try {
        outer:
          while (true) {
            if (this._hitEOF) {
              return this.emitEOF();
            }
            this._token = void 0;
            this._channel = Token_1.Token.DEFAULT_CHANNEL;
            this._tokenStartCharIndex = this._input.index;
            this._tokenStartCharPositionInLine = this.interpreter.charPositionInLine;
            this._tokenStartLine = this.interpreter.line;
            this._text = void 0;
            do {
              this._type = Token_1.Token.INVALID_TYPE;
              let ttype;
              try {
                ttype = this.interpreter.match(this._input, this._mode);
              } catch (e) {
                if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
                  this.notifyListeners(e);
                  this.recover(e);
                  ttype = Lexer2.SKIP;
                } else {
                  throw e;
                }
              }
              if (this._input.LA(1) === IntStream_1.IntStream.EOF) {
                this._hitEOF = true;
              }
              if (this._type === Token_1.Token.INVALID_TYPE) {
                this._type = ttype;
              }
              if (this._type === Lexer2.SKIP) {
                continue outer;
              }
            } while (this._type === Lexer2.MORE);
            if (this._token == null) {
              return this.emit();
            }
            return this._token;
          }
      } finally {
        this._input.release(tokenStartMarker);
      }
    }
    skip() {
      this._type = Lexer2.SKIP;
    }
    more() {
      this._type = Lexer2.MORE;
    }
    mode(m) {
      this._mode = m;
    }
    pushMode(m) {
      if (LexerATNSimulator_1.LexerATNSimulator.debug) {
        console.log("pushMode " + m);
      }
      this._modeStack.push(this._mode);
      this.mode(m);
    }
    popMode() {
      if (this._modeStack.isEmpty) {
        throw new Error("EmptyStackException");
      }
      if (LexerATNSimulator_1.LexerATNSimulator.debug) {
        console.log("popMode back to " + this._modeStack.peek());
      }
      this.mode(this._modeStack.pop());
      return this._mode;
    }
    get tokenFactory() {
      return this._factory;
    }
    set tokenFactory(factory) {
      this._factory = factory;
    }
    get inputStream() {
      return this._input;
    }
    set inputStream(input) {
      this.reset(false);
      this._input = input;
      this._tokenFactorySourcePair = {source: this, stream: this._input};
    }
    get sourceName() {
      return this._input.sourceName;
    }
    emit(token) {
      if (!token) {
        token = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.charIndex - 1, this._tokenStartLine, this._tokenStartCharPositionInLine);
      }
      this._token = token;
      return token;
    }
    emitEOF() {
      let cpos = this.charPositionInLine;
      let line = this.line;
      let eof = this._factory.create(this._tokenFactorySourcePair, Token_1.Token.EOF, void 0, Token_1.Token.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, line, cpos);
      this.emit(eof);
      return eof;
    }
    get line() {
      return this.interpreter.line;
    }
    set line(line) {
      this.interpreter.line = line;
    }
    get charPositionInLine() {
      return this.interpreter.charPositionInLine;
    }
    set charPositionInLine(charPositionInLine) {
      this.interpreter.charPositionInLine = charPositionInLine;
    }
    get charIndex() {
      return this._input.index;
    }
    get text() {
      if (this._text != null) {
        return this._text;
      }
      return this.interpreter.getText(this._input);
    }
    set text(text) {
      this._text = text;
    }
    get token() {
      return this._token;
    }
    set token(_token) {
      this._token = _token;
    }
    set type(ttype) {
      this._type = ttype;
    }
    get type() {
      return this._type;
    }
    set channel(channel) {
      this._channel = channel;
    }
    get channel() {
      return this._channel;
    }
    getAllTokens() {
      let tokens2 = [];
      let t = this.nextToken();
      while (t.type !== Token_1.Token.EOF) {
        tokens2.push(t);
        t = this.nextToken();
      }
      return tokens2;
    }
    notifyListeners(e) {
      let text = this._input.getText(Interval_1.Interval.of(this._tokenStartCharIndex, this._input.index));
      let msg = "token recognition error at: '" + this.getErrorDisplay(text) + "'";
      let listener = this.getErrorListenerDispatch();
      if (listener.syntaxError) {
        listener.syntaxError(this, void 0, this._tokenStartLine, this._tokenStartCharPositionInLine, msg, e);
      }
    }
    getErrorDisplay(s) {
      if (typeof s === "number") {
        switch (s) {
          case Token_1.Token.EOF:
            return "<EOF>";
          case 10:
            return "\\n";
          case 9:
            return "\\t";
          case 13:
            return "\\r";
        }
        return String.fromCharCode(s);
      }
      return s.replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\r/g, "\\r");
    }
    getCharErrorDisplay(c) {
      let s = this.getErrorDisplay(c);
      return "'" + s + "'";
    }
    recover(re) {
      if (re instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
        if (this._input.LA(1) !== IntStream_1.IntStream.EOF) {
          this.interpreter.consume(this._input);
        }
      } else {
        this._input.consume();
      }
    }
  };
  Lexer2.DEFAULT_MODE = 0;
  Lexer2.MORE = -2;
  Lexer2.SKIP = -3;
  Lexer2.MIN_CHAR_VALUE = 0;
  Lexer2.MAX_CHAR_VALUE = 1114111;
  __decorate([
    Decorators_1.Override
  ], Lexer2.prototype, "nextToken", null);
  __decorate([
    Decorators_1.Override
  ], Lexer2.prototype, "tokenFactory", null);
  __decorate([
    Decorators_1.Override
  ], Lexer2.prototype, "inputStream", null);
  __decorate([
    Decorators_1.Override
  ], Lexer2.prototype, "sourceName", null);
  __decorate([
    Decorators_1.Override
  ], Lexer2.prototype, "line", null);
  __decorate([
    Decorators_1.Override
  ], Lexer2.prototype, "charPositionInLine", null);
  exports.Lexer = Lexer2;
});

// node_modules/antlr4ts/misc/IntervalSet.js
var require_IntervalSet = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.IntervalSet = void 0;
  var ArrayEqualityComparator_1 = require_ArrayEqualityComparator();
  var IntegerList_1 = require_IntegerList();
  var Interval_1 = require_Interval();
  var Lexer_1 = require_Lexer();
  var MurmurHash_1 = require_MurmurHash();
  var Decorators_1 = require_Decorators();
  var Token_1 = require_Token();
  var IntervalSet = class {
    constructor(intervals) {
      this.readonly = false;
      if (intervals != null) {
        this._intervals = intervals.slice(0);
      } else {
        this._intervals = [];
      }
    }
    static get COMPLETE_CHAR_SET() {
      if (IntervalSet._COMPLETE_CHAR_SET === void 0) {
        IntervalSet._COMPLETE_CHAR_SET = IntervalSet.of(Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE);
        IntervalSet._COMPLETE_CHAR_SET.setReadonly(true);
      }
      return IntervalSet._COMPLETE_CHAR_SET;
    }
    static get EMPTY_SET() {
      if (IntervalSet._EMPTY_SET == null) {
        IntervalSet._EMPTY_SET = new IntervalSet();
        IntervalSet._EMPTY_SET.setReadonly(true);
      }
      return IntervalSet._EMPTY_SET;
    }
    static of(a, b = a) {
      let s = new IntervalSet();
      s.add(a, b);
      return s;
    }
    clear() {
      if (this.readonly) {
        throw new Error("can't alter readonly IntervalSet");
      }
      this._intervals.length = 0;
    }
    add(a, b = a) {
      this.addRange(Interval_1.Interval.of(a, b));
    }
    addRange(addition) {
      if (this.readonly) {
        throw new Error("can't alter readonly IntervalSet");
      }
      if (addition.b < addition.a) {
        return;
      }
      for (let i = 0; i < this._intervals.length; i++) {
        let r = this._intervals[i];
        if (addition.equals(r)) {
          return;
        }
        if (addition.adjacent(r) || !addition.disjoint(r)) {
          let bigger = addition.union(r);
          this._intervals[i] = bigger;
          while (i < this._intervals.length - 1) {
            i++;
            let next = this._intervals[i];
            if (!bigger.adjacent(next) && bigger.disjoint(next)) {
              break;
            }
            this._intervals.splice(i, 1);
            i--;
            this._intervals[i] = bigger.union(next);
          }
          return;
        }
        if (addition.startsBeforeDisjoint(r)) {
          this._intervals.splice(i, 0, addition);
          return;
        }
      }
      this._intervals.push(addition);
    }
    static or(sets) {
      let r = new IntervalSet();
      for (let s of sets) {
        r.addAll(s);
      }
      return r;
    }
    addAll(set) {
      if (set == null) {
        return this;
      }
      if (set instanceof IntervalSet) {
        let other = set;
        let n = other._intervals.length;
        for (let i = 0; i < n; i++) {
          let I = other._intervals[i];
          this.add(I.a, I.b);
        }
      } else {
        for (let value of set.toArray()) {
          this.add(value);
        }
      }
      return this;
    }
    complementRange(minElement, maxElement) {
      return this.complement(IntervalSet.of(minElement, maxElement));
    }
    complement(vocabulary) {
      if (vocabulary.isNil) {
        return IntervalSet.EMPTY_SET;
      }
      let vocabularyIS;
      if (vocabulary instanceof IntervalSet) {
        vocabularyIS = vocabulary;
      } else {
        vocabularyIS = new IntervalSet();
        vocabularyIS.addAll(vocabulary);
      }
      return vocabularyIS.subtract(this);
    }
    subtract(a) {
      if (a == null || a.isNil) {
        return new IntervalSet(this._intervals);
      }
      if (a instanceof IntervalSet) {
        return IntervalSet.subtract(this, a);
      }
      let other = new IntervalSet();
      other.addAll(a);
      return IntervalSet.subtract(this, other);
    }
    static subtract(left, right) {
      if (left.isNil) {
        return new IntervalSet();
      }
      let result = new IntervalSet(left._intervals);
      if (right.isNil) {
        return result;
      }
      let resultI = 0;
      let rightI = 0;
      while (resultI < result._intervals.length && rightI < right._intervals.length) {
        let resultInterval = result._intervals[resultI];
        let rightInterval = right._intervals[rightI];
        if (rightInterval.b < resultInterval.a) {
          rightI++;
          continue;
        }
        if (rightInterval.a > resultInterval.b) {
          resultI++;
          continue;
        }
        let beforeCurrent;
        let afterCurrent;
        if (rightInterval.a > resultInterval.a) {
          beforeCurrent = new Interval_1.Interval(resultInterval.a, rightInterval.a - 1);
        }
        if (rightInterval.b < resultInterval.b) {
          afterCurrent = new Interval_1.Interval(rightInterval.b + 1, resultInterval.b);
        }
        if (beforeCurrent) {
          if (afterCurrent) {
            result._intervals[resultI] = beforeCurrent;
            result._intervals.splice(resultI + 1, 0, afterCurrent);
            resultI++;
            rightI++;
            continue;
          } else {
            result._intervals[resultI] = beforeCurrent;
            resultI++;
            continue;
          }
        } else {
          if (afterCurrent) {
            result._intervals[resultI] = afterCurrent;
            rightI++;
            continue;
          } else {
            result._intervals.splice(resultI, 1);
            continue;
          }
        }
      }
      return result;
    }
    or(a) {
      let o = new IntervalSet();
      o.addAll(this);
      o.addAll(a);
      return o;
    }
    and(other) {
      if (other.isNil) {
        return new IntervalSet();
      }
      let myIntervals = this._intervals;
      let theirIntervals = other._intervals;
      let intersection;
      let mySize = myIntervals.length;
      let theirSize = theirIntervals.length;
      let i = 0;
      let j = 0;
      while (i < mySize && j < theirSize) {
        let mine = myIntervals[i];
        let theirs = theirIntervals[j];
        if (mine.startsBeforeDisjoint(theirs)) {
          i++;
        } else if (theirs.startsBeforeDisjoint(mine)) {
          j++;
        } else if (mine.properlyContains(theirs)) {
          if (!intersection) {
            intersection = new IntervalSet();
          }
          intersection.addRange(mine.intersection(theirs));
          j++;
        } else if (theirs.properlyContains(mine)) {
          if (!intersection) {
            intersection = new IntervalSet();
          }
          intersection.addRange(mine.intersection(theirs));
          i++;
        } else if (!mine.disjoint(theirs)) {
          if (!intersection) {
            intersection = new IntervalSet();
          }
          intersection.addRange(mine.intersection(theirs));
          if (mine.startsAfterNonDisjoint(theirs)) {
            j++;
          } else if (theirs.startsAfterNonDisjoint(mine)) {
            i++;
          }
        }
      }
      if (!intersection) {
        return new IntervalSet();
      }
      return intersection;
    }
    contains(el) {
      let n = this._intervals.length;
      let l = 0;
      let r = n - 1;
      while (l <= r) {
        let m = l + r >> 1;
        let I = this._intervals[m];
        let a = I.a;
        let b = I.b;
        if (b < el) {
          l = m + 1;
        } else if (a > el) {
          r = m - 1;
        } else {
          return true;
        }
      }
      return false;
    }
    get isNil() {
      return this._intervals == null || this._intervals.length === 0;
    }
    get maxElement() {
      if (this.isNil) {
        throw new RangeError("set is empty");
      }
      let last = this._intervals[this._intervals.length - 1];
      return last.b;
    }
    get minElement() {
      if (this.isNil) {
        throw new RangeError("set is empty");
      }
      return this._intervals[0].a;
    }
    get intervals() {
      return this._intervals;
    }
    hashCode() {
      let hash = MurmurHash_1.MurmurHash.initialize();
      for (let I of this._intervals) {
        hash = MurmurHash_1.MurmurHash.update(hash, I.a);
        hash = MurmurHash_1.MurmurHash.update(hash, I.b);
      }
      hash = MurmurHash_1.MurmurHash.finish(hash, this._intervals.length * 2);
      return hash;
    }
    equals(o) {
      if (o == null || !(o instanceof IntervalSet)) {
        return false;
      }
      return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._intervals, o._intervals);
    }
    toString(elemAreChar = false) {
      let buf = "";
      if (this._intervals == null || this._intervals.length === 0) {
        return "{}";
      }
      if (this.size > 1) {
        buf += "{";
      }
      let first = true;
      for (let I of this._intervals) {
        if (first) {
          first = false;
        } else {
          buf += ", ";
        }
        let a = I.a;
        let b = I.b;
        if (a === b) {
          if (a === Token_1.Token.EOF) {
            buf += "<EOF>";
          } else if (elemAreChar) {
            buf += "'" + String.fromCodePoint(a) + "'";
          } else {
            buf += a;
          }
        } else {
          if (elemAreChar) {
            buf += "'" + String.fromCodePoint(a) + "'..'" + String.fromCodePoint(b) + "'";
          } else {
            buf += a + ".." + b;
          }
        }
      }
      if (this.size > 1) {
        buf += "}";
      }
      return buf;
    }
    toStringVocabulary(vocabulary) {
      if (this._intervals == null || this._intervals.length === 0) {
        return "{}";
      }
      let buf = "";
      if (this.size > 1) {
        buf += "{";
      }
      let first = true;
      for (let I of this._intervals) {
        if (first) {
          first = false;
        } else {
          buf += ", ";
        }
        let a = I.a;
        let b = I.b;
        if (a === b) {
          buf += this.elementName(vocabulary, a);
        } else {
          for (let i = a; i <= b; i++) {
            if (i > a) {
              buf += ", ";
            }
            buf += this.elementName(vocabulary, i);
          }
        }
      }
      if (this.size > 1) {
        buf += "}";
      }
      return buf;
    }
    elementName(vocabulary, a) {
      if (a === Token_1.Token.EOF) {
        return "<EOF>";
      } else if (a === Token_1.Token.EPSILON) {
        return "<EPSILON>";
      } else {
        return vocabulary.getDisplayName(a);
      }
    }
    get size() {
      let n = 0;
      let numIntervals = this._intervals.length;
      if (numIntervals === 1) {
        let firstInterval = this._intervals[0];
        return firstInterval.b - firstInterval.a + 1;
      }
      for (let i = 0; i < numIntervals; i++) {
        let I = this._intervals[i];
        n += I.b - I.a + 1;
      }
      return n;
    }
    toIntegerList() {
      let values = new IntegerList_1.IntegerList(this.size);
      let n = this._intervals.length;
      for (let i = 0; i < n; i++) {
        let I = this._intervals[i];
        let a = I.a;
        let b = I.b;
        for (let v = a; v <= b; v++) {
          values.add(v);
        }
      }
      return values;
    }
    toSet() {
      let s = new Set();
      for (let I of this._intervals) {
        let a = I.a;
        let b = I.b;
        for (let v = a; v <= b; v++) {
          s.add(v);
        }
      }
      return s;
    }
    toArray() {
      let values = new Array();
      let n = this._intervals.length;
      for (let i = 0; i < n; i++) {
        let I = this._intervals[i];
        let a = I.a;
        let b = I.b;
        for (let v = a; v <= b; v++) {
          values.push(v);
        }
      }
      return values;
    }
    remove(el) {
      if (this.readonly) {
        throw new Error("can't alter readonly IntervalSet");
      }
      let n = this._intervals.length;
      for (let i = 0; i < n; i++) {
        let I = this._intervals[i];
        let a = I.a;
        let b = I.b;
        if (el < a) {
          break;
        }
        if (el === a && el === b) {
          this._intervals.splice(i, 1);
          break;
        }
        if (el === a) {
          this._intervals[i] = Interval_1.Interval.of(I.a + 1, I.b);
          break;
        }
        if (el === b) {
          this._intervals[i] = Interval_1.Interval.of(I.a, I.b - 1);
          break;
        }
        if (el > a && el < b) {
          let oldb = I.b;
          this._intervals[i] = Interval_1.Interval.of(I.a, el - 1);
          this.add(el + 1, oldb);
        }
      }
    }
    get isReadonly() {
      return this.readonly;
    }
    setReadonly(readonly) {
      if (this.readonly && !readonly) {
        throw new Error("can't alter readonly IntervalSet");
      }
      this.readonly = readonly;
    }
  };
  __decorate([
    Decorators_1.Override
  ], IntervalSet.prototype, "addAll", null);
  __decorate([
    Decorators_1.Override
  ], IntervalSet.prototype, "complement", null);
  __decorate([
    Decorators_1.Override
  ], IntervalSet.prototype, "subtract", null);
  __decorate([
    Decorators_1.Override
  ], IntervalSet.prototype, "or", null);
  __decorate([
    Decorators_1.Override
  ], IntervalSet.prototype, "and", null);
  __decorate([
    Decorators_1.Override
  ], IntervalSet.prototype, "contains", null);
  __decorate([
    Decorators_1.Override
  ], IntervalSet.prototype, "isNil", null);
  __decorate([
    Decorators_1.Override
  ], IntervalSet.prototype, "hashCode", null);
  __decorate([
    Decorators_1.Override
  ], IntervalSet.prototype, "equals", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], IntervalSet.prototype, "toStringVocabulary", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull)
  ], IntervalSet.prototype, "elementName", null);
  __decorate([
    Decorators_1.Override
  ], IntervalSet.prototype, "size", null);
  __decorate([
    Decorators_1.Override
  ], IntervalSet.prototype, "remove", null);
  __decorate([
    Decorators_1.NotNull
  ], IntervalSet, "of", null);
  __decorate([
    Decorators_1.NotNull
  ], IntervalSet, "subtract", null);
  exports.IntervalSet = IntervalSet;
});

// node_modules/antlr4ts/atn/ATNDeserializationOptions.js
var require_ATNDeserializationOptions = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ATNDeserializationOptions = void 0;
  var Decorators_1 = require_Decorators();
  var ATNDeserializationOptions = class {
    constructor(options) {
      this.readOnly = false;
      if (options) {
        this.verifyATN = options.verifyATN;
        this.generateRuleBypassTransitions = options.generateRuleBypassTransitions;
        this.optimize = options.optimize;
      } else {
        this.verifyATN = true;
        this.generateRuleBypassTransitions = false;
        this.optimize = true;
      }
    }
    static get defaultOptions() {
      if (ATNDeserializationOptions._defaultOptions == null) {
        ATNDeserializationOptions._defaultOptions = new ATNDeserializationOptions();
        ATNDeserializationOptions._defaultOptions.makeReadOnly();
      }
      return ATNDeserializationOptions._defaultOptions;
    }
    get isReadOnly() {
      return this.readOnly;
    }
    makeReadOnly() {
      this.readOnly = true;
    }
    get isVerifyATN() {
      return this.verifyATN;
    }
    set isVerifyATN(verifyATN) {
      this.throwIfReadOnly();
      this.verifyATN = verifyATN;
    }
    get isGenerateRuleBypassTransitions() {
      return this.generateRuleBypassTransitions;
    }
    set isGenerateRuleBypassTransitions(generateRuleBypassTransitions) {
      this.throwIfReadOnly();
      this.generateRuleBypassTransitions = generateRuleBypassTransitions;
    }
    get isOptimize() {
      return this.optimize;
    }
    set isOptimize(optimize) {
      this.throwIfReadOnly();
      this.optimize = optimize;
    }
    throwIfReadOnly() {
      if (this.isReadOnly) {
        throw new Error("The object is read only.");
      }
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], ATNDeserializationOptions, "defaultOptions", null);
  exports.ATNDeserializationOptions = ATNDeserializationOptions;
});

// node_modules/antlr4ts/atn/ActionTransition.js
var require_ActionTransition = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ActionTransition = void 0;
  var Decorators_1 = require_Decorators();
  var Transition_1 = require_Transition();
  var ActionTransition = class ActionTransition extends Transition_1.Transition {
    constructor(target, ruleIndex, actionIndex = -1, isCtxDependent = false) {
      super(target);
      this.ruleIndex = ruleIndex;
      this.actionIndex = actionIndex;
      this.isCtxDependent = isCtxDependent;
    }
    get serializationType() {
      return 6;
    }
    get isEpsilon() {
      return true;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return false;
    }
    toString() {
      return "action_" + this.ruleIndex + ":" + this.actionIndex;
    }
  };
  __decorate([
    Decorators_1.Override
  ], ActionTransition.prototype, "serializationType", null);
  __decorate([
    Decorators_1.Override
  ], ActionTransition.prototype, "isEpsilon", null);
  __decorate([
    Decorators_1.Override
  ], ActionTransition.prototype, "matches", null);
  __decorate([
    Decorators_1.Override
  ], ActionTransition.prototype, "toString", null);
  ActionTransition = __decorate([
    __param(0, Decorators_1.NotNull)
  ], ActionTransition);
  exports.ActionTransition = ActionTransition;
});

// node_modules/antlr4ts/atn/AtomTransition.js
var require_AtomTransition = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.AtomTransition = void 0;
  var IntervalSet_1 = require_IntervalSet();
  var Decorators_1 = require_Decorators();
  var Transition_1 = require_Transition();
  var AtomTransition2 = class AtomTransition extends Transition_1.Transition {
    constructor(target, label) {
      super(target);
      this._label = label;
    }
    get serializationType() {
      return 5;
    }
    get label() {
      return IntervalSet_1.IntervalSet.of(this._label);
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return this._label === symbol;
    }
    toString() {
      return String(this.label);
    }
  };
  __decorate([
    Decorators_1.Override
  ], AtomTransition2.prototype, "serializationType", null);
  __decorate([
    Decorators_1.Override,
    Decorators_1.NotNull
  ], AtomTransition2.prototype, "label", null);
  __decorate([
    Decorators_1.Override
  ], AtomTransition2.prototype, "matches", null);
  __decorate([
    Decorators_1.Override,
    Decorators_1.NotNull
  ], AtomTransition2.prototype, "toString", null);
  AtomTransition2 = __decorate([
    __param(0, Decorators_1.NotNull)
  ], AtomTransition2);
  exports.AtomTransition = AtomTransition2;
});

// node_modules/antlr4ts/atn/BlockStartState.js
var require_BlockStartState = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.BlockStartState = void 0;
  var DecisionState_1 = require_DecisionState();
  var BlockStartState = class extends DecisionState_1.DecisionState {
  };
  exports.BlockStartState = BlockStartState;
});

// node_modules/antlr4ts/atn/BasicBlockStartState.js
var require_BasicBlockStartState = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.BasicBlockStartState = void 0;
  var ATNStateType_1 = require_ATNStateType();
  var BlockStartState_1 = require_BlockStartState();
  var Decorators_1 = require_Decorators();
  var BasicBlockStartState = class extends BlockStartState_1.BlockStartState {
    get stateType() {
      return ATNStateType_1.ATNStateType.BLOCK_START;
    }
  };
  __decorate([
    Decorators_1.Override
  ], BasicBlockStartState.prototype, "stateType", null);
  exports.BasicBlockStartState = BasicBlockStartState;
});

// node_modules/antlr4ts/atn/BlockEndState.js
var require_BlockEndState = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.BlockEndState = void 0;
  var ATNState_1 = require_ATNState();
  var ATNStateType_1 = require_ATNStateType();
  var Decorators_1 = require_Decorators();
  var BlockEndState = class extends ATNState_1.ATNState {
    get stateType() {
      return ATNStateType_1.ATNStateType.BLOCK_END;
    }
  };
  __decorate([
    Decorators_1.Override
  ], BlockEndState.prototype, "stateType", null);
  exports.BlockEndState = BlockEndState;
});

// node_modules/antlr4ts/atn/EpsilonTransition.js
var require_EpsilonTransition = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.EpsilonTransition = void 0;
  var Decorators_1 = require_Decorators();
  var Transition_1 = require_Transition();
  var EpsilonTransition = class EpsilonTransition extends Transition_1.Transition {
    constructor(target, outermostPrecedenceReturn = -1) {
      super(target);
      this._outermostPrecedenceReturn = outermostPrecedenceReturn;
    }
    get outermostPrecedenceReturn() {
      return this._outermostPrecedenceReturn;
    }
    get serializationType() {
      return 1;
    }
    get isEpsilon() {
      return true;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return false;
    }
    toString() {
      return "epsilon";
    }
  };
  __decorate([
    Decorators_1.Override
  ], EpsilonTransition.prototype, "serializationType", null);
  __decorate([
    Decorators_1.Override
  ], EpsilonTransition.prototype, "isEpsilon", null);
  __decorate([
    Decorators_1.Override
  ], EpsilonTransition.prototype, "matches", null);
  __decorate([
    Decorators_1.Override,
    Decorators_1.NotNull
  ], EpsilonTransition.prototype, "toString", null);
  EpsilonTransition = __decorate([
    __param(0, Decorators_1.NotNull)
  ], EpsilonTransition);
  exports.EpsilonTransition = EpsilonTransition;
});

// node_modules/antlr4ts/atn/LexerChannelAction.js
var require_LexerChannelAction = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.LexerChannelAction = void 0;
  var MurmurHash_1 = require_MurmurHash();
  var Decorators_1 = require_Decorators();
  var LexerChannelAction = class {
    constructor(channel) {
      this._channel = channel;
    }
    get channel() {
      return this._channel;
    }
    get actionType() {
      return 0;
    }
    get isPositionDependent() {
      return false;
    }
    execute(lexer) {
      lexer.channel = this._channel;
    }
    hashCode() {
      let hash = MurmurHash_1.MurmurHash.initialize();
      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
      hash = MurmurHash_1.MurmurHash.update(hash, this._channel);
      return MurmurHash_1.MurmurHash.finish(hash, 2);
    }
    equals(obj) {
      if (obj === this) {
        return true;
      } else if (!(obj instanceof LexerChannelAction)) {
        return false;
      }
      return this._channel === obj._channel;
    }
    toString() {
      return `channel(${this._channel})`;
    }
  };
  __decorate([
    Decorators_1.Override
  ], LexerChannelAction.prototype, "actionType", null);
  __decorate([
    Decorators_1.Override
  ], LexerChannelAction.prototype, "isPositionDependent", null);
  __decorate([
    Decorators_1.Override,
    __param(0, Decorators_1.NotNull)
  ], LexerChannelAction.prototype, "execute", null);
  __decorate([
    Decorators_1.Override
  ], LexerChannelAction.prototype, "hashCode", null);
  __decorate([
    Decorators_1.Override
  ], LexerChannelAction.prototype, "equals", null);
  __decorate([
    Decorators_1.Override
  ], LexerChannelAction.prototype, "toString", null);
  exports.LexerChannelAction = LexerChannelAction;
});

// node_modules/antlr4ts/atn/LexerCustomAction.js
var require_LexerCustomAction = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.LexerCustomAction = void 0;
  var MurmurHash_1 = require_MurmurHash();
  var Decorators_1 = require_Decorators();
  var LexerCustomAction = class {
    constructor(ruleIndex, actionIndex) {
      this._ruleIndex = ruleIndex;
      this._actionIndex = actionIndex;
    }
    get ruleIndex() {
      return this._ruleIndex;
    }
    get actionIndex() {
      return this._actionIndex;
    }
    get actionType() {
      return 1;
    }
    get isPositionDependent() {
      return true;
    }
    execute(lexer) {
      lexer.action(void 0, this._ruleIndex, this._actionIndex);
    }
    hashCode() {
      let hash = MurmurHash_1.MurmurHash.initialize();
      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
      hash = MurmurHash_1.MurmurHash.update(hash, this._ruleIndex);
      hash = MurmurHash_1.MurmurHash.update(hash, this._actionIndex);
      return MurmurHash_1.MurmurHash.finish(hash, 3);
    }
    equals(obj) {
      if (obj === this) {
        return true;
      } else if (!(obj instanceof LexerCustomAction)) {
        return false;
      }
      return this._ruleIndex === obj._ruleIndex && this._actionIndex === obj._actionIndex;
    }
  };
  __decorate([
    Decorators_1.Override
  ], LexerCustomAction.prototype, "actionType", null);
  __decorate([
    Decorators_1.Override
  ], LexerCustomAction.prototype, "isPositionDependent", null);
  __decorate([
    Decorators_1.Override,
    __param(0, Decorators_1.NotNull)
  ], LexerCustomAction.prototype, "execute", null);
  __decorate([
    Decorators_1.Override
  ], LexerCustomAction.prototype, "hashCode", null);
  __decorate([
    Decorators_1.Override
  ], LexerCustomAction.prototype, "equals", null);
  exports.LexerCustomAction = LexerCustomAction;
});

// node_modules/antlr4ts/atn/LexerModeAction.js
var require_LexerModeAction = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.LexerModeAction = void 0;
  var MurmurHash_1 = require_MurmurHash();
  var Decorators_1 = require_Decorators();
  var LexerModeAction = class {
    constructor(mode) {
      this._mode = mode;
    }
    get mode() {
      return this._mode;
    }
    get actionType() {
      return 2;
    }
    get isPositionDependent() {
      return false;
    }
    execute(lexer) {
      lexer.mode(this._mode);
    }
    hashCode() {
      let hash = MurmurHash_1.MurmurHash.initialize();
      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
      hash = MurmurHash_1.MurmurHash.update(hash, this._mode);
      return MurmurHash_1.MurmurHash.finish(hash, 2);
    }
    equals(obj) {
      if (obj === this) {
        return true;
      } else if (!(obj instanceof LexerModeAction)) {
        return false;
      }
      return this._mode === obj._mode;
    }
    toString() {
      return `mode(${this._mode})`;
    }
  };
  __decorate([
    Decorators_1.Override
  ], LexerModeAction.prototype, "actionType", null);
  __decorate([
    Decorators_1.Override
  ], LexerModeAction.prototype, "isPositionDependent", null);
  __decorate([
    Decorators_1.Override,
    __param(0, Decorators_1.NotNull)
  ], LexerModeAction.prototype, "execute", null);
  __decorate([
    Decorators_1.Override
  ], LexerModeAction.prototype, "hashCode", null);
  __decorate([
    Decorators_1.Override
  ], LexerModeAction.prototype, "equals", null);
  __decorate([
    Decorators_1.Override
  ], LexerModeAction.prototype, "toString", null);
  exports.LexerModeAction = LexerModeAction;
});

// node_modules/antlr4ts/atn/LexerMoreAction.js
var require_LexerMoreAction = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.LexerMoreAction = void 0;
  var MurmurHash_1 = require_MurmurHash();
  var Decorators_1 = require_Decorators();
  var LexerMoreAction = class {
    constructor() {
    }
    get actionType() {
      return 3;
    }
    get isPositionDependent() {
      return false;
    }
    execute(lexer) {
      lexer.more();
    }
    hashCode() {
      let hash = MurmurHash_1.MurmurHash.initialize();
      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
      return MurmurHash_1.MurmurHash.finish(hash, 1);
    }
    equals(obj) {
      return obj === this;
    }
    toString() {
      return "more";
    }
  };
  __decorate([
    Decorators_1.Override
  ], LexerMoreAction.prototype, "actionType", null);
  __decorate([
    Decorators_1.Override
  ], LexerMoreAction.prototype, "isPositionDependent", null);
  __decorate([
    Decorators_1.Override,
    __param(0, Decorators_1.NotNull)
  ], LexerMoreAction.prototype, "execute", null);
  __decorate([
    Decorators_1.Override
  ], LexerMoreAction.prototype, "hashCode", null);
  __decorate([
    Decorators_1.Override
  ], LexerMoreAction.prototype, "equals", null);
  __decorate([
    Decorators_1.Override
  ], LexerMoreAction.prototype, "toString", null);
  exports.LexerMoreAction = LexerMoreAction;
  (function(LexerMoreAction2) {
    LexerMoreAction2.INSTANCE = new LexerMoreAction2();
  })(LexerMoreAction = exports.LexerMoreAction || (exports.LexerMoreAction = {}));
});

// node_modules/antlr4ts/atn/LexerPopModeAction.js
var require_LexerPopModeAction = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.LexerPopModeAction = void 0;
  var MurmurHash_1 = require_MurmurHash();
  var Decorators_1 = require_Decorators();
  var LexerPopModeAction = class {
    constructor() {
    }
    get actionType() {
      return 4;
    }
    get isPositionDependent() {
      return false;
    }
    execute(lexer) {
      lexer.popMode();
    }
    hashCode() {
      let hash = MurmurHash_1.MurmurHash.initialize();
      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
      return MurmurHash_1.MurmurHash.finish(hash, 1);
    }
    equals(obj) {
      return obj === this;
    }
    toString() {
      return "popMode";
    }
  };
  __decorate([
    Decorators_1.Override
  ], LexerPopModeAction.prototype, "actionType", null);
  __decorate([
    Decorators_1.Override
  ], LexerPopModeAction.prototype, "isPositionDependent", null);
  __decorate([
    Decorators_1.Override,
    __param(0, Decorators_1.NotNull)
  ], LexerPopModeAction.prototype, "execute", null);
  __decorate([
    Decorators_1.Override
  ], LexerPopModeAction.prototype, "hashCode", null);
  __decorate([
    Decorators_1.Override
  ], LexerPopModeAction.prototype, "equals", null);
  __decorate([
    Decorators_1.Override
  ], LexerPopModeAction.prototype, "toString", null);
  exports.LexerPopModeAction = LexerPopModeAction;
  (function(LexerPopModeAction2) {
    LexerPopModeAction2.INSTANCE = new LexerPopModeAction2();
  })(LexerPopModeAction = exports.LexerPopModeAction || (exports.LexerPopModeAction = {}));
});

// node_modules/antlr4ts/atn/LexerPushModeAction.js
var require_LexerPushModeAction = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.LexerPushModeAction = void 0;
  var MurmurHash_1 = require_MurmurHash();
  var Decorators_1 = require_Decorators();
  var LexerPushModeAction = class {
    constructor(mode) {
      this._mode = mode;
    }
    get mode() {
      return this._mode;
    }
    get actionType() {
      return 5;
    }
    get isPositionDependent() {
      return false;
    }
    execute(lexer) {
      lexer.pushMode(this._mode);
    }
    hashCode() {
      let hash = MurmurHash_1.MurmurHash.initialize();
      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
      hash = MurmurHash_1.MurmurHash.update(hash, this._mode);
      return MurmurHash_1.MurmurHash.finish(hash, 2);
    }
    equals(obj) {
      if (obj === this) {
        return true;
      } else if (!(obj instanceof LexerPushModeAction)) {
        return false;
      }
      return this._mode === obj._mode;
    }
    toString() {
      return `pushMode(${this._mode})`;
    }
  };
  __decorate([
    Decorators_1.Override
  ], LexerPushModeAction.prototype, "actionType", null);
  __decorate([
    Decorators_1.Override
  ], LexerPushModeAction.prototype, "isPositionDependent", null);
  __decorate([
    Decorators_1.Override,
    __param(0, Decorators_1.NotNull)
  ], LexerPushModeAction.prototype, "execute", null);
  __decorate([
    Decorators_1.Override
  ], LexerPushModeAction.prototype, "hashCode", null);
  __decorate([
    Decorators_1.Override
  ], LexerPushModeAction.prototype, "equals", null);
  __decorate([
    Decorators_1.Override
  ], LexerPushModeAction.prototype, "toString", null);
  exports.LexerPushModeAction = LexerPushModeAction;
});

// node_modules/antlr4ts/atn/LexerSkipAction.js
var require_LexerSkipAction = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.LexerSkipAction = void 0;
  var MurmurHash_1 = require_MurmurHash();
  var Decorators_1 = require_Decorators();
  var LexerSkipAction = class {
    constructor() {
    }
    get actionType() {
      return 6;
    }
    get isPositionDependent() {
      return false;
    }
    execute(lexer) {
      lexer.skip();
    }
    hashCode() {
      let hash = MurmurHash_1.MurmurHash.initialize();
      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
      return MurmurHash_1.MurmurHash.finish(hash, 1);
    }
    equals(obj) {
      return obj === this;
    }
    toString() {
      return "skip";
    }
  };
  __decorate([
    Decorators_1.Override
  ], LexerSkipAction.prototype, "actionType", null);
  __decorate([
    Decorators_1.Override
  ], LexerSkipAction.prototype, "isPositionDependent", null);
  __decorate([
    Decorators_1.Override,
    __param(0, Decorators_1.NotNull)
  ], LexerSkipAction.prototype, "execute", null);
  __decorate([
    Decorators_1.Override
  ], LexerSkipAction.prototype, "hashCode", null);
  __decorate([
    Decorators_1.Override
  ], LexerSkipAction.prototype, "equals", null);
  __decorate([
    Decorators_1.Override
  ], LexerSkipAction.prototype, "toString", null);
  exports.LexerSkipAction = LexerSkipAction;
  (function(LexerSkipAction2) {
    LexerSkipAction2.INSTANCE = new LexerSkipAction2();
  })(LexerSkipAction = exports.LexerSkipAction || (exports.LexerSkipAction = {}));
});

// node_modules/antlr4ts/atn/LexerTypeAction.js
var require_LexerTypeAction = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.LexerTypeAction = void 0;
  var MurmurHash_1 = require_MurmurHash();
  var Decorators_1 = require_Decorators();
  var LexerTypeAction = class {
    constructor(type) {
      this._type = type;
    }
    get type() {
      return this._type;
    }
    get actionType() {
      return 7;
    }
    get isPositionDependent() {
      return false;
    }
    execute(lexer) {
      lexer.type = this._type;
    }
    hashCode() {
      let hash = MurmurHash_1.MurmurHash.initialize();
      hash = MurmurHash_1.MurmurHash.update(hash, this.actionType);
      hash = MurmurHash_1.MurmurHash.update(hash, this._type);
      return MurmurHash_1.MurmurHash.finish(hash, 2);
    }
    equals(obj) {
      if (obj === this) {
        return true;
      } else if (!(obj instanceof LexerTypeAction)) {
        return false;
      }
      return this._type === obj._type;
    }
    toString() {
      return `type(${this._type})`;
    }
  };
  __decorate([
    Decorators_1.Override
  ], LexerTypeAction.prototype, "actionType", null);
  __decorate([
    Decorators_1.Override
  ], LexerTypeAction.prototype, "isPositionDependent", null);
  __decorate([
    Decorators_1.Override,
    __param(0, Decorators_1.NotNull)
  ], LexerTypeAction.prototype, "execute", null);
  __decorate([
    Decorators_1.Override
  ], LexerTypeAction.prototype, "hashCode", null);
  __decorate([
    Decorators_1.Override
  ], LexerTypeAction.prototype, "equals", null);
  __decorate([
    Decorators_1.Override
  ], LexerTypeAction.prototype, "toString", null);
  exports.LexerTypeAction = LexerTypeAction;
});

// node_modules/antlr4ts/atn/LoopEndState.js
var require_LoopEndState = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.LoopEndState = void 0;
  var ATNState_1 = require_ATNState();
  var ATNStateType_1 = require_ATNStateType();
  var Decorators_1 = require_Decorators();
  var LoopEndState = class extends ATNState_1.ATNState {
    get stateType() {
      return ATNStateType_1.ATNStateType.LOOP_END;
    }
  };
  __decorate([
    Decorators_1.Override
  ], LoopEndState.prototype, "stateType", null);
  exports.LoopEndState = LoopEndState;
});

// node_modules/antlr4ts/atn/ConflictInfo.js
var require_ConflictInfo = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ConflictInfo = void 0;
  var Decorators_1 = require_Decorators();
  var Utils3 = require_Utils();
  var ConflictInfo = class {
    constructor(conflictedAlts, exact) {
      this._conflictedAlts = conflictedAlts;
      this.exact = exact;
    }
    get conflictedAlts() {
      return this._conflictedAlts;
    }
    get isExact() {
      return this.exact;
    }
    equals(obj) {
      if (obj === this) {
        return true;
      } else if (!(obj instanceof ConflictInfo)) {
        return false;
      }
      return this.isExact === obj.isExact && Utils3.equals(this.conflictedAlts, obj.conflictedAlts);
    }
    hashCode() {
      return this.conflictedAlts.hashCode();
    }
  };
  __decorate([
    Decorators_1.Override
  ], ConflictInfo.prototype, "equals", null);
  __decorate([
    Decorators_1.Override
  ], ConflictInfo.prototype, "hashCode", null);
  exports.ConflictInfo = ConflictInfo;
});

// node_modules/antlr4ts/tree/TerminalNode.js
var require_TerminalNode = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.TerminalNode = void 0;
  var Interval_1 = require_Interval();
  var Decorators_1 = require_Decorators();
  var Token_1 = require_Token();
  var TerminalNode = class {
    constructor(symbol) {
      this._symbol = symbol;
    }
    getChild(i) {
      throw new RangeError("Terminal Node has no children.");
    }
    get symbol() {
      return this._symbol;
    }
    get parent() {
      return this._parent;
    }
    setParent(parent) {
      this._parent = parent;
    }
    get payload() {
      return this._symbol;
    }
    get sourceInterval() {
      let tokenIndex = this._symbol.tokenIndex;
      return new Interval_1.Interval(tokenIndex, tokenIndex);
    }
    get childCount() {
      return 0;
    }
    accept(visitor) {
      return visitor.visitTerminal(this);
    }
    get text() {
      return this._symbol.text || "";
    }
    toStringTree(parser) {
      return this.toString();
    }
    toString() {
      if (this._symbol.type === Token_1.Token.EOF) {
        return "<EOF>";
      }
      return this._symbol.text || "";
    }
  };
  __decorate([
    Decorators_1.Override
  ], TerminalNode.prototype, "getChild", null);
  __decorate([
    Decorators_1.Override
  ], TerminalNode.prototype, "parent", null);
  __decorate([
    Decorators_1.Override
  ], TerminalNode.prototype, "setParent", null);
  __decorate([
    Decorators_1.Override
  ], TerminalNode.prototype, "payload", null);
  __decorate([
    Decorators_1.Override
  ], TerminalNode.prototype, "sourceInterval", null);
  __decorate([
    Decorators_1.Override
  ], TerminalNode.prototype, "childCount", null);
  __decorate([
    Decorators_1.Override
  ], TerminalNode.prototype, "accept", null);
  __decorate([
    Decorators_1.Override
  ], TerminalNode.prototype, "text", null);
  __decorate([
    Decorators_1.Override
  ], TerminalNode.prototype, "toStringTree", null);
  __decorate([
    Decorators_1.Override
  ], TerminalNode.prototype, "toString", null);
  exports.TerminalNode = TerminalNode;
});

// node_modules/antlr4ts/tree/ErrorNode.js
var require_ErrorNode = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ErrorNode = void 0;
  var Decorators_1 = require_Decorators();
  var TerminalNode_1 = require_TerminalNode();
  var ErrorNode2 = class extends TerminalNode_1.TerminalNode {
    constructor(token) {
      super(token);
    }
    accept(visitor) {
      return visitor.visitErrorNode(this);
    }
  };
  __decorate([
    Decorators_1.Override
  ], ErrorNode2.prototype, "accept", null);
  exports.ErrorNode = ErrorNode2;
});

// node_modules/antlr4ts/tree/RuleNode.js
var require_RuleNode = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.RuleNode = void 0;
  var RuleNode = class {
  };
  exports.RuleNode = RuleNode;
});

// node_modules/antlr4ts/tree/Trees.js
var require_Trees = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.Trees = void 0;
  var ATN_1 = require_ATN();
  var CommonToken_1 = require_CommonToken();
  var ErrorNode_1 = require_ErrorNode();
  var Decorators_1 = require_Decorators();
  var Parser_1 = require_Parser();
  var ParserRuleContext_1 = require_ParserRuleContext();
  var RuleNode_1 = require_RuleNode();
  var TerminalNode_1 = require_TerminalNode();
  var Token_1 = require_Token();
  var Utils3 = require_Utils();
  var Trees = class {
    static toStringTree(t, arg2) {
      let ruleNames;
      if (arg2 instanceof Parser_1.Parser) {
        ruleNames = arg2.ruleNames;
      } else {
        ruleNames = arg2;
      }
      let s = Utils3.escapeWhitespace(this.getNodeText(t, ruleNames), false);
      if (t.childCount === 0) {
        return s;
      }
      let buf = "";
      buf += "(";
      s = Utils3.escapeWhitespace(this.getNodeText(t, ruleNames), false);
      buf += s;
      buf += " ";
      for (let i = 0; i < t.childCount; i++) {
        if (i > 0) {
          buf += " ";
        }
        buf += this.toStringTree(t.getChild(i), ruleNames);
      }
      buf += ")";
      return buf;
    }
    static getNodeText(t, arg2) {
      let ruleNames;
      if (arg2 instanceof Parser_1.Parser) {
        ruleNames = arg2.ruleNames;
      } else if (arg2) {
        ruleNames = arg2;
      } else {
        let payload = t.payload;
        if (typeof payload.text === "string") {
          return payload.text;
        }
        return t.payload.toString();
      }
      if (t instanceof RuleNode_1.RuleNode) {
        let ruleContext = t.ruleContext;
        let ruleIndex = ruleContext.ruleIndex;
        let ruleName = ruleNames[ruleIndex];
        let altNumber = ruleContext.altNumber;
        if (altNumber !== ATN_1.ATN.INVALID_ALT_NUMBER) {
          return ruleName + ":" + altNumber;
        }
        return ruleName;
      } else if (t instanceof ErrorNode_1.ErrorNode) {
        return t.toString();
      } else if (t instanceof TerminalNode_1.TerminalNode) {
        let symbol = t.symbol;
        return symbol.text || "";
      }
      throw new TypeError("Unexpected node type");
    }
    static getChildren(t) {
      let kids = [];
      for (let i = 0; i < t.childCount; i++) {
        kids.push(t.getChild(i));
      }
      return kids;
    }
    static getAncestors(t) {
      let ancestors = [];
      let p = t.parent;
      while (p) {
        ancestors.unshift(p);
        p = p.parent;
      }
      return ancestors;
    }
    static isAncestorOf(t, u) {
      if (!t || !u || !t.parent) {
        return false;
      }
      let p = u.parent;
      while (p) {
        if (t === p) {
          return true;
        }
        p = p.parent;
      }
      return false;
    }
    static findAllTokenNodes(t, ttype) {
      return Trees.findAllNodes(t, ttype, true);
    }
    static findAllRuleNodes(t, ruleIndex) {
      return Trees.findAllNodes(t, ruleIndex, false);
    }
    static findAllNodes(t, index, findTokens) {
      let nodes = [];
      Trees._findAllNodes(t, index, findTokens, nodes);
      return nodes;
    }
    static _findAllNodes(t, index, findTokens, nodes) {
      if (findTokens && t instanceof TerminalNode_1.TerminalNode) {
        if (t.symbol.type === index) {
          nodes.push(t);
        }
      } else if (!findTokens && t instanceof ParserRuleContext_1.ParserRuleContext) {
        if (t.ruleIndex === index) {
          nodes.push(t);
        }
      }
      for (let i = 0; i < t.childCount; i++) {
        Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);
      }
    }
    static getDescendants(t) {
      let nodes = [];
      function recurse(e) {
        nodes.push(e);
        const n = e.childCount;
        for (let i = 0; i < n; i++) {
          recurse(e.getChild(i));
        }
      }
      recurse(t);
      return nodes;
    }
    static getRootOfSubtreeEnclosingRegion(t, startTokenIndex, stopTokenIndex) {
      let n = t.childCount;
      for (let i = 0; i < n; i++) {
        let child = t.getChild(i);
        let r = Trees.getRootOfSubtreeEnclosingRegion(child, startTokenIndex, stopTokenIndex);
        if (r) {
          return r;
        }
      }
      if (t instanceof ParserRuleContext_1.ParserRuleContext) {
        let stopToken = t.stop;
        if (startTokenIndex >= t.start.tokenIndex && (stopToken == null || stopTokenIndex <= stopToken.tokenIndex)) {
          return t;
        }
      }
      return void 0;
    }
    static stripChildrenOutOfRange(t, root, startIndex, stopIndex) {
      if (!t) {
        return;
      }
      let count = t.childCount;
      for (let i = 0; i < count; i++) {
        let child = t.getChild(i);
        let range = child.sourceInterval;
        if (child instanceof ParserRuleContext_1.ParserRuleContext && (range.b < startIndex || range.a > stopIndex)) {
          if (Trees.isAncestorOf(child, root)) {
            let abbrev = new CommonToken_1.CommonToken(Token_1.Token.INVALID_TYPE, "...");
            t.children[i] = new TerminalNode_1.TerminalNode(abbrev);
          }
        }
      }
    }
    static findNodeSuchThat(t, pred) {
      if (pred(t)) {
        return t;
      }
      let n = t.childCount;
      for (let i = 0; i < n; i++) {
        let u = Trees.findNodeSuchThat(t.getChild(i), pred);
        if (u !== void 0) {
          return u;
        }
      }
      return void 0;
    }
  };
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], Trees, "toStringTree", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull)
  ], Trees, "getAncestors", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], Trees, "getRootOfSubtreeEnclosingRegion", null);
  exports.Trees = Trees;
});

// node_modules/antlr4ts/RuleContext.js
var require_RuleContext = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.RuleContext = void 0;
  var ATN_1 = require_ATN();
  var Recognizer_1 = require_Recognizer();
  var RuleNode_1 = require_RuleNode();
  var Interval_1 = require_Interval();
  var Decorators_1 = require_Decorators();
  var Trees_1 = require_Trees();
  var ParserRuleContext_1 = require_ParserRuleContext();
  var RuleContext = class extends RuleNode_1.RuleNode {
    constructor(parent, invokingState) {
      super();
      this._parent = parent;
      this.invokingState = invokingState != null ? invokingState : -1;
    }
    static getChildContext(parent, invokingState) {
      return new RuleContext(parent, invokingState);
    }
    depth() {
      let n = 0;
      let p = this;
      while (p) {
        p = p._parent;
        n++;
      }
      return n;
    }
    get isEmpty() {
      return this.invokingState === -1;
    }
    get sourceInterval() {
      return Interval_1.Interval.INVALID;
    }
    get ruleContext() {
      return this;
    }
    get parent() {
      return this._parent;
    }
    setParent(parent) {
      this._parent = parent;
    }
    get payload() {
      return this;
    }
    get text() {
      if (this.childCount === 0) {
        return "";
      }
      let builder = "";
      for (let i = 0; i < this.childCount; i++) {
        builder += this.getChild(i).text;
      }
      return builder.toString();
    }
    get ruleIndex() {
      return -1;
    }
    get altNumber() {
      return ATN_1.ATN.INVALID_ALT_NUMBER;
    }
    set altNumber(altNumber) {
    }
    getChild(i) {
      throw new RangeError("i must be greater than or equal to 0 and less than childCount");
    }
    get childCount() {
      return 0;
    }
    accept(visitor) {
      return visitor.visitChildren(this);
    }
    toStringTree(recog) {
      return Trees_1.Trees.toStringTree(this, recog);
    }
    toString(arg1, stop) {
      const ruleNames = arg1 instanceof Recognizer_1.Recognizer ? arg1.ruleNames : arg1;
      stop = stop || ParserRuleContext_1.ParserRuleContext.emptyContext();
      let buf = "";
      let p = this;
      buf += "[";
      while (p && p !== stop) {
        if (!ruleNames) {
          if (!p.isEmpty) {
            buf += p.invokingState;
          }
        } else {
          let ruleIndex = p.ruleIndex;
          let ruleName = ruleIndex >= 0 && ruleIndex < ruleNames.length ? ruleNames[ruleIndex] : ruleIndex.toString();
          buf += ruleName;
        }
        if (p._parent && (ruleNames || !p._parent.isEmpty)) {
          buf += " ";
        }
        p = p._parent;
      }
      buf += "]";
      return buf.toString();
    }
  };
  __decorate([
    Decorators_1.Override
  ], RuleContext.prototype, "sourceInterval", null);
  __decorate([
    Decorators_1.Override
  ], RuleContext.prototype, "ruleContext", null);
  __decorate([
    Decorators_1.Override
  ], RuleContext.prototype, "parent", null);
  __decorate([
    Decorators_1.Override
  ], RuleContext.prototype, "setParent", null);
  __decorate([
    Decorators_1.Override
  ], RuleContext.prototype, "payload", null);
  __decorate([
    Decorators_1.Override
  ], RuleContext.prototype, "text", null);
  __decorate([
    Decorators_1.Override
  ], RuleContext.prototype, "getChild", null);
  __decorate([
    Decorators_1.Override
  ], RuleContext.prototype, "childCount", null);
  __decorate([
    Decorators_1.Override
  ], RuleContext.prototype, "accept", null);
  __decorate([
    Decorators_1.Override
  ], RuleContext.prototype, "toStringTree", null);
  exports.RuleContext = RuleContext;
});

// node_modules/antlr4ts/ParserRuleContext.js
var require_ParserRuleContext = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ParserRuleContext = void 0;
  var ErrorNode_1 = require_ErrorNode();
  var Interval_1 = require_Interval();
  var Decorators_1 = require_Decorators();
  var RuleContext_1 = require_RuleContext();
  var TerminalNode_1 = require_TerminalNode();
  var ParserRuleContext2 = class extends RuleContext_1.RuleContext {
    constructor(parent, invokingStateNumber) {
      if (invokingStateNumber == null) {
        super();
      } else {
        super(parent, invokingStateNumber);
      }
    }
    static emptyContext() {
      return ParserRuleContext2.EMPTY;
    }
    copyFrom(ctx) {
      this._parent = ctx._parent;
      this.invokingState = ctx.invokingState;
      this._start = ctx._start;
      this._stop = ctx._stop;
      if (ctx.children) {
        this.children = [];
        for (let child of ctx.children) {
          if (child instanceof ErrorNode_1.ErrorNode) {
            this.addChild(child);
          }
        }
      }
    }
    enterRule(listener) {
    }
    exitRule(listener) {
    }
    addAnyChild(t) {
      if (!this.children) {
        this.children = [t];
      } else {
        this.children.push(t);
      }
      return t;
    }
    addChild(t) {
      let result;
      if (t instanceof TerminalNode_1.TerminalNode) {
        t.setParent(this);
        this.addAnyChild(t);
        return;
      } else if (t instanceof RuleContext_1.RuleContext) {
        this.addAnyChild(t);
        return;
      } else {
        t = new TerminalNode_1.TerminalNode(t);
        this.addAnyChild(t);
        t.setParent(this);
        return t;
      }
    }
    addErrorNode(node) {
      if (node instanceof ErrorNode_1.ErrorNode) {
        const errorNode = node;
        errorNode.setParent(this);
        return this.addAnyChild(errorNode);
      } else {
        const badToken = node;
        let t = new ErrorNode_1.ErrorNode(badToken);
        this.addAnyChild(t);
        t.setParent(this);
        return t;
      }
    }
    removeLastChild() {
      if (this.children) {
        this.children.pop();
      }
    }
    get parent() {
      let parent = super.parent;
      if (parent === void 0 || parent instanceof ParserRuleContext2) {
        return parent;
      }
      throw new TypeError("Invalid parent type for ParserRuleContext");
    }
    getChild(i, ctxType) {
      if (!this.children || i < 0 || i >= this.children.length) {
        throw new RangeError("index parameter must be between >= 0 and <= number of children.");
      }
      if (ctxType == null) {
        return this.children[i];
      }
      let result = this.tryGetChild(i, ctxType);
      if (result === void 0) {
        throw new Error("The specified node does not exist");
      }
      return result;
    }
    tryGetChild(i, ctxType) {
      if (!this.children || i < 0 || i >= this.children.length) {
        return void 0;
      }
      let j = -1;
      for (let o of this.children) {
        if (o instanceof ctxType) {
          j++;
          if (j === i) {
            return o;
          }
        }
      }
      return void 0;
    }
    getToken(ttype, i) {
      let result = this.tryGetToken(ttype, i);
      if (result === void 0) {
        throw new Error("The specified token does not exist");
      }
      return result;
    }
    tryGetToken(ttype, i) {
      if (!this.children || i < 0 || i >= this.children.length) {
        return void 0;
      }
      let j = -1;
      for (let o of this.children) {
        if (o instanceof TerminalNode_1.TerminalNode) {
          let symbol = o.symbol;
          if (symbol.type === ttype) {
            j++;
            if (j === i) {
              return o;
            }
          }
        }
      }
      return void 0;
    }
    getTokens(ttype) {
      let tokens2 = [];
      if (!this.children) {
        return tokens2;
      }
      for (let o of this.children) {
        if (o instanceof TerminalNode_1.TerminalNode) {
          let symbol = o.symbol;
          if (symbol.type === ttype) {
            tokens2.push(o);
          }
        }
      }
      return tokens2;
    }
    get ruleContext() {
      return this;
    }
    getRuleContext(i, ctxType) {
      return this.getChild(i, ctxType);
    }
    tryGetRuleContext(i, ctxType) {
      return this.tryGetChild(i, ctxType);
    }
    getRuleContexts(ctxType) {
      let contexts = [];
      if (!this.children) {
        return contexts;
      }
      for (let o of this.children) {
        if (o instanceof ctxType) {
          contexts.push(o);
        }
      }
      return contexts;
    }
    get childCount() {
      return this.children ? this.children.length : 0;
    }
    get sourceInterval() {
      if (!this._start) {
        return Interval_1.Interval.INVALID;
      }
      if (!this._stop || this._stop.tokenIndex < this._start.tokenIndex) {
        return Interval_1.Interval.of(this._start.tokenIndex, this._start.tokenIndex - 1);
      }
      return Interval_1.Interval.of(this._start.tokenIndex, this._stop.tokenIndex);
    }
    get start() {
      return this._start;
    }
    get stop() {
      return this._stop;
    }
    toInfoString(recognizer) {
      let rules = recognizer.getRuleInvocationStack(this).reverse();
      return "ParserRuleContext" + rules + "{start=" + this._start + ", stop=" + this._stop + "}";
    }
  };
  ParserRuleContext2.EMPTY = new ParserRuleContext2();
  __decorate([
    Decorators_1.Override
  ], ParserRuleContext2.prototype, "parent", null);
  __decorate([
    Decorators_1.Override
  ], ParserRuleContext2.prototype, "childCount", null);
  __decorate([
    Decorators_1.Override
  ], ParserRuleContext2.prototype, "sourceInterval", null);
  exports.ParserRuleContext = ParserRuleContext2;
});

// node_modules/antlr4ts/atn/PredictionMode.js
var require_PredictionMode = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.PredictionMode = void 0;
  var Array2DHashMap_1 = require_Array2DHashMap();
  var MurmurHash_1 = require_MurmurHash();
  var Decorators_1 = require_Decorators();
  var RuleStopState_1 = require_RuleStopState();
  var PredictionMode;
  (function(PredictionMode2) {
    PredictionMode2[PredictionMode2["SLL"] = 0] = "SLL";
    PredictionMode2[PredictionMode2["LL"] = 1] = "LL";
    PredictionMode2[PredictionMode2["LL_EXACT_AMBIG_DETECTION"] = 2] = "LL_EXACT_AMBIG_DETECTION";
  })(PredictionMode = exports.PredictionMode || (exports.PredictionMode = {}));
  (function(PredictionMode2) {
    class AltAndContextMap extends Array2DHashMap_1.Array2DHashMap {
      constructor() {
        super(AltAndContextConfigEqualityComparator.INSTANCE);
      }
    }
    class AltAndContextConfigEqualityComparator {
      AltAndContextConfigEqualityComparator() {
      }
      hashCode(o) {
        let hashCode = MurmurHash_1.MurmurHash.initialize(7);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, o.state.stateNumber);
        hashCode = MurmurHash_1.MurmurHash.update(hashCode, o.context);
        hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 2);
        return hashCode;
      }
      equals(a, b) {
        if (a === b) {
          return true;
        }
        if (a == null || b == null) {
          return false;
        }
        return a.state.stateNumber === b.state.stateNumber && a.context.equals(b.context);
      }
    }
    AltAndContextConfigEqualityComparator.INSTANCE = new AltAndContextConfigEqualityComparator();
    __decorate([
      Decorators_1.Override
    ], AltAndContextConfigEqualityComparator.prototype, "hashCode", null);
    __decorate([
      Decorators_1.Override
    ], AltAndContextConfigEqualityComparator.prototype, "equals", null);
    function hasConfigInRuleStopState(configs) {
      for (let c of configs) {
        if (c.state instanceof RuleStopState_1.RuleStopState) {
          return true;
        }
      }
      return false;
    }
    PredictionMode2.hasConfigInRuleStopState = hasConfigInRuleStopState;
    function allConfigsInRuleStopStates(configs) {
      for (let config of configs) {
        if (!(config.state instanceof RuleStopState_1.RuleStopState)) {
          return false;
        }
      }
      return true;
    }
    PredictionMode2.allConfigsInRuleStopStates = allConfigsInRuleStopStates;
  })(PredictionMode = exports.PredictionMode || (exports.PredictionMode = {}));
});

// node_modules/antlr4ts/atn/SimulatorState.js
var require_SimulatorState = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.SimulatorState = void 0;
  var Decorators_1 = require_Decorators();
  var ParserRuleContext_1 = require_ParserRuleContext();
  var SimulatorState = class SimulatorState {
    constructor(outerContext, s0, useContext, remainingOuterContext) {
      this.outerContext = outerContext != null ? outerContext : ParserRuleContext_1.ParserRuleContext.emptyContext();
      this.s0 = s0;
      this.useContext = useContext;
      this.remainingOuterContext = remainingOuterContext;
    }
  };
  SimulatorState = __decorate([
    __param(1, Decorators_1.NotNull)
  ], SimulatorState);
  exports.SimulatorState = SimulatorState;
});

// node_modules/antlr4ts/atn/ParserATNSimulator.js
var require_ParserATNSimulator = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ParserATNSimulator = void 0;
  var AcceptStateInfo_1 = require_AcceptStateInfo();
  var ActionTransition_1 = require_ActionTransition();
  var Array2DHashSet_1 = require_Array2DHashSet();
  var Arrays_1 = require_Arrays();
  var ATN_1 = require_ATN();
  var ATNConfig_1 = require_ATNConfig();
  var ATNConfigSet_1 = require_ATNConfigSet();
  var ATNSimulator_1 = require_ATNSimulator();
  var ATNStateType_1 = require_ATNStateType();
  var AtomTransition_1 = require_AtomTransition();
  var BitSet_1 = require_BitSet();
  var ConflictInfo_1 = require_ConflictInfo();
  var DecisionState_1 = require_DecisionState();
  var DFAState_1 = require_DFAState();
  var IntegerList_1 = require_IntegerList();
  var Interval_1 = require_Interval();
  var IntStream_1 = require_IntStream();
  var Decorators_1 = require_Decorators();
  var NotSetTransition_1 = require_NotSetTransition();
  var NoViableAltException_1 = require_NoViableAltException();
  var ObjectEqualityComparator_1 = require_ObjectEqualityComparator();
  var ParserRuleContext_1 = require_ParserRuleContext();
  var PredictionContext_1 = require_PredictionContext();
  var PredictionContextCache_1 = require_PredictionContextCache();
  var PredictionMode_1 = require_PredictionMode();
  var RuleStopState_1 = require_RuleStopState();
  var RuleTransition_1 = require_RuleTransition();
  var SemanticContext_1 = require_SemanticContext();
  var SetTransition_1 = require_SetTransition();
  var SimulatorState_1 = require_SimulatorState();
  var Token_1 = require_Token();
  var VocabularyImpl_1 = require_VocabularyImpl();
  var assert = __nccwpck_require__(9491);
  var MAX_SHORT_VALUE = 65535;
  var MIN_INTEGER_VALUE = -(1 << 31 >>> 0);
  var ParserATNSimulator2 = class ParserATNSimulator3 extends ATNSimulator_1.ATNSimulator {
    constructor(atn, parser) {
      super(atn);
      this.predictionMode = PredictionMode_1.PredictionMode.LL;
      this.force_global_context = false;
      this.always_try_local_context = true;
      this.enable_global_context_dfa = false;
      this.optimize_unique_closure = true;
      this.optimize_ll1 = true;
      this.optimize_tail_calls = true;
      this.tail_call_preserves_sll = true;
      this.treat_sllk1_conflict_as_ambiguity = false;
      this.reportAmbiguities = false;
      this.userWantsCtxSensitive = true;
      this._parser = parser;
    }
    getPredictionMode() {
      return this.predictionMode;
    }
    setPredictionMode(predictionMode) {
      this.predictionMode = predictionMode;
    }
    reset() {
    }
    adaptivePredict(input, decision, outerContext, useContext) {
      if (useContext === void 0) {
        useContext = false;
      }
      let dfa = this.atn.decisionToDFA[decision];
      assert(dfa != null);
      if (this.optimize_ll1 && !dfa.isPrecedenceDfa && !dfa.isEmpty) {
        let ll_1 = input.LA(1);
        if (ll_1 >= 0 && ll_1 <= 65535) {
          let key = (decision << 16 >>> 0) + ll_1;
          let alt = this.atn.LL1Table.get(key);
          if (alt != null) {
            return alt;
          }
        }
      }
      this.dfa = dfa;
      if (this.force_global_context) {
        useContext = true;
      } else if (!this.always_try_local_context) {
        useContext = useContext || dfa.isContextSensitive;
      }
      this.userWantsCtxSensitive = useContext || this.predictionMode !== PredictionMode_1.PredictionMode.SLL && outerContext != null && !this.atn.decisionToState[decision].sll;
      if (outerContext == null) {
        outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();
      }
      let state;
      if (!dfa.isEmpty) {
        state = this.getStartState(dfa, input, outerContext, useContext);
      }
      if (state == null) {
        if (outerContext == null) {
          outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();
        }
        if (ParserATNSimulator3.debug) {
          console.log("ATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this._parser));
        }
        state = this.computeStartState(dfa, outerContext, useContext);
      }
      let m = input.mark();
      let index = input.index;
      try {
        let alt = this.execDFA(dfa, input, index, state);
        if (ParserATNSimulator3.debug) {
          console.log("DFA after predictATN: " + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
        }
        return alt;
      } finally {
        this.dfa = void 0;
        input.seek(index);
        input.release(m);
      }
    }
    getStartState(dfa, input, outerContext, useContext) {
      if (!useContext) {
        if (dfa.isPrecedenceDfa) {
          let state = dfa.getPrecedenceStartState(this._parser.precedence, false);
          if (state == null) {
            return void 0;
          }
          return new SimulatorState_1.SimulatorState(outerContext, state, false, outerContext);
        } else {
          if (dfa.s0 == null) {
            return void 0;
          }
          return new SimulatorState_1.SimulatorState(outerContext, dfa.s0, false, outerContext);
        }
      }
      if (!this.enable_global_context_dfa) {
        return void 0;
      }
      let remainingContext = outerContext;
      assert(outerContext != null);
      let s0;
      if (dfa.isPrecedenceDfa) {
        s0 = dfa.getPrecedenceStartState(this._parser.precedence, true);
      } else {
        s0 = dfa.s0full;
      }
      while (remainingContext != null && s0 != null && s0.isContextSensitive) {
        remainingContext = this.skipTailCalls(remainingContext);
        s0 = s0.getContextTarget(this.getReturnState(remainingContext));
        if (remainingContext.isEmpty) {
          assert(s0 == null || !s0.isContextSensitive);
        } else {
          remainingContext = remainingContext.parent;
        }
      }
      if (s0 == null) {
        return void 0;
      }
      return new SimulatorState_1.SimulatorState(outerContext, s0, useContext, remainingContext);
    }
    execDFA(dfa, input, startIndex, state) {
      let outerContext = state.outerContext;
      if (ParserATNSimulator3.dfa_debug) {
        console.log("DFA decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this._parser));
      }
      if (ParserATNSimulator3.dfa_debug) {
        console.log(dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
      }
      let s = state.s0;
      let t = input.LA(1);
      let remainingOuterContext = state.remainingOuterContext;
      while (true) {
        if (ParserATNSimulator3.dfa_debug) {
          console.log("DFA state " + s.stateNumber + " LA(1)==" + this.getLookaheadName(input));
        }
        if (state.useContext) {
          while (s.isContextSymbol(t)) {
            let next;
            if (remainingOuterContext != null) {
              remainingOuterContext = this.skipTailCalls(remainingOuterContext);
              next = s.getContextTarget(this.getReturnState(remainingOuterContext));
            }
            if (next == null) {
              let initialState = new SimulatorState_1.SimulatorState(state.outerContext, s, state.useContext, remainingOuterContext);
              return this.execATN(dfa, input, startIndex, initialState);
            }
            assert(remainingOuterContext != null);
            remainingOuterContext = remainingOuterContext.parent;
            s = next;
          }
        }
        if (this.isAcceptState(s, state.useContext)) {
          if (s.predicates != null) {
            if (ParserATNSimulator3.dfa_debug) {
              console.log("accept " + s);
            }
          } else {
            if (ParserATNSimulator3.dfa_debug) {
              console.log("accept; predict " + s.prediction + " in state " + s.stateNumber);
            }
          }
          break;
        }
        assert(!this.isAcceptState(s, state.useContext));
        let target = this.getExistingTargetState(s, t);
        if (target == null) {
          if (ParserATNSimulator3.dfa_debug && t >= 0) {
            console.log("no edge for " + this._parser.vocabulary.getDisplayName(t));
          }
          let alt;
          if (ParserATNSimulator3.dfa_debug) {
            let interval = Interval_1.Interval.of(startIndex, this._parser.inputStream.index);
            console.log("ATN exec upon " + this._parser.inputStream.getText(interval) + " at DFA state " + s.stateNumber);
          }
          let initialState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
          alt = this.execATN(dfa, input, startIndex, initialState);
          if (ParserATNSimulator3.dfa_debug) {
            console.log("back from DFA update, alt=" + alt + ", dfa=\n" + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));
          }
          if (ParserATNSimulator3.dfa_debug) {
            console.log("DFA decision " + dfa.decision + " predicts " + alt);
          }
          return alt;
        } else if (target === ATNSimulator_1.ATNSimulator.ERROR) {
          let errorState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
          return this.handleNoViableAlt(input, startIndex, errorState);
        }
        s = target;
        if (!this.isAcceptState(s, state.useContext) && t !== IntStream_1.IntStream.EOF) {
          input.consume();
          t = input.LA(1);
        }
      }
      if (!state.useContext && s.configs.conflictInfo != null) {
        if (dfa.atnStartState instanceof DecisionState_1.DecisionState) {
          if (!this.userWantsCtxSensitive || !s.configs.dipsIntoOuterContext && s.configs.isExactConflict || this.treat_sllk1_conflict_as_ambiguity && input.index === startIndex) {
          } else {
            assert(!state.useContext);
            let conflictingAlts;
            let predicates2 = s.predicates;
            if (predicates2 != null) {
              let conflictIndex = input.index;
              if (conflictIndex !== startIndex) {
                input.seek(startIndex);
              }
              conflictingAlts = this.evalSemanticContext(predicates2, outerContext, true);
              if (conflictingAlts.cardinality() === 1) {
                return conflictingAlts.nextSetBit(0);
              }
              if (conflictIndex !== startIndex) {
                input.seek(conflictIndex);
              }
            }
            if (this.reportAmbiguities) {
              let conflictState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);
              this.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, input.index);
            }
            input.seek(startIndex);
            return this.adaptivePredict(input, dfa.decision, outerContext, true);
          }
        }
      }
      let predicates = s.predicates;
      if (predicates != null) {
        let stopIndex = input.index;
        if (startIndex !== stopIndex) {
          input.seek(startIndex);
        }
        let alts = this.evalSemanticContext(predicates, outerContext, this.reportAmbiguities && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION);
        switch (alts.cardinality()) {
          case 0:
            throw this.noViableAlt(input, outerContext, s.configs, startIndex);
          case 1:
            return alts.nextSetBit(0);
          default:
            if (startIndex !== stopIndex) {
              input.seek(stopIndex);
            }
            this.reportAmbiguity(dfa, s, startIndex, stopIndex, s.configs.isExactConflict, alts, s.configs);
            return alts.nextSetBit(0);
        }
      }
      if (ParserATNSimulator3.dfa_debug) {
        console.log("DFA decision " + dfa.decision + " predicts " + s.prediction);
      }
      return s.prediction;
    }
    isAcceptState(state, useContext) {
      if (!state.isAcceptState) {
        return false;
      }
      if (state.configs.conflictingAlts == null) {
        return true;
      }
      if (useContext && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION) {
        return state.configs.isExactConflict;
      }
      return true;
    }
    execATN(dfa, input, startIndex, initialState) {
      if (ParserATNSimulator3.debug) {
        console.log("execATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input));
      }
      let outerContext = initialState.outerContext;
      let useContext = initialState.useContext;
      let t = input.LA(1);
      let previous = initialState;
      let contextCache = new PredictionContextCache_1.PredictionContextCache();
      while (true) {
        let nextState = this.computeReachSet(dfa, previous, t, contextCache);
        if (nextState == null) {
          this.setDFAEdge(previous.s0, input.LA(1), ATNSimulator_1.ATNSimulator.ERROR);
          return this.handleNoViableAlt(input, startIndex, previous);
        }
        let D = nextState.s0;
        assert(D.isAcceptState || D.prediction === ATN_1.ATN.INVALID_ALT_NUMBER);
        assert(D.isAcceptState || D.configs.conflictInfo == null);
        if (this.isAcceptState(D, useContext)) {
          let conflictingAlts = D.configs.conflictingAlts;
          let predictedAlt = conflictingAlts == null ? D.prediction : ATN_1.ATN.INVALID_ALT_NUMBER;
          if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
            if (this.optimize_ll1 && input.index === startIndex && !dfa.isPrecedenceDfa && nextState.outerContext === nextState.remainingOuterContext && dfa.decision >= 0 && !D.configs.hasSemanticContext) {
              if (t >= 0 && t <= MAX_SHORT_VALUE) {
                let key = (dfa.decision << 16 >>> 0) + t;
                this.atn.LL1Table.set(key, predictedAlt);
              }
            }
            if (useContext && this.always_try_local_context) {
              this.reportContextSensitivity(dfa, predictedAlt, nextState, startIndex, input.index);
            }
          }
          predictedAlt = D.prediction;
          let attemptFullContext = conflictingAlts != null && this.userWantsCtxSensitive;
          if (attemptFullContext) {
            attemptFullContext = !useContext && (D.configs.dipsIntoOuterContext || !D.configs.isExactConflict) && (!this.treat_sllk1_conflict_as_ambiguity || input.index !== startIndex);
          }
          if (D.configs.hasSemanticContext) {
            let predPredictions = D.predicates;
            if (predPredictions != null) {
              let conflictIndex = input.index;
              if (conflictIndex !== startIndex) {
                input.seek(startIndex);
              }
              conflictingAlts = this.evalSemanticContext(predPredictions, outerContext, attemptFullContext || this.reportAmbiguities);
              switch (conflictingAlts.cardinality()) {
                case 0:
                  throw this.noViableAlt(input, outerContext, D.configs, startIndex);
                case 1:
                  return conflictingAlts.nextSetBit(0);
                default:
                  break;
              }
              if (conflictIndex !== startIndex) {
                input.seek(conflictIndex);
              }
            }
          }
          if (!attemptFullContext) {
            if (conflictingAlts != null) {
              if (this.reportAmbiguities && conflictingAlts.cardinality() > 1) {
                this.reportAmbiguity(dfa, D, startIndex, input.index, D.configs.isExactConflict, conflictingAlts, D.configs);
              }
              predictedAlt = conflictingAlts.nextSetBit(0);
            }
            return predictedAlt;
          } else {
            assert(!useContext);
            assert(this.isAcceptState(D, false));
            if (ParserATNSimulator3.debug) {
              console.log("RETRY with outerContext=" + outerContext);
            }
            let fullContextState = this.computeStartState(dfa, outerContext, true);
            if (this.reportAmbiguities) {
              this.reportAttemptingFullContext(dfa, conflictingAlts, nextState, startIndex, input.index);
            }
            input.seek(startIndex);
            return this.execATN(dfa, input, startIndex, fullContextState);
          }
        }
        previous = nextState;
        if (t !== IntStream_1.IntStream.EOF) {
          input.consume();
          t = input.LA(1);
        }
      }
    }
    handleNoViableAlt(input, startIndex, previous) {
      if (previous.s0 != null) {
        let alts = new BitSet_1.BitSet();
        let maxAlt = 0;
        for (let config of previous.s0.configs) {
          if (config.reachesIntoOuterContext || config.state instanceof RuleStopState_1.RuleStopState) {
            alts.set(config.alt);
            maxAlt = Math.max(maxAlt, config.alt);
          }
        }
        switch (alts.cardinality()) {
          case 0:
            break;
          case 1:
            return alts.nextSetBit(0);
          default:
            if (!previous.s0.configs.hasSemanticContext) {
              return alts.nextSetBit(0);
            }
            let filteredConfigs = new ATNConfigSet_1.ATNConfigSet();
            for (let config of previous.s0.configs) {
              if (config.reachesIntoOuterContext || config.state instanceof RuleStopState_1.RuleStopState) {
                filteredConfigs.add(config);
              }
            }
            let altToPred = this.getPredsForAmbigAlts(alts, filteredConfigs, maxAlt);
            if (altToPred != null) {
              let predicates = this.getPredicatePredictions(alts, altToPred);
              if (predicates != null) {
                let stopIndex = input.index;
                try {
                  input.seek(startIndex);
                  let filteredAlts = this.evalSemanticContext(predicates, previous.outerContext, false);
                  if (!filteredAlts.isEmpty) {
                    return filteredAlts.nextSetBit(0);
                  }
                } finally {
                  input.seek(stopIndex);
                }
              }
            }
            return alts.nextSetBit(0);
        }
      }
      throw this.noViableAlt(input, previous.outerContext, previous.s0.configs, startIndex);
    }
    computeReachSet(dfa, previous, t, contextCache) {
      let useContext = previous.useContext;
      let remainingGlobalContext = previous.remainingOuterContext;
      let s = previous.s0;
      if (useContext) {
        while (s.isContextSymbol(t)) {
          let next;
          if (remainingGlobalContext != null) {
            remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
            next = s.getContextTarget(this.getReturnState(remainingGlobalContext));
          }
          if (next == null) {
            break;
          }
          assert(remainingGlobalContext != null);
          remainingGlobalContext = remainingGlobalContext.parent;
          s = next;
        }
      }
      assert(!this.isAcceptState(s, useContext));
      if (this.isAcceptState(s, useContext)) {
        return new SimulatorState_1.SimulatorState(previous.outerContext, s, useContext, remainingGlobalContext);
      }
      let s0 = s;
      let target = this.getExistingTargetState(s0, t);
      if (target == null) {
        let result = this.computeTargetState(dfa, s0, remainingGlobalContext, t, useContext, contextCache);
        target = result[0];
        remainingGlobalContext = result[1];
      }
      if (target === ATNSimulator_1.ATNSimulator.ERROR) {
        return void 0;
      }
      assert(!useContext || !target.configs.dipsIntoOuterContext);
      return new SimulatorState_1.SimulatorState(previous.outerContext, target, useContext, remainingGlobalContext);
    }
    getExistingTargetState(s, t) {
      return s.getTarget(t);
    }
    computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {
      let closureConfigs = s.configs.toArray();
      let contextElements;
      let reach = new ATNConfigSet_1.ATNConfigSet();
      let stepIntoGlobal;
      do {
        let hasMoreContext = !useContext || remainingGlobalContext != null;
        if (!hasMoreContext) {
          reach.isOutermostConfigSet = true;
        }
        let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();
        let skippedStopStates;
        for (let c of closureConfigs) {
          if (ParserATNSimulator3.debug) {
            console.log("testing " + this.getTokenName(t) + " at " + c.toString());
          }
          if (c.state instanceof RuleStopState_1.RuleStopState) {
            assert(c.context.isEmpty);
            if (useContext && !c.reachesIntoOuterContext || t === IntStream_1.IntStream.EOF) {
              if (skippedStopStates == null) {
                skippedStopStates = [];
              }
              skippedStopStates.push(c);
            }
            continue;
          }
          let n = c.state.numberOfOptimizedTransitions;
          for (let ti = 0; ti < n; ti++) {
            let trans = c.state.getOptimizedTransition(ti);
            let target = this.getReachableTarget(c, trans, t);
            if (target != null) {
              reachIntermediate.add(c.transform(target, false), contextCache);
            }
          }
        }
        if (this.optimize_unique_closure && skippedStopStates == null && t !== Token_1.Token.EOF && reachIntermediate.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
          reachIntermediate.isOutermostConfigSet = reach.isOutermostConfigSet;
          reach = reachIntermediate;
          break;
        }
        let collectPredicates = false;
        let treatEofAsEpsilon = t === Token_1.Token.EOF;
        this.closure(reachIntermediate, reach, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon);
        stepIntoGlobal = reach.dipsIntoOuterContext;
        if (t === IntStream_1.IntStream.EOF) {
          reach = this.removeAllConfigsNotInRuleStopState(reach, contextCache);
        }
        if (skippedStopStates != null && (!useContext || !PredictionMode_1.PredictionMode.hasConfigInRuleStopState(reach))) {
          assert(skippedStopStates.length > 0);
          for (let c of skippedStopStates) {
            reach.add(c, contextCache);
          }
        }
        if (useContext && stepIntoGlobal) {
          reach.clear();
          remainingGlobalContext = remainingGlobalContext;
          remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
          let nextContextElement = this.getReturnState(remainingGlobalContext);
          if (contextElements == null) {
            contextElements = new IntegerList_1.IntegerList();
          }
          if (remainingGlobalContext.isEmpty) {
            remainingGlobalContext = void 0;
          } else {
            remainingGlobalContext = remainingGlobalContext.parent;
          }
          contextElements.add(nextContextElement);
          if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
            for (let i = 0; i < closureConfigs.length; i++) {
              closureConfigs[i] = closureConfigs[i].appendContext(nextContextElement, contextCache);
            }
          }
        }
      } while (useContext && stepIntoGlobal);
      if (reach.isEmpty) {
        this.setDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);
        return [ATNSimulator_1.ATNSimulator.ERROR, remainingGlobalContext];
      }
      let result = this.addDFAEdge(dfa, s, t, contextElements, reach, contextCache);
      return [result, remainingGlobalContext];
    }
    removeAllConfigsNotInRuleStopState(configs, contextCache) {
      if (PredictionMode_1.PredictionMode.allConfigsInRuleStopStates(configs)) {
        return configs;
      }
      let result = new ATNConfigSet_1.ATNConfigSet();
      for (let config of configs) {
        if (!(config.state instanceof RuleStopState_1.RuleStopState)) {
          continue;
        }
        result.add(config, contextCache);
      }
      return result;
    }
    computeStartState(dfa, globalContext, useContext) {
      let s0 = dfa.isPrecedenceDfa ? dfa.getPrecedenceStartState(this._parser.precedence, useContext) : useContext ? dfa.s0full : dfa.s0;
      if (s0 != null) {
        if (!useContext) {
          return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, globalContext);
        }
        s0.setContextSensitive(this.atn);
      }
      let decision = dfa.decision;
      let p = dfa.atnStartState;
      let previousContext = 0;
      let remainingGlobalContext = globalContext;
      let initialContext = useContext ? PredictionContext_1.PredictionContext.EMPTY_FULL : PredictionContext_1.PredictionContext.EMPTY_LOCAL;
      let contextCache = new PredictionContextCache_1.PredictionContextCache();
      if (useContext) {
        if (!this.enable_global_context_dfa) {
          while (remainingGlobalContext != null) {
            if (remainingGlobalContext.isEmpty) {
              previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
              remainingGlobalContext = void 0;
            } else {
              previousContext = this.getReturnState(remainingGlobalContext);
              initialContext = initialContext.appendSingleContext(previousContext, contextCache);
              remainingGlobalContext = remainingGlobalContext.parent;
            }
          }
        }
        while (s0 != null && s0.isContextSensitive && remainingGlobalContext != null) {
          let next;
          remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
          if (remainingGlobalContext.isEmpty) {
            next = s0.getContextTarget(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY);
            previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
            remainingGlobalContext = void 0;
          } else {
            previousContext = this.getReturnState(remainingGlobalContext);
            next = s0.getContextTarget(previousContext);
            initialContext = initialContext.appendSingleContext(previousContext, contextCache);
            remainingGlobalContext = remainingGlobalContext.parent;
          }
          if (next == null) {
            break;
          }
          s0 = next;
        }
      }
      if (s0 != null && !s0.isContextSensitive) {
        return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);
      }
      let configs = new ATNConfigSet_1.ATNConfigSet();
      while (true) {
        let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();
        let n = p.numberOfTransitions;
        for (let ti = 0; ti < n; ti++) {
          let target = p.transition(ti).target;
          reachIntermediate.add(ATNConfig_1.ATNConfig.create(target, ti + 1, initialContext));
        }
        let hasMoreContext = remainingGlobalContext != null;
        if (!hasMoreContext) {
          configs.isOutermostConfigSet = true;
        }
        let collectPredicates = true;
        this.closure(reachIntermediate, configs, collectPredicates, hasMoreContext, contextCache, false);
        let stepIntoGlobal = configs.dipsIntoOuterContext;
        let next;
        if (useContext && !this.enable_global_context_dfa) {
          s0 = this.addDFAState(dfa, configs, contextCache);
          break;
        } else if (s0 == null) {
          if (!dfa.isPrecedenceDfa) {
            next = this.addDFAState(dfa, configs, contextCache);
            if (useContext) {
              if (!dfa.s0full) {
                dfa.s0full = next;
              } else {
                next = dfa.s0full;
              }
            } else {
              if (!dfa.s0) {
                dfa.s0 = next;
              } else {
                next = dfa.s0;
              }
            }
          } else {
            configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);
            next = this.addDFAState(dfa, configs, contextCache);
            dfa.setPrecedenceStartState(this._parser.precedence, useContext, next);
          }
        } else {
          if (dfa.isPrecedenceDfa) {
            configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);
          }
          next = this.addDFAState(dfa, configs, contextCache);
          s0.setContextTarget(previousContext, next);
        }
        s0 = next;
        if (!useContext || !stepIntoGlobal) {
          break;
        }
        next.setContextSensitive(this.atn);
        remainingGlobalContext = remainingGlobalContext;
        configs.clear();
        remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);
        let nextContextElement = this.getReturnState(remainingGlobalContext);
        if (remainingGlobalContext.isEmpty) {
          remainingGlobalContext = void 0;
        } else {
          remainingGlobalContext = remainingGlobalContext.parent;
        }
        if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
          initialContext = initialContext.appendSingleContext(nextContextElement, contextCache);
        }
        previousContext = nextContextElement;
      }
      return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);
    }
    applyPrecedenceFilter(configs, globalContext, contextCache) {
      let statesFromAlt1 = new Map();
      let configSet = new ATNConfigSet_1.ATNConfigSet();
      for (let config of configs) {
        if (config.alt !== 1) {
          continue;
        }
        let updatedContext = config.semanticContext.evalPrecedence(this._parser, globalContext);
        if (updatedContext == null) {
          continue;
        }
        statesFromAlt1.set(config.state.stateNumber, config.context);
        if (updatedContext !== config.semanticContext) {
          configSet.add(config.transform(config.state, false, updatedContext), contextCache);
        } else {
          configSet.add(config, contextCache);
        }
      }
      for (let config of configs) {
        if (config.alt === 1) {
          continue;
        }
        if (!config.isPrecedenceFilterSuppressed) {
          let context = statesFromAlt1.get(config.state.stateNumber);
          if (context != null && context.equals(config.context)) {
            continue;
          }
        }
        configSet.add(config, contextCache);
      }
      return configSet;
    }
    getReachableTarget(source, trans, ttype) {
      if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
        return trans.target;
      }
      return void 0;
    }
    predicateDFAState(D, configs, nalts) {
      let conflictingAlts = this.getConflictingAltsFromConfigSet(configs);
      if (!conflictingAlts) {
        throw new Error("This unhandled scenario is intended to be unreachable, but I'm currently not sure of why we know that's the case.");
      }
      if (ParserATNSimulator3.debug) {
        console.log("predicateDFAState " + D);
      }
      let altToPred = this.getPredsForAmbigAlts(conflictingAlts, configs, nalts);
      let predPredictions;
      if (altToPred != null) {
        predPredictions = this.getPredicatePredictions(conflictingAlts, altToPred);
        D.predicates = predPredictions;
      }
      return predPredictions;
    }
    getPredsForAmbigAlts(ambigAlts, configs, nalts) {
      let altToPred = new Array(nalts + 1);
      let n = altToPred.length;
      for (let c of configs) {
        if (ambigAlts.get(c.alt)) {
          altToPred[c.alt] = SemanticContext_1.SemanticContext.or(altToPred[c.alt], c.semanticContext);
        }
      }
      let nPredAlts = 0;
      for (let i = 0; i < n; i++) {
        if (altToPred[i] == null) {
          altToPred[i] = SemanticContext_1.SemanticContext.NONE;
        } else if (altToPred[i] !== SemanticContext_1.SemanticContext.NONE) {
          nPredAlts++;
        }
      }
      let result = altToPred;
      if (nPredAlts === 0) {
        result = void 0;
      }
      if (ParserATNSimulator3.debug) {
        console.log("getPredsForAmbigAlts result " + (result ? Arrays_1.Arrays.toString(result) : "undefined"));
      }
      return result;
    }
    getPredicatePredictions(ambigAlts, altToPred) {
      let pairs = [];
      let containsPredicate = false;
      for (let i = 1; i < altToPred.length; i++) {
        let pred = altToPred[i];
        assert(pred != null);
        if (ambigAlts != null && ambigAlts.get(i) && pred === SemanticContext_1.SemanticContext.NONE) {
          pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i));
        } else if (pred !== SemanticContext_1.SemanticContext.NONE) {
          containsPredicate = true;
          pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i));
        }
      }
      if (!containsPredicate) {
        return void 0;
      }
      return pairs;
    }
    evalSemanticContext(predPredictions, outerContext, complete) {
      let predictions = new BitSet_1.BitSet();
      for (let pair of predPredictions) {
        if (pair.pred === SemanticContext_1.SemanticContext.NONE) {
          predictions.set(pair.alt);
          if (!complete) {
            break;
          }
          continue;
        }
        let evaluatedResult = this.evalSemanticContextImpl(pair.pred, outerContext, pair.alt);
        if (ParserATNSimulator3.debug || ParserATNSimulator3.dfa_debug) {
          console.log("eval pred " + pair + "=" + evaluatedResult);
        }
        if (evaluatedResult) {
          if (ParserATNSimulator3.debug || ParserATNSimulator3.dfa_debug) {
            console.log("PREDICT " + pair.alt);
          }
          predictions.set(pair.alt);
          if (!complete) {
            break;
          }
        }
      }
      return predictions;
    }
    evalSemanticContextImpl(pred, parserCallStack, alt) {
      return pred.eval(this._parser, parserCallStack);
    }
    closure(sourceConfigs, configs, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon) {
      if (contextCache == null) {
        contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;
      }
      let currentConfigs = sourceConfigs;
      let closureBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);
      while (currentConfigs.size > 0) {
        let intermediate = new ATNConfigSet_1.ATNConfigSet();
        for (let config of currentConfigs) {
          this.closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContext, contextCache, 0, treatEofAsEpsilon);
        }
        currentConfigs = intermediate;
      }
    }
    closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth, treatEofAsEpsilon) {
      if (ParserATNSimulator3.debug) {
        console.log("closure(" + config.toString(this._parser, true) + ")");
      }
      if (config.state instanceof RuleStopState_1.RuleStopState) {
        if (!config.context.isEmpty) {
          let hasEmpty = config.context.hasEmpty;
          let nonEmptySize = config.context.size - (hasEmpty ? 1 : 0);
          for (let i = 0; i < nonEmptySize; i++) {
            let newContext = config.context.getParent(i);
            let returnState = this.atn.states[config.context.getReturnState(i)];
            let c = ATNConfig_1.ATNConfig.create(returnState, config.alt, newContext, config.semanticContext);
            c.outerContextDepth = config.outerContextDepth;
            c.isPrecedenceFilterSuppressed = config.isPrecedenceFilterSuppressed;
            assert(depth > MIN_INTEGER_VALUE);
            this.closureImpl(c, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth - 1, treatEofAsEpsilon);
          }
          if (!hasEmpty || !hasMoreContexts) {
            return;
          }
          config = config.transform(config.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
        } else if (!hasMoreContexts) {
          configs.add(config, contextCache);
          return;
        } else {
          if (ParserATNSimulator3.debug) {
            console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
          }
          if (config.context === PredictionContext_1.PredictionContext.EMPTY_FULL) {
            config = config.transform(config.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);
          } else if (!config.reachesIntoOuterContext && PredictionContext_1.PredictionContext.isEmptyLocal(config.context)) {
            configs.add(config, contextCache);
          }
        }
      }
      let p = config.state;
      if (!p.onlyHasEpsilonTransitions) {
        configs.add(config, contextCache);
        if (ParserATNSimulator3.debug) {
          console.log("added config " + configs);
        }
      }
      for (let i = 0; i < p.numberOfOptimizedTransitions; i++) {
        if (i === 0 && p.stateType === ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY && p.precedenceRuleDecision && !config.context.hasEmpty) {
          let precedenceDecision = p;
          let suppress = true;
          for (let j = 0; j < config.context.size; j++) {
            if (!precedenceDecision.precedenceLoopbackStates.get(config.context.getReturnState(j))) {
              suppress = false;
              break;
            }
          }
          if (suppress) {
            continue;
          }
        }
        let t = p.getOptimizedTransition(i);
        let continueCollecting = !(t instanceof ActionTransition_1.ActionTransition) && collectPredicates;
        let c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, contextCache, treatEofAsEpsilon);
        if (c != null) {
          if (t instanceof RuleTransition_1.RuleTransition) {
            if (intermediate != null && !collectPredicates) {
              intermediate.add(c, contextCache);
              continue;
            }
          }
          let newDepth = depth;
          if (config.state instanceof RuleStopState_1.RuleStopState) {
            if (this.dfa != null && this.dfa.isPrecedenceDfa) {
              let outermostPrecedenceReturn = t.outermostPrecedenceReturn;
              if (outermostPrecedenceReturn === this.dfa.atnStartState.ruleIndex) {
                c.isPrecedenceFilterSuppressed = true;
              }
            }
            c.outerContextDepth = c.outerContextDepth + 1;
            if (!closureBusy.add(c)) {
              continue;
            }
            assert(newDepth > MIN_INTEGER_VALUE);
            newDepth--;
            if (ParserATNSimulator3.debug) {
              console.log("dips into outer ctx: " + c);
            }
          } else if (t instanceof RuleTransition_1.RuleTransition) {
            if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config.context))) {
              assert(c.context === config.context);
              if (newDepth === 0) {
                newDepth--;
                if (!this.tail_call_preserves_sll && PredictionContext_1.PredictionContext.isEmptyLocal(config.context)) {
                  c.outerContextDepth = c.outerContextDepth + 1;
                }
              }
            } else {
              if (newDepth >= 0) {
                newDepth++;
              }
            }
          } else {
            if (!t.isEpsilon && !closureBusy.add(c)) {
              continue;
            }
          }
          this.closureImpl(c, configs, intermediate, closureBusy, continueCollecting, hasMoreContexts, contextCache, newDepth, treatEofAsEpsilon);
        }
      }
    }
    getRuleName(index) {
      if (this._parser != null && index >= 0) {
        return this._parser.ruleNames[index];
      }
      return "<rule " + index + ">";
    }
    getEpsilonTarget(config, t, collectPredicates, inContext, contextCache, treatEofAsEpsilon) {
      switch (t.serializationType) {
        case 3:
          return this.ruleTransition(config, t, contextCache);
        case 10:
          return this.precedenceTransition(config, t, collectPredicates, inContext);
        case 4:
          return this.predTransition(config, t, collectPredicates, inContext);
        case 6:
          return this.actionTransition(config, t);
        case 1:
          return config.transform(t.target, false);
        case 5:
        case 2:
        case 7:
          if (treatEofAsEpsilon) {
            if (t.matches(Token_1.Token.EOF, 0, 1)) {
              return config.transform(t.target, false);
            }
          }
          return void 0;
        default:
          return void 0;
      }
    }
    actionTransition(config, t) {
      if (ParserATNSimulator3.debug) {
        console.log("ACTION edge " + t.ruleIndex + ":" + t.actionIndex);
      }
      return config.transform(t.target, false);
    }
    precedenceTransition(config, pt, collectPredicates, inContext) {
      if (ParserATNSimulator3.debug) {
        console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.precedence + ">=_p, ctx dependent=true");
        if (this._parser != null) {
          console.log("context surrounding pred is " + this._parser.getRuleInvocationStack());
        }
      }
      let c;
      if (collectPredicates && inContext) {
        let newSemCtx = SemanticContext_1.SemanticContext.and(config.semanticContext, pt.predicate);
        c = config.transform(pt.target, false, newSemCtx);
      } else {
        c = config.transform(pt.target, false);
      }
      if (ParserATNSimulator3.debug) {
        console.log("config from pred transition=" + c);
      }
      return c;
    }
    predTransition(config, pt, collectPredicates, inContext) {
      if (ParserATNSimulator3.debug) {
        console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex + ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
        if (this._parser != null) {
          console.log("context surrounding pred is " + this._parser.getRuleInvocationStack());
        }
      }
      let c;
      if (collectPredicates && (!pt.isCtxDependent || pt.isCtxDependent && inContext)) {
        let newSemCtx = SemanticContext_1.SemanticContext.and(config.semanticContext, pt.predicate);
        c = config.transform(pt.target, false, newSemCtx);
      } else {
        c = config.transform(pt.target, false);
      }
      if (ParserATNSimulator3.debug) {
        console.log("config from pred transition=" + c);
      }
      return c;
    }
    ruleTransition(config, t, contextCache) {
      if (ParserATNSimulator3.debug) {
        console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config.context);
      }
      let returnState = t.followState;
      let newContext;
      if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config.context))) {
        newContext = config.context;
      } else if (contextCache != null) {
        newContext = contextCache.getChild(config.context, returnState.stateNumber);
      } else {
        newContext = config.context.getChild(returnState.stateNumber);
      }
      return config.transform(t.target, false, newContext);
    }
    isConflicted(configset, contextCache) {
      if (configset.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER || configset.size <= 1) {
        return void 0;
      }
      let configs = configset.toArray();
      configs.sort(ParserATNSimulator3.STATE_ALT_SORT_COMPARATOR);
      let exact = !configset.dipsIntoOuterContext;
      let alts = new BitSet_1.BitSet();
      let minAlt = configs[0].alt;
      alts.set(minAlt);
      let currentState = configs[0].state.nonStopStateNumber;
      for (let config of configs) {
        let stateNumber = config.state.nonStopStateNumber;
        if (stateNumber !== currentState) {
          if (config.alt !== minAlt) {
            return void 0;
          }
          currentState = stateNumber;
        }
      }
      let representedAlts;
      if (exact) {
        currentState = configs[0].state.nonStopStateNumber;
        representedAlts = new BitSet_1.BitSet();
        let maxAlt = minAlt;
        for (let config of configs) {
          if (config.state.nonStopStateNumber !== currentState) {
            break;
          }
          let alt = config.alt;
          representedAlts.set(alt);
          maxAlt = alt;
        }
        currentState = configs[0].state.nonStopStateNumber;
        let currentAlt = minAlt;
        for (let config of configs) {
          let stateNumber = config.state.nonStopStateNumber;
          let alt = config.alt;
          if (stateNumber !== currentState) {
            if (currentAlt !== maxAlt) {
              exact = false;
              break;
            }
            currentState = stateNumber;
            currentAlt = minAlt;
          } else if (alt !== currentAlt) {
            if (alt !== representedAlts.nextSetBit(currentAlt + 1)) {
              exact = false;
              break;
            }
            currentAlt = alt;
          }
        }
      }
      currentState = configs[0].state.nonStopStateNumber;
      let firstIndexCurrentState = 0;
      let lastIndexCurrentStateMinAlt = 0;
      let joinedCheckContext = configs[0].context;
      for (let i = 1; i < configs.length; i++) {
        let config = configs[i];
        if (config.alt !== minAlt) {
          break;
        }
        if (config.state.nonStopStateNumber !== currentState) {
          break;
        }
        lastIndexCurrentStateMinAlt = i;
        joinedCheckContext = contextCache.join(joinedCheckContext, configs[i].context);
      }
      for (let i = lastIndexCurrentStateMinAlt + 1; i < configs.length; i++) {
        let config = configs[i];
        let state = config.state;
        alts.set(config.alt);
        if (state.nonStopStateNumber !== currentState) {
          currentState = state.nonStopStateNumber;
          firstIndexCurrentState = i;
          lastIndexCurrentStateMinAlt = i;
          joinedCheckContext = config.context;
          for (let j = firstIndexCurrentState + 1; j < configs.length; j++) {
            let config2 = configs[j];
            if (config2.alt !== minAlt) {
              break;
            }
            if (config2.state.nonStopStateNumber !== currentState) {
              break;
            }
            lastIndexCurrentStateMinAlt = j;
            joinedCheckContext = contextCache.join(joinedCheckContext, config2.context);
          }
          i = lastIndexCurrentStateMinAlt;
          continue;
        }
        let joinedCheckContext2 = config.context;
        let currentAlt = config.alt;
        let lastIndexCurrentStateCurrentAlt = i;
        for (let j = lastIndexCurrentStateCurrentAlt + 1; j < configs.length; j++) {
          let config2 = configs[j];
          if (config2.alt !== currentAlt) {
            break;
          }
          if (config2.state.nonStopStateNumber !== currentState) {
            break;
          }
          lastIndexCurrentStateCurrentAlt = j;
          joinedCheckContext2 = contextCache.join(joinedCheckContext2, config2.context);
        }
        i = lastIndexCurrentStateCurrentAlt;
        let check = contextCache.join(joinedCheckContext, joinedCheckContext2);
        if (!joinedCheckContext.equals(check)) {
          return void 0;
        }
        exact = exact && joinedCheckContext.equals(joinedCheckContext2);
      }
      return new ConflictInfo_1.ConflictInfo(alts, exact);
    }
    getConflictingAltsFromConfigSet(configs) {
      let conflictingAlts = configs.conflictingAlts;
      if (conflictingAlts == null && configs.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
        conflictingAlts = new BitSet_1.BitSet();
        conflictingAlts.set(configs.uniqueAlt);
      }
      return conflictingAlts;
    }
    getTokenName(t) {
      if (t === Token_1.Token.EOF) {
        return "EOF";
      }
      let vocabulary = this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;
      let displayName = vocabulary.getDisplayName(t);
      if (displayName === String(t)) {
        return displayName;
      }
      return displayName + "<" + t + ">";
    }
    getLookaheadName(input) {
      return this.getTokenName(input.LA(1));
    }
    dumpDeadEndConfigs(nvae) {
      console.log("dead end configs: ");
      let deadEndConfigs = nvae.deadEndConfigs;
      if (!deadEndConfigs) {
        return;
      }
      for (let c of deadEndConfigs) {
        let trans = "no edges";
        if (c.state.numberOfOptimizedTransitions > 0) {
          let t = c.state.getOptimizedTransition(0);
          if (t instanceof AtomTransition_1.AtomTransition) {
            trans = "Atom " + this.getTokenName(t._label);
          } else if (t instanceof SetTransition_1.SetTransition) {
            let not = t instanceof NotSetTransition_1.NotSetTransition;
            trans = (not ? "~" : "") + "Set " + t.set.toString();
          }
        }
        console.log(c.toString(this._parser, true) + ":" + trans);
      }
    }
    noViableAlt(input, outerContext, configs, startIndex) {
      return new NoViableAltException_1.NoViableAltException(this._parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
    }
    getUniqueAlt(configs) {
      let alt = ATN_1.ATN.INVALID_ALT_NUMBER;
      for (let c of configs) {
        if (alt === ATN_1.ATN.INVALID_ALT_NUMBER) {
          alt = c.alt;
        } else if (c.alt !== alt) {
          return ATN_1.ATN.INVALID_ALT_NUMBER;
        }
      }
      return alt;
    }
    configWithAltAtStopState(configs, alt) {
      for (let c of configs) {
        if (c.alt === alt) {
          if (c.state instanceof RuleStopState_1.RuleStopState) {
            return true;
          }
        }
      }
      return false;
    }
    addDFAEdge(dfa, fromState, t, contextTransitions, toConfigs, contextCache) {
      assert(contextTransitions == null || contextTransitions.isEmpty || dfa.isContextSensitive);
      let from = fromState;
      let to = this.addDFAState(dfa, toConfigs, contextCache);
      if (contextTransitions != null) {
        for (let context of contextTransitions.toArray()) {
          if (context === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
            if (from.configs.isOutermostConfigSet) {
              continue;
            }
          }
          from.setContextSensitive(this.atn);
          from.setContextSymbol(t);
          let next = from.getContextTarget(context);
          if (next != null) {
            from = next;
            continue;
          }
          next = this.addDFAContextState(dfa, from.configs, context, contextCache);
          assert(context !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY || next.configs.isOutermostConfigSet);
          from.setContextTarget(context, next);
          from = next;
        }
      }
      if (ParserATNSimulator3.debug) {
        console.log("EDGE " + from + " -> " + to + " upon " + this.getTokenName(t));
      }
      this.setDFAEdge(from, t, to);
      if (ParserATNSimulator3.debug) {
        console.log("DFA=\n" + dfa.toString(this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY, this._parser != null ? this._parser.ruleNames : void 0));
      }
      return to;
    }
    setDFAEdge(p, t, q) {
      if (p != null) {
        p.setTarget(t, q);
      }
    }
    addDFAContextState(dfa, configs, returnContext, contextCache) {
      if (returnContext !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {
        let contextConfigs = new ATNConfigSet_1.ATNConfigSet();
        for (let config of configs) {
          contextConfigs.add(config.appendContext(returnContext, contextCache));
        }
        return this.addDFAState(dfa, contextConfigs, contextCache);
      } else {
        assert(!configs.isOutermostConfigSet, "Shouldn't be adding a duplicate edge.");
        configs = configs.clone(true);
        configs.isOutermostConfigSet = true;
        return this.addDFAState(dfa, configs, contextCache);
      }
    }
    addDFAState(dfa, configs, contextCache) {
      let enableDfa = this.enable_global_context_dfa || !configs.isOutermostConfigSet;
      if (enableDfa) {
        if (!configs.isReadOnly) {
          configs.optimizeConfigs(this);
        }
        let proposed = this.createDFAState(dfa, configs);
        let existing = dfa.states.get(proposed);
        if (existing != null) {
          return existing;
        }
      }
      if (!configs.isReadOnly) {
        if (configs.conflictInfo == null) {
          configs.conflictInfo = this.isConflicted(configs, contextCache);
        }
      }
      let newState = this.createDFAState(dfa, configs.clone(true));
      let decisionState = this.atn.getDecisionState(dfa.decision);
      let predictedAlt = this.getUniqueAlt(configs);
      if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {
        newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(predictedAlt);
      } else if (configs.conflictingAlts != null) {
        let conflictingAlts = configs.conflictingAlts;
        if (conflictingAlts) {
          newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(conflictingAlts.nextSetBit(0));
        }
      }
      if (newState.isAcceptState && configs.hasSemanticContext) {
        this.predicateDFAState(newState, configs, decisionState.numberOfTransitions);
      }
      if (!enableDfa) {
        return newState;
      }
      let added = dfa.addState(newState);
      if (ParserATNSimulator3.debug && added === newState) {
        console.log("adding new DFA state: " + newState);
      }
      return added;
    }
    createDFAState(dfa, configs) {
      return new DFAState_1.DFAState(configs);
    }
    reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {
      if (ParserATNSimulator3.debug || ParserATNSimulator3.retry_debug) {
        let interval = Interval_1.Interval.of(startIndex, stopIndex);
        console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + conflictState.s0.configs + ", input=" + this._parser.inputStream.getText(interval));
      }
      if (this._parser != null) {
        let listener = this._parser.getErrorListenerDispatch();
        if (listener.reportAttemptingFullContext) {
          listener.reportAttemptingFullContext(this._parser, dfa, startIndex, stopIndex, conflictingAlts, conflictState);
        }
      }
    }
    reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {
      if (ParserATNSimulator3.debug || ParserATNSimulator3.retry_debug) {
        let interval = Interval_1.Interval.of(startIndex, stopIndex);
        console.log("reportContextSensitivity decision=" + dfa.decision + ":" + acceptState.s0.configs + ", input=" + this._parser.inputStream.getText(interval));
      }
      if (this._parser != null) {
        let listener = this._parser.getErrorListenerDispatch();
        if (listener.reportContextSensitivity) {
          listener.reportContextSensitivity(this._parser, dfa, startIndex, stopIndex, prediction, acceptState);
        }
      }
    }
    reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
      if (ParserATNSimulator3.debug || ParserATNSimulator3.retry_debug) {
        let interval = Interval_1.Interval.of(startIndex, stopIndex);
        console.log("reportAmbiguity " + ambigAlts + ":" + configs + ", input=" + this._parser.inputStream.getText(interval));
      }
      if (this._parser != null) {
        let listener = this._parser.getErrorListenerDispatch();
        if (listener.reportAmbiguity) {
          listener.reportAmbiguity(this._parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
        }
      }
    }
    getReturnState(context) {
      if (context.isEmpty) {
        return PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;
      }
      let state = this.atn.states[context.invokingState];
      let transition = state.transition(0);
      return transition.followState.stateNumber;
    }
    skipTailCalls(context) {
      if (!this.optimize_tail_calls) {
        return context;
      }
      while (!context.isEmpty) {
        let state = this.atn.states[context.invokingState];
        assert(state.numberOfTransitions === 1 && state.transition(0).serializationType === 3);
        let transition = state.transition(0);
        if (!transition.tailCall) {
          break;
        }
        context = context.parent;
      }
      return context;
    }
    get parser() {
      return this._parser;
    }
  };
  ParserATNSimulator2.debug = false;
  ParserATNSimulator2.dfa_debug = false;
  ParserATNSimulator2.retry_debug = false;
  ParserATNSimulator2.STATE_ALT_SORT_COMPARATOR = (o1, o2) => {
    let diff = o1.state.nonStopStateNumber - o2.state.nonStopStateNumber;
    if (diff !== 0) {
      return diff;
    }
    diff = o1.alt - o2.alt;
    if (diff !== 0) {
      return diff;
    }
    return 0;
  };
  __decorate([
    Decorators_1.NotNull
  ], ParserATNSimulator2.prototype, "predictionMode", void 0);
  __decorate([
    Decorators_1.NotNull
  ], ParserATNSimulator2.prototype, "getPredictionMode", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "setPredictionMode", null);
  __decorate([
    Decorators_1.Override
  ], ParserATNSimulator2.prototype, "reset", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "adaptivePredict", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "getStartState", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull),
    __param(3, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "execDFA", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull),
    __param(3, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "execATN", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "handleNoViableAlt", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "getExistingTargetState", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "computeTargetState", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "removeAllConfigsNotInRuleStopState", null);
  __decorate([
    Decorators_1.NotNull
  ], ParserATNSimulator2.prototype, "computeStartState", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "applyPrecedenceFilter", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "getReachableTarget", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "getPredsForAmbigAlts", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "evalSemanticContext", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "evalSemanticContextImpl", null);
  __decorate([
    __param(1, Decorators_1.NotNull),
    __param(4, Decorators_1.Nullable)
  ], ParserATNSimulator2.prototype, "closure", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull),
    __param(2, Decorators_1.Nullable),
    __param(3, Decorators_1.NotNull),
    __param(6, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "closureImpl", null);
  __decorate([
    Decorators_1.NotNull
  ], ParserATNSimulator2.prototype, "getRuleName", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "getEpsilonTarget", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "actionTransition", null);
  __decorate([
    Decorators_1.Nullable,
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "precedenceTransition", null);
  __decorate([
    Decorators_1.Nullable,
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "predTransition", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull),
    __param(2, Decorators_1.Nullable)
  ], ParserATNSimulator2.prototype, "ruleTransition", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "isConflicted", null);
  __decorate([
    Decorators_1.NotNull
  ], ParserATNSimulator2.prototype, "getTokenName", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "dumpDeadEndConfigs", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "noViableAlt", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "getUniqueAlt", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "configWithAltAtStopState", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull),
    __param(4, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "addDFAEdge", null);
  __decorate([
    __param(0, Decorators_1.Nullable),
    __param(2, Decorators_1.Nullable)
  ], ParserATNSimulator2.prototype, "setDFAEdge", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "addDFAContextState", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "addDFAState", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "createDFAState", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "reportAttemptingFullContext", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "reportContextSensitivity", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(5, Decorators_1.NotNull),
    __param(6, Decorators_1.NotNull)
  ], ParserATNSimulator2.prototype, "reportAmbiguity", null);
  ParserATNSimulator2 = __decorate([
    __param(0, Decorators_1.NotNull)
  ], ParserATNSimulator2);
  exports.ParserATNSimulator = ParserATNSimulator2;
});

// node_modules/antlr4ts/atn/PlusBlockStartState.js
var require_PlusBlockStartState = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.PlusBlockStartState = void 0;
  var ATNStateType_1 = require_ATNStateType();
  var BlockStartState_1 = require_BlockStartState();
  var Decorators_1 = require_Decorators();
  var PlusBlockStartState = class extends BlockStartState_1.BlockStartState {
    get stateType() {
      return ATNStateType_1.ATNStateType.PLUS_BLOCK_START;
    }
  };
  __decorate([
    Decorators_1.Override
  ], PlusBlockStartState.prototype, "stateType", null);
  exports.PlusBlockStartState = PlusBlockStartState;
});

// node_modules/antlr4ts/atn/PlusLoopbackState.js
var require_PlusLoopbackState = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.PlusLoopbackState = void 0;
  var ATNStateType_1 = require_ATNStateType();
  var DecisionState_1 = require_DecisionState();
  var Decorators_1 = require_Decorators();
  var PlusLoopbackState = class extends DecisionState_1.DecisionState {
    get stateType() {
      return ATNStateType_1.ATNStateType.PLUS_LOOP_BACK;
    }
  };
  __decorate([
    Decorators_1.Override
  ], PlusLoopbackState.prototype, "stateType", null);
  exports.PlusLoopbackState = PlusLoopbackState;
});

// node_modules/antlr4ts/atn/PrecedencePredicateTransition.js
var require_PrecedencePredicateTransition = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.PrecedencePredicateTransition = void 0;
  var AbstractPredicateTransition_1 = require_AbstractPredicateTransition();
  var Decorators_1 = require_Decorators();
  var SemanticContext_1 = require_SemanticContext();
  var PrecedencePredicateTransition = class PrecedencePredicateTransition extends AbstractPredicateTransition_1.AbstractPredicateTransition {
    constructor(target, precedence) {
      super(target);
      this.precedence = precedence;
    }
    get serializationType() {
      return 10;
    }
    get isEpsilon() {
      return true;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return false;
    }
    get predicate() {
      return new SemanticContext_1.SemanticContext.PrecedencePredicate(this.precedence);
    }
    toString() {
      return this.precedence + " >= _p";
    }
  };
  __decorate([
    Decorators_1.Override
  ], PrecedencePredicateTransition.prototype, "serializationType", null);
  __decorate([
    Decorators_1.Override
  ], PrecedencePredicateTransition.prototype, "isEpsilon", null);
  __decorate([
    Decorators_1.Override
  ], PrecedencePredicateTransition.prototype, "matches", null);
  __decorate([
    Decorators_1.Override
  ], PrecedencePredicateTransition.prototype, "toString", null);
  PrecedencePredicateTransition = __decorate([
    __param(0, Decorators_1.NotNull)
  ], PrecedencePredicateTransition);
  exports.PrecedencePredicateTransition = PrecedencePredicateTransition;
});

// node_modules/antlr4ts/atn/RangeTransition.js
var require_RangeTransition = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.RangeTransition = void 0;
  var IntervalSet_1 = require_IntervalSet();
  var Decorators_1 = require_Decorators();
  var Transition_1 = require_Transition();
  var RangeTransition = class RangeTransition extends Transition_1.Transition {
    constructor(target, from, to) {
      super(target);
      this.from = from;
      this.to = to;
    }
    get serializationType() {
      return 2;
    }
    get label() {
      return IntervalSet_1.IntervalSet.of(this.from, this.to);
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return symbol >= this.from && symbol <= this.to;
    }
    toString() {
      return "'" + String.fromCodePoint(this.from) + "'..'" + String.fromCodePoint(this.to) + "'";
    }
  };
  __decorate([
    Decorators_1.Override
  ], RangeTransition.prototype, "serializationType", null);
  __decorate([
    Decorators_1.Override,
    Decorators_1.NotNull
  ], RangeTransition.prototype, "label", null);
  __decorate([
    Decorators_1.Override
  ], RangeTransition.prototype, "matches", null);
  __decorate([
    Decorators_1.Override,
    Decorators_1.NotNull
  ], RangeTransition.prototype, "toString", null);
  RangeTransition = __decorate([
    __param(0, Decorators_1.NotNull)
  ], RangeTransition);
  exports.RangeTransition = RangeTransition;
});

// node_modules/antlr4ts/atn/RuleStartState.js
var require_RuleStartState = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.RuleStartState = void 0;
  var ATNState_1 = require_ATNState();
  var ATNStateType_1 = require_ATNStateType();
  var Decorators_1 = require_Decorators();
  var RuleStartState = class extends ATNState_1.ATNState {
    constructor() {
      super(...arguments);
      this.isPrecedenceRule = false;
      this.leftFactored = false;
    }
    get stateType() {
      return ATNStateType_1.ATNStateType.RULE_START;
    }
  };
  __decorate([
    Decorators_1.Override
  ], RuleStartState.prototype, "stateType", null);
  exports.RuleStartState = RuleStartState;
});

// node_modules/antlr4ts/atn/StarBlockStartState.js
var require_StarBlockStartState = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.StarBlockStartState = void 0;
  var ATNStateType_1 = require_ATNStateType();
  var BlockStartState_1 = require_BlockStartState();
  var Decorators_1 = require_Decorators();
  var StarBlockStartState = class extends BlockStartState_1.BlockStartState {
    get stateType() {
      return ATNStateType_1.ATNStateType.STAR_BLOCK_START;
    }
  };
  __decorate([
    Decorators_1.Override
  ], StarBlockStartState.prototype, "stateType", null);
  exports.StarBlockStartState = StarBlockStartState;
});

// node_modules/antlr4ts/atn/StarLoopbackState.js
var require_StarLoopbackState = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.StarLoopbackState = void 0;
  var ATNState_1 = require_ATNState();
  var ATNStateType_1 = require_ATNStateType();
  var Decorators_1 = require_Decorators();
  var StarLoopbackState = class extends ATNState_1.ATNState {
    get loopEntryState() {
      return this.transition(0).target;
    }
    get stateType() {
      return ATNStateType_1.ATNStateType.STAR_LOOP_BACK;
    }
  };
  __decorate([
    Decorators_1.Override
  ], StarLoopbackState.prototype, "stateType", null);
  exports.StarLoopbackState = StarLoopbackState;
});

// node_modules/antlr4ts/atn/TokensStartState.js
var require_TokensStartState = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.TokensStartState = void 0;
  var ATNStateType_1 = require_ATNStateType();
  var DecisionState_1 = require_DecisionState();
  var Decorators_1 = require_Decorators();
  var TokensStartState = class extends DecisionState_1.DecisionState {
    get stateType() {
      return ATNStateType_1.ATNStateType.TOKEN_START;
    }
  };
  __decorate([
    Decorators_1.Override
  ], TokensStartState.prototype, "stateType", null);
  exports.TokensStartState = TokensStartState;
});

// node_modules/antlr4ts/misc/UUID.js
var require_UUID = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.UUID = void 0;
  var MurmurHash_1 = require_MurmurHash();
  var UUID = class {
    constructor(mostSigBits, moreSigBits, lessSigBits, leastSigBits) {
      this.data = new Uint32Array(4);
      this.data[0] = mostSigBits;
      this.data[1] = moreSigBits;
      this.data[2] = lessSigBits;
      this.data[3] = leastSigBits;
    }
    static fromString(data) {
      if (!/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.test(data)) {
        throw new Error("Incorrectly formatted UUID");
      }
      let segments = data.split("-");
      let mostSigBits = parseInt(segments[0], 16);
      let moreSigBits = (parseInt(segments[1], 16) << 16 >>> 0) + parseInt(segments[2], 16);
      let lessSigBits = (parseInt(segments[3], 16) << 16 >>> 0) + parseInt(segments[4].substr(0, 4), 16);
      let leastSigBits = parseInt(segments[4].substr(-8), 16);
      return new UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);
    }
    hashCode() {
      return MurmurHash_1.MurmurHash.hashCode([this.data[0], this.data[1], this.data[2], this.data[3]]);
    }
    equals(obj) {
      if (obj === this) {
        return true;
      } else if (!(obj instanceof UUID)) {
        return false;
      }
      return this.data[0] === obj.data[0] && this.data[1] === obj.data[1] && this.data[2] === obj.data[2] && this.data[3] === obj.data[3];
    }
    toString() {
      return ("00000000" + this.data[0].toString(16)).substr(-8) + "-" + ("0000" + (this.data[1] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[1].toString(16)).substr(-4) + "-" + ("0000" + (this.data[2] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[2].toString(16)).substr(-4) + ("00000000" + this.data[3].toString(16)).substr(-8);
    }
  };
  exports.UUID = UUID;
});

// node_modules/antlr4ts/atn/ATNDeserializer.js
var require_ATNDeserializer = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ATNDeserializer = void 0;
  var ActionTransition_1 = require_ActionTransition();
  var Array2DHashSet_1 = require_Array2DHashSet();
  var ATN_1 = require_ATN();
  var ATNDeserializationOptions_1 = require_ATNDeserializationOptions();
  var ATNStateType_1 = require_ATNStateType();
  var AtomTransition_1 = require_AtomTransition();
  var BasicBlockStartState_1 = require_BasicBlockStartState();
  var BasicState_1 = require_BasicState();
  var BitSet_1 = require_BitSet();
  var BlockEndState_1 = require_BlockEndState();
  var BlockStartState_1 = require_BlockStartState();
  var DecisionState_1 = require_DecisionState();
  var DFA_1 = require_DFA();
  var EpsilonTransition_1 = require_EpsilonTransition();
  var IntervalSet_1 = require_IntervalSet();
  var InvalidState_1 = require_InvalidState();
  var LexerChannelAction_1 = require_LexerChannelAction();
  var LexerCustomAction_1 = require_LexerCustomAction();
  var LexerModeAction_1 = require_LexerModeAction();
  var LexerMoreAction_1 = require_LexerMoreAction();
  var LexerPopModeAction_1 = require_LexerPopModeAction();
  var LexerPushModeAction_1 = require_LexerPushModeAction();
  var LexerSkipAction_1 = require_LexerSkipAction();
  var LexerTypeAction_1 = require_LexerTypeAction();
  var LoopEndState_1 = require_LoopEndState();
  var Decorators_1 = require_Decorators();
  var NotSetTransition_1 = require_NotSetTransition();
  var ParserATNSimulator_1 = require_ParserATNSimulator();
  var PlusBlockStartState_1 = require_PlusBlockStartState();
  var PlusLoopbackState_1 = require_PlusLoopbackState();
  var PrecedencePredicateTransition_1 = require_PrecedencePredicateTransition();
  var PredicateTransition_1 = require_PredicateTransition();
  var RangeTransition_1 = require_RangeTransition();
  var RuleStartState_1 = require_RuleStartState();
  var RuleStopState_1 = require_RuleStopState();
  var RuleTransition_1 = require_RuleTransition();
  var SetTransition_1 = require_SetTransition();
  var StarBlockStartState_1 = require_StarBlockStartState();
  var StarLoopbackState_1 = require_StarLoopbackState();
  var StarLoopEntryState_1 = require_StarLoopEntryState();
  var Token_1 = require_Token();
  var TokensStartState_1 = require_TokensStartState();
  var UUID_1 = require_UUID();
  var WildcardTransition_1 = require_WildcardTransition();
  var UnicodeDeserializingMode;
  (function(UnicodeDeserializingMode2) {
    UnicodeDeserializingMode2[UnicodeDeserializingMode2["UNICODE_BMP"] = 0] = "UNICODE_BMP";
    UnicodeDeserializingMode2[UnicodeDeserializingMode2["UNICODE_SMP"] = 1] = "UNICODE_SMP";
  })(UnicodeDeserializingMode || (UnicodeDeserializingMode = {}));
  var ATNDeserializer3 = class {
    constructor(deserializationOptions) {
      if (deserializationOptions === void 0) {
        deserializationOptions = ATNDeserializationOptions_1.ATNDeserializationOptions.defaultOptions;
      }
      this.deserializationOptions = deserializationOptions;
    }
    static get SERIALIZED_VERSION() {
      return 3;
    }
    static isFeatureSupported(feature, actualUuid) {
      let featureIndex = ATNDeserializer3.SUPPORTED_UUIDS.findIndex((e) => e.equals(feature));
      if (featureIndex < 0) {
        return false;
      }
      return ATNDeserializer3.SUPPORTED_UUIDS.findIndex((e) => e.equals(actualUuid)) >= featureIndex;
    }
    static getUnicodeDeserializer(mode) {
      if (mode === 0) {
        return {
          readUnicode: (data, p) => {
            return ATNDeserializer3.toInt(data[p]);
          },
          size: 1
        };
      } else {
        return {
          readUnicode: (data, p) => {
            return ATNDeserializer3.toInt32(data, p);
          },
          size: 2
        };
      }
    }
    deserialize(data) {
      data = data.slice(0);
      for (let i = 1; i < data.length; i++) {
        data[i] = data[i] - 2 & 65535;
      }
      let p = 0;
      let version = ATNDeserializer3.toInt(data[p++]);
      if (version !== ATNDeserializer3.SERIALIZED_VERSION) {
        let reason = `Could not deserialize ATN with version ${version} (expected ${ATNDeserializer3.SERIALIZED_VERSION}).`;
        throw new Error(reason);
      }
      let uuid = ATNDeserializer3.toUUID(data, p);
      p += 8;
      if (ATNDeserializer3.SUPPORTED_UUIDS.findIndex((e) => e.equals(uuid)) < 0) {
        let reason = `Could not deserialize ATN with UUID ${uuid} (expected ${ATNDeserializer3.SERIALIZED_UUID} or a legacy UUID).`;
        throw new Error(reason);
      }
      let supportsLexerActions = ATNDeserializer3.isFeatureSupported(ATNDeserializer3.ADDED_LEXER_ACTIONS, uuid);
      let grammarType = ATNDeserializer3.toInt(data[p++]);
      let maxTokenType = ATNDeserializer3.toInt(data[p++]);
      let atn = new ATN_1.ATN(grammarType, maxTokenType);
      let loopBackStateNumbers = [];
      let endStateNumbers = [];
      let nstates = ATNDeserializer3.toInt(data[p++]);
      for (let i = 0; i < nstates; i++) {
        let stype = ATNDeserializer3.toInt(data[p++]);
        if (stype === ATNStateType_1.ATNStateType.INVALID_TYPE) {
          atn.addState(new InvalidState_1.InvalidState());
          continue;
        }
        let ruleIndex = ATNDeserializer3.toInt(data[p++]);
        if (ruleIndex === 65535) {
          ruleIndex = -1;
        }
        let s = this.stateFactory(stype, ruleIndex);
        if (stype === ATNStateType_1.ATNStateType.LOOP_END) {
          let loopBackStateNumber = ATNDeserializer3.toInt(data[p++]);
          loopBackStateNumbers.push([s, loopBackStateNumber]);
        } else if (s instanceof BlockStartState_1.BlockStartState) {
          let endStateNumber = ATNDeserializer3.toInt(data[p++]);
          endStateNumbers.push([s, endStateNumber]);
        }
        atn.addState(s);
      }
      for (let pair of loopBackStateNumbers) {
        pair[0].loopBackState = atn.states[pair[1]];
      }
      for (let pair of endStateNumbers) {
        pair[0].endState = atn.states[pair[1]];
      }
      let numNonGreedyStates = ATNDeserializer3.toInt(data[p++]);
      for (let i = 0; i < numNonGreedyStates; i++) {
        let stateNumber = ATNDeserializer3.toInt(data[p++]);
        atn.states[stateNumber].nonGreedy = true;
      }
      let numSllDecisions = ATNDeserializer3.toInt(data[p++]);
      for (let i = 0; i < numSllDecisions; i++) {
        let stateNumber = ATNDeserializer3.toInt(data[p++]);
        atn.states[stateNumber].sll = true;
      }
      let numPrecedenceStates = ATNDeserializer3.toInt(data[p++]);
      for (let i = 0; i < numPrecedenceStates; i++) {
        let stateNumber = ATNDeserializer3.toInt(data[p++]);
        atn.states[stateNumber].isPrecedenceRule = true;
      }
      let nrules = ATNDeserializer3.toInt(data[p++]);
      if (atn.grammarType === 0) {
        atn.ruleToTokenType = new Int32Array(nrules);
      }
      atn.ruleToStartState = new Array(nrules);
      for (let i = 0; i < nrules; i++) {
        let s = ATNDeserializer3.toInt(data[p++]);
        let startState = atn.states[s];
        startState.leftFactored = ATNDeserializer3.toInt(data[p++]) !== 0;
        atn.ruleToStartState[i] = startState;
        if (atn.grammarType === 0) {
          let tokenType = ATNDeserializer3.toInt(data[p++]);
          if (tokenType === 65535) {
            tokenType = Token_1.Token.EOF;
          }
          atn.ruleToTokenType[i] = tokenType;
          if (!ATNDeserializer3.isFeatureSupported(ATNDeserializer3.ADDED_LEXER_ACTIONS, uuid)) {
            let actionIndexIgnored = ATNDeserializer3.toInt(data[p++]);
            if (actionIndexIgnored === 65535) {
              actionIndexIgnored = -1;
            }
          }
        }
      }
      atn.ruleToStopState = new Array(nrules);
      for (let state of atn.states) {
        if (!(state instanceof RuleStopState_1.RuleStopState)) {
          continue;
        }
        atn.ruleToStopState[state.ruleIndex] = state;
        atn.ruleToStartState[state.ruleIndex].stopState = state;
      }
      let nmodes = ATNDeserializer3.toInt(data[p++]);
      for (let i = 0; i < nmodes; i++) {
        let s = ATNDeserializer3.toInt(data[p++]);
        atn.modeToStartState.push(atn.states[s]);
      }
      atn.modeToDFA = new Array(nmodes);
      for (let i = 0; i < nmodes; i++) {
        atn.modeToDFA[i] = new DFA_1.DFA(atn.modeToStartState[i]);
      }
      let sets = [];
      p = this.deserializeSets(data, p, sets, ATNDeserializer3.getUnicodeDeserializer(0));
      if (ATNDeserializer3.isFeatureSupported(ATNDeserializer3.ADDED_UNICODE_SMP, uuid)) {
        p = this.deserializeSets(data, p, sets, ATNDeserializer3.getUnicodeDeserializer(1));
      }
      let nedges = ATNDeserializer3.toInt(data[p++]);
      for (let i = 0; i < nedges; i++) {
        let src = ATNDeserializer3.toInt(data[p]);
        let trg = ATNDeserializer3.toInt(data[p + 1]);
        let ttype = ATNDeserializer3.toInt(data[p + 2]);
        let arg1 = ATNDeserializer3.toInt(data[p + 3]);
        let arg2 = ATNDeserializer3.toInt(data[p + 4]);
        let arg3 = ATNDeserializer3.toInt(data[p + 5]);
        let trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);
        let srcState = atn.states[src];
        srcState.addTransition(trans);
        p += 6;
      }
      let returnTransitionsSet = new Array2DHashSet_1.Array2DHashSet({
        hashCode: (o) => o.stopState ^ o.returnState ^ o.outermostPrecedenceReturn,
        equals: (a, b) => {
          return a.stopState === b.stopState && a.returnState === b.returnState && a.outermostPrecedenceReturn === b.outermostPrecedenceReturn;
        }
      });
      let returnTransitions = [];
      for (let state of atn.states) {
        let returningToLeftFactored = state.ruleIndex >= 0 && atn.ruleToStartState[state.ruleIndex].leftFactored;
        for (let i = 0; i < state.numberOfTransitions; i++) {
          let t = state.transition(i);
          if (!(t instanceof RuleTransition_1.RuleTransition)) {
            continue;
          }
          let ruleTransition = t;
          let returningFromLeftFactored = atn.ruleToStartState[ruleTransition.target.ruleIndex].leftFactored;
          if (!returningFromLeftFactored && returningToLeftFactored) {
            continue;
          }
          let outermostPrecedenceReturn = -1;
          if (atn.ruleToStartState[ruleTransition.target.ruleIndex].isPrecedenceRule) {
            if (ruleTransition.precedence === 0) {
              outermostPrecedenceReturn = ruleTransition.target.ruleIndex;
            }
          }
          let current = {stopState: ruleTransition.target.ruleIndex, returnState: ruleTransition.followState.stateNumber, outermostPrecedenceReturn};
          if (returnTransitionsSet.add(current)) {
            returnTransitions.push(current);
          }
        }
      }
      for (let returnTransition of returnTransitions) {
        let transition = new EpsilonTransition_1.EpsilonTransition(atn.states[returnTransition.returnState], returnTransition.outermostPrecedenceReturn);
        atn.ruleToStopState[returnTransition.stopState].addTransition(transition);
      }
      for (let state of atn.states) {
        if (state instanceof BlockStartState_1.BlockStartState) {
          if (state.endState === void 0) {
            throw new Error("IllegalStateException");
          }
          if (state.endState.startState !== void 0) {
            throw new Error("IllegalStateException");
          }
          state.endState.startState = state;
        }
        if (state instanceof PlusLoopbackState_1.PlusLoopbackState) {
          let loopbackState = state;
          for (let i = 0; i < loopbackState.numberOfTransitions; i++) {
            let target = loopbackState.transition(i).target;
            if (target instanceof PlusBlockStartState_1.PlusBlockStartState) {
              target.loopBackState = loopbackState;
            }
          }
        } else if (state instanceof StarLoopbackState_1.StarLoopbackState) {
          let loopbackState = state;
          for (let i = 0; i < loopbackState.numberOfTransitions; i++) {
            let target = loopbackState.transition(i).target;
            if (target instanceof StarLoopEntryState_1.StarLoopEntryState) {
              target.loopBackState = loopbackState;
            }
          }
        }
      }
      let ndecisions = ATNDeserializer3.toInt(data[p++]);
      for (let i = 1; i <= ndecisions; i++) {
        let s = ATNDeserializer3.toInt(data[p++]);
        let decState = atn.states[s];
        atn.decisionToState.push(decState);
        decState.decision = i - 1;
      }
      if (atn.grammarType === 0) {
        if (supportsLexerActions) {
          atn.lexerActions = new Array(ATNDeserializer3.toInt(data[p++]));
          for (let i = 0; i < atn.lexerActions.length; i++) {
            let actionType = ATNDeserializer3.toInt(data[p++]);
            let data1 = ATNDeserializer3.toInt(data[p++]);
            if (data1 === 65535) {
              data1 = -1;
            }
            let data2 = ATNDeserializer3.toInt(data[p++]);
            if (data2 === 65535) {
              data2 = -1;
            }
            let lexerAction = this.lexerActionFactory(actionType, data1, data2);
            atn.lexerActions[i] = lexerAction;
          }
        } else {
          let legacyLexerActions = [];
          for (let state of atn.states) {
            for (let i = 0; i < state.numberOfTransitions; i++) {
              let transition = state.transition(i);
              if (!(transition instanceof ActionTransition_1.ActionTransition)) {
                continue;
              }
              let ruleIndex = transition.ruleIndex;
              let actionIndex = transition.actionIndex;
              let lexerAction = new LexerCustomAction_1.LexerCustomAction(ruleIndex, actionIndex);
              state.setTransition(i, new ActionTransition_1.ActionTransition(transition.target, ruleIndex, legacyLexerActions.length, false));
              legacyLexerActions.push(lexerAction);
            }
          }
          atn.lexerActions = legacyLexerActions;
        }
      }
      this.markPrecedenceDecisions(atn);
      atn.decisionToDFA = new Array(ndecisions);
      for (let i = 0; i < ndecisions; i++) {
        atn.decisionToDFA[i] = new DFA_1.DFA(atn.decisionToState[i], i);
      }
      if (this.deserializationOptions.isVerifyATN) {
        this.verifyATN(atn);
      }
      if (this.deserializationOptions.isGenerateRuleBypassTransitions && atn.grammarType === 1) {
        atn.ruleToTokenType = new Int32Array(atn.ruleToStartState.length);
        for (let i = 0; i < atn.ruleToStartState.length; i++) {
          atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;
        }
        for (let i = 0; i < atn.ruleToStartState.length; i++) {
          let bypassStart = new BasicBlockStartState_1.BasicBlockStartState();
          bypassStart.ruleIndex = i;
          atn.addState(bypassStart);
          let bypassStop = new BlockEndState_1.BlockEndState();
          bypassStop.ruleIndex = i;
          atn.addState(bypassStop);
          bypassStart.endState = bypassStop;
          atn.defineDecisionState(bypassStart);
          bypassStop.startState = bypassStart;
          let endState;
          let excludeTransition;
          if (atn.ruleToStartState[i].isPrecedenceRule) {
            endState = void 0;
            for (let state of atn.states) {
              if (state.ruleIndex !== i) {
                continue;
              }
              if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
                continue;
              }
              let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;
              if (!(maybeLoopEndState instanceof LoopEndState_1.LoopEndState)) {
                continue;
              }
              if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {
                endState = state;
                break;
              }
            }
            if (!endState) {
              throw new Error("Couldn't identify final state of the precedence rule prefix section.");
            }
            excludeTransition = endState.loopBackState.transition(0);
          } else {
            endState = atn.ruleToStopState[i];
          }
          for (let state of atn.states) {
            for (let i2 = 0; i2 < state.numberOfTransitions; i2++) {
              let transition = state.transition(i2);
              if (transition === excludeTransition) {
                continue;
              }
              if (transition.target === endState) {
                transition.target = bypassStop;
              }
            }
          }
          while (atn.ruleToStartState[i].numberOfTransitions > 0) {
            let transition = atn.ruleToStartState[i].removeTransition(atn.ruleToStartState[i].numberOfTransitions - 1);
            bypassStart.addTransition(transition);
          }
          atn.ruleToStartState[i].addTransition(new EpsilonTransition_1.EpsilonTransition(bypassStart));
          bypassStop.addTransition(new EpsilonTransition_1.EpsilonTransition(endState));
          let matchState = new BasicState_1.BasicState();
          atn.addState(matchState);
          matchState.addTransition(new AtomTransition_1.AtomTransition(bypassStop, atn.ruleToTokenType[i]));
          bypassStart.addTransition(new EpsilonTransition_1.EpsilonTransition(matchState));
        }
        if (this.deserializationOptions.isVerifyATN) {
          this.verifyATN(atn);
        }
      }
      if (this.deserializationOptions.isOptimize) {
        while (true) {
          let optimizationCount = 0;
          optimizationCount += ATNDeserializer3.inlineSetRules(atn);
          optimizationCount += ATNDeserializer3.combineChainedEpsilons(atn);
          let preserveOrder = atn.grammarType === 0;
          optimizationCount += ATNDeserializer3.optimizeSets(atn, preserveOrder);
          if (optimizationCount === 0) {
            break;
          }
        }
        if (this.deserializationOptions.isVerifyATN) {
          this.verifyATN(atn);
        }
      }
      ATNDeserializer3.identifyTailCalls(atn);
      return atn;
    }
    deserializeSets(data, p, sets, unicodeDeserializer) {
      let nsets = ATNDeserializer3.toInt(data[p++]);
      for (let i = 0; i < nsets; i++) {
        let nintervals = ATNDeserializer3.toInt(data[p]);
        p++;
        let set = new IntervalSet_1.IntervalSet();
        sets.push(set);
        let containsEof = ATNDeserializer3.toInt(data[p++]) !== 0;
        if (containsEof) {
          set.add(-1);
        }
        for (let j = 0; j < nintervals; j++) {
          let a = unicodeDeserializer.readUnicode(data, p);
          p += unicodeDeserializer.size;
          let b = unicodeDeserializer.readUnicode(data, p);
          p += unicodeDeserializer.size;
          set.add(a, b);
        }
      }
      return p;
    }
    markPrecedenceDecisions(atn) {
      let rulePrecedenceDecisions = new Map();
      for (let state of atn.states) {
        if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
          continue;
        }
        if (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {
          let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;
          if (maybeLoopEndState instanceof LoopEndState_1.LoopEndState) {
            if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {
              rulePrecedenceDecisions.set(state.ruleIndex, state);
              state.precedenceRuleDecision = true;
              state.precedenceLoopbackStates = new BitSet_1.BitSet(atn.states.length);
            }
          }
        }
      }
      for (let precedenceDecision of rulePrecedenceDecisions) {
        for (let transition of atn.ruleToStopState[precedenceDecision[0]].getTransitions()) {
          if (transition.serializationType !== 1) {
            continue;
          }
          let epsilonTransition = transition;
          if (epsilonTransition.outermostPrecedenceReturn !== -1) {
            continue;
          }
          precedenceDecision[1].precedenceLoopbackStates.set(transition.target.stateNumber);
        }
      }
    }
    verifyATN(atn) {
      for (let state of atn.states) {
        this.checkCondition(state !== void 0, "ATN states should not be undefined.");
        if (state.stateType === ATNStateType_1.ATNStateType.INVALID_TYPE) {
          continue;
        }
        this.checkCondition(state.onlyHasEpsilonTransitions || state.numberOfTransitions <= 1);
        if (state instanceof PlusBlockStartState_1.PlusBlockStartState) {
          this.checkCondition(state.loopBackState !== void 0);
        }
        if (state instanceof StarLoopEntryState_1.StarLoopEntryState) {
          let starLoopEntryState = state;
          this.checkCondition(starLoopEntryState.loopBackState !== void 0);
          this.checkCondition(starLoopEntryState.numberOfTransitions === 2);
          if (starLoopEntryState.transition(0).target instanceof StarBlockStartState_1.StarBlockStartState) {
            this.checkCondition(starLoopEntryState.transition(1).target instanceof LoopEndState_1.LoopEndState);
            this.checkCondition(!starLoopEntryState.nonGreedy);
          } else if (starLoopEntryState.transition(0).target instanceof LoopEndState_1.LoopEndState) {
            this.checkCondition(starLoopEntryState.transition(1).target instanceof StarBlockStartState_1.StarBlockStartState);
            this.checkCondition(starLoopEntryState.nonGreedy);
          } else {
            throw new Error("IllegalStateException");
          }
        }
        if (state instanceof StarLoopbackState_1.StarLoopbackState) {
          this.checkCondition(state.numberOfTransitions === 1);
          this.checkCondition(state.transition(0).target instanceof StarLoopEntryState_1.StarLoopEntryState);
        }
        if (state instanceof LoopEndState_1.LoopEndState) {
          this.checkCondition(state.loopBackState !== void 0);
        }
        if (state instanceof RuleStartState_1.RuleStartState) {
          this.checkCondition(state.stopState !== void 0);
        }
        if (state instanceof BlockStartState_1.BlockStartState) {
          this.checkCondition(state.endState !== void 0);
        }
        if (state instanceof BlockEndState_1.BlockEndState) {
          this.checkCondition(state.startState !== void 0);
        }
        if (state instanceof DecisionState_1.DecisionState) {
          let decisionState = state;
          this.checkCondition(decisionState.numberOfTransitions <= 1 || decisionState.decision >= 0);
        } else {
          this.checkCondition(state.numberOfTransitions <= 1 || state instanceof RuleStopState_1.RuleStopState);
        }
      }
    }
    checkCondition(condition, message) {
      if (!condition) {
        throw new Error("IllegalStateException: " + message);
      }
    }
    static inlineSetRules(atn) {
      let inlinedCalls = 0;
      let ruleToInlineTransition = new Array(atn.ruleToStartState.length);
      for (let i = 0; i < atn.ruleToStartState.length; i++) {
        let startState = atn.ruleToStartState[i];
        let middleState = startState;
        while (middleState.onlyHasEpsilonTransitions && middleState.numberOfOptimizedTransitions === 1 && middleState.getOptimizedTransition(0).serializationType === 1) {
          middleState = middleState.getOptimizedTransition(0).target;
        }
        if (middleState.numberOfOptimizedTransitions !== 1) {
          continue;
        }
        let matchTransition = middleState.getOptimizedTransition(0);
        let matchTarget = matchTransition.target;
        if (matchTransition.isEpsilon || !matchTarget.onlyHasEpsilonTransitions || matchTarget.numberOfOptimizedTransitions !== 1 || !(matchTarget.getOptimizedTransition(0).target instanceof RuleStopState_1.RuleStopState)) {
          continue;
        }
        switch (matchTransition.serializationType) {
          case 5:
          case 2:
          case 7:
            ruleToInlineTransition[i] = matchTransition;
            break;
          case 8:
          case 9:
            continue;
          default:
            continue;
        }
      }
      for (let state of atn.states) {
        if (state.ruleIndex < 0) {
          continue;
        }
        let optimizedTransitions;
        for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
          let transition = state.getOptimizedTransition(i);
          if (!(transition instanceof RuleTransition_1.RuleTransition)) {
            if (optimizedTransitions !== void 0) {
              optimizedTransitions.push(transition);
            }
            continue;
          }
          let ruleTransition = transition;
          let effective = ruleToInlineTransition[ruleTransition.target.ruleIndex];
          if (effective === void 0) {
            if (optimizedTransitions !== void 0) {
              optimizedTransitions.push(transition);
            }
            continue;
          }
          if (optimizedTransitions === void 0) {
            optimizedTransitions = [];
            for (let j = 0; j < i; j++) {
              optimizedTransitions.push(state.getOptimizedTransition(i));
            }
          }
          inlinedCalls++;
          let target = ruleTransition.followState;
          let intermediateState = new BasicState_1.BasicState();
          intermediateState.setRuleIndex(target.ruleIndex);
          atn.addState(intermediateState);
          optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(intermediateState));
          switch (effective.serializationType) {
            case 5:
              intermediateState.addTransition(new AtomTransition_1.AtomTransition(target, effective._label));
              break;
            case 2:
              intermediateState.addTransition(new RangeTransition_1.RangeTransition(target, effective.from, effective.to));
              break;
            case 7:
              intermediateState.addTransition(new SetTransition_1.SetTransition(target, effective.label));
              break;
            default:
              throw new Error("UnsupportedOperationException");
          }
        }
        if (optimizedTransitions !== void 0) {
          if (state.isOptimized) {
            while (state.numberOfOptimizedTransitions > 0) {
              state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);
            }
          }
          for (let transition of optimizedTransitions) {
            state.addOptimizedTransition(transition);
          }
        }
      }
      if (ParserATNSimulator_1.ParserATNSimulator.debug) {
        console.log("ATN runtime optimizer removed " + inlinedCalls + " rule invocations by inlining sets.");
      }
      return inlinedCalls;
    }
    static combineChainedEpsilons(atn) {
      let removedEdges = 0;
      for (let state of atn.states) {
        if (!state.onlyHasEpsilonTransitions || state instanceof RuleStopState_1.RuleStopState) {
          continue;
        }
        let optimizedTransitions;
        nextTransition:
          for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
            let transition = state.getOptimizedTransition(i);
            let intermediate = transition.target;
            if (transition.serializationType !== 1 || transition.outermostPrecedenceReturn !== -1 || intermediate.stateType !== ATNStateType_1.ATNStateType.BASIC || !intermediate.onlyHasEpsilonTransitions) {
              if (optimizedTransitions !== void 0) {
                optimizedTransitions.push(transition);
              }
              continue nextTransition;
            }
            for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {
              if (intermediate.getOptimizedTransition(j).serializationType !== 1 || intermediate.getOptimizedTransition(j).outermostPrecedenceReturn !== -1) {
                if (optimizedTransitions !== void 0) {
                  optimizedTransitions.push(transition);
                }
                continue nextTransition;
              }
            }
            removedEdges++;
            if (optimizedTransitions === void 0) {
              optimizedTransitions = [];
              for (let j = 0; j < i; j++) {
                optimizedTransitions.push(state.getOptimizedTransition(j));
              }
            }
            for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {
              let target = intermediate.getOptimizedTransition(j).target;
              optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(target));
            }
          }
        if (optimizedTransitions !== void 0) {
          if (state.isOptimized) {
            while (state.numberOfOptimizedTransitions > 0) {
              state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);
            }
          }
          for (let transition of optimizedTransitions) {
            state.addOptimizedTransition(transition);
          }
        }
      }
      if (ParserATNSimulator_1.ParserATNSimulator.debug) {
        console.log("ATN runtime optimizer removed " + removedEdges + " transitions by combining chained epsilon transitions.");
      }
      return removedEdges;
    }
    static optimizeSets(atn, preserveOrder) {
      if (preserveOrder) {
        return 0;
      }
      let removedPaths = 0;
      let decisions = atn.decisionToState;
      for (let decision of decisions) {
        let setTransitions = new IntervalSet_1.IntervalSet();
        for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {
          let epsTransition = decision.getOptimizedTransition(i);
          if (!(epsTransition instanceof EpsilonTransition_1.EpsilonTransition)) {
            continue;
          }
          if (epsTransition.target.numberOfOptimizedTransitions !== 1) {
            continue;
          }
          let transition = epsTransition.target.getOptimizedTransition(0);
          if (!(transition.target instanceof BlockEndState_1.BlockEndState)) {
            continue;
          }
          if (transition instanceof NotSetTransition_1.NotSetTransition) {
            continue;
          }
          if (transition instanceof AtomTransition_1.AtomTransition || transition instanceof RangeTransition_1.RangeTransition || transition instanceof SetTransition_1.SetTransition) {
            setTransitions.add(i);
          }
        }
        if (setTransitions.size <= 1) {
          continue;
        }
        let optimizedTransitions = [];
        for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {
          if (!setTransitions.contains(i)) {
            optimizedTransitions.push(decision.getOptimizedTransition(i));
          }
        }
        let blockEndState = decision.getOptimizedTransition(setTransitions.minElement).target.getOptimizedTransition(0).target;
        let matchSet = new IntervalSet_1.IntervalSet();
        for (let interval of setTransitions.intervals) {
          for (let j = interval.a; j <= interval.b; j++) {
            let matchTransition = decision.getOptimizedTransition(j).target.getOptimizedTransition(0);
            if (matchTransition instanceof NotSetTransition_1.NotSetTransition) {
              throw new Error("Not yet implemented.");
            } else {
              matchSet.addAll(matchTransition.label);
            }
          }
        }
        let newTransition;
        if (matchSet.intervals.length === 1) {
          if (matchSet.size === 1) {
            newTransition = new AtomTransition_1.AtomTransition(blockEndState, matchSet.minElement);
          } else {
            let matchInterval = matchSet.intervals[0];
            newTransition = new RangeTransition_1.RangeTransition(blockEndState, matchInterval.a, matchInterval.b);
          }
        } else {
          newTransition = new SetTransition_1.SetTransition(blockEndState, matchSet);
        }
        let setOptimizedState = new BasicState_1.BasicState();
        setOptimizedState.setRuleIndex(decision.ruleIndex);
        atn.addState(setOptimizedState);
        setOptimizedState.addTransition(newTransition);
        optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(setOptimizedState));
        removedPaths += decision.numberOfOptimizedTransitions - optimizedTransitions.length;
        if (decision.isOptimized) {
          while (decision.numberOfOptimizedTransitions > 0) {
            decision.removeOptimizedTransition(decision.numberOfOptimizedTransitions - 1);
          }
        }
        for (let transition of optimizedTransitions) {
          decision.addOptimizedTransition(transition);
        }
      }
      if (ParserATNSimulator_1.ParserATNSimulator.debug) {
        console.log("ATN runtime optimizer removed " + removedPaths + " paths by collapsing sets.");
      }
      return removedPaths;
    }
    static identifyTailCalls(atn) {
      for (let state of atn.states) {
        for (let i = 0; i < state.numberOfTransitions; i++) {
          let transition = state.transition(i);
          if (!(transition instanceof RuleTransition_1.RuleTransition)) {
            continue;
          }
          transition.tailCall = this.testTailCall(atn, transition, false);
          transition.optimizedTailCall = this.testTailCall(atn, transition, true);
        }
        if (!state.isOptimized) {
          continue;
        }
        for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {
          let transition = state.getOptimizedTransition(i);
          if (!(transition instanceof RuleTransition_1.RuleTransition)) {
            continue;
          }
          transition.tailCall = this.testTailCall(atn, transition, false);
          transition.optimizedTailCall = this.testTailCall(atn, transition, true);
        }
      }
    }
    static testTailCall(atn, transition, optimizedPath) {
      if (!optimizedPath && transition.tailCall) {
        return true;
      }
      if (optimizedPath && transition.optimizedTailCall) {
        return true;
      }
      let reachable = new BitSet_1.BitSet(atn.states.length);
      let worklist = [];
      worklist.push(transition.followState);
      while (true) {
        let state = worklist.pop();
        if (!state) {
          break;
        }
        if (reachable.get(state.stateNumber)) {
          continue;
        }
        if (state instanceof RuleStopState_1.RuleStopState) {
          continue;
        }
        if (!state.onlyHasEpsilonTransitions) {
          return false;
        }
        let transitionCount = optimizedPath ? state.numberOfOptimizedTransitions : state.numberOfTransitions;
        for (let i = 0; i < transitionCount; i++) {
          let t = optimizedPath ? state.getOptimizedTransition(i) : state.transition(i);
          if (t.serializationType !== 1) {
            return false;
          }
          worklist.push(t.target);
        }
      }
      return true;
    }
    static toInt(c) {
      return c;
    }
    static toInt32(data, offset) {
      return (data[offset] | data[offset + 1] << 16) >>> 0;
    }
    static toUUID(data, offset) {
      let leastSigBits = ATNDeserializer3.toInt32(data, offset);
      let lessSigBits = ATNDeserializer3.toInt32(data, offset + 2);
      let moreSigBits = ATNDeserializer3.toInt32(data, offset + 4);
      let mostSigBits = ATNDeserializer3.toInt32(data, offset + 6);
      return new UUID_1.UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);
    }
    edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {
      let target = atn.states[trg];
      switch (type) {
        case 1:
          return new EpsilonTransition_1.EpsilonTransition(target);
        case 2:
          if (arg3 !== 0) {
            return new RangeTransition_1.RangeTransition(target, Token_1.Token.EOF, arg2);
          } else {
            return new RangeTransition_1.RangeTransition(target, arg1, arg2);
          }
        case 3:
          let rt = new RuleTransition_1.RuleTransition(atn.states[arg1], arg2, arg3, target);
          return rt;
        case 4:
          let pt = new PredicateTransition_1.PredicateTransition(target, arg1, arg2, arg3 !== 0);
          return pt;
        case 10:
          return new PrecedencePredicateTransition_1.PrecedencePredicateTransition(target, arg1);
        case 5:
          if (arg3 !== 0) {
            return new AtomTransition_1.AtomTransition(target, Token_1.Token.EOF);
          } else {
            return new AtomTransition_1.AtomTransition(target, arg1);
          }
        case 6:
          let a = new ActionTransition_1.ActionTransition(target, arg1, arg2, arg3 !== 0);
          return a;
        case 7:
          return new SetTransition_1.SetTransition(target, sets[arg1]);
        case 8:
          return new NotSetTransition_1.NotSetTransition(target, sets[arg1]);
        case 9:
          return new WildcardTransition_1.WildcardTransition(target);
      }
      throw new Error("The specified transition type is not valid.");
    }
    stateFactory(type, ruleIndex) {
      let s;
      switch (type) {
        case ATNStateType_1.ATNStateType.INVALID_TYPE:
          return new InvalidState_1.InvalidState();
        case ATNStateType_1.ATNStateType.BASIC:
          s = new BasicState_1.BasicState();
          break;
        case ATNStateType_1.ATNStateType.RULE_START:
          s = new RuleStartState_1.RuleStartState();
          break;
        case ATNStateType_1.ATNStateType.BLOCK_START:
          s = new BasicBlockStartState_1.BasicBlockStartState();
          break;
        case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:
          s = new PlusBlockStartState_1.PlusBlockStartState();
          break;
        case ATNStateType_1.ATNStateType.STAR_BLOCK_START:
          s = new StarBlockStartState_1.StarBlockStartState();
          break;
        case ATNStateType_1.ATNStateType.TOKEN_START:
          s = new TokensStartState_1.TokensStartState();
          break;
        case ATNStateType_1.ATNStateType.RULE_STOP:
          s = new RuleStopState_1.RuleStopState();
          break;
        case ATNStateType_1.ATNStateType.BLOCK_END:
          s = new BlockEndState_1.BlockEndState();
          break;
        case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:
          s = new StarLoopbackState_1.StarLoopbackState();
          break;
        case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:
          s = new StarLoopEntryState_1.StarLoopEntryState();
          break;
        case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:
          s = new PlusLoopbackState_1.PlusLoopbackState();
          break;
        case ATNStateType_1.ATNStateType.LOOP_END:
          s = new LoopEndState_1.LoopEndState();
          break;
        default:
          let message = `The specified state type ${type} is not valid.`;
          throw new Error(message);
      }
      s.ruleIndex = ruleIndex;
      return s;
    }
    lexerActionFactory(type, data1, data2) {
      switch (type) {
        case 0:
          return new LexerChannelAction_1.LexerChannelAction(data1);
        case 1:
          return new LexerCustomAction_1.LexerCustomAction(data1, data2);
        case 2:
          return new LexerModeAction_1.LexerModeAction(data1);
        case 3:
          return LexerMoreAction_1.LexerMoreAction.INSTANCE;
        case 4:
          return LexerPopModeAction_1.LexerPopModeAction.INSTANCE;
        case 5:
          return new LexerPushModeAction_1.LexerPushModeAction(data1);
        case 6:
          return LexerSkipAction_1.LexerSkipAction.INSTANCE;
        case 7:
          return new LexerTypeAction_1.LexerTypeAction(data1);
        default:
          let message = `The specified lexer action type ${type} is not valid.`;
          throw new Error(message);
      }
    }
  };
  ATNDeserializer3.BASE_SERIALIZED_UUID = UUID_1.UUID.fromString("E4178468-DF95-44D0-AD87-F22A5D5FB6D3");
  ATNDeserializer3.ADDED_LEXER_ACTIONS = UUID_1.UUID.fromString("AB35191A-1603-487E-B75A-479B831EAF6D");
  ATNDeserializer3.ADDED_UNICODE_SMP = UUID_1.UUID.fromString("C23FEA89-0605-4f51-AFB8-058BCAB8C91B");
  ATNDeserializer3.SUPPORTED_UUIDS = [
    ATNDeserializer3.BASE_SERIALIZED_UUID,
    ATNDeserializer3.ADDED_LEXER_ACTIONS,
    ATNDeserializer3.ADDED_UNICODE_SMP
  ];
  ATNDeserializer3.SERIALIZED_UUID = ATNDeserializer3.ADDED_UNICODE_SMP;
  __decorate([
    Decorators_1.NotNull
  ], ATNDeserializer3.prototype, "deserializationOptions", void 0);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], ATNDeserializer3.prototype, "deserialize", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], ATNDeserializer3.prototype, "markPrecedenceDecisions", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull)
  ], ATNDeserializer3.prototype, "edgeFactory", null);
  exports.ATNDeserializer = ATNDeserializer3;
});

// node_modules/antlr4ts/atn/ParseInfo.js
var require_ParseInfo = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ParseInfo = void 0;
  var Decorators_1 = require_Decorators();
  var ParseInfo = class ParseInfo {
    constructor(atnSimulator) {
      this.atnSimulator = atnSimulator;
    }
    getDecisionInfo() {
      return this.atnSimulator.getDecisionInfo();
    }
    getLLDecisions() {
      let decisions = this.atnSimulator.getDecisionInfo();
      let LL = [];
      for (let i = 0; i < decisions.length; i++) {
        let fallBack = decisions[i].LL_Fallback;
        if (fallBack > 0) {
          LL.push(i);
        }
      }
      return LL;
    }
    getTotalTimeInPrediction() {
      let decisions = this.atnSimulator.getDecisionInfo();
      let t = 0;
      for (let decision of decisions) {
        t += decision.timeInPrediction;
      }
      return t;
    }
    getTotalSLLLookaheadOps() {
      let decisions = this.atnSimulator.getDecisionInfo();
      let k = 0;
      for (let decision of decisions) {
        k += decision.SLL_TotalLook;
      }
      return k;
    }
    getTotalLLLookaheadOps() {
      let decisions = this.atnSimulator.getDecisionInfo();
      let k = 0;
      for (let decision of decisions) {
        k += decision.LL_TotalLook;
      }
      return k;
    }
    getTotalSLLATNLookaheadOps() {
      let decisions = this.atnSimulator.getDecisionInfo();
      let k = 0;
      for (let decision of decisions) {
        k += decision.SLL_ATNTransitions;
      }
      return k;
    }
    getTotalLLATNLookaheadOps() {
      let decisions = this.atnSimulator.getDecisionInfo();
      let k = 0;
      for (let decision of decisions) {
        k += decision.LL_ATNTransitions;
      }
      return k;
    }
    getTotalATNLookaheadOps() {
      let decisions = this.atnSimulator.getDecisionInfo();
      let k = 0;
      for (let decision of decisions) {
        k += decision.SLL_ATNTransitions;
        k += decision.LL_ATNTransitions;
      }
      return k;
    }
    getDFASize(decision) {
      if (decision) {
        let decisionToDFA = this.atnSimulator.atn.decisionToDFA[decision];
        return decisionToDFA.states.size;
      } else {
        let n = 0;
        let decisionToDFA = this.atnSimulator.atn.decisionToDFA;
        for (let i = 0; i < decisionToDFA.length; i++) {
          n += this.getDFASize(i);
        }
        return n;
      }
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], ParseInfo.prototype, "getDecisionInfo", null);
  __decorate([
    Decorators_1.NotNull
  ], ParseInfo.prototype, "getLLDecisions", null);
  ParseInfo = __decorate([
    __param(0, Decorators_1.NotNull)
  ], ParseInfo);
  exports.ParseInfo = ParseInfo;
});

// node_modules/antlr4ts/ProxyParserErrorListener.js
var require_ProxyParserErrorListener = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ProxyParserErrorListener = void 0;
  var ProxyErrorListener_1 = require_ProxyErrorListener();
  var Decorators_1 = require_Decorators();
  var ProxyParserErrorListener = class extends ProxyErrorListener_1.ProxyErrorListener {
    constructor(delegates) {
      super(delegates);
    }
    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
      this.getDelegates().forEach((listener) => {
        if (listener.reportAmbiguity) {
          listener.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
        }
      });
    }
    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {
      this.getDelegates().forEach((listener) => {
        if (listener.reportAttemptingFullContext) {
          listener.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState);
        }
      });
    }
    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {
      this.getDelegates().forEach((listener) => {
        if (listener.reportContextSensitivity) {
          listener.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState);
        }
      });
    }
  };
  __decorate([
    Decorators_1.Override
  ], ProxyParserErrorListener.prototype, "reportAmbiguity", null);
  __decorate([
    Decorators_1.Override
  ], ProxyParserErrorListener.prototype, "reportAttemptingFullContext", null);
  __decorate([
    Decorators_1.Override
  ], ProxyParserErrorListener.prototype, "reportContextSensitivity", null);
  exports.ProxyParserErrorListener = ProxyParserErrorListener;
});

// node_modules/antlr4ts/misc/Character.js
var require_Character = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.isSupplementaryCodePoint = exports.isLowSurrogate = exports.isHighSurrogate = void 0;
  function isHighSurrogate(ch) {
    return ch >= 55296 && ch <= 56319;
  }
  exports.isHighSurrogate = isHighSurrogate;
  function isLowSurrogate(ch) {
    return ch >= 56320 && ch <= 57343;
  }
  exports.isLowSurrogate = isLowSurrogate;
  function isSupplementaryCodePoint(ch) {
    return ch >= 65536;
  }
  exports.isSupplementaryCodePoint = isSupplementaryCodePoint;
});

// node_modules/antlr4ts/CodePointBuffer.js
var require_CodePointBuffer = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.CodePointBuffer = void 0;
  var assert = __nccwpck_require__(9491);
  var Character = require_Character();
  var CodePointBuffer = class {
    constructor(buffer, size) {
      this.buffer = buffer;
      this._position = 0;
      this._size = size;
    }
    static withArray(buffer) {
      return new CodePointBuffer(buffer, buffer.length);
    }
    get position() {
      return this._position;
    }
    set position(newPosition) {
      if (newPosition < 0 || newPosition > this._size) {
        throw new RangeError();
      }
      this._position = newPosition;
    }
    get remaining() {
      return this._size - this.position;
    }
    get(offset) {
      return this.buffer[offset];
    }
    array() {
      return this.buffer.slice(0, this._size);
    }
    static builder(initialBufferSize) {
      return new CodePointBuffer.Builder(initialBufferSize);
    }
  };
  exports.CodePointBuffer = CodePointBuffer;
  (function(CodePointBuffer2) {
    let Type;
    (function(Type2) {
      Type2[Type2["BYTE"] = 0] = "BYTE";
      Type2[Type2["CHAR"] = 1] = "CHAR";
      Type2[Type2["INT"] = 2] = "INT";
    })(Type || (Type = {}));
    class Builder {
      constructor(initialBufferSize) {
        this.type = 0;
        this.buffer = new Uint8Array(initialBufferSize);
        this.prevHighSurrogate = -1;
        this.position = 0;
      }
      build() {
        return new CodePointBuffer2(this.buffer, this.position);
      }
      static roundUpToNextPowerOfTwo(i) {
        let nextPowerOfTwo = 32 - Math.clz32(i - 1);
        return Math.pow(2, nextPowerOfTwo);
      }
      ensureRemaining(remainingNeeded) {
        switch (this.type) {
          case 0:
            if (this.buffer.length - this.position < remainingNeeded) {
              let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
              let newBuffer = new Uint8Array(newCapacity);
              newBuffer.set(this.buffer.subarray(0, this.position), 0);
              this.buffer = newBuffer;
            }
            break;
          case 1:
            if (this.buffer.length - this.position < remainingNeeded) {
              let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
              let newBuffer = new Uint16Array(newCapacity);
              newBuffer.set(this.buffer.subarray(0, this.position), 0);
              this.buffer = newBuffer;
            }
            break;
          case 2:
            if (this.buffer.length - this.position < remainingNeeded) {
              let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);
              let newBuffer = new Int32Array(newCapacity);
              newBuffer.set(this.buffer.subarray(0, this.position), 0);
              this.buffer = newBuffer;
            }
            break;
        }
      }
      append(utf16In) {
        this.ensureRemaining(utf16In.length);
        this.appendArray(utf16In);
      }
      appendArray(utf16In) {
        switch (this.type) {
          case 0:
            this.appendArrayByte(utf16In);
            break;
          case 1:
            this.appendArrayChar(utf16In);
            break;
          case 2:
            this.appendArrayInt(utf16In);
            break;
        }
      }
      appendArrayByte(utf16In) {
        assert(this.prevHighSurrogate === -1);
        let input = utf16In;
        let inOffset = 0;
        let inLimit = utf16In.length;
        let outByte = this.buffer;
        let outOffset = this.position;
        while (inOffset < inLimit) {
          let c = input[inOffset];
          if (c <= 255) {
            outByte[outOffset] = c;
          } else {
            utf16In = utf16In.subarray(inOffset, inLimit);
            this.position = outOffset;
            if (!Character.isHighSurrogate(c)) {
              this.byteToCharBuffer(utf16In.length);
              this.appendArrayChar(utf16In);
              return;
            } else {
              this.byteToIntBuffer(utf16In.length);
              this.appendArrayInt(utf16In);
              return;
            }
          }
          inOffset++;
          outOffset++;
        }
        this.position = outOffset;
      }
      appendArrayChar(utf16In) {
        assert(this.prevHighSurrogate === -1);
        let input = utf16In;
        let inOffset = 0;
        let inLimit = utf16In.length;
        let outChar = this.buffer;
        let outOffset = this.position;
        while (inOffset < inLimit) {
          let c = input[inOffset];
          if (!Character.isHighSurrogate(c)) {
            outChar[outOffset] = c;
          } else {
            utf16In = utf16In.subarray(inOffset, inLimit);
            this.position = outOffset;
            this.charToIntBuffer(utf16In.length);
            this.appendArrayInt(utf16In);
            return;
          }
          inOffset++;
          outOffset++;
        }
        this.position = outOffset;
      }
      appendArrayInt(utf16In) {
        let input = utf16In;
        let inOffset = 0;
        let inLimit = utf16In.length;
        let outInt = this.buffer;
        let outOffset = this.position;
        while (inOffset < inLimit) {
          let c = input[inOffset];
          inOffset++;
          if (this.prevHighSurrogate !== -1) {
            if (Character.isLowSurrogate(c)) {
              outInt[outOffset] = String.fromCharCode(this.prevHighSurrogate, c).codePointAt(0);
              outOffset++;
              this.prevHighSurrogate = -1;
            } else {
              outInt[outOffset] = this.prevHighSurrogate;
              outOffset++;
              if (Character.isHighSurrogate(c)) {
                this.prevHighSurrogate = c;
              } else {
                outInt[outOffset] = c;
                outOffset++;
                this.prevHighSurrogate = -1;
              }
            }
          } else if (Character.isHighSurrogate(c)) {
            this.prevHighSurrogate = c;
          } else {
            outInt[outOffset] = c;
            outOffset++;
          }
        }
        if (this.prevHighSurrogate !== -1) {
          outInt[outOffset] = this.prevHighSurrogate;
          outOffset++;
        }
        this.position = outOffset;
      }
      byteToCharBuffer(toAppend) {
        let newBuffer = new Uint16Array(Math.max(this.position + toAppend, this.buffer.length >> 1));
        newBuffer.set(this.buffer.subarray(0, this.position), 0);
        this.type = 1;
        this.buffer = newBuffer;
      }
      byteToIntBuffer(toAppend) {
        let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 2));
        newBuffer.set(this.buffer.subarray(0, this.position), 0);
        this.type = 2;
        this.buffer = newBuffer;
      }
      charToIntBuffer(toAppend) {
        let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 1));
        newBuffer.set(this.buffer.subarray(0, this.position), 0);
        this.type = 2;
        this.buffer = newBuffer;
      }
    }
    CodePointBuffer2.Builder = Builder;
  })(CodePointBuffer = exports.CodePointBuffer || (exports.CodePointBuffer = {}));
});

// node_modules/antlr4ts/CodePointCharStream.js
var require_CodePointCharStream = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.CodePointCharStream = void 0;
  var assert = __nccwpck_require__(9491);
  var IntStream_1 = require_IntStream();
  var Interval_1 = require_Interval();
  var Decorators_1 = require_Decorators();
  var CodePointCharStream = class {
    constructor(array, position, remaining, name) {
      assert(position === 0);
      this._array = array;
      this._size = remaining;
      this._name = name;
      this._position = 0;
    }
    get internalStorage() {
      return this._array;
    }
    static fromBuffer(codePointBuffer, name) {
      if (name === void 0 || name.length === 0) {
        name = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
      }
      return new CodePointCharStream(codePointBuffer.array(), codePointBuffer.position, codePointBuffer.remaining, name);
    }
    consume() {
      if (this._size - this._position === 0) {
        assert(this.LA(1) === IntStream_1.IntStream.EOF);
        throw new RangeError("cannot consume EOF");
      }
      this._position++;
    }
    get index() {
      return this._position;
    }
    get size() {
      return this._size;
    }
    mark() {
      return -1;
    }
    release(marker) {
    }
    seek(index) {
      this._position = index;
    }
    get sourceName() {
      return this._name;
    }
    toString() {
      return this.getText(Interval_1.Interval.of(0, this.size - 1));
    }
    LA(i) {
      let offset;
      switch (Math.sign(i)) {
        case -1:
          offset = this.index + i;
          if (offset < 0) {
            return IntStream_1.IntStream.EOF;
          }
          return this._array[offset];
        case 0:
          return 0;
        case 1:
          offset = this.index + i - 1;
          if (offset >= this.size) {
            return IntStream_1.IntStream.EOF;
          }
          return this._array[offset];
      }
      throw new RangeError("Not reached");
    }
    getText(interval) {
      const startIdx = Math.min(interval.a, this.size);
      const len = Math.min(interval.b - interval.a + 1, this.size - startIdx);
      if (this._array instanceof Int32Array) {
        return String.fromCodePoint(...Array.from(this._array.subarray(startIdx, startIdx + len)));
      } else {
        return String.fromCharCode(...Array.from(this._array.subarray(startIdx, startIdx + len)));
      }
    }
  };
  __decorate([
    Decorators_1.Override
  ], CodePointCharStream.prototype, "consume", null);
  __decorate([
    Decorators_1.Override
  ], CodePointCharStream.prototype, "index", null);
  __decorate([
    Decorators_1.Override
  ], CodePointCharStream.prototype, "size", null);
  __decorate([
    Decorators_1.Override
  ], CodePointCharStream.prototype, "mark", null);
  __decorate([
    Decorators_1.Override
  ], CodePointCharStream.prototype, "release", null);
  __decorate([
    Decorators_1.Override
  ], CodePointCharStream.prototype, "seek", null);
  __decorate([
    Decorators_1.Override
  ], CodePointCharStream.prototype, "sourceName", null);
  __decorate([
    Decorators_1.Override
  ], CodePointCharStream.prototype, "toString", null);
  __decorate([
    Decorators_1.Override
  ], CodePointCharStream.prototype, "LA", null);
  __decorate([
    Decorators_1.Override
  ], CodePointCharStream.prototype, "getText", null);
  exports.CodePointCharStream = CodePointCharStream;
});

// node_modules/antlr4ts/CharStreams.js
var require_CharStreams = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.CharStreams = void 0;
  var CodePointBuffer_1 = require_CodePointBuffer();
  var CodePointCharStream_1 = require_CodePointCharStream();
  var IntStream_1 = require_IntStream();
  var CharStreams;
  (function(CharStreams2) {
    function fromString(s, sourceName) {
      if (sourceName === void 0 || sourceName.length === 0) {
        sourceName = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;
      }
      let codePointBufferBuilder = CodePointBuffer_1.CodePointBuffer.builder(s.length);
      let cb = new Uint16Array(s.length);
      for (let i = 0; i < s.length; i++) {
        cb[i] = s.charCodeAt(i);
      }
      codePointBufferBuilder.append(cb);
      return CodePointCharStream_1.CodePointCharStream.fromBuffer(codePointBufferBuilder.build(), sourceName);
    }
    CharStreams2.fromString = fromString;
  })(CharStreams = exports.CharStreams || (exports.CharStreams = {}));
});

// node_modules/antlr4ts/BufferedTokenStream.js
var require_BufferedTokenStream = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.BufferedTokenStream = void 0;
  var assert = __nccwpck_require__(9491);
  var CommonToken_1 = require_CommonToken();
  var Interval_1 = require_Interval();
  var Lexer_1 = require_Lexer();
  var Decorators_1 = require_Decorators();
  var Token_1 = require_Token();
  var BufferedTokenStream = class BufferedTokenStream {
    constructor(tokenSource) {
      this.tokens = [];
      this.p = -1;
      this.fetchedEOF = false;
      if (tokenSource == null) {
        throw new Error("tokenSource cannot be null");
      }
      this._tokenSource = tokenSource;
    }
    get tokenSource() {
      return this._tokenSource;
    }
    set tokenSource(tokenSource) {
      this._tokenSource = tokenSource;
      this.tokens.length = 0;
      this.p = -1;
      this.fetchedEOF = false;
    }
    get index() {
      return this.p;
    }
    mark() {
      return 0;
    }
    release(marker) {
    }
    seek(index) {
      this.lazyInit();
      this.p = this.adjustSeekIndex(index);
    }
    get size() {
      return this.tokens.length;
    }
    consume() {
      let skipEofCheck;
      if (this.p >= 0) {
        if (this.fetchedEOF) {
          skipEofCheck = this.p < this.tokens.length - 1;
        } else {
          skipEofCheck = this.p < this.tokens.length;
        }
      } else {
        skipEofCheck = false;
      }
      if (!skipEofCheck && this.LA(1) === Token_1.Token.EOF) {
        throw new Error("cannot consume EOF");
      }
      if (this.sync(this.p + 1)) {
        this.p = this.adjustSeekIndex(this.p + 1);
      }
    }
    sync(i) {
      assert(i >= 0);
      let n = i - this.tokens.length + 1;
      if (n > 0) {
        let fetched = this.fetch(n);
        return fetched >= n;
      }
      return true;
    }
    fetch(n) {
      if (this.fetchedEOF) {
        return 0;
      }
      for (let i = 0; i < n; i++) {
        let t = this.tokenSource.nextToken();
        if (this.isWritableToken(t)) {
          t.tokenIndex = this.tokens.length;
        }
        this.tokens.push(t);
        if (t.type === Token_1.Token.EOF) {
          this.fetchedEOF = true;
          return i + 1;
        }
      }
      return n;
    }
    get(i) {
      if (i < 0 || i >= this.tokens.length) {
        throw new RangeError("token index " + i + " out of range 0.." + (this.tokens.length - 1));
      }
      return this.tokens[i];
    }
    getRange(start, stop) {
      if (start < 0 || stop < 0) {
        return [];
      }
      this.lazyInit();
      let subset = new Array();
      if (stop >= this.tokens.length) {
        stop = this.tokens.length - 1;
      }
      for (let i = start; i <= stop; i++) {
        let t = this.tokens[i];
        if (t.type === Token_1.Token.EOF) {
          break;
        }
        subset.push(t);
      }
      return subset;
    }
    LA(i) {
      let token = this.LT(i);
      if (!token) {
        return Token_1.Token.INVALID_TYPE;
      }
      return token.type;
    }
    tryLB(k) {
      if (this.p - k < 0) {
        return void 0;
      }
      return this.tokens[this.p - k];
    }
    LT(k) {
      let result = this.tryLT(k);
      if (result === void 0) {
        throw new RangeError("requested lookback index out of range");
      }
      return result;
    }
    tryLT(k) {
      this.lazyInit();
      if (k === 0) {
        throw new RangeError("0 is not a valid lookahead index");
      }
      if (k < 0) {
        return this.tryLB(-k);
      }
      let i = this.p + k - 1;
      this.sync(i);
      if (i >= this.tokens.length) {
        return this.tokens[this.tokens.length - 1];
      }
      return this.tokens[i];
    }
    adjustSeekIndex(i) {
      return i;
    }
    lazyInit() {
      if (this.p === -1) {
        this.setup();
      }
    }
    setup() {
      this.sync(0);
      this.p = this.adjustSeekIndex(0);
    }
    getTokens(start, stop, types) {
      this.lazyInit();
      if (start === void 0) {
        assert(stop === void 0 && types === void 0);
        return this.tokens;
      } else if (stop === void 0) {
        stop = this.tokens.length - 1;
      }
      if (start < 0 || stop >= this.tokens.length || stop < 0 || start >= this.tokens.length) {
        throw new RangeError("start " + start + " or stop " + stop + " not in 0.." + (this.tokens.length - 1));
      }
      if (start > stop) {
        return [];
      }
      if (types === void 0) {
        return this.tokens.slice(start, stop + 1);
      } else if (typeof types === "number") {
        types = new Set().add(types);
      }
      let typesSet = types;
      let filteredTokens = this.tokens.slice(start, stop + 1);
      filteredTokens = filteredTokens.filter((value) => typesSet.has(value.type));
      return filteredTokens;
    }
    nextTokenOnChannel(i, channel) {
      this.sync(i);
      if (i >= this.size) {
        return this.size - 1;
      }
      let token = this.tokens[i];
      while (token.channel !== channel) {
        if (token.type === Token_1.Token.EOF) {
          return i;
        }
        i++;
        this.sync(i);
        token = this.tokens[i];
      }
      return i;
    }
    previousTokenOnChannel(i, channel) {
      this.sync(i);
      if (i >= this.size) {
        return this.size - 1;
      }
      while (i >= 0) {
        let token = this.tokens[i];
        if (token.type === Token_1.Token.EOF || token.channel === channel) {
          return i;
        }
        i--;
      }
      return i;
    }
    getHiddenTokensToRight(tokenIndex, channel = -1) {
      this.lazyInit();
      if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
        throw new RangeError(tokenIndex + " not in 0.." + (this.tokens.length - 1));
      }
      let nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);
      let to;
      let from = tokenIndex + 1;
      if (nextOnChannel === -1) {
        to = this.size - 1;
      } else {
        to = nextOnChannel;
      }
      return this.filterForChannel(from, to, channel);
    }
    getHiddenTokensToLeft(tokenIndex, channel = -1) {
      this.lazyInit();
      if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
        throw new RangeError(tokenIndex + " not in 0.." + (this.tokens.length - 1));
      }
      if (tokenIndex === 0) {
        return [];
      }
      let prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL);
      if (prevOnChannel === tokenIndex - 1) {
        return [];
      }
      let from = prevOnChannel + 1;
      let to = tokenIndex - 1;
      return this.filterForChannel(from, to, channel);
    }
    filterForChannel(from, to, channel) {
      let hidden = new Array();
      for (let i = from; i <= to; i++) {
        let t = this.tokens[i];
        if (channel === -1) {
          if (t.channel !== Lexer_1.Lexer.DEFAULT_TOKEN_CHANNEL) {
            hidden.push(t);
          }
        } else {
          if (t.channel === channel) {
            hidden.push(t);
          }
        }
      }
      return hidden;
    }
    get sourceName() {
      return this.tokenSource.sourceName;
    }
    getText(interval) {
      if (interval === void 0) {
        interval = Interval_1.Interval.of(0, this.size - 1);
      } else if (!(interval instanceof Interval_1.Interval)) {
        interval = interval.sourceInterval;
      }
      let start = interval.a;
      let stop = interval.b;
      if (start < 0 || stop < 0) {
        return "";
      }
      this.fill();
      if (stop >= this.tokens.length) {
        stop = this.tokens.length - 1;
      }
      let buf = "";
      for (let i = start; i <= stop; i++) {
        let t = this.tokens[i];
        if (t.type === Token_1.Token.EOF) {
          break;
        }
        buf += t.text;
      }
      return buf.toString();
    }
    getTextFromRange(start, stop) {
      if (this.isToken(start) && this.isToken(stop)) {
        return this.getText(Interval_1.Interval.of(start.tokenIndex, stop.tokenIndex));
      }
      return "";
    }
    fill() {
      this.lazyInit();
      const blockSize = 1e3;
      while (true) {
        let fetched = this.fetch(blockSize);
        if (fetched < blockSize) {
          return;
        }
      }
    }
    isWritableToken(t) {
      return t instanceof CommonToken_1.CommonToken;
    }
    isToken(t) {
      return t instanceof CommonToken_1.CommonToken;
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], BufferedTokenStream.prototype, "_tokenSource", void 0);
  __decorate([
    Decorators_1.Override
  ], BufferedTokenStream.prototype, "tokenSource", null);
  __decorate([
    Decorators_1.Override
  ], BufferedTokenStream.prototype, "index", null);
  __decorate([
    Decorators_1.Override
  ], BufferedTokenStream.prototype, "mark", null);
  __decorate([
    Decorators_1.Override
  ], BufferedTokenStream.prototype, "release", null);
  __decorate([
    Decorators_1.Override
  ], BufferedTokenStream.prototype, "seek", null);
  __decorate([
    Decorators_1.Override
  ], BufferedTokenStream.prototype, "size", null);
  __decorate([
    Decorators_1.Override
  ], BufferedTokenStream.prototype, "consume", null);
  __decorate([
    Decorators_1.Override
  ], BufferedTokenStream.prototype, "get", null);
  __decorate([
    Decorators_1.Override
  ], BufferedTokenStream.prototype, "LA", null);
  __decorate([
    Decorators_1.NotNull,
    Decorators_1.Override
  ], BufferedTokenStream.prototype, "LT", null);
  __decorate([
    Decorators_1.Override
  ], BufferedTokenStream.prototype, "sourceName", null);
  __decorate([
    Decorators_1.NotNull,
    Decorators_1.Override
  ], BufferedTokenStream.prototype, "getText", null);
  __decorate([
    Decorators_1.NotNull,
    Decorators_1.Override
  ], BufferedTokenStream.prototype, "getTextFromRange", null);
  BufferedTokenStream = __decorate([
    __param(0, Decorators_1.NotNull)
  ], BufferedTokenStream);
  exports.BufferedTokenStream = BufferedTokenStream;
});

// node_modules/antlr4ts/CommonTokenStream.js
var require_CommonTokenStream = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.CommonTokenStream = void 0;
  var BufferedTokenStream_1 = require_BufferedTokenStream();
  var Decorators_1 = require_Decorators();
  var Token_1 = require_Token();
  var CommonTokenStream2 = class CommonTokenStream extends BufferedTokenStream_1.BufferedTokenStream {
    constructor(tokenSource, channel = Token_1.Token.DEFAULT_CHANNEL) {
      super(tokenSource);
      this.channel = channel;
    }
    adjustSeekIndex(i) {
      return this.nextTokenOnChannel(i, this.channel);
    }
    tryLB(k) {
      if (this.p - k < 0) {
        return void 0;
      }
      let i = this.p;
      let n = 1;
      while (n <= k && i > 0) {
        i = this.previousTokenOnChannel(i - 1, this.channel);
        n++;
      }
      if (i < 0) {
        return void 0;
      }
      return this.tokens[i];
    }
    tryLT(k) {
      this.lazyInit();
      if (k === 0) {
        throw new RangeError("0 is not a valid lookahead index");
      }
      if (k < 0) {
        return this.tryLB(-k);
      }
      let i = this.p;
      let n = 1;
      while (n < k) {
        if (this.sync(i + 1)) {
          i = this.nextTokenOnChannel(i + 1, this.channel);
        }
        n++;
      }
      return this.tokens[i];
    }
    getNumberOfOnChannelTokens() {
      let n = 0;
      this.fill();
      for (let t of this.tokens) {
        if (t.channel === this.channel) {
          n++;
        }
        if (t.type === Token_1.Token.EOF) {
          break;
        }
      }
      return n;
    }
  };
  __decorate([
    Decorators_1.Override
  ], CommonTokenStream2.prototype, "adjustSeekIndex", null);
  __decorate([
    Decorators_1.Override
  ], CommonTokenStream2.prototype, "tryLB", null);
  __decorate([
    Decorators_1.Override
  ], CommonTokenStream2.prototype, "tryLT", null);
  CommonTokenStream2 = __decorate([
    __param(0, Decorators_1.NotNull)
  ], CommonTokenStream2);
  exports.CommonTokenStream = CommonTokenStream2;
});

// node_modules/antlr4ts/ListTokenSource.js
var require_ListTokenSource = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ListTokenSource = void 0;
  var CommonTokenFactory_1 = require_CommonTokenFactory();
  var Decorators_1 = require_Decorators();
  var Token_1 = require_Token();
  var ListTokenSource = class ListTokenSource {
    constructor(tokens2, sourceName) {
      this.i = 0;
      this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;
      if (tokens2 == null) {
        throw new Error("tokens cannot be null");
      }
      this.tokens = tokens2;
      this._sourceName = sourceName;
    }
    get charPositionInLine() {
      if (this.i < this.tokens.length) {
        return this.tokens[this.i].charPositionInLine;
      } else if (this.eofToken != null) {
        return this.eofToken.charPositionInLine;
      } else if (this.tokens.length > 0) {
        let lastToken = this.tokens[this.tokens.length - 1];
        let tokenText = lastToken.text;
        if (tokenText != null) {
          let lastNewLine = tokenText.lastIndexOf("\n");
          if (lastNewLine >= 0) {
            return tokenText.length - lastNewLine - 1;
          }
        }
        return lastToken.charPositionInLine + lastToken.stopIndex - lastToken.startIndex + 1;
      }
      return 0;
    }
    nextToken() {
      if (this.i >= this.tokens.length) {
        if (this.eofToken == null) {
          let start = -1;
          if (this.tokens.length > 0) {
            let previousStop = this.tokens[this.tokens.length - 1].stopIndex;
            if (previousStop !== -1) {
              start = previousStop + 1;
            }
          }
          let stop = Math.max(-1, start - 1);
          this.eofToken = this._factory.create({source: this, stream: this.inputStream}, Token_1.Token.EOF, "EOF", Token_1.Token.DEFAULT_CHANNEL, start, stop, this.line, this.charPositionInLine);
        }
        return this.eofToken;
      }
      let t = this.tokens[this.i];
      if (this.i === this.tokens.length - 1 && t.type === Token_1.Token.EOF) {
        this.eofToken = t;
      }
      this.i++;
      return t;
    }
    get line() {
      if (this.i < this.tokens.length) {
        return this.tokens[this.i].line;
      } else if (this.eofToken != null) {
        return this.eofToken.line;
      } else if (this.tokens.length > 0) {
        let lastToken = this.tokens[this.tokens.length - 1];
        let line = lastToken.line;
        let tokenText = lastToken.text;
        if (tokenText != null) {
          for (let i = 0; i < tokenText.length; i++) {
            if (tokenText.charAt(i) === "\n") {
              line++;
            }
          }
        }
        return line;
      }
      return 1;
    }
    get inputStream() {
      if (this.i < this.tokens.length) {
        return this.tokens[this.i].inputStream;
      } else if (this.eofToken != null) {
        return this.eofToken.inputStream;
      } else if (this.tokens.length > 0) {
        return this.tokens[this.tokens.length - 1].inputStream;
      }
      return void 0;
    }
    get sourceName() {
      if (this._sourceName) {
        return this._sourceName;
      }
      let inputStream = this.inputStream;
      if (inputStream != null) {
        return inputStream.sourceName;
      }
      return "List";
    }
    set tokenFactory(factory) {
      this._factory = factory;
    }
    get tokenFactory() {
      return this._factory;
    }
  };
  __decorate([
    Decorators_1.Override
  ], ListTokenSource.prototype, "charPositionInLine", null);
  __decorate([
    Decorators_1.Override
  ], ListTokenSource.prototype, "nextToken", null);
  __decorate([
    Decorators_1.Override
  ], ListTokenSource.prototype, "line", null);
  __decorate([
    Decorators_1.Override
  ], ListTokenSource.prototype, "inputStream", null);
  __decorate([
    Decorators_1.Override
  ], ListTokenSource.prototype, "sourceName", null);
  __decorate([
    Decorators_1.Override,
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull)
  ], ListTokenSource.prototype, "tokenFactory", null);
  ListTokenSource = __decorate([
    __param(0, Decorators_1.NotNull)
  ], ListTokenSource);
  exports.ListTokenSource = ListTokenSource;
});

// node_modules/antlr4ts/misc/MultiMap.js
var require_MultiMap = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.MultiMap = void 0;
  var MultiMap = class extends Map {
    constructor() {
      super();
    }
    map(key, value) {
      let elementsForKey = super.get(key);
      if (!elementsForKey) {
        elementsForKey = [];
        super.set(key, elementsForKey);
      }
      elementsForKey.push(value);
    }
    getPairs() {
      let pairs = [];
      this.forEach((values, key) => {
        values.forEach((v) => {
          pairs.push([key, v]);
        });
      });
      return pairs;
    }
  };
  exports.MultiMap = MultiMap;
});

// node_modules/antlr4ts/misc/ParseCancellationException.js
var require_ParseCancellationException = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ParseCancellationException = void 0;
  var ParseCancellationException = class extends Error {
    constructor(cause) {
      super(cause.message);
      this.cause = cause;
      this.stack = cause.stack;
    }
    getCause() {
      return this.cause;
    }
  };
  exports.ParseCancellationException = ParseCancellationException;
});

// node_modules/antlr4ts/InterpreterRuleContext.js
var require_InterpreterRuleContext = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.InterpreterRuleContext = void 0;
  var Decorators_1 = require_Decorators();
  var ParserRuleContext_1 = require_ParserRuleContext();
  var InterpreterRuleContext = class extends ParserRuleContext_1.ParserRuleContext {
    constructor(ruleIndex, parent, invokingStateNumber) {
      if (invokingStateNumber !== void 0) {
        super(parent, invokingStateNumber);
      } else {
        super();
      }
      this._ruleIndex = ruleIndex;
    }
    get ruleIndex() {
      return this._ruleIndex;
    }
  };
  __decorate([
    Decorators_1.Override
  ], InterpreterRuleContext.prototype, "ruleIndex", null);
  exports.InterpreterRuleContext = InterpreterRuleContext;
});

// node_modules/antlr4ts/ParserInterpreter.js
var require_ParserInterpreter = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ParserInterpreter = void 0;
  var ATNState_1 = require_ATNState();
  var ATNStateType_1 = require_ATNStateType();
  var BitSet_1 = require_BitSet();
  var FailedPredicateException_1 = require_FailedPredicateException();
  var InputMismatchException_1 = require_InputMismatchException();
  var InterpreterRuleContext_1 = require_InterpreterRuleContext();
  var LoopEndState_1 = require_LoopEndState();
  var Decorators_1 = require_Decorators();
  var Decorators_2 = require_Decorators();
  var Parser_1 = require_Parser();
  var ParserATNSimulator_1 = require_ParserATNSimulator();
  var RecognitionException_1 = require_RecognitionException();
  var StarLoopEntryState_1 = require_StarLoopEntryState();
  var Token_1 = require_Token();
  var ParserInterpreter = class ParserInterpreter2 extends Parser_1.Parser {
    constructor(grammarFileName, vocabulary, ruleNames, atn, input) {
      super(grammarFileName instanceof ParserInterpreter2 ? grammarFileName.inputStream : input);
      this._parentContextStack = [];
      this.overrideDecision = -1;
      this.overrideDecisionInputIndex = -1;
      this.overrideDecisionAlt = -1;
      this.overrideDecisionReached = false;
      this._overrideDecisionRoot = void 0;
      if (grammarFileName instanceof ParserInterpreter2) {
        let old = grammarFileName;
        this._grammarFileName = old._grammarFileName;
        this._atn = old._atn;
        this.pushRecursionContextStates = old.pushRecursionContextStates;
        this._ruleNames = old._ruleNames;
        this._vocabulary = old._vocabulary;
        this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this._atn, this);
      } else {
        vocabulary = vocabulary;
        ruleNames = ruleNames;
        atn = atn;
        this._grammarFileName = grammarFileName;
        this._atn = atn;
        this._ruleNames = ruleNames.slice(0);
        this._vocabulary = vocabulary;
        this.pushRecursionContextStates = new BitSet_1.BitSet(atn.states.length);
        for (let state of atn.states) {
          if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {
            continue;
          }
          if (state.precedenceRuleDecision) {
            this.pushRecursionContextStates.set(state.stateNumber);
          }
        }
        this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(atn, this);
      }
    }
    reset(resetInput) {
      if (resetInput === void 0) {
        super.reset();
      } else {
        super.reset(resetInput);
      }
      this.overrideDecisionReached = false;
      this._overrideDecisionRoot = void 0;
    }
    get atn() {
      return this._atn;
    }
    get vocabulary() {
      return this._vocabulary;
    }
    get ruleNames() {
      return this._ruleNames;
    }
    get grammarFileName() {
      return this._grammarFileName;
    }
    parse(startRuleIndex) {
      let startRuleStartState = this._atn.ruleToStartState[startRuleIndex];
      this._rootContext = this.createInterpreterRuleContext(void 0, ATNState_1.ATNState.INVALID_STATE_NUMBER, startRuleIndex);
      if (startRuleStartState.isPrecedenceRule) {
        this.enterRecursionRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex, 0);
      } else {
        this.enterRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex);
      }
      while (true) {
        let p = this.atnState;
        switch (p.stateType) {
          case ATNStateType_1.ATNStateType.RULE_STOP:
            if (this._ctx.isEmpty) {
              if (startRuleStartState.isPrecedenceRule) {
                let result = this._ctx;
                let parentContext = this._parentContextStack.pop();
                this.unrollRecursionContexts(parentContext[0]);
                return result;
              } else {
                this.exitRule();
                return this._rootContext;
              }
            }
            this.visitRuleStopState(p);
            break;
          default:
            try {
              this.visitState(p);
            } catch (e) {
              if (e instanceof RecognitionException_1.RecognitionException) {
                this.state = this._atn.ruleToStopState[p.ruleIndex].stateNumber;
                this.context.exception = e;
                this.errorHandler.reportError(this, e);
                this.recover(e);
              } else {
                throw e;
              }
            }
            break;
        }
      }
    }
    enterRecursionRule(localctx, state, ruleIndex, precedence) {
      this._parentContextStack.push([this._ctx, localctx.invokingState]);
      super.enterRecursionRule(localctx, state, ruleIndex, precedence);
    }
    get atnState() {
      return this._atn.states[this.state];
    }
    visitState(p) {
      let predictedAlt = 1;
      if (p.numberOfTransitions > 1) {
        predictedAlt = this.visitDecisionState(p);
      }
      let transition = p.transition(predictedAlt - 1);
      switch (transition.serializationType) {
        case 1:
          if (this.pushRecursionContextStates.get(p.stateNumber) && !(transition.target instanceof LoopEndState_1.LoopEndState)) {
            let parentContext = this._parentContextStack[this._parentContextStack.length - 1];
            let localctx = this.createInterpreterRuleContext(parentContext[0], parentContext[1], this._ctx.ruleIndex);
            this.pushNewRecursionContext(localctx, this._atn.ruleToStartState[p.ruleIndex].stateNumber, this._ctx.ruleIndex);
          }
          break;
        case 5:
          this.match(transition._label);
          break;
        case 2:
        case 7:
        case 8:
          if (!transition.matches(this._input.LA(1), Token_1.Token.MIN_USER_TOKEN_TYPE, 65535)) {
            this.recoverInline();
          }
          this.matchWildcard();
          break;
        case 9:
          this.matchWildcard();
          break;
        case 3:
          let ruleStartState = transition.target;
          let ruleIndex = ruleStartState.ruleIndex;
          let newctx = this.createInterpreterRuleContext(this._ctx, p.stateNumber, ruleIndex);
          if (ruleStartState.isPrecedenceRule) {
            this.enterRecursionRule(newctx, ruleStartState.stateNumber, ruleIndex, transition.precedence);
          } else {
            this.enterRule(newctx, transition.target.stateNumber, ruleIndex);
          }
          break;
        case 4:
          let predicateTransition = transition;
          if (!this.sempred(this._ctx, predicateTransition.ruleIndex, predicateTransition.predIndex)) {
            throw new FailedPredicateException_1.FailedPredicateException(this);
          }
          break;
        case 6:
          let actionTransition = transition;
          this.action(this._ctx, actionTransition.ruleIndex, actionTransition.actionIndex);
          break;
        case 10:
          if (!this.precpred(this._ctx, transition.precedence)) {
            let precedence = transition.precedence;
            throw new FailedPredicateException_1.FailedPredicateException(this, `precpred(_ctx, ${precedence})`);
          }
          break;
        default:
          throw new Error("UnsupportedOperationException: Unrecognized ATN transition type.");
      }
      this.state = transition.target.stateNumber;
    }
    visitDecisionState(p) {
      let predictedAlt;
      this.errorHandler.sync(this);
      let decision = p.decision;
      if (decision === this.overrideDecision && this._input.index === this.overrideDecisionInputIndex && !this.overrideDecisionReached) {
        predictedAlt = this.overrideDecisionAlt;
        this.overrideDecisionReached = true;
      } else {
        predictedAlt = this.interpreter.adaptivePredict(this._input, decision, this._ctx);
      }
      return predictedAlt;
    }
    createInterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {
      return new InterpreterRuleContext_1.InterpreterRuleContext(ruleIndex, parent, invokingStateNumber);
    }
    visitRuleStopState(p) {
      let ruleStartState = this._atn.ruleToStartState[p.ruleIndex];
      if (ruleStartState.isPrecedenceRule) {
        let parentContext = this._parentContextStack.pop();
        this.unrollRecursionContexts(parentContext[0]);
        this.state = parentContext[1];
      } else {
        this.exitRule();
      }
      let ruleTransition = this._atn.states[this.state].transition(0);
      this.state = ruleTransition.followState.stateNumber;
    }
    addDecisionOverride(decision, tokenIndex, forcedAlt) {
      this.overrideDecision = decision;
      this.overrideDecisionInputIndex = tokenIndex;
      this.overrideDecisionAlt = forcedAlt;
    }
    get overrideDecisionRoot() {
      return this._overrideDecisionRoot;
    }
    recover(e) {
      let i = this._input.index;
      this.errorHandler.recover(this, e);
      if (this._input.index === i) {
        let tok = e.getOffendingToken();
        if (!tok) {
          throw new Error("Expected exception to have an offending token");
        }
        let source = tok.tokenSource;
        let stream = source !== void 0 ? source.inputStream : void 0;
        let sourcePair = {source, stream};
        if (e instanceof InputMismatchException_1.InputMismatchException) {
          let expectedTokens = e.expectedTokens;
          if (expectedTokens === void 0) {
            throw new Error("Expected the exception to provide expected tokens");
          }
          let expectedTokenType = Token_1.Token.INVALID_TYPE;
          if (!expectedTokens.isNil) {
            expectedTokenType = expectedTokens.minElement;
          }
          let errToken = this.tokenFactory.create(sourcePair, expectedTokenType, tok.text, Token_1.Token.DEFAULT_CHANNEL, -1, -1, tok.line, tok.charPositionInLine);
          this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));
        } else {
          let source2 = tok.tokenSource;
          let errToken = this.tokenFactory.create(sourcePair, Token_1.Token.INVALID_TYPE, tok.text, Token_1.Token.DEFAULT_CHANNEL, -1, -1, tok.line, tok.charPositionInLine);
          this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));
        }
      }
    }
    recoverInline() {
      return this._errHandler.recoverInline(this);
    }
    get rootContext() {
      return this._rootContext;
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], ParserInterpreter.prototype, "_vocabulary", void 0);
  __decorate([
    Decorators_2.Override
  ], ParserInterpreter.prototype, "reset", null);
  __decorate([
    Decorators_2.Override
  ], ParserInterpreter.prototype, "atn", null);
  __decorate([
    Decorators_2.Override
  ], ParserInterpreter.prototype, "vocabulary", null);
  __decorate([
    Decorators_2.Override
  ], ParserInterpreter.prototype, "ruleNames", null);
  __decorate([
    Decorators_2.Override
  ], ParserInterpreter.prototype, "grammarFileName", null);
  __decorate([
    Decorators_2.Override
  ], ParserInterpreter.prototype, "enterRecursionRule", null);
  ParserInterpreter = __decorate([
    __param(1, Decorators_1.NotNull)
  ], ParserInterpreter);
  exports.ParserInterpreter = ParserInterpreter;
});

// node_modules/antlr4ts/tree/pattern/ParseTreeMatch.js
var require_ParseTreeMatch = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ParseTreeMatch = void 0;
  var Decorators_1 = require_Decorators();
  var ParseTreeMatch = class ParseTreeMatch {
    constructor(tree, pattern, labels, mismatchedNode) {
      if (!tree) {
        throw new Error("tree cannot be null");
      }
      if (!pattern) {
        throw new Error("pattern cannot be null");
      }
      if (!labels) {
        throw new Error("labels cannot be null");
      }
      this._tree = tree;
      this._pattern = pattern;
      this._labels = labels;
      this._mismatchedNode = mismatchedNode;
    }
    get(label) {
      let parseTrees = this._labels.get(label);
      if (!parseTrees || parseTrees.length === 0) {
        return void 0;
      }
      return parseTrees[parseTrees.length - 1];
    }
    getAll(label) {
      const nodes = this._labels.get(label);
      if (!nodes) {
        return [];
      }
      return nodes;
    }
    get labels() {
      return this._labels;
    }
    get mismatchedNode() {
      return this._mismatchedNode;
    }
    get succeeded() {
      return !this._mismatchedNode;
    }
    get pattern() {
      return this._pattern;
    }
    get tree() {
      return this._tree;
    }
    toString() {
      return `Match ${this.succeeded ? "succeeded" : "failed"}; found ${this.labels.size} labels`;
    }
  };
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull)
  ], ParseTreeMatch.prototype, "getAll", null);
  __decorate([
    Decorators_1.NotNull
  ], ParseTreeMatch.prototype, "labels", null);
  __decorate([
    Decorators_1.NotNull
  ], ParseTreeMatch.prototype, "pattern", null);
  __decorate([
    Decorators_1.NotNull
  ], ParseTreeMatch.prototype, "tree", null);
  __decorate([
    Decorators_1.Override
  ], ParseTreeMatch.prototype, "toString", null);
  ParseTreeMatch = __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull)
  ], ParseTreeMatch);
  exports.ParseTreeMatch = ParseTreeMatch;
});

// node_modules/antlr4ts/tree/xpath/XPathLexer.js
var require_XPathLexer = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.XPathLexer = void 0;
  var ATNDeserializer_1 = require_ATNDeserializer();
  var Lexer_1 = require_Lexer();
  var LexerATNSimulator_1 = require_LexerATNSimulator();
  var VocabularyImpl_1 = require_VocabularyImpl();
  var Utils3 = require_Utils();
  var XPathLexer = class extends Lexer_1.Lexer {
    constructor(input) {
      super(input);
      this._interp = new LexerATNSimulator_1.LexerATNSimulator(XPathLexer._ATN, this);
    }
    get vocabulary() {
      return XPathLexer.VOCABULARY;
    }
    get grammarFileName() {
      return "XPathLexer.g4";
    }
    get ruleNames() {
      return XPathLexer.ruleNames;
    }
    get serializedATN() {
      return XPathLexer._serializedATN;
    }
    get channelNames() {
      return XPathLexer.channelNames;
    }
    get modeNames() {
      return XPathLexer.modeNames;
    }
    action(_localctx, ruleIndex, actionIndex) {
      switch (ruleIndex) {
        case 4:
          this.ID_action(_localctx, actionIndex);
          break;
      }
    }
    ID_action(_localctx, actionIndex) {
      switch (actionIndex) {
        case 0:
          let text = this.text;
          if (text.charAt(0) === text.charAt(0).toUpperCase()) {
            this.type = XPathLexer.TOKEN_REF;
          } else {
            this.type = XPathLexer.RULE_REF;
          }
          break;
      }
    }
    static get _ATN() {
      if (!XPathLexer.__ATN) {
        XPathLexer.__ATN = new ATNDeserializer_1.ATNDeserializer().deserialize(Utils3.toCharArray(XPathLexer._serializedATN));
      }
      return XPathLexer.__ATN;
    }
  };
  exports.XPathLexer = XPathLexer;
  XPathLexer.TOKEN_REF = 1;
  XPathLexer.RULE_REF = 2;
  XPathLexer.ANYWHERE = 3;
  XPathLexer.ROOT = 4;
  XPathLexer.WILDCARD = 5;
  XPathLexer.BANG = 6;
  XPathLexer.ID = 7;
  XPathLexer.STRING = 8;
  XPathLexer.channelNames = [
    "DEFAULT_TOKEN_CHANNEL",
    "HIDDEN"
  ];
  XPathLexer.modeNames = [
    "DEFAULT_MODE"
  ];
  XPathLexer.ruleNames = [
    "ANYWHERE",
    "ROOT",
    "WILDCARD",
    "BANG",
    "ID",
    "NameChar",
    "NameStartChar",
    "STRING"
  ];
  XPathLexer._LITERAL_NAMES = [
    void 0,
    void 0,
    void 0,
    "'//'",
    "'/'",
    "'*'",
    "'!'"
  ];
  XPathLexer._SYMBOLIC_NAMES = [
    void 0,
    "TOKEN_REF",
    "RULE_REF",
    "ANYWHERE",
    "ROOT",
    "WILDCARD",
    "BANG",
    "ID",
    "STRING"
  ];
  XPathLexer.VOCABULARY = new VocabularyImpl_1.VocabularyImpl(XPathLexer._LITERAL_NAMES, XPathLexer._SYMBOLIC_NAMES, []);
  XPathLexer._serializedATNSegments = 2;
  XPathLexer._serializedATNSegment0 = '\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\n2\b					\x07	\x07\b	\b			\x07\n\f"\v\x07\x07\b\b		\x07	,\n	\f		/\v			-\n\x07\x07	\b\v	\r\n\u02B6\n2;C\\aac|\x81\xA1\xAC\xAC\xAF\xAF\xB7\xB7\xBC\xBC\xC2\xD8\xDA\xF8\xFA\u02C3\u02C8\u02D3\u02E2\u02E6\u02EE\u02EE\u02F0\u02F0\u0302\u0376\u0378\u0379\u037C\u037F\u0381\u0381\u0388\u0388\u038A\u038C\u038E\u038E\u0390\u03A3\u03A5\u03F7\u03F9\u0483\u0485\u0489\u048C\u0531\u0533\u0558\u055B\u055B\u0563\u0589\u0593\u05BF\u05C1\u05C1\u05C3\u05C4\u05C6\u05C7\u05C9\u05C9\u05D2\u05EC\u05F2\u05F4\u0602\u0607\u0612\u061C\u061E\u061E\u0622\u066B\u0670\u06D5\u06D7\u06DF\u06E1\u06EA\u06EC\u06FE\u0701\u0701\u0711\u074C\u074F\u07B3\u07C2\u07F7\u07FC\u07FC\u0802\u082F\u0842\u085D\u08A2\u08B6\u08B8\u08BF\u08D6\u0965\u0968\u0971\u0973\u0985\u0987\u098E\u0991\u0992\u0995\u09AA\u09AC\u09B2\u09B4\u09B4\u09B8\u09BB\u09BE\u09C6\u09C9\u09CA\u09CD\u09D0\u09D9\u09D9\u09DE\u09DF\u09E1\u09E5\u09E8\u09F3\u0A03\u0A05\u0A07\u0A0C\u0A11\u0A12\u0A15\u0A2A\u0A2C\u0A32\u0A34\u0A35\u0A37\u0A38\u0A3A\u0A3B\u0A3E\u0A3E\u0A40\u0A44\u0A49\u0A4A\u0A4D\u0A4F\u0A53\u0A53\u0A5B\u0A5E\u0A60\u0A60\u0A68\u0A77\u0A83\u0A85\u0A87\u0A8F\u0A91\u0A93\u0A95\u0AAA\u0AAC\u0AB2\u0AB4\u0AB5\u0AB7\u0ABB\u0ABE\u0AC7\u0AC9\u0ACB\u0ACD\u0ACF\u0AD2\u0AD2\u0AE2\u0AE5\u0AE8\u0AF1\u0AFB\u0AFB\u0B03\u0B05\u0B07\u0B0E\u0B11\u0B12\u0B15\u0B2A\u0B2C\u0B32\u0B34\u0B35\u0B37\u0B3B\u0B3E\u0B46\u0B49\u0B4A\u0B4D\u0B4F\u0B58\u0B59\u0B5E\u0B5F\u0B61\u0B65\u0B68\u0B71\u0B73\u0B73\u0B84\u0B85\u0B87\u0B8C\u0B90\u0B92\u0B94\u0B97\u0B9B\u0B9C\u0B9E\u0B9E\u0BA0\u0BA1\u0BA5\u0BA6\u0BAA\u0BAC\u0BB0\u0BBB\u0BC0\u0BC4\u0BC8\u0BCA\u0BCC\u0BCF\u0BD2\u0BD2\u0BD9\u0BD9\u0BE8\u0BF1\u0C02\u0C05\u0C07\u0C0E\u0C10\u0C12\u0C14\u0C2A\u0C2C\u0C3B\u0C3F\u0C46\u0C48\u0C4A\u0C4C\u0C4F\u0C57\u0C58\u0C5A\u0C5C\u0C62\u0C65\u0C68\u0C71\u0C82\u0C85\u0C87\u0C8E\u0C90\u0C92\u0C94\u0CAA\u0CAC\u0CB5\u0CB7\u0CBB\u0CBE\u0CC6\u0CC8\u0CCA\u0CCC\u0CCF\u0CD7\u0CD8\u0CE0\u0CE0\u0CE2\u0CE5\u0CE8\u0CF1\u0CF3\u0CF4\u0D03\u0D05\u0D07\u0D0E\u0D10\u0D12\u0D14\u0D3C\u0D3F\u0D46\u0D48\u0D4A\u0D4C\u0D50\u0D56\u0D59\u0D61\u0D65\u0D68\u0D71\u0D7C\u0D81\u0D84\u0D85\u0D87\u0D98\u0D9C\u0DB3\u0DB5\u0DBD\u0DBF\u0DBF\u0DC2\u0DC8\u0DCC\u0DCC\u0DD1\u0DD6\u0DD8\u0DD8\u0DDA\u0DE1\u0DE8\u0DF1\u0DF4\u0DF5\u0E03\u0E3C\u0E42\u0E50\u0E52\u0E5B\u0E83\u0E84\u0E86\u0E86\u0E89\u0E8A\u0E8C\u0E8C\u0E8F\u0E8F\u0E96\u0E99\u0E9B\u0EA1\u0EA3\u0EA5\u0EA7\u0EA7\u0EA9\u0EA9\u0EAC\u0EAD\u0EAF\u0EBB\u0EBD\u0EBF\u0EC2\u0EC6\u0EC8\u0EC8\u0ECA\u0ECF\u0ED2\u0EDB\u0EDE\u0EE1\u0F02\u0F02\u0F1A\u0F1B\u0F22\u0F2B\u0F37\u0F37\u0F39\u0F39\u0F3B\u0F3B\u0F40\u0F49\u0F4B\u0F6E\u0F73\u0F86\u0F88\u0F99\u0F9B\u0FBE\u0FC8\u0FC8\u1002\u104B\u1052\u109F\u10A2\u10C7\u10C9\u10C9\u10CF\u10CF\u10D2\u10FC\u10FE\u124A\u124C\u124F\u1252\u1258\u125A\u125A\u125C\u125F\u1262\u128A\u128C\u128F\u1292\u12B2\u12B4\u12B7\u12BA\u12C0\u12C2\u12C2\u12C4\u12C7\u12CA\u12D8\u12DA\u1312\u1314\u1317\u131A\u135C\u135F\u1361\u1382\u1391\u13A2\u13F7\u13FA\u13FF\u1403\u166E\u1671\u1681\u1683\u169C\u16A2\u16EC\u16F0\u16FA\u1702\u170E\u1710\u1716\u1722\u1736\u1742\u1755\u1762\u176E\u1770\u1772\u1774\u1775\u1782\u17D5\u17D9\u17D9\u17DE\u17DF\u17E2\u17EB\u180D\u1810\u1812\u181B\u1822\u1879\u1882\u18AC\u18B2\u18F7\u1902\u1920\u1922\u192D\u1932\u193D\u1948\u196F\u1972\u1976\u1982\u19AD\u19B2\u19CB\u19D2\u19DB\u1A02\u1A1D\u1A22\u1A60\u1A62\u1A7E\u1A81\u1A8B\u1A92\u1A9B\u1AA9\u1AA9\u1AB2\u1ABF\u1B02\u1B4D\u1B52\u1B5B\u1B6D\u1B75\u1B82\u1BF5\u1C02\u1C39\u1C42\u1C4B\u1C4F\u1C7F\u1C82\u1C8A\u1CD2\u1CD4\u1CD6\u1CF8\u1CFA\u1CFB\u1D02\u1DF7\u1DFD\u1F17\u1F1A\u1F1F\u1F22\u1F47\u1F4A\u1F4F\u1F52\u1F59\u1F5B\u1F5B\u1F5D\u1F5D\u1F5F\u1F5F\u1F61\u1F7F\u1F82\u1FB6\u1FB8\u1FBE\u1FC0\u1FC0\u1FC4\u1FC6\u1FC8\u1FCE\u1FD2\u1FD5\u1FD8\u1FDD\u1FE2\u1FEE\u1FF4\u1FF6\u1FF8\u1FFE\u200D\u2011\u202C\u2030\u2041\u2042\u2056\u2056\u2062\u2066\u2068\u2071\u2073\u2073\u2081\u2081\u2092\u209E\u20D2\u20DE\u20E3\u20E3\u20E7\u20F2\u2104\u2104\u2109\u2109\u210C\u2115\u2117\u2117\u211B\u211F\u2126\u2126\u2128\u2128\u212A\u212A\u212C\u212F\u2131\u213B\u213E\u2141\u2147\u214B\u2150\u2150\u2162\u218A\u2C02\u2C30\u2C32\u2C60\u2C62\u2CE6\u2CED\u2CF5\u2D02\u2D27\u2D29\u2D29\u2D2F\u2D2F\u2D32\u2D69\u2D71\u2D71\u2D81\u2D98\u2DA2\u2DA8\u2DAA\u2DB0\u2DB2\u2DB8\u2DBA\u2DC0\u2DC2\u2DC8\u2DCA\u2DD0\u2DD2\u2DD8\u2DDA\u2DE0\u2DE2\u2E01\u2E31\u2E31\u3007\u3009\u3023\u3031\u3033\u3037\u303A\u303E\u3043\u3098\u309B\u309C\u309F\u30A1\u30A3\u30FC\u30FE\u3101\u3107\u312F\u3133\u3190\u31A2\u31BC\u31F2\u3201\u3402\u4DB7\u4E02\u9FD7\uA002\uA48E\uA4D2\uA4FF\uA502\uA60E\uA612\uA62D\uA642\uA671\uA676\uA67F\uA681\uA6F3\uA719\uA721\uA724\uA78A\uA78D\uA7B0\uA7B2\uA7B9\uA7F9\uA829\uA842\uA875\uA882\uA8C7\uA8D2\uA8DB\uA8E2\uA8F9\uA8FD\uA8FD\uA8FF\uA8FF\uA902\uA92F\uA932\uA955\uA962\uA97E\uA982\uA9C2\uA9D1\uA9DB\uA9E2\uAA00\uAA02\uAA38\uAA42\uAA4F\uAA52\uAA5B\uAA62\uAA78\uAA7C\uAAC4\uAADD\uAADF\uAAE2\uAAF1\uAAF4\uAAF8\uAB03\uAB08\uAB0B\uAB10\uAB13\uAB18\uAB22\uAB28\uAB2A\uAB30\uAB32\uAB5C\uAB5E\uAB67\uAB72\uABEC\uABEE\uABEF\uABF2\uABFB\uAC02\uD7A5\uD7B2\uD7C8\uD7CD\uD7FD\uF902\uFA6F\uFA72\uFADB\uFB02\uFB08\uFB15\uFB19\uFB1F\uFB2A\uFB2C\uFB38\uFB3A\uFB3E\uFB40\uFB40\uFB42\uFB43\uFB45\uFB46\uFB48\uFBB3\uFBD5\uFD3F\uFD52\uFD91\uFD94\uFDC9\uFDF2\uFDFD\uFE02\uFE11\uFE22\uFE31\uFE35\uFE36\uFE4F\uFE51\uFE72\uFE76\uFE78\uFEFE\uFF01\uFF01\uFF12\uFF1B\uFF23\uFF3C\uFF41\uFF41\uFF43\uFF5C\uFF68\uFFC0\uFFC4\uFFC9\uFFCC\uFFD1\uFFD4\uFFD9\uFFDC\uFFDE\uFFFB\uFFFD\r(*<>?AOR_\x82\xFC\u0142\u0176\u01FF\u01FF\u0282\u029E\u02A2\u02D2\u02E2\u02E2\u0302\u0321\u0332\u034C\u0352\u037C\u0382\u039F\u03A2\u03C5\u03CA\u03D1\u03D3\u03D7\u0402\u049F\u04A2\u04AB\u04B2\u04D5\u04DA\u04FD\u0502\u0529\u0532\u0565\u0602\u0738\u0742\u0757\u0762\u0769\u0802\u0807\u080A\u080A\u080C\u0837\u0839\u083A\u083E\u083E\u0841\u0857\u0862\u0878\u0882\u08A0\u08E2\u08F4\u08F6\u08F7\u0902\u0917\u0922\u093B\u0982\u09B9\u09C0\u09C1\u0A02\u0A05\u0A07\u0A08\u0A0E\u0A15\u0A17\u0A19\u0A1B\u0A35\u0A3A\u0A3C\u0A41\u0A41\u0A62\u0A7E\u0A82\u0A9E\u0AC2\u0AC9\u0ACB\u0AE8\u0B02\u0B37\u0B42\u0B57\u0B62\u0B74\u0B82\u0B93\u0C02\u0C4A\u0C82\u0CB4\u0CC2\u0CF4\u1002\u1048\u1068\u1071\u1081\u10BC\u10BF\u10BF\u10D2\u10EA\u10F2\u10FB\u1102\u1136\u1138\u1141\u1152\u1175\u1178\u1178\u1182\u11C6\u11CC\u11CE\u11D2\u11DC\u11DE\u11DE\u1202\u1213\u1215\u1239\u1240\u1240\u1282\u1288\u128A\u128A\u128C\u128F\u1291\u129F\u12A1\u12AA\u12B2\u12EC\u12F2\u12FB\u1302\u1305\u1307\u130E\u1311\u1312\u1315\u132A\u132C\u1332\u1334\u1335\u1337\u133B\u133E\u1346\u1349\u134A\u134D\u134F\u1352\u1352\u1359\u1359\u135F\u1365\u1368\u136E\u1372\u1376\u1402\u144C\u1452\u145B\u1482\u14C7\u14C9\u14C9\u14D2\u14DB\u1582\u15B7\u15BA\u15C2\u15DA\u15DF\u1602\u1642\u1646\u1646\u1652\u165B\u1682\u16B9\u16C2\u16CB\u1702\u171B\u171F\u172D\u1732\u173B\u18A2\u18EB\u1901\u1901\u1AC2\u1AFA\u1C02\u1C0A\u1C0C\u1C38\u1C3A\u1C42\u1C52\u1C5B\u1C74\u1C91\u1C94\u1CA9\u1CAB\u1CB8\u2002\u239B\u2402\u2470\u2482\u2545\u3002\u3430\u4402\u4648\u6802\u6A3A\u6A42\u6A60\u6A62\u6A6B\u6AD2\u6AEF\u6AF2\u6AF6\u6B02\u6B38\u6B42\u6B45\u6B52\u6B5B\u6B65\u6B79\u6B7F\u6B91\u6F02\u6F46\u6F52\u6F80\u6F91\u6FA1\u6FE2\u6FE2\u7002\u87EE\u8802\u8AF4\uB002\uB003\uBC02\uBC6C\uBC72\uBC7E\uBC82\uBC8A\uBC92\uBC9B\uBC9F\uBCA0\uBCA2\uBCA5\uD167\uD16B\uD16F\uD184\uD187\uD18D\uD1AC\uD1AF\uD244\uD246\uD402\uD456\uD458\uD49E\uD4A0\uD4A1\uD4A4\uD4A4\uD4A7\uD4A8\uD4AB\uD4AE\uD4B0\uD4BB\uD4BD\uD4BD\uD4BF\uD4C5\uD4C7\uD507\uD509\uD50C\uD50F\uD516\uD518\uD51E\uD520\uD53B\uD53D\uD540\uD542\uD546\uD548\uD548\uD54C\uD552\uD554\uD6A7\uD6AA\uD6C2\uD6C4\uD6DC\uD6DE\uD6FC\uD6FE\uD716\uD718\uD736\uD738\uD750\uD752\uD770\uD772\uD78A\uD78C\uD7AA\uD7AC\uD7C4\uD7C6\uD7CD\uD7D0\uD801\uDA02\uDA38\uDA3D\uDA6E\uDA77\uDA77\uDA86\uDA86\uDA9D\uDAA1\uDAA3\uDAB1\uE002\uE008\uE00A\uE01A\uE01D\uE023\uE025\uE026\uE028\uE02C\uE802\uE8C6\uE8D2\uE8D8\uE902\uE94C\uE952\uE95B\uEE02\uEE05\uEE07\uEE21\uEE23\uEE24\uEE26\uEE26\uEE29\uEE29\uEE2B\uEE34\uEE36\uEE39\uEE3B\uEE3B\uEE3D\uEE3D\uEE44\uEE44\uEE49\uEE49\uEE4B\uEE4B\uEE4D\uEE4D\uEE4F\uEE51\uEE53\uEE54\uEE56\uEE56\uEE59\uEE59\uEE5B\uEE5B\uEE5D\uEE5D\uEE5F\uEE5F\uEE61\uEE61\uEE63\uEE64\uEE66\uEE66\uEE69\uEE6C\uEE6E\uEE74\uEE76\uEE79\uEE7B\uEE7E\uEE80\uEE80\uEE82\uEE8B\uEE8D\uEE9D\uEEA3\uEEA5\uEEA7\uEEAB\uEEAD\uEEBD\uA6D8\uA702\uB736\uB742\uB81F\uB822\uCEA3\uF802\uFA1F"\x81\u0102\u01F1\u0240C\\c|\xAC\xAC\xB7\xB7\xBC\xBC\xC2\xD8\xDA\xF8\xFA\u02C3\u02C8\u02D3\u02E2\u02E6\u02EE\u02EE\u02F0\u02F0\u0372\u0376\u0378\u0379\u037C\u037F\u0381\u0381\u0388\u0388\u038A\u038C\u038E\u038E\u0390\u03A3\u03A5\u03F7\u03F9\u0483\u048C\u0531\u0533\u0558\u055B\u055B\u0563\u0589\u05D2\u05EC\u05F2\u05F4\u0622\u064C\u0670\u0671\u0673\u06D5\u06D7\u06D7\u06E7\u06E8\u06F0\u06F1\u06FC\u06FE\u0701\u0701\u0712\u0712\u0714\u0731\u074F\u07A7\u07B3\u07B3\u07CC\u07EC\u07F6\u07F7\u07FC\u07FC\u0802\u0817\u081C\u081C\u0826\u0826\u082A\u082A\u0842\u085A\u08A2\u08B6\u08B8\u08BF\u0906\u093B\u093F\u093F\u0952\u0952\u095A\u0963\u0973\u0982\u0987\u098E\u0991\u0992\u0995\u09AA\u09AC\u09B2\u09B4\u09B4\u09B8\u09BB\u09BF\u09BF\u09D0\u09D0\u09DE\u09DF\u09E1\u09E3\u09F2\u09F3\u0A07\u0A0C\u0A11\u0A12\u0A15\u0A2A\u0A2C\u0A32\u0A34\u0A35\u0A37\u0A38\u0A3A\u0A3B\u0A5B\u0A5E\u0A60\u0A60\u0A74\u0A76\u0A87\u0A8F\u0A91\u0A93\u0A95\u0AAA\u0AAC\u0AB2\u0AB4\u0AB5\u0AB7\u0ABB\u0ABF\u0ABF\u0AD2\u0AD2\u0AE2\u0AE3\u0AFB\u0AFB\u0B07\u0B0E\u0B11\u0B12\u0B15\u0B2A\u0B2C\u0B32\u0B34\u0B35\u0B37\u0B3B\u0B3F\u0B3F\u0B5E\u0B5F\u0B61\u0B63\u0B73\u0B73\u0B85\u0B85\u0B87\u0B8C\u0B90\u0B92\u0B94\u0B97\u0B9B\u0B9C\u0B9E\u0B9E\u0BA0\u0BA1\u0BA5\u0BA6\u0BAA\u0BAC\u0BB0\u0BBB\u0BD2\u0BD2\u0C07\u0C0E\u0C10\u0C12\u0C14\u0C2A\u0C2C\u0C3B\u0C3F\u0C3F\u0C5A\u0C5C\u0C62\u0C63\u0C82\u0C82\u0C87\u0C8E\u0C90\u0C92\u0C94\u0CAA\u0CAC\u0CB5\u0CB7\u0CBB\u0CBF\u0CBF\u0CE0\u0CE0\u0CE2\u0CE3\u0CF3\u0CF4\u0D07\u0D0E\u0D10\u0D12\u0D14\u0D3C\u0D3F\u0D3F\u0D50\u0D50\u0D56\u0D58\u0D61\u0D63\u0D7C\u0D81\u0D87\u0D98\u0D9C\u0DB3\u0DB5\u0DBD\u0DBF\u0DBF\u0DC2\u0DC8\u0E03\u0E32\u0E34\u0E35\u0E42\u0E48\u0E83\u0E84\u0E86\u0E86\u0E89\u0E8A\u0E8C\u0E8C\u0E8F\u0E8F\u0E96\u0E99\u0E9B\u0EA1\u0EA3\u0EA5\u0EA7\u0EA7\u0EA9\u0EA9\u0EAC\u0EAD\u0EAF\u0EB2\u0EB4\u0EB5\u0EBF\u0EBF\u0EC2\u0EC6\u0EC8\u0EC8\u0EDE\u0EE1\u0F02\u0F02\u0F42\u0F49\u0F4B\u0F6E\u0F8A\u0F8E\u1002\u102C\u1041\u1041\u1052\u1057\u105C\u105F\u1063\u1063\u1067\u1068\u1070\u1072\u1077\u1083\u1090\u1090\u10A2\u10C7\u10C9\u10C9\u10CF\u10CF\u10D2\u10FC\u10FE\u124A\u124C\u124F\u1252\u1258\u125A\u125A\u125C\u125F\u1262\u128A\u128C\u128F\u1292\u12B2\u12B4\u12B7\u12BA\u12C0\u12C2\u12C2\u12C4\u12C7\u12CA\u12D8\u12DA\u1312\u1314\u1317\u131A\u135C\u1382\u1391\u13A2\u13F7\u13FA\u13FF\u1403\u166E\u1671\u1681\u1683\u169C\u16A2\u16EC\u16F0\u16FA\u1702\u170E\u1710\u1713\u1722\u1733\u1742\u1753\u1762\u176E\u1770\u1772\u1782\u17B5\u17D9\u17D9\u17DE\u17DE\u1822\u1879\u1882\u1886\u1889\u18AA\u18AC\u18AC\u18B2\u18F7\u1902\u1920\u1952\u196F\u1972\u1976\u1982\u19AD\u19B2\u19CB\u1A02\u1A18\u1A22\u1A56\u1AA9\u1AA9\u1B07\u1B35\u1B47\u1B4D\u1B85\u1BA2\u1BB0\u1BB1\u1BBC\u1BE7\u1C02\u1C25\u1C4F\u1C51\u1C5C\u1C7F\u1C82\u1C8A\u1CEB\u1CEE\u1CF0\u1CF3\u1CF7\u1CF8\u1D02\u1DC1\u1E02\u1F17\u1F1A\u1F1F\u1F22\u1F47\u1F4A\u1F4F\u1F52\u1F59\u1F5B\u1F5B\u1F5D\u1F5D\u1F5F\u1F5F\u1F61\u1F7F\u1F82\u1FB6\u1FB8\u1FBE\u1FC0\u1FC0\u1FC4\u1FC6\u1FC8\u1FCE\u1FD2\u1FD5\u1FD8\u1FDD\u1FE2\u1FEE\u1FF4\u1FF6\u1FF8\u1FFE\u2073\u2073\u2081\u2081\u2092\u209E\u2104\u2104\u2109\u2109\u210C\u2115\u2117\u2117\u211B\u211F\u2126\u2126\u2128\u2128\u212A\u212A\u212C\u212F\u2131\u213B\u213E\u2141\u2147\u214B\u2150\u2150\u2162\u218A\u2C02\u2C30\u2C32\u2C60\u2C62\u2CE6\u2CED\u2CF0\u2CF4\u2CF5\u2D02\u2D27\u2D29\u2D29\u2D2F\u2D2F\u2D32\u2D69\u2D71\u2D71\u2D82\u2D98\u2DA2\u2DA8\u2DAA\u2DB0\u2DB2\u2DB8\u2DBA\u2DC0\u2DC2\u2DC8\u2DCA\u2DD0\u2DD2\u2DD8\u2DDA\u2DE0\u2E31\u2E31\u3007\u3009\u3023\u302B\u3033\u3037\u303A\u303E\u3043\u3098\u309F\u30A1\u30A3\u30FC\u30FE\u3101\u3107\u312F\u3133\u3190\u31A2\u31BC\u31F2\u3201\u3402\u4DB7\u4E02\u9FD7\uA002\uA48E\uA4D2\uA4FF\uA502\uA60E\uA612\uA621\uA62C\uA62D\uA642\uA670\uA681\uA69F\uA6A2\uA6F1\uA719\uA721\uA724\uA78A\uA78D\uA7B0\uA7B2\uA7B9\uA7F9\uA803\uA805\uA807\uA809\uA80C\uA80E\uA824\uA842\uA875\uA884\uA8B5\uA8F4\uA8F9\uA8FD\uA8FD\uA8FF\uA8FF\uA90C\uA927\uA932\uA948\uA962\uA97E\uA986\uA9B4\uA9D1\uA9D1\uA9E2\uA9E6\uA9E8\uA9F1\uA9FC\uAA00\uAA02\uAA2A\uAA42\uAA44\uAA46\uAA4D\uAA62\uAA78\uAA7C\uAA7C\uAA80\uAAB1\uAAB3\uAAB3\uAAB7\uAAB8\uAABB\uAABF\uAAC2\uAAC2\uAAC4\uAAC4\uAADD\uAADF\uAAE2\uAAEC\uAAF4\uAAF6\uAB03\uAB08\uAB0B\uAB10\uAB13\uAB18\uAB22\uAB28\uAB2A\uAB30\uAB32\uAB5C\uAB5E\uAB67\uAB72\uABE4\uAC02\uD7A5\uD7B2\uD7C8\uD7CD\uD7FD\uF902\uFA6F\uFA72\uFADB\uFB02\uFB08\uFB15\uFB19\uFB1F\uFB1F\uFB21\uFB2A\uFB2C\uFB38\uFB3A\uFB3E\uFB40\uFB40\uFB42\uFB43\uFB45\uFB46\uFB48\uFBB3\uFBD5\uFD3F\uFD52\uFD91\uFD94\uFDC9\uFDF2\uFDFD\uFE72\uFE76\uFE78\uFEFE\uFF23\uFF3C\uFF43\uFF5C\uFF68\uFFC0\uFFC4\uFFC9\uFFCC\uFFD1\uFFD4\uFFD9\uFFDC\uFFDE\r(*<>?AOR_\x82\xFC\u0142\u0176\u0282\u029E\u02A2\u02D2\u0302\u0321\u0332\u034C\u0352\u0377\u0382\u039F\u03A2\u03C5\u03CA\u03D1\u03D3\u03D7\u0402\u049F\u04B2\u04D5\u04DA\u04FD\u0502\u0529\u0532\u0565\u0602\u0738\u0742\u0757\u0762\u0769\u0802\u0807\u080A\u080A\u080C\u0837\u0839\u083A\u083E\u083E\u0841\u0857\u0862\u0878\u0882\u08A0\u08E2\u08F4\u08F6\u08F7\u0902\u0917\u0922\u093B\u0982\u09B9\u09C0\u09C1\u0A02\u0A02\u0A12\u0A15\u0A17\u0A19\u0A1B\u0A35\u0A62\u0A7E\u0A82\u0A9E\u0AC2\u0AC9\u0ACB\u0AE6\u0B02\u0B37\u0B42\u0B57\u0B62\u0B74\u0B82\u0B93\u0C02\u0C4A\u0C82\u0CB4\u0CC2\u0CF4\u1005\u1039\u1085\u10B1\u10D2\u10EA\u1105\u1128\u1152\u1174\u1178\u1178\u1185\u11B4\u11C3\u11C6\u11DC\u11DC\u11DE\u11DE\u1202\u1213\u1215\u122D\u1282\u1288\u128A\u128A\u128C\u128F\u1291\u129F\u12A1\u12AA\u12B2\u12E0\u1307\u130E\u1311\u1312\u1315\u132A\u132C\u1332\u1334\u1335\u1337\u133B\u133F\u133F\u1352\u1352\u135F\u1363\u1402\u1436\u1449\u144C\u1482\u14B1\u14C6\u14C7\u14C9\u14C9\u1582\u15B0\u15DA\u15DD\u1602\u1631\u1646\u1646\u1682\u16AC\u1702\u171B\u18A2\u18E1\u1901\u1901\u1AC2\u1AFA\u1C02\u1C0A\u1C0C\u1C30\u1C42\u1C42\u1C74\u1C91\u2002\u239B\u2402\u2470\u2482\u2545\u3002\u3430\u4402\u4648\u6802\u6A3A\u6A42\u6A60\u6AD2\u6AEF\u6B02\u6B31\u6B42\u6B45\u6B65\u6B79\u6B7F\u6B91\u6F02\u6F46\u6F52\u6F52\u6F95\u6FA1\u6FE2\u6FE2\u7002\u87EE\u8802\u8AF4\uB002\uB003\uBC02\uBC6C\uBC72\uBC7E\uBC82\uBC8A\uBC92\uBC9B\uD402\uD456\uD458\uD49E\uD4A0\uD4A1\uD4A4\uD4A4\uD4A7\uD4A8\uD4AB\uD4AE\uD4B0\uD4BB\uD4BD\uD4BD\uD4BF\uD4C5\uD4C7\uD507\uD509\uD50C\uD50F\uD516\uD518\uD51E\uD520\uD53B\uD53D\uD540\uD542\uD546\uD548\uD548';
  XPathLexer._serializedATNSegment1 = `\uD54C\uD552\uD554\uD6A7\uD6AA\uD6C2\uD6C4\uD6DC\uD6DE\uD6FC\uD6FE\uD716\uD718\uD736\uD738\uD750\uD752\uD770\uD772\uD78A\uD78C\uD7AA\uD7AC\uD7C4\uD7C6\uD7CD\uE802\uE8C6\uE902\uE945\uEE02\uEE05\uEE07\uEE21\uEE23\uEE24\uEE26\uEE26\uEE29\uEE29\uEE2B\uEE34\uEE36\uEE39\uEE3B\uEE3B\uEE3D\uEE3D\uEE44\uEE44\uEE49\uEE49\uEE4B\uEE4B\uEE4D\uEE4D\uEE4F\uEE51\uEE53\uEE54\uEE56\uEE56\uEE59\uEE59\uEE5B\uEE5B\uEE5D\uEE5D\uEE5F\uEE5F\uEE61\uEE61\uEE63\uEE64\uEE66\uEE66\uEE69\uEE6C\uEE6E\uEE74\uEE76\uEE79\uEE7B\uEE7E\uEE80\uEE80\uEE82\uEE8B\uEE8D\uEE9D\uEEA3\uEEA5\uEEA7\uEEAB\uEEAD\uEEBD\uA6D8\uA702\uB736\uB742\uB81F\uB822\uCEA3\uF802\uFA1F1\x07	\v\x07	\v\r%')\x071\x071\x071\x07,\b\x07#
 \b\r\x07"  !!#" #$\b$\f%&	&'(	()-\x07)*,\v+*,/-.-+.0/-01\x07)1 -`;
  XPathLexer._serializedATN = Utils3.join([
    XPathLexer._serializedATNSegment0,
    XPathLexer._serializedATNSegment1
  ], "");
});

// node_modules/antlr4ts/tree/xpath/XPathLexerErrorListener.js
var require_XPathLexerErrorListener = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.XPathLexerErrorListener = void 0;
  var Decorators_1 = require_Decorators();
  var XPathLexerErrorListener = class {
    syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
    }
  };
  __decorate([
    Decorators_1.Override
  ], XPathLexerErrorListener.prototype, "syntaxError", null);
  exports.XPathLexerErrorListener = XPathLexerErrorListener;
});

// node_modules/antlr4ts/tree/xpath/XPathElement.js
var require_XPathElement = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.XPathElement = void 0;
  var Decorators_1 = require_Decorators();
  var XPathElement = class {
    constructor(nodeName) {
      this.nodeName = nodeName;
      this.invert = false;
    }
    toString() {
      let inv = this.invert ? "!" : "";
      let className = Object.constructor.name;
      return className + "[" + inv + this.nodeName + "]";
    }
  };
  __decorate([
    Decorators_1.Override
  ], XPathElement.prototype, "toString", null);
  exports.XPathElement = XPathElement;
});

// node_modules/antlr4ts/tree/xpath/XPathRuleAnywhereElement.js
var require_XPathRuleAnywhereElement = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.XPathRuleAnywhereElement = void 0;
  var Decorators_1 = require_Decorators();
  var Trees_1 = require_Trees();
  var XPathElement_1 = require_XPathElement();
  var XPathRuleAnywhereElement = class extends XPathElement_1.XPathElement {
    constructor(ruleName, ruleIndex) {
      super(ruleName);
      this.ruleIndex = ruleIndex;
    }
    evaluate(t) {
      return Trees_1.Trees.findAllRuleNodes(t, this.ruleIndex);
    }
  };
  __decorate([
    Decorators_1.Override
  ], XPathRuleAnywhereElement.prototype, "evaluate", null);
  exports.XPathRuleAnywhereElement = XPathRuleAnywhereElement;
});

// node_modules/antlr4ts/tree/xpath/XPathRuleElement.js
var require_XPathRuleElement = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.XPathRuleElement = void 0;
  var ParserRuleContext_1 = require_ParserRuleContext();
  var Decorators_1 = require_Decorators();
  var Trees_1 = require_Trees();
  var XPathElement_1 = require_XPathElement();
  var XPathRuleElement = class extends XPathElement_1.XPathElement {
    constructor(ruleName, ruleIndex) {
      super(ruleName);
      this.ruleIndex = ruleIndex;
    }
    evaluate(t) {
      let nodes = [];
      for (let c of Trees_1.Trees.getChildren(t)) {
        if (c instanceof ParserRuleContext_1.ParserRuleContext) {
          if (c.ruleIndex === this.ruleIndex && !this.invert || c.ruleIndex !== this.ruleIndex && this.invert) {
            nodes.push(c);
          }
        }
      }
      return nodes;
    }
  };
  __decorate([
    Decorators_1.Override
  ], XPathRuleElement.prototype, "evaluate", null);
  exports.XPathRuleElement = XPathRuleElement;
});

// node_modules/antlr4ts/tree/xpath/XPathTokenAnywhereElement.js
var require_XPathTokenAnywhereElement = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.XPathTokenAnywhereElement = void 0;
  var Decorators_1 = require_Decorators();
  var Trees_1 = require_Trees();
  var XPathElement_1 = require_XPathElement();
  var XPathTokenAnywhereElement = class extends XPathElement_1.XPathElement {
    constructor(tokenName, tokenType) {
      super(tokenName);
      this.tokenType = tokenType;
    }
    evaluate(t) {
      return Trees_1.Trees.findAllTokenNodes(t, this.tokenType);
    }
  };
  __decorate([
    Decorators_1.Override
  ], XPathTokenAnywhereElement.prototype, "evaluate", null);
  exports.XPathTokenAnywhereElement = XPathTokenAnywhereElement;
});

// node_modules/antlr4ts/tree/xpath/XPathTokenElement.js
var require_XPathTokenElement = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.XPathTokenElement = void 0;
  var Decorators_1 = require_Decorators();
  var TerminalNode_1 = require_TerminalNode();
  var Trees_1 = require_Trees();
  var XPathElement_1 = require_XPathElement();
  var XPathTokenElement = class extends XPathElement_1.XPathElement {
    constructor(tokenName, tokenType) {
      super(tokenName);
      this.tokenType = tokenType;
    }
    evaluate(t) {
      let nodes = [];
      for (let c of Trees_1.Trees.getChildren(t)) {
        if (c instanceof TerminalNode_1.TerminalNode) {
          if (c.symbol.type === this.tokenType && !this.invert || c.symbol.type !== this.tokenType && this.invert) {
            nodes.push(c);
          }
        }
      }
      return nodes;
    }
  };
  __decorate([
    Decorators_1.Override
  ], XPathTokenElement.prototype, "evaluate", null);
  exports.XPathTokenElement = XPathTokenElement;
});

// node_modules/antlr4ts/tree/xpath/XPathWildcardAnywhereElement.js
var require_XPathWildcardAnywhereElement = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.XPathWildcardAnywhereElement = void 0;
  var Decorators_1 = require_Decorators();
  var Trees_1 = require_Trees();
  var XPath_1 = require_XPath();
  var XPathElement_1 = require_XPathElement();
  var XPathWildcardAnywhereElement = class extends XPathElement_1.XPathElement {
    constructor() {
      super(XPath_1.XPath.WILDCARD);
    }
    evaluate(t) {
      if (this.invert) {
        return [];
      }
      return Trees_1.Trees.getDescendants(t);
    }
  };
  __decorate([
    Decorators_1.Override
  ], XPathWildcardAnywhereElement.prototype, "evaluate", null);
  exports.XPathWildcardAnywhereElement = XPathWildcardAnywhereElement;
});

// node_modules/antlr4ts/tree/xpath/XPathWildcardElement.js
var require_XPathWildcardElement = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.XPathWildcardElement = void 0;
  var Decorators_1 = require_Decorators();
  var Trees_1 = require_Trees();
  var XPath_1 = require_XPath();
  var XPathElement_1 = require_XPathElement();
  var XPathWildcardElement = class extends XPathElement_1.XPathElement {
    constructor() {
      super(XPath_1.XPath.WILDCARD);
    }
    evaluate(t) {
      let kids = [];
      if (this.invert) {
        return kids;
      }
      for (let c of Trees_1.Trees.getChildren(t)) {
        kids.push(c);
      }
      return kids;
    }
  };
  __decorate([
    Decorators_1.Override
  ], XPathWildcardElement.prototype, "evaluate", null);
  exports.XPathWildcardElement = XPathWildcardElement;
});

// node_modules/antlr4ts/tree/xpath/XPath.js
var require_XPath = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.XPath = void 0;
  var CharStreams_1 = require_CharStreams();
  var CommonTokenStream_1 = require_CommonTokenStream();
  var LexerNoViableAltException_1 = require_LexerNoViableAltException();
  var ParserRuleContext_1 = require_ParserRuleContext();
  var Token_1 = require_Token();
  var XPathLexer_1 = require_XPathLexer();
  var XPathLexerErrorListener_1 = require_XPathLexerErrorListener();
  var XPathRuleAnywhereElement_1 = require_XPathRuleAnywhereElement();
  var XPathRuleElement_1 = require_XPathRuleElement();
  var XPathTokenAnywhereElement_1 = require_XPathTokenAnywhereElement();
  var XPathTokenElement_1 = require_XPathTokenElement();
  var XPathWildcardAnywhereElement_1 = require_XPathWildcardAnywhereElement();
  var XPathWildcardElement_1 = require_XPathWildcardElement();
  var XPath = class {
    constructor(parser, path) {
      this.parser = parser;
      this.path = path;
      this.elements = this.split(path);
    }
    split(path) {
      let lexer = new XPathLexer_1.XPathLexer(CharStreams_1.CharStreams.fromString(path));
      lexer.recover = (e) => {
        throw e;
      };
      lexer.removeErrorListeners();
      lexer.addErrorListener(new XPathLexerErrorListener_1.XPathLexerErrorListener());
      let tokenStream = new CommonTokenStream_1.CommonTokenStream(lexer);
      try {
        tokenStream.fill();
      } catch (e) {
        if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {
          let pos = lexer.charPositionInLine;
          let msg = "Invalid tokens or characters at index " + pos + " in path '" + path + "' -- " + e.message;
          throw new RangeError(msg);
        }
        throw e;
      }
      let tokens2 = tokenStream.getTokens();
      let elements = [];
      let n = tokens2.length;
      let i = 0;
      loop:
        while (i < n) {
          let el = tokens2[i];
          let next;
          switch (el.type) {
            case XPathLexer_1.XPathLexer.ROOT:
            case XPathLexer_1.XPathLexer.ANYWHERE:
              let anywhere = el.type === XPathLexer_1.XPathLexer.ANYWHERE;
              i++;
              next = tokens2[i];
              let invert = next.type === XPathLexer_1.XPathLexer.BANG;
              if (invert) {
                i++;
                next = tokens2[i];
              }
              let pathElement = this.getXPathElement(next, anywhere);
              pathElement.invert = invert;
              elements.push(pathElement);
              i++;
              break;
            case XPathLexer_1.XPathLexer.TOKEN_REF:
            case XPathLexer_1.XPathLexer.RULE_REF:
            case XPathLexer_1.XPathLexer.WILDCARD:
              elements.push(this.getXPathElement(el, false));
              i++;
              break;
            case Token_1.Token.EOF:
              break loop;
            default:
              throw new Error("Unknowth path element " + el);
          }
        }
      return elements;
    }
    getXPathElement(wordToken, anywhere) {
      if (wordToken.type === Token_1.Token.EOF) {
        throw new Error("Missing path element at end of path");
      }
      let word = wordToken.text;
      if (word == null) {
        throw new Error("Expected wordToken to have text content.");
      }
      let ttype = this.parser.getTokenType(word);
      let ruleIndex = this.parser.getRuleIndex(word);
      switch (wordToken.type) {
        case XPathLexer_1.XPathLexer.WILDCARD:
          return anywhere ? new XPathWildcardAnywhereElement_1.XPathWildcardAnywhereElement() : new XPathWildcardElement_1.XPathWildcardElement();
        case XPathLexer_1.XPathLexer.TOKEN_REF:
        case XPathLexer_1.XPathLexer.STRING:
          if (ttype === Token_1.Token.INVALID_TYPE) {
            throw new Error(word + " at index " + wordToken.startIndex + " isn't a valid token name");
          }
          return anywhere ? new XPathTokenAnywhereElement_1.XPathTokenAnywhereElement(word, ttype) : new XPathTokenElement_1.XPathTokenElement(word, ttype);
        default:
          if (ruleIndex === -1) {
            throw new Error(word + " at index " + wordToken.startIndex + " isn't a valid rule name");
          }
          return anywhere ? new XPathRuleAnywhereElement_1.XPathRuleAnywhereElement(word, ruleIndex) : new XPathRuleElement_1.XPathRuleElement(word, ruleIndex);
      }
    }
    static findAll(tree, xpath, parser) {
      let p = new XPath(parser, xpath);
      return p.evaluate(tree);
    }
    evaluate(t) {
      let dummyRoot = new ParserRuleContext_1.ParserRuleContext();
      dummyRoot.addChild(t);
      let work = new Set([dummyRoot]);
      let i = 0;
      while (i < this.elements.length) {
        let next = new Set();
        for (let node of work) {
          if (node.childCount > 0) {
            let matching = this.elements[i].evaluate(node);
            matching.forEach(next.add, next);
          }
        }
        i++;
        work = next;
      }
      return work;
    }
  };
  exports.XPath = XPath;
  XPath.WILDCARD = "*";
  XPath.NOT = "!";
});

// node_modules/antlr4ts/tree/pattern/ParseTreePattern.js
var require_ParseTreePattern = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ParseTreePattern = void 0;
  var Decorators_1 = require_Decorators();
  var XPath_1 = require_XPath();
  var ParseTreePattern = class ParseTreePattern {
    constructor(matcher, pattern, patternRuleIndex, patternTree) {
      this._matcher = matcher;
      this._patternRuleIndex = patternRuleIndex;
      this._pattern = pattern;
      this._patternTree = patternTree;
    }
    match(tree) {
      return this._matcher.match(tree, this);
    }
    matches(tree) {
      return this._matcher.match(tree, this).succeeded;
    }
    findAll(tree, xpath) {
      let subtrees = XPath_1.XPath.findAll(tree, xpath, this._matcher.parser);
      let matches = [];
      for (let t of subtrees) {
        let match = this.match(t);
        if (match.succeeded) {
          matches.push(match);
        }
      }
      return matches;
    }
    get matcher() {
      return this._matcher;
    }
    get pattern() {
      return this._pattern;
    }
    get patternRuleIndex() {
      return this._patternRuleIndex;
    }
    get patternTree() {
      return this._patternTree;
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], ParseTreePattern.prototype, "_pattern", void 0);
  __decorate([
    Decorators_1.NotNull
  ], ParseTreePattern.prototype, "_patternTree", void 0);
  __decorate([
    Decorators_1.NotNull
  ], ParseTreePattern.prototype, "_matcher", void 0);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull)
  ], ParseTreePattern.prototype, "match", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], ParseTreePattern.prototype, "matches", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull)
  ], ParseTreePattern.prototype, "findAll", null);
  __decorate([
    Decorators_1.NotNull
  ], ParseTreePattern.prototype, "matcher", null);
  __decorate([
    Decorators_1.NotNull
  ], ParseTreePattern.prototype, "pattern", null);
  __decorate([
    Decorators_1.NotNull
  ], ParseTreePattern.prototype, "patternTree", null);
  ParseTreePattern = __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull),
    __param(3, Decorators_1.NotNull)
  ], ParseTreePattern);
  exports.ParseTreePattern = ParseTreePattern;
});

// node_modules/antlr4ts/tree/pattern/RuleTagToken.js
var require_RuleTagToken = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.RuleTagToken = void 0;
  var Decorators_1 = require_Decorators();
  var Token_1 = require_Token();
  var RuleTagToken = class RuleTagToken {
    constructor(ruleName, bypassTokenType, label) {
      if (ruleName == null || ruleName.length === 0) {
        throw new Error("ruleName cannot be null or empty.");
      }
      this._ruleName = ruleName;
      this.bypassTokenType = bypassTokenType;
      this._label = label;
    }
    get ruleName() {
      return this._ruleName;
    }
    get label() {
      return this._label;
    }
    get channel() {
      return Token_1.Token.DEFAULT_CHANNEL;
    }
    get text() {
      if (this._label != null) {
        return "<" + this._label + ":" + this._ruleName + ">";
      }
      return "<" + this._ruleName + ">";
    }
    get type() {
      return this.bypassTokenType;
    }
    get line() {
      return 0;
    }
    get charPositionInLine() {
      return -1;
    }
    get tokenIndex() {
      return -1;
    }
    get startIndex() {
      return -1;
    }
    get stopIndex() {
      return -1;
    }
    get tokenSource() {
      return void 0;
    }
    get inputStream() {
      return void 0;
    }
    toString() {
      return this._ruleName + ":" + this.bypassTokenType;
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], RuleTagToken.prototype, "ruleName", null);
  __decorate([
    Decorators_1.Override
  ], RuleTagToken.prototype, "channel", null);
  __decorate([
    Decorators_1.Override
  ], RuleTagToken.prototype, "text", null);
  __decorate([
    Decorators_1.Override
  ], RuleTagToken.prototype, "type", null);
  __decorate([
    Decorators_1.Override
  ], RuleTagToken.prototype, "line", null);
  __decorate([
    Decorators_1.Override
  ], RuleTagToken.prototype, "charPositionInLine", null);
  __decorate([
    Decorators_1.Override
  ], RuleTagToken.prototype, "tokenIndex", null);
  __decorate([
    Decorators_1.Override
  ], RuleTagToken.prototype, "startIndex", null);
  __decorate([
    Decorators_1.Override
  ], RuleTagToken.prototype, "stopIndex", null);
  __decorate([
    Decorators_1.Override
  ], RuleTagToken.prototype, "tokenSource", null);
  __decorate([
    Decorators_1.Override
  ], RuleTagToken.prototype, "inputStream", null);
  __decorate([
    Decorators_1.Override
  ], RuleTagToken.prototype, "toString", null);
  RuleTagToken = __decorate([
    __param(0, Decorators_1.NotNull)
  ], RuleTagToken);
  exports.RuleTagToken = RuleTagToken;
});

// node_modules/antlr4ts/tree/pattern/Chunk.js
var require_Chunk = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.Chunk = void 0;
  var Chunk = class {
  };
  exports.Chunk = Chunk;
});

// node_modules/antlr4ts/tree/pattern/TagChunk.js
var require_TagChunk = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.TagChunk = void 0;
  var Chunk_1 = require_Chunk();
  var Decorators_1 = require_Decorators();
  var TagChunk = class extends Chunk_1.Chunk {
    constructor(tag, label) {
      super();
      if (tag == null || tag.length === 0) {
        throw new Error("tag cannot be null or empty");
      }
      this._tag = tag;
      this._label = label;
    }
    get tag() {
      return this._tag;
    }
    get label() {
      return this._label;
    }
    toString() {
      if (this._label != null) {
        return this._label + ":" + this._tag;
      }
      return this._tag;
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], TagChunk.prototype, "tag", null);
  __decorate([
    Decorators_1.Override
  ], TagChunk.prototype, "toString", null);
  exports.TagChunk = TagChunk;
});

// node_modules/antlr4ts/tree/pattern/TextChunk.js
var require_TextChunk = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.TextChunk = void 0;
  var Chunk_1 = require_Chunk();
  var Decorators_1 = require_Decorators();
  var TextChunk = class TextChunk extends Chunk_1.Chunk {
    constructor(text) {
      super();
      if (text == null) {
        throw new Error("text cannot be null");
      }
      this._text = text;
    }
    get text() {
      return this._text;
    }
    toString() {
      return "'" + this._text + "'";
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], TextChunk.prototype, "_text", void 0);
  __decorate([
    Decorators_1.NotNull
  ], TextChunk.prototype, "text", null);
  __decorate([
    Decorators_1.Override
  ], TextChunk.prototype, "toString", null);
  TextChunk = __decorate([
    __param(0, Decorators_1.NotNull)
  ], TextChunk);
  exports.TextChunk = TextChunk;
});

// node_modules/antlr4ts/tree/pattern/TokenTagToken.js
var require_TokenTagToken = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.TokenTagToken = void 0;
  var CommonToken_1 = require_CommonToken();
  var Decorators_1 = require_Decorators();
  var TokenTagToken = class TokenTagToken extends CommonToken_1.CommonToken {
    constructor(tokenName, type, label) {
      super(type);
      this._tokenName = tokenName;
      this._label = label;
    }
    get tokenName() {
      return this._tokenName;
    }
    get label() {
      return this._label;
    }
    get text() {
      if (this._label != null) {
        return "<" + this._label + ":" + this._tokenName + ">";
      }
      return "<" + this._tokenName + ">";
    }
    toString() {
      return this._tokenName + ":" + this.type;
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], TokenTagToken.prototype, "_tokenName", void 0);
  __decorate([
    Decorators_1.NotNull
  ], TokenTagToken.prototype, "tokenName", null);
  __decorate([
    Decorators_1.Override
  ], TokenTagToken.prototype, "text", null);
  __decorate([
    Decorators_1.Override
  ], TokenTagToken.prototype, "toString", null);
  TokenTagToken = __decorate([
    __param(0, Decorators_1.NotNull)
  ], TokenTagToken);
  exports.TokenTagToken = TokenTagToken;
});

// node_modules/antlr4ts/tree/pattern/ParseTreePatternMatcher.js
var require_ParseTreePatternMatcher = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ParseTreePatternMatcher = void 0;
  var BailErrorStrategy_1 = require_BailErrorStrategy();
  var CharStreams_1 = require_CharStreams();
  var CommonTokenStream_1 = require_CommonTokenStream();
  var ListTokenSource_1 = require_ListTokenSource();
  var MultiMap_1 = require_MultiMap();
  var Decorators_1 = require_Decorators();
  var ParseCancellationException_1 = require_ParseCancellationException();
  var ParserInterpreter_1 = require_ParserInterpreter();
  var ParserRuleContext_1 = require_ParserRuleContext();
  var ParseTreeMatch_1 = require_ParseTreeMatch();
  var ParseTreePattern_1 = require_ParseTreePattern();
  var RecognitionException_1 = require_RecognitionException();
  var RuleNode_1 = require_RuleNode();
  var RuleTagToken_1 = require_RuleTagToken();
  var TagChunk_1 = require_TagChunk();
  var TerminalNode_1 = require_TerminalNode();
  var TextChunk_1 = require_TextChunk();
  var Token_1 = require_Token();
  var TokenTagToken_1 = require_TokenTagToken();
  var ParseTreePatternMatcher2 = class {
    constructor(lexer, parser) {
      this.start = "<";
      this.stop = ">";
      this.escape = "\\";
      this.escapeRE = /\\/g;
      this._lexer = lexer;
      this._parser = parser;
    }
    setDelimiters(start, stop, escapeLeft) {
      if (!start) {
        throw new Error("start cannot be null or empty");
      }
      if (!stop) {
        throw new Error("stop cannot be null or empty");
      }
      this.start = start;
      this.stop = stop;
      this.escape = escapeLeft;
      this.escapeRE = new RegExp(escapeLeft.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g");
    }
    matches(tree, pattern, patternRuleIndex = 0) {
      if (typeof pattern === "string") {
        let p = this.compile(pattern, patternRuleIndex);
        return this.matches(tree, p);
      } else {
        let labels = new MultiMap_1.MultiMap();
        let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);
        return !mismatchedNode;
      }
    }
    match(tree, pattern, patternRuleIndex = 0) {
      if (typeof pattern === "string") {
        let p = this.compile(pattern, patternRuleIndex);
        return this.match(tree, p);
      } else {
        let labels = new MultiMap_1.MultiMap();
        let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);
        return new ParseTreeMatch_1.ParseTreeMatch(tree, pattern, labels, mismatchedNode);
      }
    }
    compile(pattern, patternRuleIndex) {
      let tokenList = this.tokenize(pattern);
      let tokenSrc = new ListTokenSource_1.ListTokenSource(tokenList);
      let tokens2 = new CommonTokenStream_1.CommonTokenStream(tokenSrc);
      const parser = this._parser;
      let parserInterp = new ParserInterpreter_1.ParserInterpreter(parser.grammarFileName, parser.vocabulary, parser.ruleNames, parser.getATNWithBypassAlts(), tokens2);
      let tree;
      try {
        parserInterp.errorHandler = new BailErrorStrategy_1.BailErrorStrategy();
        tree = parserInterp.parse(patternRuleIndex);
      } catch (e) {
        if (e instanceof ParseCancellationException_1.ParseCancellationException) {
          throw e.getCause();
        } else if (e instanceof RecognitionException_1.RecognitionException) {
          throw e;
        } else if (e instanceof Error) {
          throw new ParseTreePatternMatcher2.CannotInvokeStartRule(e);
        } else {
          throw e;
        }
      }
      if (tokens2.LA(1) !== Token_1.Token.EOF) {
        throw new ParseTreePatternMatcher2.StartRuleDoesNotConsumeFullPattern();
      }
      return new ParseTreePattern_1.ParseTreePattern(this, pattern, patternRuleIndex, tree);
    }
    get lexer() {
      return this._lexer;
    }
    get parser() {
      return this._parser;
    }
    matchImpl(tree, patternTree, labels) {
      if (!tree) {
        throw new TypeError("tree cannot be null");
      }
      if (!patternTree) {
        throw new TypeError("patternTree cannot be null");
      }
      if (tree instanceof TerminalNode_1.TerminalNode && patternTree instanceof TerminalNode_1.TerminalNode) {
        let mismatchedNode;
        if (tree.symbol.type === patternTree.symbol.type) {
          if (patternTree.symbol instanceof TokenTagToken_1.TokenTagToken) {
            let tokenTagToken = patternTree.symbol;
            labels.map(tokenTagToken.tokenName, tree);
            const l = tokenTagToken.label;
            if (l) {
              labels.map(l, tree);
            }
          } else if (tree.text === patternTree.text) {
          } else {
            if (!mismatchedNode) {
              mismatchedNode = tree;
            }
          }
        } else {
          if (!mismatchedNode) {
            mismatchedNode = tree;
          }
        }
        return mismatchedNode;
      }
      if (tree instanceof ParserRuleContext_1.ParserRuleContext && patternTree instanceof ParserRuleContext_1.ParserRuleContext) {
        let mismatchedNode;
        let ruleTagToken = this.getRuleTagToken(patternTree);
        if (ruleTagToken) {
          let m;
          if (tree.ruleContext.ruleIndex === patternTree.ruleContext.ruleIndex) {
            labels.map(ruleTagToken.ruleName, tree);
            const l = ruleTagToken.label;
            if (l) {
              labels.map(l, tree);
            }
          } else {
            if (!mismatchedNode) {
              mismatchedNode = tree;
            }
          }
          return mismatchedNode;
        }
        if (tree.childCount !== patternTree.childCount) {
          if (!mismatchedNode) {
            mismatchedNode = tree;
          }
          return mismatchedNode;
        }
        let n = tree.childCount;
        for (let i = 0; i < n; i++) {
          let childMatch = this.matchImpl(tree.getChild(i), patternTree.getChild(i), labels);
          if (childMatch) {
            return childMatch;
          }
        }
        return mismatchedNode;
      }
      return tree;
    }
    getRuleTagToken(t) {
      if (t instanceof RuleNode_1.RuleNode) {
        if (t.childCount === 1 && t.getChild(0) instanceof TerminalNode_1.TerminalNode) {
          let c = t.getChild(0);
          if (c.symbol instanceof RuleTagToken_1.RuleTagToken) {
            return c.symbol;
          }
        }
      }
      return void 0;
    }
    tokenize(pattern) {
      let chunks = this.split(pattern);
      let tokens2 = [];
      for (let chunk of chunks) {
        if (chunk instanceof TagChunk_1.TagChunk) {
          let tagChunk = chunk;
          const firstChar = tagChunk.tag.substr(0, 1);
          if (firstChar === firstChar.toUpperCase()) {
            let ttype = this._parser.getTokenType(tagChunk.tag);
            if (ttype === Token_1.Token.INVALID_TYPE) {
              throw new Error("Unknown token " + tagChunk.tag + " in pattern: " + pattern);
            }
            let t = new TokenTagToken_1.TokenTagToken(tagChunk.tag, ttype, tagChunk.label);
            tokens2.push(t);
          } else if (firstChar === firstChar.toLowerCase()) {
            let ruleIndex = this._parser.getRuleIndex(tagChunk.tag);
            if (ruleIndex === -1) {
              throw new Error("Unknown rule " + tagChunk.tag + " in pattern: " + pattern);
            }
            let ruleImaginaryTokenType = this._parser.getATNWithBypassAlts().ruleToTokenType[ruleIndex];
            tokens2.push(new RuleTagToken_1.RuleTagToken(tagChunk.tag, ruleImaginaryTokenType, tagChunk.label));
          } else {
            throw new Error("invalid tag: " + tagChunk.tag + " in pattern: " + pattern);
          }
        } else {
          let textChunk = chunk;
          this._lexer.inputStream = CharStreams_1.CharStreams.fromString(textChunk.text);
          let t = this._lexer.nextToken();
          while (t.type !== Token_1.Token.EOF) {
            tokens2.push(t);
            t = this._lexer.nextToken();
          }
        }
      }
      return tokens2;
    }
    split(pattern) {
      let p = 0;
      let n = pattern.length;
      let chunks = [];
      let buf;
      let starts = [];
      let stops = [];
      while (p < n) {
        if (p === pattern.indexOf(this.escape + this.start, p)) {
          p += this.escape.length + this.start.length;
        } else if (p === pattern.indexOf(this.escape + this.stop, p)) {
          p += this.escape.length + this.stop.length;
        } else if (p === pattern.indexOf(this.start, p)) {
          starts.push(p);
          p += this.start.length;
        } else if (p === pattern.indexOf(this.stop, p)) {
          stops.push(p);
          p += this.stop.length;
        } else {
          p++;
        }
      }
      if (starts.length > stops.length) {
        throw new Error("unterminated tag in pattern: " + pattern);
      }
      if (starts.length < stops.length) {
        throw new Error("missing start tag in pattern: " + pattern);
      }
      let ntags = starts.length;
      for (let i = 0; i < ntags; i++) {
        if (starts[i] >= stops[i]) {
          throw new Error("tag delimiters out of order in pattern: " + pattern);
        }
      }
      if (ntags === 0) {
        let text = pattern.substring(0, n);
        chunks.push(new TextChunk_1.TextChunk(text));
      }
      if (ntags > 0 && starts[0] > 0) {
        let text = pattern.substring(0, starts[0]);
        chunks.push(new TextChunk_1.TextChunk(text));
      }
      for (let i = 0; i < ntags; i++) {
        let tag = pattern.substring(starts[i] + this.start.length, stops[i]);
        let ruleOrToken = tag;
        let label;
        let colon = tag.indexOf(":");
        if (colon >= 0) {
          label = tag.substring(0, colon);
          ruleOrToken = tag.substring(colon + 1, tag.length);
        }
        chunks.push(new TagChunk_1.TagChunk(ruleOrToken, label));
        if (i + 1 < ntags) {
          let text = pattern.substring(stops[i] + this.stop.length, starts[i + 1]);
          chunks.push(new TextChunk_1.TextChunk(text));
        }
      }
      if (ntags > 0) {
        let afterLastTag = stops[ntags - 1] + this.stop.length;
        if (afterLastTag < n) {
          let text = pattern.substring(afterLastTag, n);
          chunks.push(new TextChunk_1.TextChunk(text));
        }
      }
      for (let i = 0; i < chunks.length; i++) {
        let c = chunks[i];
        if (c instanceof TextChunk_1.TextChunk) {
          let unescaped = c.text.replace(this.escapeRE, "");
          if (unescaped.length < c.text.length) {
            chunks[i] = new TextChunk_1.TextChunk(unescaped);
          }
        }
      }
      return chunks;
    }
  };
  __decorate([
    Decorators_1.NotNull,
    __param(1, Decorators_1.NotNull)
  ], ParseTreePatternMatcher2.prototype, "match", null);
  __decorate([
    Decorators_1.NotNull
  ], ParseTreePatternMatcher2.prototype, "lexer", null);
  __decorate([
    Decorators_1.NotNull
  ], ParseTreePatternMatcher2.prototype, "parser", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull)
  ], ParseTreePatternMatcher2.prototype, "matchImpl", null);
  exports.ParseTreePatternMatcher = ParseTreePatternMatcher2;
  (function(ParseTreePatternMatcher3) {
    class CannotInvokeStartRule extends Error {
      constructor(error) {
        super(`CannotInvokeStartRule: ${error}`);
        this.error = error;
      }
    }
    ParseTreePatternMatcher3.CannotInvokeStartRule = CannotInvokeStartRule;
    class StartRuleDoesNotConsumeFullPattern extends Error {
      constructor() {
        super("StartRuleDoesNotConsumeFullPattern");
      }
    }
    ParseTreePatternMatcher3.StartRuleDoesNotConsumeFullPattern = StartRuleDoesNotConsumeFullPattern;
  })(ParseTreePatternMatcher2 = exports.ParseTreePatternMatcher || (exports.ParseTreePatternMatcher = {}));
});

// node_modules/antlr4ts/atn/DecisionEventInfo.js
var require_DecisionEventInfo = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.DecisionEventInfo = void 0;
  var Decorators_1 = require_Decorators();
  var DecisionEventInfo = class DecisionEventInfo {
    constructor(decision, state, input, startIndex, stopIndex, fullCtx) {
      this.decision = decision;
      this.fullCtx = fullCtx;
      this.stopIndex = stopIndex;
      this.input = input;
      this.startIndex = startIndex;
      this.state = state;
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], DecisionEventInfo.prototype, "input", void 0);
  DecisionEventInfo = __decorate([
    __param(2, Decorators_1.NotNull)
  ], DecisionEventInfo);
  exports.DecisionEventInfo = DecisionEventInfo;
});

// node_modules/antlr4ts/atn/AmbiguityInfo.js
var require_AmbiguityInfo = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.AmbiguityInfo = void 0;
  var DecisionEventInfo_1 = require_DecisionEventInfo();
  var Decorators_1 = require_Decorators();
  var AmbiguityInfo = class AmbiguityInfo extends DecisionEventInfo_1.DecisionEventInfo {
    constructor(decision, state, ambigAlts, input, startIndex, stopIndex) {
      super(decision, state, input, startIndex, stopIndex, state.useContext);
      this.ambigAlts = ambigAlts;
    }
    get ambiguousAlternatives() {
      return this.ambigAlts;
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], AmbiguityInfo.prototype, "ambigAlts", void 0);
  __decorate([
    Decorators_1.NotNull
  ], AmbiguityInfo.prototype, "ambiguousAlternatives", null);
  AmbiguityInfo = __decorate([
    __param(1, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull),
    __param(3, Decorators_1.NotNull)
  ], AmbiguityInfo);
  exports.AmbiguityInfo = AmbiguityInfo;
});

// node_modules/antlr4ts/atn/ContextSensitivityInfo.js
var require_ContextSensitivityInfo = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ContextSensitivityInfo = void 0;
  var DecisionEventInfo_1 = require_DecisionEventInfo();
  var Decorators_1 = require_Decorators();
  var ContextSensitivityInfo = class ContextSensitivityInfo extends DecisionEventInfo_1.DecisionEventInfo {
    constructor(decision, state, input, startIndex, stopIndex) {
      super(decision, state, input, startIndex, stopIndex, true);
    }
  };
  ContextSensitivityInfo = __decorate([
    __param(1, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull)
  ], ContextSensitivityInfo);
  exports.ContextSensitivityInfo = ContextSensitivityInfo;
});

// node_modules/antlr4ts/atn/DecisionInfo.js
var require_DecisionInfo = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.DecisionInfo = void 0;
  var Decorators_1 = require_Decorators();
  var DecisionInfo = class {
    constructor(decision) {
      this.invocations = 0;
      this.timeInPrediction = 0;
      this.SLL_TotalLook = 0;
      this.SLL_MinLook = 0;
      this.SLL_MaxLook = 0;
      this.LL_TotalLook = 0;
      this.LL_MinLook = 0;
      this.LL_MaxLook = 0;
      this.contextSensitivities = [];
      this.errors = [];
      this.ambiguities = [];
      this.predicateEvals = [];
      this.SLL_ATNTransitions = 0;
      this.SLL_DFATransitions = 0;
      this.LL_Fallback = 0;
      this.LL_ATNTransitions = 0;
      this.LL_DFATransitions = 0;
      this.decision = decision;
    }
    toString() {
      return "{decision=" + this.decision + ", contextSensitivities=" + this.contextSensitivities.length + ", errors=" + this.errors.length + ", ambiguities=" + this.ambiguities.length + ", SLL_lookahead=" + this.SLL_TotalLook + ", SLL_ATNTransitions=" + this.SLL_ATNTransitions + ", SLL_DFATransitions=" + this.SLL_DFATransitions + ", LL_Fallback=" + this.LL_Fallback + ", LL_lookahead=" + this.LL_TotalLook + ", LL_ATNTransitions=" + this.LL_ATNTransitions + "}";
    }
  };
  __decorate([
    Decorators_1.Override
  ], DecisionInfo.prototype, "toString", null);
  exports.DecisionInfo = DecisionInfo;
});

// node_modules/antlr4ts/atn/ErrorInfo.js
var require_ErrorInfo = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ErrorInfo = void 0;
  var DecisionEventInfo_1 = require_DecisionEventInfo();
  var Decorators_1 = require_Decorators();
  var ErrorInfo = class ErrorInfo extends DecisionEventInfo_1.DecisionEventInfo {
    constructor(decision, state, input, startIndex, stopIndex) {
      super(decision, state, input, startIndex, stopIndex, state.useContext);
    }
  };
  ErrorInfo = __decorate([
    __param(1, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull)
  ], ErrorInfo);
  exports.ErrorInfo = ErrorInfo;
});

// node_modules/antlr4ts/atn/LookaheadEventInfo.js
var require_LookaheadEventInfo = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.LookaheadEventInfo = void 0;
  var DecisionEventInfo_1 = require_DecisionEventInfo();
  var Decorators_1 = require_Decorators();
  var LookaheadEventInfo = class LookaheadEventInfo extends DecisionEventInfo_1.DecisionEventInfo {
    constructor(decision, state, predictedAlt, input, startIndex, stopIndex, fullCtx) {
      super(decision, state, input, startIndex, stopIndex, fullCtx);
      this.predictedAlt = predictedAlt;
    }
  };
  LookaheadEventInfo = __decorate([
    __param(3, Decorators_1.NotNull)
  ], LookaheadEventInfo);
  exports.LookaheadEventInfo = LookaheadEventInfo;
});

// node_modules/antlr4ts/atn/PredicateEvalInfo.js
var require_PredicateEvalInfo = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.PredicateEvalInfo = void 0;
  var DecisionEventInfo_1 = require_DecisionEventInfo();
  var Decorators_1 = require_Decorators();
  var PredicateEvalInfo = class PredicateEvalInfo extends DecisionEventInfo_1.DecisionEventInfo {
    constructor(state, decision, input, startIndex, stopIndex, semctx, evalResult, predictedAlt) {
      super(decision, state, input, startIndex, stopIndex, state.useContext);
      this.semctx = semctx;
      this.evalResult = evalResult;
      this.predictedAlt = predictedAlt;
    }
  };
  PredicateEvalInfo = __decorate([
    __param(0, Decorators_1.NotNull),
    __param(2, Decorators_1.NotNull),
    __param(5, Decorators_1.NotNull)
  ], PredicateEvalInfo);
  exports.PredicateEvalInfo = PredicateEvalInfo;
});

// node_modules/antlr4ts/atn/ProfilingATNSimulator.js
var require_ProfilingATNSimulator = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ProfilingATNSimulator = void 0;
  var AmbiguityInfo_1 = require_AmbiguityInfo();
  var ATN_1 = require_ATN();
  var ATNSimulator_1 = require_ATNSimulator();
  var ContextSensitivityInfo_1 = require_ContextSensitivityInfo();
  var DecisionInfo_1 = require_DecisionInfo();
  var ErrorInfo_1 = require_ErrorInfo();
  var Decorators_1 = require_Decorators();
  var LookaheadEventInfo_1 = require_LookaheadEventInfo();
  var ParserATNSimulator_1 = require_ParserATNSimulator();
  var PredicateEvalInfo_1 = require_PredicateEvalInfo();
  var SemanticContext_1 = require_SemanticContext();
  var SimulatorState_1 = require_SimulatorState();
  var ProfilingATNSimulator = class extends ParserATNSimulator_1.ParserATNSimulator {
    constructor(parser) {
      super(parser.interpreter.atn, parser);
      this._startIndex = 0;
      this._sllStopIndex = 0;
      this._llStopIndex = 0;
      this.currentDecision = 0;
      this.conflictingAltResolvedBySLL = 0;
      this.optimize_ll1 = false;
      this.reportAmbiguities = true;
      this.numDecisions = this.atn.decisionToState.length;
      this.decisions = [];
      for (let i = 0; i < this.numDecisions; i++) {
        this.decisions.push(new DecisionInfo_1.DecisionInfo(i));
      }
    }
    adaptivePredict(input, decision, outerContext, useContext) {
      if (useContext !== void 0) {
        return super.adaptivePredict(input, decision, outerContext, useContext);
      }
      try {
        this._input = input;
        this._startIndex = input.index;
        this._sllStopIndex = this._startIndex - 1;
        this._llStopIndex = -1;
        this.currentDecision = decision;
        this.currentState = void 0;
        this.conflictingAltResolvedBySLL = ATN_1.ATN.INVALID_ALT_NUMBER;
        let start = process.hrtime();
        let alt = super.adaptivePredict(input, decision, outerContext);
        let stop = process.hrtime();
        let nanoseconds = (stop[0] - start[0]) * 1e9;
        if (nanoseconds === 0) {
          nanoseconds = stop[1] - start[1];
        } else {
          nanoseconds += 1e9 - start[1] + stop[1];
        }
        this.decisions[decision].timeInPrediction += nanoseconds;
        this.decisions[decision].invocations++;
        let SLL_k = this._sllStopIndex - this._startIndex + 1;
        this.decisions[decision].SLL_TotalLook += SLL_k;
        this.decisions[decision].SLL_MinLook = this.decisions[decision].SLL_MinLook === 0 ? SLL_k : Math.min(this.decisions[decision].SLL_MinLook, SLL_k);
        if (SLL_k > this.decisions[decision].SLL_MaxLook) {
          this.decisions[decision].SLL_MaxLook = SLL_k;
          this.decisions[decision].SLL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, void 0, alt, input, this._startIndex, this._sllStopIndex, false);
        }
        if (this._llStopIndex >= 0) {
          let LL_k = this._llStopIndex - this._startIndex + 1;
          this.decisions[decision].LL_TotalLook += LL_k;
          this.decisions[decision].LL_MinLook = this.decisions[decision].LL_MinLook === 0 ? LL_k : Math.min(this.decisions[decision].LL_MinLook, LL_k);
          if (LL_k > this.decisions[decision].LL_MaxLook) {
            this.decisions[decision].LL_MaxLook = LL_k;
            this.decisions[decision].LL_MaxLookEvent = new LookaheadEventInfo_1.LookaheadEventInfo(decision, void 0, alt, input, this._startIndex, this._llStopIndex, true);
          }
        }
        return alt;
      } finally {
        this._input = void 0;
        this.currentDecision = -1;
      }
    }
    getStartState(dfa, input, outerContext, useContext) {
      let state = super.getStartState(dfa, input, outerContext, useContext);
      this.currentState = state;
      return state;
    }
    computeStartState(dfa, globalContext, useContext) {
      let state = super.computeStartState(dfa, globalContext, useContext);
      this.currentState = state;
      return state;
    }
    computeReachSet(dfa, previous, t, contextCache) {
      if (this._input === void 0) {
        throw new Error("Invalid state");
      }
      let reachState = super.computeReachSet(dfa, previous, t, contextCache);
      if (reachState == null) {
        this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, previous, this._input, this._startIndex, this._input.index));
      }
      this.currentState = reachState;
      return reachState;
    }
    getExistingTargetState(previousD, t) {
      if (this.currentState === void 0 || this._input === void 0) {
        throw new Error("Invalid state");
      }
      if (this.currentState.useContext) {
        this._llStopIndex = this._input.index;
      } else {
        this._sllStopIndex = this._input.index;
      }
      let existingTargetState = super.getExistingTargetState(previousD, t);
      if (existingTargetState != null) {
        this.currentState = new SimulatorState_1.SimulatorState(this.currentState.outerContext, existingTargetState, this.currentState.useContext, this.currentState.remainingOuterContext);
        if (this.currentState.useContext) {
          this.decisions[this.currentDecision].LL_DFATransitions++;
        } else {
          this.decisions[this.currentDecision].SLL_DFATransitions++;
        }
        if (existingTargetState === ATNSimulator_1.ATNSimulator.ERROR) {
          let state = new SimulatorState_1.SimulatorState(this.currentState.outerContext, previousD, this.currentState.useContext, this.currentState.remainingOuterContext);
          this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, state, this._input, this._startIndex, this._input.index));
        }
      }
      return existingTargetState;
    }
    computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {
      let targetState = super.computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache);
      if (useContext) {
        this.decisions[this.currentDecision].LL_ATNTransitions++;
      } else {
        this.decisions[this.currentDecision].SLL_ATNTransitions++;
      }
      return targetState;
    }
    evalSemanticContextImpl(pred, parserCallStack, alt) {
      if (this.currentState === void 0 || this._input === void 0) {
        throw new Error("Invalid state");
      }
      let result = super.evalSemanticContextImpl(pred, parserCallStack, alt);
      if (!(pred instanceof SemanticContext_1.SemanticContext.PrecedencePredicate)) {
        let fullContext = this._llStopIndex >= 0;
        let stopIndex = fullContext ? this._llStopIndex : this._sllStopIndex;
        this.decisions[this.currentDecision].predicateEvals.push(new PredicateEvalInfo_1.PredicateEvalInfo(this.currentState, this.currentDecision, this._input, this._startIndex, stopIndex, pred, result, alt));
      }
      return result;
    }
    reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {
      if (this._input === void 0) {
        throw new Error("Invalid state");
      }
      if (prediction !== this.conflictingAltResolvedBySLL) {
        this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, acceptState, this._input, startIndex, stopIndex));
      }
      super.reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex);
    }
    reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {
      if (conflictingAlts != null) {
        this.conflictingAltResolvedBySLL = conflictingAlts.nextSetBit(0);
      } else {
        this.conflictingAltResolvedBySLL = conflictState.s0.configs.getRepresentedAlternatives().nextSetBit(0);
      }
      this.decisions[this.currentDecision].LL_Fallback++;
      super.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex);
    }
    reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
      if (this.currentState === void 0 || this._input === void 0) {
        throw new Error("Invalid state");
      }
      let prediction;
      if (ambigAlts != null) {
        prediction = ambigAlts.nextSetBit(0);
      } else {
        prediction = configs.getRepresentedAlternatives().nextSetBit(0);
      }
      if (this.conflictingAltResolvedBySLL !== ATN_1.ATN.INVALID_ALT_NUMBER && prediction !== this.conflictingAltResolvedBySLL) {
        this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, this.currentState, this._input, startIndex, stopIndex));
      }
      this.decisions[this.currentDecision].ambiguities.push(new AmbiguityInfo_1.AmbiguityInfo(this.currentDecision, this.currentState, ambigAlts, this._input, startIndex, stopIndex));
      super.reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs);
    }
    getDecisionInfo() {
      return this.decisions;
    }
    getCurrentState() {
      return this.currentState;
    }
  };
  __decorate([
    Decorators_1.Override,
    __param(0, Decorators_1.NotNull)
  ], ProfilingATNSimulator.prototype, "adaptivePredict", null);
  __decorate([
    Decorators_1.Override
  ], ProfilingATNSimulator.prototype, "getStartState", null);
  __decorate([
    Decorators_1.Override
  ], ProfilingATNSimulator.prototype, "computeStartState", null);
  __decorate([
    Decorators_1.Override
  ], ProfilingATNSimulator.prototype, "computeReachSet", null);
  __decorate([
    Decorators_1.Override
  ], ProfilingATNSimulator.prototype, "getExistingTargetState", null);
  __decorate([
    Decorators_1.Override
  ], ProfilingATNSimulator.prototype, "computeTargetState", null);
  __decorate([
    Decorators_1.Override
  ], ProfilingATNSimulator.prototype, "evalSemanticContextImpl", null);
  __decorate([
    Decorators_1.Override
  ], ProfilingATNSimulator.prototype, "reportContextSensitivity", null);
  __decorate([
    Decorators_1.Override
  ], ProfilingATNSimulator.prototype, "reportAttemptingFullContext", null);
  __decorate([
    Decorators_1.Override,
    __param(0, Decorators_1.NotNull),
    __param(5, Decorators_1.NotNull),
    __param(6, Decorators_1.NotNull)
  ], ProfilingATNSimulator.prototype, "reportAmbiguity", null);
  exports.ProfilingATNSimulator = ProfilingATNSimulator;
});

// node_modules/antlr4ts/Parser.js
var require_Parser = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.Parser = void 0;
  var Utils3 = require_Utils();
  var ATNDeserializationOptions_1 = require_ATNDeserializationOptions();
  var ATNDeserializer_1 = require_ATNDeserializer();
  var DefaultErrorStrategy_1 = require_DefaultErrorStrategy();
  var ErrorNode_1 = require_ErrorNode();
  var IntegerStack_1 = require_IntegerStack();
  var Lexer_1 = require_Lexer();
  var Decorators_1 = require_Decorators();
  var ParseInfo_1 = require_ParseInfo();
  var ParserATNSimulator_1 = require_ParserATNSimulator();
  var ProxyParserErrorListener_1 = require_ProxyParserErrorListener();
  var Recognizer_1 = require_Recognizer();
  var TerminalNode_1 = require_TerminalNode();
  var Token_1 = require_Token();
  var TraceListener = class {
    constructor(ruleNames, tokenStream) {
      this.ruleNames = ruleNames;
      this.tokenStream = tokenStream;
    }
    enterEveryRule(ctx) {
      console.log("enter   " + this.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text);
    }
    exitEveryRule(ctx) {
      console.log("exit    " + this.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text);
    }
    visitErrorNode(node) {
    }
    visitTerminal(node) {
      let parent = node.parent.ruleContext;
      let token = node.symbol;
      console.log("consume " + token + " rule " + this.ruleNames[parent.ruleIndex]);
    }
  };
  __decorate([
    Decorators_1.Override
  ], TraceListener.prototype, "enterEveryRule", null);
  __decorate([
    Decorators_1.Override
  ], TraceListener.prototype, "exitEveryRule", null);
  __decorate([
    Decorators_1.Override
  ], TraceListener.prototype, "visitErrorNode", null);
  __decorate([
    Decorators_1.Override
  ], TraceListener.prototype, "visitTerminal", null);
  var Parser2 = class extends Recognizer_1.Recognizer {
    constructor(input) {
      super();
      this._errHandler = new DefaultErrorStrategy_1.DefaultErrorStrategy();
      this._precedenceStack = new IntegerStack_1.IntegerStack();
      this._buildParseTrees = true;
      this._parseListeners = [];
      this._syntaxErrors = 0;
      this.matchedEOF = false;
      this._precedenceStack.push(0);
      this.inputStream = input;
    }
    reset(resetInput) {
      if (resetInput === void 0 || resetInput) {
        this.inputStream.seek(0);
      }
      this._errHandler.reset(this);
      this._ctx = void 0;
      this._syntaxErrors = 0;
      this.matchedEOF = false;
      this.isTrace = false;
      this._precedenceStack.clear();
      this._precedenceStack.push(0);
      let interpreter = this.interpreter;
      if (interpreter != null) {
        interpreter.reset();
      }
    }
    match(ttype) {
      let t = this.currentToken;
      if (t.type === ttype) {
        if (ttype === Token_1.Token.EOF) {
          this.matchedEOF = true;
        }
        this._errHandler.reportMatch(this);
        this.consume();
      } else {
        t = this._errHandler.recoverInline(this);
        if (this._buildParseTrees && t.tokenIndex === -1) {
          this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));
        }
      }
      return t;
    }
    matchWildcard() {
      let t = this.currentToken;
      if (t.type > 0) {
        this._errHandler.reportMatch(this);
        this.consume();
      } else {
        t = this._errHandler.recoverInline(this);
        if (this._buildParseTrees && t.tokenIndex === -1) {
          this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));
        }
      }
      return t;
    }
    set buildParseTree(buildParseTrees) {
      this._buildParseTrees = buildParseTrees;
    }
    get buildParseTree() {
      return this._buildParseTrees;
    }
    getParseListeners() {
      return this._parseListeners;
    }
    addParseListener(listener) {
      if (listener == null) {
        throw new TypeError("listener cannot be null");
      }
      this._parseListeners.push(listener);
    }
    removeParseListener(listener) {
      let index = this._parseListeners.findIndex((l) => l === listener);
      if (index !== -1) {
        this._parseListeners.splice(index, 1);
      }
    }
    removeParseListeners() {
      this._parseListeners.length = 0;
    }
    triggerEnterRuleEvent() {
      for (let listener of this._parseListeners) {
        if (listener.enterEveryRule) {
          listener.enterEveryRule(this._ctx);
        }
        this._ctx.enterRule(listener);
      }
    }
    triggerExitRuleEvent() {
      for (let i = this._parseListeners.length - 1; i >= 0; i--) {
        let listener = this._parseListeners[i];
        this._ctx.exitRule(listener);
        if (listener.exitEveryRule) {
          listener.exitEveryRule(this._ctx);
        }
      }
    }
    get numberOfSyntaxErrors() {
      return this._syntaxErrors;
    }
    get tokenFactory() {
      return this._input.tokenSource.tokenFactory;
    }
    getATNWithBypassAlts() {
      let serializedAtn = this.serializedATN;
      if (serializedAtn == null) {
        throw new Error("The current parser does not support an ATN with bypass alternatives.");
      }
      let result = Parser2.bypassAltsAtnCache.get(serializedAtn);
      if (result == null) {
        let deserializationOptions = new ATNDeserializationOptions_1.ATNDeserializationOptions();
        deserializationOptions.isGenerateRuleBypassTransitions = true;
        result = new ATNDeserializer_1.ATNDeserializer(deserializationOptions).deserialize(Utils3.toCharArray(serializedAtn));
        Parser2.bypassAltsAtnCache.set(serializedAtn, result);
      }
      return result;
    }
    compileParseTreePattern(pattern, patternRuleIndex, lexer) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!lexer) {
          if (this.inputStream) {
            let tokenSource = this.inputStream.tokenSource;
            if (tokenSource instanceof Lexer_1.Lexer) {
              lexer = tokenSource;
            }
          }
          if (!lexer) {
            throw new Error("Parser can't discover a lexer to use");
          }
        }
        let currentLexer = lexer;
        let m = yield Promise.resolve().then(() => require_ParseTreePatternMatcher());
        let matcher = new m.ParseTreePatternMatcher(currentLexer, this);
        return matcher.compile(pattern, patternRuleIndex);
      });
    }
    get errorHandler() {
      return this._errHandler;
    }
    set errorHandler(handler) {
      this._errHandler = handler;
    }
    get inputStream() {
      return this._input;
    }
    set inputStream(input) {
      this.reset(false);
      this._input = input;
    }
    get currentToken() {
      return this._input.LT(1);
    }
    notifyErrorListeners(msg, offendingToken, e) {
      if (offendingToken === void 0) {
        offendingToken = this.currentToken;
      } else if (offendingToken === null) {
        offendingToken = void 0;
      }
      this._syntaxErrors++;
      let line = -1;
      let charPositionInLine = -1;
      if (offendingToken != null) {
        line = offendingToken.line;
        charPositionInLine = offendingToken.charPositionInLine;
      }
      let listener = this.getErrorListenerDispatch();
      if (listener.syntaxError) {
        listener.syntaxError(this, offendingToken, line, charPositionInLine, msg, e);
      }
    }
    consume() {
      let o = this.currentToken;
      if (o.type !== Parser2.EOF) {
        this.inputStream.consume();
      }
      let hasListener = this._parseListeners.length !== 0;
      if (this._buildParseTrees || hasListener) {
        if (this._errHandler.inErrorRecoveryMode(this)) {
          let node = this._ctx.addErrorNode(this.createErrorNode(this._ctx, o));
          if (hasListener) {
            for (let listener of this._parseListeners) {
              if (listener.visitErrorNode) {
                listener.visitErrorNode(node);
              }
            }
          }
        } else {
          let node = this.createTerminalNode(this._ctx, o);
          this._ctx.addChild(node);
          if (hasListener) {
            for (let listener of this._parseListeners) {
              if (listener.visitTerminal) {
                listener.visitTerminal(node);
              }
            }
          }
        }
      }
      return o;
    }
    createTerminalNode(parent, t) {
      return new TerminalNode_1.TerminalNode(t);
    }
    createErrorNode(parent, t) {
      return new ErrorNode_1.ErrorNode(t);
    }
    addContextToParseTree() {
      let parent = this._ctx._parent;
      if (parent != null) {
        parent.addChild(this._ctx);
      }
    }
    enterRule(localctx, state, ruleIndex) {
      this.state = state;
      this._ctx = localctx;
      this._ctx._start = this._input.LT(1);
      if (this._buildParseTrees) {
        this.addContextToParseTree();
      }
      this.triggerEnterRuleEvent();
    }
    enterLeftFactoredRule(localctx, state, ruleIndex) {
      this.state = state;
      if (this._buildParseTrees) {
        let factoredContext = this._ctx.getChild(this._ctx.childCount - 1);
        this._ctx.removeLastChild();
        factoredContext._parent = localctx;
        localctx.addChild(factoredContext);
      }
      this._ctx = localctx;
      this._ctx._start = this._input.LT(1);
      if (this._buildParseTrees) {
        this.addContextToParseTree();
      }
      this.triggerEnterRuleEvent();
    }
    exitRule() {
      if (this.matchedEOF) {
        this._ctx._stop = this._input.LT(1);
      } else {
        this._ctx._stop = this._input.tryLT(-1);
      }
      this.triggerExitRuleEvent();
      this.state = this._ctx.invokingState;
      this._ctx = this._ctx._parent;
    }
    enterOuterAlt(localctx, altNum) {
      localctx.altNumber = altNum;
      if (this._buildParseTrees && this._ctx !== localctx) {
        let parent = this._ctx._parent;
        if (parent != null) {
          parent.removeLastChild();
          parent.addChild(localctx);
        }
      }
      this._ctx = localctx;
    }
    get precedence() {
      if (this._precedenceStack.isEmpty) {
        return -1;
      }
      return this._precedenceStack.peek();
    }
    enterRecursionRule(localctx, state, ruleIndex, precedence) {
      this.state = state;
      this._precedenceStack.push(precedence);
      this._ctx = localctx;
      this._ctx._start = this._input.LT(1);
      this.triggerEnterRuleEvent();
    }
    pushNewRecursionContext(localctx, state, ruleIndex) {
      let previous = this._ctx;
      previous._parent = localctx;
      previous.invokingState = state;
      previous._stop = this._input.tryLT(-1);
      this._ctx = localctx;
      this._ctx._start = previous._start;
      if (this._buildParseTrees) {
        this._ctx.addChild(previous);
      }
      this.triggerEnterRuleEvent();
    }
    unrollRecursionContexts(_parentctx) {
      this._precedenceStack.pop();
      this._ctx._stop = this._input.tryLT(-1);
      let retctx = this._ctx;
      if (this._parseListeners.length > 0) {
        while (this._ctx !== _parentctx) {
          this.triggerExitRuleEvent();
          this._ctx = this._ctx._parent;
        }
      } else {
        this._ctx = _parentctx;
      }
      retctx._parent = _parentctx;
      if (this._buildParseTrees && _parentctx != null) {
        _parentctx.addChild(retctx);
      }
    }
    getInvokingContext(ruleIndex) {
      let p = this._ctx;
      while (p && p.ruleIndex !== ruleIndex) {
        p = p._parent;
      }
      return p;
    }
    get context() {
      return this._ctx;
    }
    set context(ctx) {
      this._ctx = ctx;
    }
    precpred(localctx, precedence) {
      return precedence >= this._precedenceStack.peek();
    }
    getErrorListenerDispatch() {
      return new ProxyParserErrorListener_1.ProxyParserErrorListener(this.getErrorListeners());
    }
    inContext(context) {
      return false;
    }
    isExpectedToken(symbol) {
      let atn = this.interpreter.atn;
      let ctx = this._ctx;
      let s = atn.states[this.state];
      let following = atn.nextTokens(s);
      if (following.contains(symbol)) {
        return true;
      }
      if (!following.contains(Token_1.Token.EPSILON)) {
        return false;
      }
      while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {
        let invokingState = atn.states[ctx.invokingState];
        let rt = invokingState.transition(0);
        following = atn.nextTokens(rt.followState);
        if (following.contains(symbol)) {
          return true;
        }
        ctx = ctx._parent;
      }
      if (following.contains(Token_1.Token.EPSILON) && symbol === Token_1.Token.EOF) {
        return true;
      }
      return false;
    }
    get isMatchedEOF() {
      return this.matchedEOF;
    }
    getExpectedTokens() {
      return this.atn.getExpectedTokens(this.state, this.context);
    }
    getExpectedTokensWithinCurrentRule() {
      let atn = this.interpreter.atn;
      let s = atn.states[this.state];
      return atn.nextTokens(s);
    }
    getRuleIndex(ruleName) {
      let ruleIndex = this.getRuleIndexMap().get(ruleName);
      if (ruleIndex != null) {
        return ruleIndex;
      }
      return -1;
    }
    get ruleContext() {
      return this._ctx;
    }
    getRuleInvocationStack(ctx = this._ctx) {
      let p = ctx;
      let ruleNames = this.ruleNames;
      let stack = [];
      while (p != null) {
        let ruleIndex = p.ruleIndex;
        if (ruleIndex < 0) {
          stack.push("n/a");
        } else {
          stack.push(ruleNames[ruleIndex]);
        }
        p = p._parent;
      }
      return stack;
    }
    getDFAStrings() {
      let s = [];
      for (let dfa of this._interp.atn.decisionToDFA) {
        s.push(dfa.toString(this.vocabulary, this.ruleNames));
      }
      return s;
    }
    dumpDFA() {
      let seenOne = false;
      for (let dfa of this._interp.atn.decisionToDFA) {
        if (!dfa.isEmpty) {
          if (seenOne) {
            console.log();
          }
          console.log("Decision " + dfa.decision + ":");
          process.stdout.write(dfa.toString(this.vocabulary, this.ruleNames));
          seenOne = true;
        }
      }
    }
    get sourceName() {
      return this._input.sourceName;
    }
    get parseInfo() {
      return Promise.resolve().then(() => require_ProfilingATNSimulator()).then((m) => {
        let interp = this.interpreter;
        if (interp instanceof m.ProfilingATNSimulator) {
          return new ParseInfo_1.ParseInfo(interp);
        }
        return void 0;
      });
    }
    setProfile(profile) {
      return __awaiter(this, void 0, void 0, function* () {
        let m = yield Promise.resolve().then(() => require_ProfilingATNSimulator());
        let interp = this.interpreter;
        if (profile) {
          if (!(interp instanceof m.ProfilingATNSimulator)) {
            this.interpreter = new m.ProfilingATNSimulator(this);
          }
        } else if (interp instanceof m.ProfilingATNSimulator) {
          this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this.atn, this);
        }
        this.interpreter.setPredictionMode(interp.getPredictionMode());
      });
    }
    set isTrace(trace) {
      if (!trace) {
        if (this._tracer) {
          this.removeParseListener(this._tracer);
          this._tracer = void 0;
        }
      } else {
        if (this._tracer) {
          this.removeParseListener(this._tracer);
        } else {
          this._tracer = new TraceListener(this.ruleNames, this._input);
        }
        this.addParseListener(this._tracer);
      }
    }
    get isTrace() {
      return this._tracer != null;
    }
  };
  Parser2.bypassAltsAtnCache = new Map();
  __decorate([
    Decorators_1.NotNull
  ], Parser2.prototype, "_errHandler", void 0);
  __decorate([
    Decorators_1.NotNull
  ], Parser2.prototype, "match", null);
  __decorate([
    Decorators_1.NotNull
  ], Parser2.prototype, "matchWildcard", null);
  __decorate([
    Decorators_1.NotNull
  ], Parser2.prototype, "getParseListeners", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], Parser2.prototype, "addParseListener", null);
  __decorate([
    Decorators_1.NotNull
  ], Parser2.prototype, "getATNWithBypassAlts", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull)
  ], Parser2.prototype, "errorHandler", null);
  __decorate([
    Decorators_1.Override
  ], Parser2.prototype, "inputStream", null);
  __decorate([
    Decorators_1.NotNull
  ], Parser2.prototype, "currentToken", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], Parser2.prototype, "enterRule", null);
  __decorate([
    Decorators_1.Override,
    __param(0, Decorators_1.Nullable)
  ], Parser2.prototype, "precpred", null);
  __decorate([
    Decorators_1.Override
  ], Parser2.prototype, "getErrorListenerDispatch", null);
  __decorate([
    Decorators_1.NotNull
  ], Parser2.prototype, "getExpectedTokens", null);
  __decorate([
    Decorators_1.NotNull
  ], Parser2.prototype, "getExpectedTokensWithinCurrentRule", null);
  __decorate([
    Decorators_1.Override
  ], Parser2.prototype, "parseInfo", null);
  exports.Parser = Parser2;
});

// node_modules/antlr4ts/NoViableAltException.js
var require_NoViableAltException = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.NoViableAltException = void 0;
  var Parser_1 = require_Parser();
  var RecognitionException_1 = require_RecognitionException();
  var Decorators_1 = require_Decorators();
  var NoViableAltException2 = class extends RecognitionException_1.RecognitionException {
    constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {
      if (recognizer instanceof Parser_1.Parser) {
        if (input === void 0) {
          input = recognizer.inputStream;
        }
        if (startToken === void 0) {
          startToken = recognizer.currentToken;
        }
        if (offendingToken === void 0) {
          offendingToken = recognizer.currentToken;
        }
        if (ctx === void 0) {
          ctx = recognizer.context;
        }
      }
      super(recognizer, input, ctx);
      this._deadEndConfigs = deadEndConfigs;
      this._startToken = startToken;
      this.setOffendingToken(recognizer, offendingToken);
    }
    get startToken() {
      return this._startToken;
    }
    get deadEndConfigs() {
      return this._deadEndConfigs;
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], NoViableAltException2.prototype, "_startToken", void 0);
  exports.NoViableAltException = NoViableAltException2;
});

// node_modules/antlr4ts/DefaultErrorStrategy.js
var require_DefaultErrorStrategy = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.DefaultErrorStrategy = void 0;
  var ATNState_1 = require_ATNState();
  var ATNStateType_1 = require_ATNStateType();
  var FailedPredicateException_1 = require_FailedPredicateException();
  var InputMismatchException_1 = require_InputMismatchException();
  var IntervalSet_1 = require_IntervalSet();
  var NoViableAltException_1 = require_NoViableAltException();
  var PredictionContext_1 = require_PredictionContext();
  var Token_1 = require_Token();
  var Decorators_1 = require_Decorators();
  var DefaultErrorStrategy = class {
    constructor() {
      this.errorRecoveryMode = false;
      this.lastErrorIndex = -1;
      this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;
    }
    reset(recognizer) {
      this.endErrorCondition(recognizer);
    }
    beginErrorCondition(recognizer) {
      this.errorRecoveryMode = true;
    }
    inErrorRecoveryMode(recognizer) {
      return this.errorRecoveryMode;
    }
    endErrorCondition(recognizer) {
      this.errorRecoveryMode = false;
      this.lastErrorStates = void 0;
      this.lastErrorIndex = -1;
    }
    reportMatch(recognizer) {
      this.endErrorCondition(recognizer);
    }
    reportError(recognizer, e) {
      if (this.inErrorRecoveryMode(recognizer)) {
        return;
      }
      this.beginErrorCondition(recognizer);
      if (e instanceof NoViableAltException_1.NoViableAltException) {
        this.reportNoViableAlternative(recognizer, e);
      } else if (e instanceof InputMismatchException_1.InputMismatchException) {
        this.reportInputMismatch(recognizer, e);
      } else if (e instanceof FailedPredicateException_1.FailedPredicateException) {
        this.reportFailedPredicate(recognizer, e);
      } else {
        console.error(`unknown recognition error type: ${e}`);
        this.notifyErrorListeners(recognizer, e.toString(), e);
      }
    }
    notifyErrorListeners(recognizer, message, e) {
      let offendingToken = e.getOffendingToken(recognizer);
      if (offendingToken === void 0) {
        offendingToken = null;
      }
      recognizer.notifyErrorListeners(message, offendingToken, e);
    }
    recover(recognizer, e) {
      if (this.lastErrorIndex === recognizer.inputStream.index && this.lastErrorStates && this.lastErrorStates.contains(recognizer.state)) {
        recognizer.consume();
      }
      this.lastErrorIndex = recognizer.inputStream.index;
      if (!this.lastErrorStates) {
        this.lastErrorStates = new IntervalSet_1.IntervalSet();
      }
      this.lastErrorStates.add(recognizer.state);
      let followSet = this.getErrorRecoverySet(recognizer);
      this.consumeUntil(recognizer, followSet);
    }
    sync(recognizer) {
      let s = recognizer.interpreter.atn.states[recognizer.state];
      if (this.inErrorRecoveryMode(recognizer)) {
        return;
      }
      let tokens2 = recognizer.inputStream;
      let la = tokens2.LA(1);
      let nextTokens = recognizer.atn.nextTokens(s);
      if (nextTokens.contains(la)) {
        this.nextTokensContext = void 0;
        this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;
        return;
      }
      if (nextTokens.contains(Token_1.Token.EPSILON)) {
        if (this.nextTokensContext === void 0) {
          this.nextTokensContext = recognizer.context;
          this.nextTokensState = recognizer.state;
        }
        return;
      }
      switch (s.stateType) {
        case ATNStateType_1.ATNStateType.BLOCK_START:
        case ATNStateType_1.ATNStateType.STAR_BLOCK_START:
        case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:
        case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:
          if (this.singleTokenDeletion(recognizer)) {
            return;
          }
          throw new InputMismatchException_1.InputMismatchException(recognizer);
        case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:
        case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:
          this.reportUnwantedToken(recognizer);
          let expecting = recognizer.getExpectedTokens();
          let whatFollowsLoopIterationOrRule = expecting.or(this.getErrorRecoverySet(recognizer));
          this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
          break;
        default:
          break;
      }
    }
    reportNoViableAlternative(recognizer, e) {
      let tokens2 = recognizer.inputStream;
      let input;
      if (tokens2) {
        if (e.startToken.type === Token_1.Token.EOF) {
          input = "<EOF>";
        } else {
          input = tokens2.getTextFromRange(e.startToken, e.getOffendingToken());
        }
      } else {
        input = "<unknown input>";
      }
      let msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
      this.notifyErrorListeners(recognizer, msg, e);
    }
    reportInputMismatch(recognizer, e) {
      let expected = e.expectedTokens;
      let expectedString = expected ? expected.toStringVocabulary(recognizer.vocabulary) : "";
      let msg = "mismatched input " + this.getTokenErrorDisplay(e.getOffendingToken(recognizer)) + " expecting " + expectedString;
      this.notifyErrorListeners(recognizer, msg, e);
    }
    reportFailedPredicate(recognizer, e) {
      let ruleName = recognizer.ruleNames[recognizer.context.ruleIndex];
      let msg = "rule " + ruleName + " " + e.message;
      this.notifyErrorListeners(recognizer, msg, e);
    }
    reportUnwantedToken(recognizer) {
      if (this.inErrorRecoveryMode(recognizer)) {
        return;
      }
      this.beginErrorCondition(recognizer);
      let t = recognizer.currentToken;
      let tokenName = this.getTokenErrorDisplay(t);
      let expecting = this.getExpectedTokens(recognizer);
      let msg = "extraneous input " + tokenName + " expecting " + expecting.toStringVocabulary(recognizer.vocabulary);
      recognizer.notifyErrorListeners(msg, t, void 0);
    }
    reportMissingToken(recognizer) {
      if (this.inErrorRecoveryMode(recognizer)) {
        return;
      }
      this.beginErrorCondition(recognizer);
      let t = recognizer.currentToken;
      let expecting = this.getExpectedTokens(recognizer);
      let msg = "missing " + expecting.toStringVocabulary(recognizer.vocabulary) + " at " + this.getTokenErrorDisplay(t);
      recognizer.notifyErrorListeners(msg, t, void 0);
    }
    recoverInline(recognizer) {
      let matchedSymbol = this.singleTokenDeletion(recognizer);
      if (matchedSymbol) {
        recognizer.consume();
        return matchedSymbol;
      }
      if (this.singleTokenInsertion(recognizer)) {
        return this.getMissingSymbol(recognizer);
      }
      if (this.nextTokensContext === void 0) {
        throw new InputMismatchException_1.InputMismatchException(recognizer);
      } else {
        throw new InputMismatchException_1.InputMismatchException(recognizer, this.nextTokensState, this.nextTokensContext);
      }
    }
    singleTokenInsertion(recognizer) {
      let currentSymbolType = recognizer.inputStream.LA(1);
      let currentState = recognizer.interpreter.atn.states[recognizer.state];
      let next = currentState.transition(0).target;
      let atn = recognizer.interpreter.atn;
      let expectingAtLL2 = atn.nextTokens(next, PredictionContext_1.PredictionContext.fromRuleContext(atn, recognizer.context));
      if (expectingAtLL2.contains(currentSymbolType)) {
        this.reportMissingToken(recognizer);
        return true;
      }
      return false;
    }
    singleTokenDeletion(recognizer) {
      let nextTokenType = recognizer.inputStream.LA(2);
      let expecting = this.getExpectedTokens(recognizer);
      if (expecting.contains(nextTokenType)) {
        this.reportUnwantedToken(recognizer);
        recognizer.consume();
        let matchedSymbol = recognizer.currentToken;
        this.reportMatch(recognizer);
        return matchedSymbol;
      }
      return void 0;
    }
    getMissingSymbol(recognizer) {
      let currentSymbol = recognizer.currentToken;
      let expecting = this.getExpectedTokens(recognizer);
      let expectedTokenType = Token_1.Token.INVALID_TYPE;
      if (!expecting.isNil) {
        expectedTokenType = expecting.minElement;
      }
      let tokenText;
      if (expectedTokenType === Token_1.Token.EOF) {
        tokenText = "<missing EOF>";
      } else {
        tokenText = "<missing " + recognizer.vocabulary.getDisplayName(expectedTokenType) + ">";
      }
      let current = currentSymbol;
      let lookback = recognizer.inputStream.tryLT(-1);
      if (current.type === Token_1.Token.EOF && lookback != null) {
        current = lookback;
      }
      return this.constructToken(recognizer.inputStream.tokenSource, expectedTokenType, tokenText, current);
    }
    constructToken(tokenSource, expectedTokenType, tokenText, current) {
      let factory = tokenSource.tokenFactory;
      let x = current.tokenSource;
      let stream = x ? x.inputStream : void 0;
      return factory.create({source: tokenSource, stream}, expectedTokenType, tokenText, Token_1.Token.DEFAULT_CHANNEL, -1, -1, current.line, current.charPositionInLine);
    }
    getExpectedTokens(recognizer) {
      return recognizer.getExpectedTokens();
    }
    getTokenErrorDisplay(t) {
      if (!t) {
        return "<no token>";
      }
      let s = this.getSymbolText(t);
      if (!s) {
        if (this.getSymbolType(t) === Token_1.Token.EOF) {
          s = "<EOF>";
        } else {
          s = `<${this.getSymbolType(t)}>`;
        }
      }
      return this.escapeWSAndQuote(s);
    }
    getSymbolText(symbol) {
      return symbol.text;
    }
    getSymbolType(symbol) {
      return symbol.type;
    }
    escapeWSAndQuote(s) {
      s = s.replace("\n", "\\n");
      s = s.replace("\r", "\\r");
      s = s.replace("	", "\\t");
      return "'" + s + "'";
    }
    getErrorRecoverySet(recognizer) {
      let atn = recognizer.interpreter.atn;
      let ctx = recognizer.context;
      let recoverSet = new IntervalSet_1.IntervalSet();
      while (ctx && ctx.invokingState >= 0) {
        let invokingState = atn.states[ctx.invokingState];
        let rt = invokingState.transition(0);
        let follow = atn.nextTokens(rt.followState);
        recoverSet.addAll(follow);
        ctx = ctx._parent;
      }
      recoverSet.remove(Token_1.Token.EPSILON);
      return recoverSet;
    }
    consumeUntil(recognizer, set) {
      let ttype = recognizer.inputStream.LA(1);
      while (ttype !== Token_1.Token.EOF && !set.contains(ttype)) {
        recognizer.consume();
        ttype = recognizer.inputStream.LA(1);
      }
    }
  };
  __decorate([
    Decorators_1.Override
  ], DefaultErrorStrategy.prototype, "reset", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], DefaultErrorStrategy.prototype, "beginErrorCondition", null);
  __decorate([
    Decorators_1.Override
  ], DefaultErrorStrategy.prototype, "inErrorRecoveryMode", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], DefaultErrorStrategy.prototype, "endErrorCondition", null);
  __decorate([
    Decorators_1.Override
  ], DefaultErrorStrategy.prototype, "reportMatch", null);
  __decorate([
    Decorators_1.Override
  ], DefaultErrorStrategy.prototype, "reportError", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], DefaultErrorStrategy.prototype, "notifyErrorListeners", null);
  __decorate([
    Decorators_1.Override
  ], DefaultErrorStrategy.prototype, "recover", null);
  __decorate([
    Decorators_1.Override
  ], DefaultErrorStrategy.prototype, "sync", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull)
  ], DefaultErrorStrategy.prototype, "reportNoViableAlternative", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull)
  ], DefaultErrorStrategy.prototype, "reportInputMismatch", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull)
  ], DefaultErrorStrategy.prototype, "reportFailedPredicate", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], DefaultErrorStrategy.prototype, "reportUnwantedToken", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], DefaultErrorStrategy.prototype, "reportMissingToken", null);
  __decorate([
    Decorators_1.Override
  ], DefaultErrorStrategy.prototype, "recoverInline", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], DefaultErrorStrategy.prototype, "singleTokenInsertion", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], DefaultErrorStrategy.prototype, "singleTokenDeletion", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull)
  ], DefaultErrorStrategy.prototype, "getMissingSymbol", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull)
  ], DefaultErrorStrategy.prototype, "getExpectedTokens", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], DefaultErrorStrategy.prototype, "getSymbolText", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], DefaultErrorStrategy.prototype, "getSymbolType", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull)
  ], DefaultErrorStrategy.prototype, "escapeWSAndQuote", null);
  __decorate([
    Decorators_1.NotNull,
    __param(0, Decorators_1.NotNull)
  ], DefaultErrorStrategy.prototype, "getErrorRecoverySet", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull)
  ], DefaultErrorStrategy.prototype, "consumeUntil", null);
  exports.DefaultErrorStrategy = DefaultErrorStrategy;
});

// node_modules/antlr4ts/BailErrorStrategy.js
var require_BailErrorStrategy = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.BailErrorStrategy = void 0;
  var DefaultErrorStrategy_1 = require_DefaultErrorStrategy();
  var InputMismatchException_1 = require_InputMismatchException();
  var Decorators_1 = require_Decorators();
  var ParseCancellationException_1 = require_ParseCancellationException();
  var BailErrorStrategy = class extends DefaultErrorStrategy_1.DefaultErrorStrategy {
    recover(recognizer, e) {
      for (let context = recognizer.context; context; context = context.parent) {
        context.exception = e;
      }
      throw new ParseCancellationException_1.ParseCancellationException(e);
    }
    recoverInline(recognizer) {
      let e = new InputMismatchException_1.InputMismatchException(recognizer);
      for (let context = recognizer.context; context; context = context.parent) {
        context.exception = e;
      }
      throw new ParseCancellationException_1.ParseCancellationException(e);
    }
    sync(recognizer) {
    }
  };
  __decorate([
    Decorators_1.Override
  ], BailErrorStrategy.prototype, "recover", null);
  __decorate([
    Decorators_1.Override
  ], BailErrorStrategy.prototype, "recoverInline", null);
  __decorate([
    Decorators_1.Override
  ], BailErrorStrategy.prototype, "sync", null);
  exports.BailErrorStrategy = BailErrorStrategy;
});

// node_modules/antlr4ts/CharStream.js
var require_CharStream = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
});

// node_modules/antlr4ts/Dependents.js
var require_Dependents = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.Dependents = void 0;
  var Dependents;
  (function(Dependents2) {
    Dependents2[Dependents2["SELF"] = 0] = "SELF";
    Dependents2[Dependents2["PARENTS"] = 1] = "PARENTS";
    Dependents2[Dependents2["CHILDREN"] = 2] = "CHILDREN";
    Dependents2[Dependents2["ANCESTORS"] = 3] = "ANCESTORS";
    Dependents2[Dependents2["DESCENDANTS"] = 4] = "DESCENDANTS";
    Dependents2[Dependents2["SIBLINGS"] = 5] = "SIBLINGS";
    Dependents2[Dependents2["PRECEEDING_SIBLINGS"] = 6] = "PRECEEDING_SIBLINGS";
    Dependents2[Dependents2["FOLLOWING_SIBLINGS"] = 7] = "FOLLOWING_SIBLINGS";
    Dependents2[Dependents2["PRECEEDING"] = 8] = "PRECEEDING";
    Dependents2[Dependents2["FOLLOWING"] = 9] = "FOLLOWING";
  })(Dependents = exports.Dependents || (exports.Dependents = {}));
});

// node_modules/antlr4ts/DiagnosticErrorListener.js
var require_DiagnosticErrorListener = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.DiagnosticErrorListener = void 0;
  var BitSet_1 = require_BitSet();
  var Decorators_1 = require_Decorators();
  var Interval_1 = require_Interval();
  var DiagnosticErrorListener = class {
    constructor(exactOnly = true) {
      this.exactOnly = exactOnly;
      this.exactOnly = exactOnly;
    }
    syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e) {
    }
    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
      if (this.exactOnly && !exact) {
        return;
      }
      let decision = this.getDecisionDescription(recognizer, dfa);
      let conflictingAlts = this.getConflictingAlts(ambigAlts, configs);
      let text = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
      let message = `reportAmbiguity d=${decision}: ambigAlts=${conflictingAlts}, input='${text}'`;
      recognizer.notifyErrorListeners(message);
    }
    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {
      let format = "reportAttemptingFullContext d=%s, input='%s'";
      let decision = this.getDecisionDescription(recognizer, dfa);
      let text = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
      let message = `reportAttemptingFullContext d=${decision}, input='${text}'`;
      recognizer.notifyErrorListeners(message);
    }
    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {
      let format = "reportContextSensitivity d=%s, input='%s'";
      let decision = this.getDecisionDescription(recognizer, dfa);
      let text = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));
      let message = `reportContextSensitivity d=${decision}, input='${text}'`;
      recognizer.notifyErrorListeners(message);
    }
    getDecisionDescription(recognizer, dfa) {
      let decision = dfa.decision;
      let ruleIndex = dfa.atnStartState.ruleIndex;
      let ruleNames = recognizer.ruleNames;
      if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
        return decision.toString();
      }
      let ruleName = ruleNames[ruleIndex];
      if (!ruleName) {
        return decision.toString();
      }
      return `${decision} (${ruleName})`;
    }
    getConflictingAlts(reportedAlts, configs) {
      if (reportedAlts != null) {
        return reportedAlts;
      }
      let result = new BitSet_1.BitSet();
      for (let config of configs) {
        result.set(config.alt);
      }
      return result;
    }
  };
  __decorate([
    Decorators_1.Override
  ], DiagnosticErrorListener.prototype, "syntaxError", null);
  __decorate([
    Decorators_1.Override,
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull),
    __param(6, Decorators_1.NotNull)
  ], DiagnosticErrorListener.prototype, "reportAmbiguity", null);
  __decorate([
    Decorators_1.Override,
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull),
    __param(5, Decorators_1.NotNull)
  ], DiagnosticErrorListener.prototype, "reportAttemptingFullContext", null);
  __decorate([
    Decorators_1.Override,
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull),
    __param(5, Decorators_1.NotNull)
  ], DiagnosticErrorListener.prototype, "reportContextSensitivity", null);
  __decorate([
    __param(0, Decorators_1.NotNull),
    __param(1, Decorators_1.NotNull)
  ], DiagnosticErrorListener.prototype, "getDecisionDescription", null);
  __decorate([
    Decorators_1.NotNull,
    __param(1, Decorators_1.NotNull)
  ], DiagnosticErrorListener.prototype, "getConflictingAlts", null);
  exports.DiagnosticErrorListener = DiagnosticErrorListener;
});

// node_modules/antlr4ts/LexerInterpreter.js
var require_LexerInterpreter = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.LexerInterpreter = void 0;
  var Lexer_1 = require_Lexer();
  var LexerATNSimulator_1 = require_LexerATNSimulator();
  var Decorators_1 = require_Decorators();
  var Decorators_2 = require_Decorators();
  var LexerInterpreter = class LexerInterpreter extends Lexer_1.Lexer {
    constructor(grammarFileName, vocabulary, ruleNames, channelNames, modeNames, atn, input) {
      super(input);
      if (atn.grammarType !== 0) {
        throw new Error("IllegalArgumentException: The ATN must be a lexer ATN.");
      }
      this._grammarFileName = grammarFileName;
      this._atn = atn;
      this._ruleNames = ruleNames.slice(0);
      this._channelNames = channelNames.slice(0);
      this._modeNames = modeNames.slice(0);
      this._vocabulary = vocabulary;
      this._interp = new LexerATNSimulator_1.LexerATNSimulator(atn, this);
    }
    get atn() {
      return this._atn;
    }
    get grammarFileName() {
      return this._grammarFileName;
    }
    get ruleNames() {
      return this._ruleNames;
    }
    get channelNames() {
      return this._channelNames;
    }
    get modeNames() {
      return this._modeNames;
    }
    get vocabulary() {
      return this._vocabulary;
    }
  };
  __decorate([
    Decorators_1.NotNull
  ], LexerInterpreter.prototype, "_vocabulary", void 0);
  __decorate([
    Decorators_2.Override
  ], LexerInterpreter.prototype, "atn", null);
  __decorate([
    Decorators_2.Override
  ], LexerInterpreter.prototype, "grammarFileName", null);
  __decorate([
    Decorators_2.Override
  ], LexerInterpreter.prototype, "ruleNames", null);
  __decorate([
    Decorators_2.Override
  ], LexerInterpreter.prototype, "channelNames", null);
  __decorate([
    Decorators_2.Override
  ], LexerInterpreter.prototype, "modeNames", null);
  __decorate([
    Decorators_2.Override
  ], LexerInterpreter.prototype, "vocabulary", null);
  LexerInterpreter = __decorate([
    __param(1, Decorators_1.NotNull)
  ], LexerInterpreter);
  exports.LexerInterpreter = LexerInterpreter;
});

// node_modules/antlr4ts/ParserErrorListener.js
var require_ParserErrorListener = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
});

// node_modules/antlr4ts/RuleContextWithAltNum.js
var require_RuleContextWithAltNum = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.RuleContextWithAltNum = void 0;
  var ATN_1 = require_ATN();
  var Decorators_1 = require_Decorators();
  var ParserRuleContext_1 = require_ParserRuleContext();
  var RuleContextWithAltNum = class extends ParserRuleContext_1.ParserRuleContext {
    constructor(parent, invokingStateNumber) {
      if (invokingStateNumber !== void 0) {
        super(parent, invokingStateNumber);
      } else {
        super();
      }
      this._altNumber = ATN_1.ATN.INVALID_ALT_NUMBER;
    }
    get altNumber() {
      return this._altNumber;
    }
    set altNumber(altNum) {
      this._altNumber = altNum;
    }
  };
  __decorate([
    Decorators_1.Override
  ], RuleContextWithAltNum.prototype, "altNumber", null);
  exports.RuleContextWithAltNum = RuleContextWithAltNum;
});

// node_modules/antlr4ts/RuleDependency.js
var require_RuleDependency = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.RuleDependency = void 0;
  function RuleDependency(dependency) {
    return (target, propertyKey, propertyDescriptor) => {
    };
  }
  exports.RuleDependency = RuleDependency;
});

// node_modules/antlr4ts/RuleVersion.js
var require_RuleVersion = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.RuleVersion = void 0;
  function RuleVersion(version) {
    return (target, propertyKey, propertyDescriptor) => {
    };
  }
  exports.RuleVersion = RuleVersion;
});

// node_modules/antlr4ts/TokenFactory.js
var require_TokenFactory = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
});

// node_modules/antlr4ts/TokenSource.js
var require_TokenSource = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
});

// node_modules/antlr4ts/TokenStream.js
var require_TokenStream = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
});

// node_modules/antlr4ts/TokenStreamRewriter.js
var require_TokenStreamRewriter = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.RewriteOperation = exports.TokenStreamRewriter = void 0;
  var Interval_1 = require_Interval();
  var Decorators_1 = require_Decorators();
  var Token_1 = require_Token();
  var TokenStreamRewriter = class {
    constructor(tokens2) {
      this.tokens = tokens2;
      this.programs = new Map();
      this.programs.set(TokenStreamRewriter.DEFAULT_PROGRAM_NAME, []);
      this.lastRewriteTokenIndexes = new Map();
    }
    getTokenStream() {
      return this.tokens;
    }
    rollback(instructionIndex, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
      let is = this.programs.get(programName);
      if (is != null) {
        this.programs.set(programName, is.slice(TokenStreamRewriter.MIN_TOKEN_INDEX, instructionIndex));
      }
    }
    deleteProgram(programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
      this.rollback(TokenStreamRewriter.MIN_TOKEN_INDEX, programName);
    }
    insertAfter(tokenOrIndex, text, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
      let index;
      if (typeof tokenOrIndex === "number") {
        index = tokenOrIndex;
      } else {
        index = tokenOrIndex.tokenIndex;
      }
      let rewrites = this.getProgram(programName);
      let op = new InsertAfterOp(this.tokens, index, rewrites.length, text);
      rewrites.push(op);
    }
    insertBefore(tokenOrIndex, text, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
      let index;
      if (typeof tokenOrIndex === "number") {
        index = tokenOrIndex;
      } else {
        index = tokenOrIndex.tokenIndex;
      }
      let rewrites = this.getProgram(programName);
      let op = new InsertBeforeOp(this.tokens, index, rewrites.length, text);
      rewrites.push(op);
    }
    replaceSingle(index, text) {
      if (typeof index === "number") {
        this.replace(index, index, text);
      } else {
        this.replace(index, index, text);
      }
    }
    replace(from, to, text, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
      if (typeof from !== "number") {
        from = from.tokenIndex;
      }
      if (typeof to !== "number") {
        to = to.tokenIndex;
      }
      if (from > to || from < 0 || to < 0 || to >= this.tokens.size) {
        throw new RangeError(`replace: range invalid: ${from}..${to}(size=${this.tokens.size})`);
      }
      let rewrites = this.getProgram(programName);
      let op = new ReplaceOp(this.tokens, from, to, rewrites.length, text);
      rewrites.push(op);
    }
    delete(from, to, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
      if (to === void 0) {
        to = from;
      }
      if (typeof from === "number") {
        this.replace(from, to, "", programName);
      } else {
        this.replace(from, to, "", programName);
      }
    }
    getLastRewriteTokenIndex(programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
      let I = this.lastRewriteTokenIndexes.get(programName);
      if (I == null) {
        return -1;
      }
      return I;
    }
    setLastRewriteTokenIndex(programName, i) {
      this.lastRewriteTokenIndexes.set(programName, i);
    }
    getProgram(name) {
      let is = this.programs.get(name);
      if (is == null) {
        is = this.initializeProgram(name);
      }
      return is;
    }
    initializeProgram(name) {
      let is = [];
      this.programs.set(name, is);
      return is;
    }
    getText(intervalOrProgram, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
      let interval;
      if (intervalOrProgram instanceof Interval_1.Interval) {
        interval = intervalOrProgram;
      } else {
        interval = Interval_1.Interval.of(0, this.tokens.size - 1);
      }
      if (typeof intervalOrProgram === "string") {
        programName = intervalOrProgram;
      }
      let rewrites = this.programs.get(programName);
      let start = interval.a;
      let stop = interval.b;
      if (stop > this.tokens.size - 1) {
        stop = this.tokens.size - 1;
      }
      if (start < 0) {
        start = 0;
      }
      if (rewrites == null || rewrites.length === 0) {
        return this.tokens.getText(interval);
      }
      let buf = [];
      let indexToOp = this.reduceToSingleOperationPerIndex(rewrites);
      let i = start;
      while (i <= stop && i < this.tokens.size) {
        let op = indexToOp.get(i);
        indexToOp.delete(i);
        let t = this.tokens.get(i);
        if (op == null) {
          if (t.type !== Token_1.Token.EOF) {
            buf.push(String(t.text));
          }
          i++;
        } else {
          i = op.execute(buf);
        }
      }
      if (stop === this.tokens.size - 1) {
        for (let op of indexToOp.values()) {
          if (op.index >= this.tokens.size - 1) {
            buf.push(op.text.toString());
          }
        }
      }
      return buf.join("");
    }
    reduceToSingleOperationPerIndex(rewrites) {
      for (let i = 0; i < rewrites.length; i++) {
        let op = rewrites[i];
        if (op == null) {
          continue;
        }
        if (!(op instanceof ReplaceOp)) {
          continue;
        }
        let rop = op;
        let inserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);
        for (let iop of inserts) {
          if (iop.index === rop.index) {
            rewrites[iop.instructionIndex] = void 0;
            rop.text = iop.text.toString() + (rop.text != null ? rop.text.toString() : "");
          } else if (iop.index > rop.index && iop.index <= rop.lastIndex) {
            rewrites[iop.instructionIndex] = void 0;
          }
        }
        let prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);
        for (let prevRop of prevReplaces) {
          if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {
            rewrites[prevRop.instructionIndex] = void 0;
            continue;
          }
          let disjoint = prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;
          if (prevRop.text == null && rop.text == null && !disjoint) {
            rewrites[prevRop.instructionIndex] = void 0;
            rop.index = Math.min(prevRop.index, rop.index);
            rop.lastIndex = Math.max(prevRop.lastIndex, rop.lastIndex);
          } else if (!disjoint) {
            throw new Error(`replace op boundaries of ${rop} overlap with previous ${prevRop}`);
          }
        }
      }
      for (let i = 0; i < rewrites.length; i++) {
        let op = rewrites[i];
        if (op == null) {
          continue;
        }
        if (!(op instanceof InsertBeforeOp)) {
          continue;
        }
        let iop = op;
        let prevInserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);
        for (let prevIop of prevInserts) {
          if (prevIop.index === iop.index) {
            if (prevIop instanceof InsertAfterOp) {
              iop.text = this.catOpText(prevIop.text, iop.text);
              rewrites[prevIop.instructionIndex] = void 0;
            } else if (prevIop instanceof InsertBeforeOp) {
              iop.text = this.catOpText(iop.text, prevIop.text);
              rewrites[prevIop.instructionIndex] = void 0;
            }
          }
        }
        let prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);
        for (let rop of prevReplaces) {
          if (iop.index === rop.index) {
            rop.text = this.catOpText(iop.text, rop.text);
            rewrites[i] = void 0;
            continue;
          }
          if (iop.index >= rop.index && iop.index <= rop.lastIndex) {
            throw new Error(`insert op ${iop} within boundaries of previous ${rop}`);
          }
        }
      }
      let m = new Map();
      for (let op of rewrites) {
        if (op == null) {
          continue;
        }
        if (m.get(op.index) != null) {
          throw new Error("should only be one op per index");
        }
        m.set(op.index, op);
      }
      return m;
    }
    catOpText(a, b) {
      let x = "";
      let y = "";
      if (a != null) {
        x = a.toString();
      }
      if (b != null) {
        y = b.toString();
      }
      return x + y;
    }
    getKindOfOps(rewrites, kind, before) {
      let ops = [];
      for (let i = 0; i < before && i < rewrites.length; i++) {
        let op = rewrites[i];
        if (op == null) {
          continue;
        }
        if (op instanceof kind) {
          ops.push(op);
        }
      }
      return ops;
    }
  };
  exports.TokenStreamRewriter = TokenStreamRewriter;
  TokenStreamRewriter.DEFAULT_PROGRAM_NAME = "default";
  TokenStreamRewriter.PROGRAM_INIT_SIZE = 100;
  TokenStreamRewriter.MIN_TOKEN_INDEX = 0;
  var RewriteOperation = class {
    constructor(tokens2, index, instructionIndex, text) {
      this.tokens = tokens2;
      this.instructionIndex = instructionIndex;
      this.index = index;
      this.text = text === void 0 ? "" : text;
    }
    execute(buf) {
      return this.index;
    }
    toString() {
      let opName = this.constructor.name;
      let $index = opName.indexOf("$");
      opName = opName.substring($index + 1, opName.length);
      return "<" + opName + "@" + this.tokens.get(this.index) + ':"' + this.text + '">';
    }
  };
  __decorate([
    Decorators_1.Override
  ], RewriteOperation.prototype, "toString", null);
  exports.RewriteOperation = RewriteOperation;
  var InsertBeforeOp = class extends RewriteOperation {
    constructor(tokens2, index, instructionIndex, text) {
      super(tokens2, index, instructionIndex, text);
    }
    execute(buf) {
      buf.push(this.text.toString());
      if (this.tokens.get(this.index).type !== Token_1.Token.EOF) {
        buf.push(String(this.tokens.get(this.index).text));
      }
      return this.index + 1;
    }
  };
  __decorate([
    Decorators_1.Override
  ], InsertBeforeOp.prototype, "execute", null);
  var InsertAfterOp = class extends InsertBeforeOp {
    constructor(tokens2, index, instructionIndex, text) {
      super(tokens2, index + 1, instructionIndex, text);
    }
  };
  var ReplaceOp = class extends RewriteOperation {
    constructor(tokens2, from, to, instructionIndex, text) {
      super(tokens2, from, instructionIndex, text);
      this.lastIndex = to;
    }
    execute(buf) {
      if (this.text != null) {
        buf.push(this.text.toString());
      }
      return this.lastIndex + 1;
    }
    toString() {
      if (this.text == null) {
        return "<DeleteOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ">";
      }
      return "<ReplaceOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ':"' + this.text + '">';
    }
  };
  __decorate([
    Decorators_1.Override
  ], ReplaceOp.prototype, "execute", null);
  __decorate([
    Decorators_1.Override
  ], ReplaceOp.prototype, "toString", null);
});

// node_modules/antlr4ts/Vocabulary.js
var require_Vocabulary = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
});

// node_modules/antlr4ts/WritableToken.js
var require_WritableToken = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
});

// node_modules/antlr4ts/index.js
var require_antlr4ts = __commonJS((exports) => {
  "use strict";
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  __exportStar(require_ANTLRErrorListener(), exports);
  __exportStar(require_ANTLRErrorStrategy(), exports);
  __exportStar(require_ANTLRInputStream(), exports);
  __exportStar(require_BailErrorStrategy(), exports);
  __exportStar(require_BufferedTokenStream(), exports);
  __exportStar(require_CharStream(), exports);
  __exportStar(require_CharStreams(), exports);
  __exportStar(require_CodePointBuffer(), exports);
  __exportStar(require_CodePointCharStream(), exports);
  __exportStar(require_CommonToken(), exports);
  __exportStar(require_CommonTokenFactory(), exports);
  __exportStar(require_CommonTokenStream(), exports);
  __exportStar(require_ConsoleErrorListener(), exports);
  __exportStar(require_DefaultErrorStrategy(), exports);
  __exportStar(require_Dependents(), exports);
  __exportStar(require_DiagnosticErrorListener(), exports);
  __exportStar(require_FailedPredicateException(), exports);
  __exportStar(require_InputMismatchException(), exports);
  __exportStar(require_InterpreterRuleContext(), exports);
  __exportStar(require_IntStream(), exports);
  __exportStar(require_Lexer(), exports);
  __exportStar(require_LexerInterpreter(), exports);
  __exportStar(require_LexerNoViableAltException(), exports);
  __exportStar(require_ListTokenSource(), exports);
  __exportStar(require_NoViableAltException(), exports);
  __exportStar(require_Parser(), exports);
  __exportStar(require_ParserErrorListener(), exports);
  __exportStar(require_ParserInterpreter(), exports);
  __exportStar(require_ParserRuleContext(), exports);
  __exportStar(require_ProxyErrorListener(), exports);
  __exportStar(require_ProxyParserErrorListener(), exports);
  __exportStar(require_RecognitionException(), exports);
  __exportStar(require_Recognizer(), exports);
  __exportStar(require_RuleContext(), exports);
  __exportStar(require_RuleContextWithAltNum(), exports);
  __exportStar(require_RuleDependency(), exports);
  __exportStar(require_RuleVersion(), exports);
  __exportStar(require_Token(), exports);
  __exportStar(require_TokenFactory(), exports);
  __exportStar(require_TokenSource(), exports);
  __exportStar(require_TokenStream(), exports);
  __exportStar(require_TokenStreamRewriter(), exports);
  __exportStar(require_Vocabulary(), exports);
  __exportStar(require_VocabularyImpl(), exports);
  __exportStar(require_WritableToken(), exports);
});

// node_modules/antlr4ts/tree/AbstractParseTreeVisitor.js
var require_AbstractParseTreeVisitor = __commonJS((exports) => {
  "use strict";
  var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if (d = decorators[i])
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __param = exports && exports.__param || function(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.AbstractParseTreeVisitor = void 0;
  var Decorators_1 = require_Decorators();
  var AbstractParseTreeVisitor2 = class {
    visit(tree) {
      return tree.accept(this);
    }
    visitChildren(node) {
      let result = this.defaultResult();
      let n = node.childCount;
      for (let i = 0; i < n; i++) {
        if (!this.shouldVisitNextChild(node, result)) {
          break;
        }
        let c = node.getChild(i);
        let childResult = c.accept(this);
        result = this.aggregateResult(result, childResult);
      }
      return result;
    }
    visitTerminal(node) {
      return this.defaultResult();
    }
    visitErrorNode(node) {
      return this.defaultResult();
    }
    aggregateResult(aggregate, nextResult) {
      return nextResult;
    }
    shouldVisitNextChild(node, currentResult) {
      return true;
    }
  };
  __decorate([
    Decorators_1.Override,
    __param(0, Decorators_1.NotNull)
  ], AbstractParseTreeVisitor2.prototype, "visit", null);
  __decorate([
    Decorators_1.Override,
    __param(0, Decorators_1.NotNull)
  ], AbstractParseTreeVisitor2.prototype, "visitChildren", null);
  __decorate([
    Decorators_1.Override,
    __param(0, Decorators_1.NotNull)
  ], AbstractParseTreeVisitor2.prototype, "visitTerminal", null);
  __decorate([
    Decorators_1.Override,
    __param(0, Decorators_1.NotNull)
  ], AbstractParseTreeVisitor2.prototype, "visitErrorNode", null);
  __decorate([
    __param(0, Decorators_1.NotNull)
  ], AbstractParseTreeVisitor2.prototype, "shouldVisitNextChild", null);
  exports.AbstractParseTreeVisitor = AbstractParseTreeVisitor2;
});

// node_modules/antlr4/src/antlr4/Utils.js
var require_Utils2 = __commonJS((exports, module2) => {
  function arrayToString(a) {
    return Array.isArray(a) ? "[" + a.join(", ") + "]" : "null";
  }
  String.prototype.seed = String.prototype.seed || Math.round(Math.random() * Math.pow(2, 32));
  String.prototype.hashCode = function() {
    const key = this.toString();
    let h1b, k1;
    const remainder = key.length & 3;
    const bytes = key.length - remainder;
    let h1 = String.prototype.seed;
    const c1 = 3432918353;
    const c2 = 461845907;
    let i = 0;
    while (i < bytes) {
      k1 = key.charCodeAt(i) & 255 | (key.charCodeAt(++i) & 255) << 8 | (key.charCodeAt(++i) & 255) << 16 | (key.charCodeAt(++i) & 255) << 24;
      ++i;
      k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;
      k1 = k1 << 15 | k1 >>> 17;
      k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;
      h1 ^= k1;
      h1 = h1 << 13 | h1 >>> 19;
      h1b = (h1 & 65535) * 5 + (((h1 >>> 16) * 5 & 65535) << 16) & 4294967295;
      h1 = (h1b & 65535) + 27492 + (((h1b >>> 16) + 58964 & 65535) << 16);
    }
    k1 = 0;
    switch (remainder) {
      case 3:
        k1 ^= (key.charCodeAt(i + 2) & 255) << 16;
      case 2:
        k1 ^= (key.charCodeAt(i + 1) & 255) << 8;
      case 1:
        k1 ^= key.charCodeAt(i) & 255;
        k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;
        h1 ^= k1;
    }
    h1 ^= key.length;
    h1 ^= h1 >>> 16;
    h1 = (h1 & 65535) * 2246822507 + (((h1 >>> 16) * 2246822507 & 65535) << 16) & 4294967295;
    h1 ^= h1 >>> 13;
    h1 = (h1 & 65535) * 3266489909 + (((h1 >>> 16) * 3266489909 & 65535) << 16) & 4294967295;
    h1 ^= h1 >>> 16;
    return h1 >>> 0;
  };
  function standardEqualsFunction(a, b) {
    return a ? a.equals(b) : a == b;
  }
  function standardHashCodeFunction(a) {
    return a ? a.hashCode() : -1;
  }
  var Set2 = class {
    constructor(hashFunction, equalsFunction) {
      this.data = {};
      this.hashFunction = hashFunction || standardHashCodeFunction;
      this.equalsFunction = equalsFunction || standardEqualsFunction;
    }
    add(value) {
      const hash = this.hashFunction(value);
      const key = "hash_" + hash;
      if (key in this.data) {
        const values = this.data[key];
        for (let i = 0; i < values.length; i++) {
          if (this.equalsFunction(value, values[i])) {
            return values[i];
          }
        }
        values.push(value);
        return value;
      } else {
        this.data[key] = [value];
        return value;
      }
    }
    contains(value) {
      return this.get(value) != null;
    }
    get(value) {
      const hash = this.hashFunction(value);
      const key = "hash_" + hash;
      if (key in this.data) {
        const values = this.data[key];
        for (let i = 0; i < values.length; i++) {
          if (this.equalsFunction(value, values[i])) {
            return values[i];
          }
        }
      }
      return null;
    }
    values() {
      let l = [];
      for (const key in this.data) {
        if (key.indexOf("hash_") === 0) {
          l = l.concat(this.data[key]);
        }
      }
      return l;
    }
    toString() {
      return arrayToString(this.values());
    }
    get length() {
      let l = 0;
      for (const key in this.data) {
        if (key.indexOf("hash_") === 0) {
          l = l + this.data[key].length;
        }
      }
      return l;
    }
  };
  var BitSet = class {
    constructor() {
      this.data = [];
    }
    add(value) {
      this.data[value] = true;
    }
    or(set) {
      const bits = this;
      Object.keys(set.data).map(function(alt) {
        bits.add(alt);
      });
    }
    remove(value) {
      delete this.data[value];
    }
    contains(value) {
      return this.data[value] === true;
    }
    values() {
      return Object.keys(this.data);
    }
    minValue() {
      return Math.min.apply(null, this.values());
    }
    hashCode() {
      const hash = new Hash2();
      hash.update(this.values());
      return hash.finish();
    }
    equals(other) {
      if (!(other instanceof BitSet)) {
        return false;
      }
      return this.hashCode() === other.hashCode();
    }
    toString() {
      return "{" + this.values().join(", ") + "}";
    }
    get length() {
      return this.values().length;
    }
  };
  var Map2 = class {
    constructor(hashFunction, equalsFunction) {
      this.data = {};
      this.hashFunction = hashFunction || standardHashCodeFunction;
      this.equalsFunction = equalsFunction || standardEqualsFunction;
    }
    put(key, value) {
      const hashKey = "hash_" + this.hashFunction(key);
      if (hashKey in this.data) {
        const entries = this.data[hashKey];
        for (let i = 0; i < entries.length; i++) {
          const entry = entries[i];
          if (this.equalsFunction(key, entry.key)) {
            const oldValue = entry.value;
            entry.value = value;
            return oldValue;
          }
        }
        entries.push({key, value});
        return value;
      } else {
        this.data[hashKey] = [{key, value}];
        return value;
      }
    }
    containsKey(key) {
      const hashKey = "hash_" + this.hashFunction(key);
      if (hashKey in this.data) {
        const entries = this.data[hashKey];
        for (let i = 0; i < entries.length; i++) {
          const entry = entries[i];
          if (this.equalsFunction(key, entry.key))
            return true;
        }
      }
      return false;
    }
    get(key) {
      const hashKey = "hash_" + this.hashFunction(key);
      if (hashKey in this.data) {
        const entries = this.data[hashKey];
        for (let i = 0; i < entries.length; i++) {
          const entry = entries[i];
          if (this.equalsFunction(key, entry.key))
            return entry.value;
        }
      }
      return null;
    }
    entries() {
      let l = [];
      for (const key in this.data) {
        if (key.indexOf("hash_") === 0) {
          l = l.concat(this.data[key]);
        }
      }
      return l;
    }
    getKeys() {
      return this.entries().map(function(e) {
        return e.key;
      });
    }
    getValues() {
      return this.entries().map(function(e) {
        return e.value;
      });
    }
    toString() {
      const ss = this.entries().map(function(entry) {
        return "{" + entry.key + ":" + entry.value + "}";
      });
      return "[" + ss.join(", ") + "]";
    }
    get length() {
      let l = 0;
      for (const hashKey in this.data) {
        if (hashKey.indexOf("hash_") === 0) {
          l = l + this.data[hashKey].length;
        }
      }
      return l;
    }
  };
  var AltDict = class {
    constructor() {
      this.data = {};
    }
    get(key) {
      key = "k-" + key;
      if (key in this.data) {
        return this.data[key];
      } else {
        return null;
      }
    }
    put(key, value) {
      key = "k-" + key;
      this.data[key] = value;
    }
    values() {
      const data = this.data;
      const keys = Object.keys(this.data);
      return keys.map(function(key) {
        return data[key];
      });
    }
  };
  var DoubleDict = class {
    constructor(defaultMapCtor) {
      this.defaultMapCtor = defaultMapCtor || Map2;
      this.cacheMap = new this.defaultMapCtor();
    }
    get(a, b) {
      const d = this.cacheMap.get(a) || null;
      return d === null ? null : d.get(b) || null;
    }
    set(a, b, o) {
      let d = this.cacheMap.get(a) || null;
      if (d === null) {
        d = new this.defaultMapCtor();
        this.cacheMap.put(a, d);
      }
      d.put(b, o);
    }
  };
  var Hash2 = class {
    constructor() {
      this.count = 0;
      this.hash = 0;
    }
    update() {
      for (let i = 0; i < arguments.length; i++) {
        const value = arguments[i];
        if (value == null)
          continue;
        if (Array.isArray(value))
          this.update.apply(this, value);
        else {
          let k = 0;
          switch (typeof value) {
            case "undefined":
            case "function":
              continue;
            case "number":
            case "boolean":
              k = value;
              break;
            case "string":
              k = value.hashCode();
              break;
            default:
              if (value.updateHashCode)
                value.updateHashCode(this);
              else
                console.log("No updateHashCode for " + value.toString());
              continue;
          }
          k = k * 3432918353;
          k = k << 15 | k >>> 32 - 15;
          k = k * 461845907;
          this.count = this.count + 1;
          let hash = this.hash ^ k;
          hash = hash << 13 | hash >>> 32 - 13;
          hash = hash * 5 + 3864292196;
          this.hash = hash;
        }
      }
    }
    finish() {
      let hash = this.hash ^ this.count * 4;
      hash = hash ^ hash >>> 16;
      hash = hash * 2246822507;
      hash = hash ^ hash >>> 13;
      hash = hash * 3266489909;
      hash = hash ^ hash >>> 16;
      return hash;
    }
  };
  function hashStuff() {
    const hash = new Hash2();
    hash.update.apply(hash, arguments);
    return hash.finish();
  }
  function escapeWhitespace(s, escapeSpaces) {
    s = s.replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r");
    if (escapeSpaces) {
      s = s.replace(/ /g, "\xB7");
    }
    return s;
  }
  function titleCase(str) {
    return str.replace(/\w\S*/g, function(txt) {
      return txt.charAt(0).toUpperCase() + txt.substr(1);
    });
  }
  function equalArrays(a, b) {
    if (!Array.isArray(a) || !Array.isArray(b))
      return false;
    if (a === b)
      return true;
    if (a.length !== b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      if (a[i] === b[i])
        continue;
      if (!a[i].equals || !a[i].equals(b[i]))
        return false;
    }
    return true;
  }
  module2.exports = {
    Hash: Hash2,
    Set: Set2,
    Map: Map2,
    BitSet,
    AltDict,
    DoubleDict,
    hashStuff,
    escapeWhitespace,
    arrayToString,
    titleCase,
    equalArrays
  };
});

// node_modules/antlr4/src/antlr4/Token.js
var require_Token2 = __commonJS((exports, module2) => {
  var Token2 = class {
    constructor() {
      this.source = null;
      this.type = null;
      this.channel = null;
      this.start = null;
      this.stop = null;
      this.tokenIndex = null;
      this.line = null;
      this.column = null;
      this._text = null;
    }
    getTokenSource() {
      return this.source[0];
    }
    getInputStream() {
      return this.source[1];
    }
    get text() {
      return this._text;
    }
    set text(text) {
      this._text = text;
    }
  };
  Token2.INVALID_TYPE = 0;
  Token2.EPSILON = -2;
  Token2.MIN_USER_TOKEN_TYPE = 1;
  Token2.EOF = -1;
  Token2.DEFAULT_CHANNEL = 0;
  Token2.HIDDEN_CHANNEL = 1;
  var CommonToken = class extends Token2 {
    constructor(source, type, channel, start, stop) {
      super();
      this.source = source !== void 0 ? source : CommonToken.EMPTY_SOURCE;
      this.type = type !== void 0 ? type : null;
      this.channel = channel !== void 0 ? channel : Token2.DEFAULT_CHANNEL;
      this.start = start !== void 0 ? start : -1;
      this.stop = stop !== void 0 ? stop : -1;
      this.tokenIndex = -1;
      if (this.source[0] !== null) {
        this.line = source[0].line;
        this.column = source[0].column;
      } else {
        this.column = -1;
      }
    }
    clone() {
      const t = new CommonToken(this.source, this.type, this.channel, this.start, this.stop);
      t.tokenIndex = this.tokenIndex;
      t.line = this.line;
      t.column = this.column;
      t.text = this.text;
      return t;
    }
    toString() {
      let txt = this.text;
      if (txt !== null) {
        txt = txt.replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
      } else {
        txt = "<no text>";
      }
      return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + txt + "',<" + this.type + ">" + (this.channel > 0 ? ",channel=" + this.channel : "") + "," + this.line + ":" + this.column + "]";
    }
    get text() {
      if (this._text !== null) {
        return this._text;
      }
      const input = this.getInputStream();
      if (input === null) {
        return null;
      }
      const n = input.size;
      if (this.start < n && this.stop < n) {
        return input.getText(this.start, this.stop);
      } else {
        return "<EOF>";
      }
    }
    set text(text) {
      this._text = text;
    }
  };
  CommonToken.EMPTY_SOURCE = [null, null];
  module2.exports = {
    Token: Token2,
    CommonToken
  };
});

// node_modules/antlr4/src/antlr4/atn/ATNState.js
var require_ATNState2 = __commonJS((exports, module2) => {
  var ATNState = class {
    constructor() {
      this.atn = null;
      this.stateNumber = ATNState.INVALID_STATE_NUMBER;
      this.stateType = null;
      this.ruleIndex = 0;
      this.epsilonOnlyTransitions = false;
      this.transitions = [];
      this.nextTokenWithinRule = null;
    }
    toString() {
      return this.stateNumber;
    }
    equals(other) {
      if (other instanceof ATNState) {
        return this.stateNumber === other.stateNumber;
      } else {
        return false;
      }
    }
    isNonGreedyExitState() {
      return false;
    }
    addTransition(trans, index) {
      if (index === void 0) {
        index = -1;
      }
      if (this.transitions.length === 0) {
        this.epsilonOnlyTransitions = trans.isEpsilon;
      } else if (this.epsilonOnlyTransitions !== trans.isEpsilon) {
        this.epsilonOnlyTransitions = false;
      }
      if (index === -1) {
        this.transitions.push(trans);
      } else {
        this.transitions.splice(index, 1, trans);
      }
    }
  };
  ATNState.INVALID_TYPE = 0;
  ATNState.BASIC = 1;
  ATNState.RULE_START = 2;
  ATNState.BLOCK_START = 3;
  ATNState.PLUS_BLOCK_START = 4;
  ATNState.STAR_BLOCK_START = 5;
  ATNState.TOKEN_START = 6;
  ATNState.RULE_STOP = 7;
  ATNState.BLOCK_END = 8;
  ATNState.STAR_LOOP_BACK = 9;
  ATNState.STAR_LOOP_ENTRY = 10;
  ATNState.PLUS_LOOP_BACK = 11;
  ATNState.LOOP_END = 12;
  ATNState.serializationNames = [
    "INVALID",
    "BASIC",
    "RULE_START",
    "BLOCK_START",
    "PLUS_BLOCK_START",
    "STAR_BLOCK_START",
    "TOKEN_START",
    "RULE_STOP",
    "BLOCK_END",
    "STAR_LOOP_BACK",
    "STAR_LOOP_ENTRY",
    "PLUS_LOOP_BACK",
    "LOOP_END"
  ];
  ATNState.INVALID_STATE_NUMBER = -1;
  var BasicState = class extends ATNState {
    constructor() {
      super();
      this.stateType = ATNState.BASIC;
    }
  };
  var DecisionState = class extends ATNState {
    constructor() {
      super();
      this.decision = -1;
      this.nonGreedy = false;
      return this;
    }
  };
  var BlockStartState = class extends DecisionState {
    constructor() {
      super();
      this.endState = null;
      return this;
    }
  };
  var BasicBlockStartState = class extends BlockStartState {
    constructor() {
      super();
      this.stateType = ATNState.BLOCK_START;
      return this;
    }
  };
  var BlockEndState = class extends ATNState {
    constructor() {
      super();
      this.stateType = ATNState.BLOCK_END;
      this.startState = null;
      return this;
    }
  };
  var RuleStopState = class extends ATNState {
    constructor() {
      super();
      this.stateType = ATNState.RULE_STOP;
      return this;
    }
  };
  var RuleStartState = class extends ATNState {
    constructor() {
      super();
      this.stateType = ATNState.RULE_START;
      this.stopState = null;
      this.isPrecedenceRule = false;
      return this;
    }
  };
  var PlusLoopbackState = class extends DecisionState {
    constructor() {
      super();
      this.stateType = ATNState.PLUS_LOOP_BACK;
      return this;
    }
  };
  var PlusBlockStartState = class extends BlockStartState {
    constructor() {
      super();
      this.stateType = ATNState.PLUS_BLOCK_START;
      this.loopBackState = null;
      return this;
    }
  };
  var StarBlockStartState = class extends BlockStartState {
    constructor() {
      super();
      this.stateType = ATNState.STAR_BLOCK_START;
      return this;
    }
  };
  var StarLoopbackState = class extends ATNState {
    constructor() {
      super();
      this.stateType = ATNState.STAR_LOOP_BACK;
      return this;
    }
  };
  var StarLoopEntryState = class extends DecisionState {
    constructor() {
      super();
      this.stateType = ATNState.STAR_LOOP_ENTRY;
      this.loopBackState = null;
      this.isPrecedenceDecision = null;
      return this;
    }
  };
  var LoopEndState = class extends ATNState {
    constructor() {
      super();
      this.stateType = ATNState.LOOP_END;
      this.loopBackState = null;
      return this;
    }
  };
  var TokensStartState = class extends DecisionState {
    constructor() {
      super();
      this.stateType = ATNState.TOKEN_START;
      return this;
    }
  };
  module2.exports = {
    ATNState,
    BasicState,
    DecisionState,
    BlockStartState,
    BlockEndState,
    LoopEndState,
    RuleStartState,
    RuleStopState,
    TokensStartState,
    PlusLoopbackState,
    StarLoopbackState,
    StarLoopEntryState,
    PlusBlockStartState,
    StarBlockStartState,
    BasicBlockStartState
  };
});

// node_modules/antlr4/src/antlr4/atn/SemanticContext.js
var require_SemanticContext2 = __commonJS((exports, module2) => {
  var {Set: Set2, Hash: Hash2, equalArrays} = require_Utils2();
  var SemanticContext = class {
    hashCode() {
      const hash = new Hash2();
      this.updateHashCode(hash);
      return hash.finish();
    }
    evaluate(parser, outerContext) {
    }
    evalPrecedence(parser, outerContext) {
      return this;
    }
    static andContext(a, b) {
      if (a === null || a === SemanticContext.NONE) {
        return b;
      }
      if (b === null || b === SemanticContext.NONE) {
        return a;
      }
      const result = new AND(a, b);
      if (result.opnds.length === 1) {
        return result.opnds[0];
      } else {
        return result;
      }
    }
    static orContext(a, b) {
      if (a === null) {
        return b;
      }
      if (b === null) {
        return a;
      }
      if (a === SemanticContext.NONE || b === SemanticContext.NONE) {
        return SemanticContext.NONE;
      }
      const result = new OR(a, b);
      if (result.opnds.length === 1) {
        return result.opnds[0];
      } else {
        return result;
      }
    }
  };
  var Predicate = class extends SemanticContext {
    constructor(ruleIndex, predIndex, isCtxDependent) {
      super();
      this.ruleIndex = ruleIndex === void 0 ? -1 : ruleIndex;
      this.predIndex = predIndex === void 0 ? -1 : predIndex;
      this.isCtxDependent = isCtxDependent === void 0 ? false : isCtxDependent;
    }
    evaluate(parser, outerContext) {
      const localctx = this.isCtxDependent ? outerContext : null;
      return parser.sempred(localctx, this.ruleIndex, this.predIndex);
    }
    updateHashCode(hash) {
      hash.update(this.ruleIndex, this.predIndex, this.isCtxDependent);
    }
    equals(other) {
      if (this === other) {
        return true;
      } else if (!(other instanceof Predicate)) {
        return false;
      } else {
        return this.ruleIndex === other.ruleIndex && this.predIndex === other.predIndex && this.isCtxDependent === other.isCtxDependent;
      }
    }
    toString() {
      return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
    }
  };
  SemanticContext.NONE = new Predicate();
  var PrecedencePredicate = class extends SemanticContext {
    constructor(precedence) {
      super();
      this.precedence = precedence === void 0 ? 0 : precedence;
    }
    evaluate(parser, outerContext) {
      return parser.precpred(outerContext, this.precedence);
    }
    evalPrecedence(parser, outerContext) {
      if (parser.precpred(outerContext, this.precedence)) {
        return SemanticContext.NONE;
      } else {
        return null;
      }
    }
    compareTo(other) {
      return this.precedence - other.precedence;
    }
    updateHashCode(hash) {
      hash.update(this.precedence);
    }
    equals(other) {
      if (this === other) {
        return true;
      } else if (!(other instanceof PrecedencePredicate)) {
        return false;
      } else {
        return this.precedence === other.precedence;
      }
    }
    toString() {
      return "{" + this.precedence + ">=prec}?";
    }
    static filterPrecedencePredicates(set) {
      const result = [];
      set.values().map(function(context) {
        if (context instanceof PrecedencePredicate) {
          result.push(context);
        }
      });
      return result;
    }
  };
  var AND = class extends SemanticContext {
    constructor(a, b) {
      super();
      const operands = new Set2();
      if (a instanceof AND) {
        a.opnds.map(function(o) {
          operands.add(o);
        });
      } else {
        operands.add(a);
      }
      if (b instanceof AND) {
        b.opnds.map(function(o) {
          operands.add(o);
        });
      } else {
        operands.add(b);
      }
      const precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);
      if (precedencePredicates.length > 0) {
        let reduced = null;
        precedencePredicates.map(function(p) {
          if (reduced === null || p.precedence < reduced.precedence) {
            reduced = p;
          }
        });
        operands.add(reduced);
      }
      this.opnds = Array.from(operands.values());
    }
    equals(other) {
      if (this === other) {
        return true;
      } else if (!(other instanceof AND)) {
        return false;
      } else {
        return equalArrays(this.opnds, other.opnds);
      }
    }
    updateHashCode(hash) {
      hash.update(this.opnds, "AND");
    }
    evaluate(parser, outerContext) {
      for (let i = 0; i < this.opnds.length; i++) {
        if (!this.opnds[i].evaluate(parser, outerContext)) {
          return false;
        }
      }
      return true;
    }
    evalPrecedence(parser, outerContext) {
      let differs = false;
      const operands = [];
      for (let i = 0; i < this.opnds.length; i++) {
        const context = this.opnds[i];
        const evaluated = context.evalPrecedence(parser, outerContext);
        differs |= evaluated !== context;
        if (evaluated === null) {
          return null;
        } else if (evaluated !== SemanticContext.NONE) {
          operands.push(evaluated);
        }
      }
      if (!differs) {
        return this;
      }
      if (operands.length === 0) {
        return SemanticContext.NONE;
      }
      let result = null;
      operands.map(function(o) {
        result = result === null ? o : SemanticContext.andContext(result, o);
      });
      return result;
    }
    toString() {
      const s = this.opnds.map((o) => o.toString());
      return (s.length > 3 ? s.slice(3) : s).join("&&");
    }
  };
  var OR = class extends SemanticContext {
    constructor(a, b) {
      super();
      const operands = new Set2();
      if (a instanceof OR) {
        a.opnds.map(function(o) {
          operands.add(o);
        });
      } else {
        operands.add(a);
      }
      if (b instanceof OR) {
        b.opnds.map(function(o) {
          operands.add(o);
        });
      } else {
        operands.add(b);
      }
      const precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);
      if (precedencePredicates.length > 0) {
        const s = precedencePredicates.sort(function(a2, b2) {
          return a2.compareTo(b2);
        });
        const reduced = s[s.length - 1];
        operands.add(reduced);
      }
      this.opnds = Array.from(operands.values());
    }
    equals(other) {
      if (this === other) {
        return true;
      } else if (!(other instanceof OR)) {
        return false;
      } else {
        return equalArrays(this.opnds, other.opnds);
      }
    }
    updateHashCode(hash) {
      hash.update(this.opnds, "OR");
    }
    evaluate(parser, outerContext) {
      for (let i = 0; i < this.opnds.length; i++) {
        if (this.opnds[i].evaluate(parser, outerContext)) {
          return true;
        }
      }
      return false;
    }
    evalPrecedence(parser, outerContext) {
      let differs = false;
      const operands = [];
      for (let i = 0; i < this.opnds.length; i++) {
        const context = this.opnds[i];
        const evaluated = context.evalPrecedence(parser, outerContext);
        differs |= evaluated !== context;
        if (evaluated === SemanticContext.NONE) {
          return SemanticContext.NONE;
        } else if (evaluated !== null) {
          operands.push(evaluated);
        }
      }
      if (!differs) {
        return this;
      }
      if (operands.length === 0) {
        return null;
      }
      const result = null;
      operands.map(function(o) {
        return result === null ? o : SemanticContext.orContext(result, o);
      });
      return result;
    }
    toString() {
      const s = this.opnds.map((o) => o.toString());
      return (s.length > 3 ? s.slice(3) : s).join("||");
    }
  };
  module2.exports = {
    SemanticContext,
    PrecedencePredicate,
    Predicate
  };
});

// node_modules/antlr4/src/antlr4/atn/ATNConfig.js
var require_ATNConfig2 = __commonJS((exports, module2) => {
  var {DecisionState} = require_ATNState2();
  var {SemanticContext} = require_SemanticContext2();
  var {Hash: Hash2} = require_Utils2();
  function checkParams(params, isCfg) {
    if (params === null) {
      const result = {state: null, alt: null, context: null, semanticContext: null};
      if (isCfg) {
        result.reachesIntoOuterContext = 0;
      }
      return result;
    } else {
      const props = {};
      props.state = params.state || null;
      props.alt = params.alt === void 0 ? null : params.alt;
      props.context = params.context || null;
      props.semanticContext = params.semanticContext || null;
      if (isCfg) {
        props.reachesIntoOuterContext = params.reachesIntoOuterContext || 0;
        props.precedenceFilterSuppressed = params.precedenceFilterSuppressed || false;
      }
      return props;
    }
  }
  var ATNConfig = class {
    constructor(params, config) {
      this.checkContext(params, config);
      params = checkParams(params);
      config = checkParams(config, true);
      this.state = params.state !== null ? params.state : config.state;
      this.alt = params.alt !== null ? params.alt : config.alt;
      this.context = params.context !== null ? params.context : config.context;
      this.semanticContext = params.semanticContext !== null ? params.semanticContext : config.semanticContext !== null ? config.semanticContext : SemanticContext.NONE;
      this.reachesIntoOuterContext = config.reachesIntoOuterContext;
      this.precedenceFilterSuppressed = config.precedenceFilterSuppressed;
    }
    checkContext(params, config) {
      if ((params.context === null || params.context === void 0) && (config === null || config.context === null || config.context === void 0)) {
        this.context = null;
      }
    }
    hashCode() {
      const hash = new Hash2();
      this.updateHashCode(hash);
      return hash.finish();
    }
    updateHashCode(hash) {
      hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);
    }
    equals(other) {
      if (this === other) {
        return true;
      } else if (!(other instanceof ATNConfig)) {
        return false;
      } else {
        return this.state.stateNumber === other.state.stateNumber && this.alt === other.alt && (this.context === null ? other.context === null : this.context.equals(other.context)) && this.semanticContext.equals(other.semanticContext) && this.precedenceFilterSuppressed === other.precedenceFilterSuppressed;
      }
    }
    hashCodeForConfigSet() {
      const hash = new Hash2();
      hash.update(this.state.stateNumber, this.alt, this.semanticContext);
      return hash.finish();
    }
    equalsForConfigSet(other) {
      if (this === other) {
        return true;
      } else if (!(other instanceof ATNConfig)) {
        return false;
      } else {
        return this.state.stateNumber === other.state.stateNumber && this.alt === other.alt && this.semanticContext.equals(other.semanticContext);
      }
    }
    toString() {
      return "(" + this.state + "," + this.alt + (this.context !== null ? ",[" + this.context.toString() + "]" : "") + (this.semanticContext !== SemanticContext.NONE ? "," + this.semanticContext.toString() : "") + (this.reachesIntoOuterContext > 0 ? ",up=" + this.reachesIntoOuterContext : "") + ")";
    }
  };
  var LexerATNConfig = class extends ATNConfig {
    constructor(params, config) {
      super(params, config);
      const lexerActionExecutor = params.lexerActionExecutor || null;
      this.lexerActionExecutor = lexerActionExecutor || (config !== null ? config.lexerActionExecutor : null);
      this.passedThroughNonGreedyDecision = config !== null ? this.checkNonGreedyDecision(config, this.state) : false;
      this.hashCodeForConfigSet = LexerATNConfig.prototype.hashCode;
      this.equalsForConfigSet = LexerATNConfig.prototype.equals;
      return this;
    }
    updateHashCode(hash) {
      hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);
    }
    equals(other) {
      return this === other || other instanceof LexerATNConfig && this.passedThroughNonGreedyDecision === other.passedThroughNonGreedyDecision && (this.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) && super.equals(other);
    }
    checkNonGreedyDecision(source, target) {
      return source.passedThroughNonGreedyDecision || target instanceof DecisionState && target.nonGreedy;
    }
  };
  module2.exports.ATNConfig = ATNConfig;
  module2.exports.LexerATNConfig = LexerATNConfig;
});

// node_modules/antlr4/src/antlr4/IntervalSet.js
var require_IntervalSet2 = __commonJS((exports, module2) => {
  var {Token: Token2} = require_Token2();
  var Interval = class {
    constructor(start, stop) {
      this.start = start;
      this.stop = stop;
    }
    contains(item) {
      return item >= this.start && item < this.stop;
    }
    toString() {
      if (this.start === this.stop - 1) {
        return this.start.toString();
      } else {
        return this.start.toString() + ".." + (this.stop - 1).toString();
      }
    }
    get length() {
      return this.stop - this.start;
    }
  };
  var IntervalSet = class {
    constructor() {
      this.intervals = null;
      this.readOnly = false;
    }
    first(v) {
      if (this.intervals === null || this.intervals.length === 0) {
        return Token2.INVALID_TYPE;
      } else {
        return this.intervals[0].start;
      }
    }
    addOne(v) {
      this.addInterval(new Interval(v, v + 1));
    }
    addRange(l, h) {
      this.addInterval(new Interval(l, h + 1));
    }
    addInterval(toAdd) {
      if (this.intervals === null) {
        this.intervals = [];
        this.intervals.push(toAdd);
      } else {
        for (let pos = 0; pos < this.intervals.length; pos++) {
          const existing = this.intervals[pos];
          if (toAdd.stop < existing.start) {
            this.intervals.splice(pos, 0, toAdd);
            return;
          } else if (toAdd.stop === existing.start) {
            this.intervals[pos].start = toAdd.start;
            return;
          } else if (toAdd.start <= existing.stop) {
            this.intervals[pos] = new Interval(Math.min(existing.start, toAdd.start), Math.max(existing.stop, toAdd.stop));
            this.reduce(pos);
            return;
          }
        }
        this.intervals.push(toAdd);
      }
    }
    addSet(other) {
      if (other.intervals !== null) {
        other.intervals.forEach((toAdd) => this.addInterval(toAdd), this);
      }
      return this;
    }
    reduce(pos) {
      if (pos < this.intervals.length - 1) {
        const current = this.intervals[pos];
        const next = this.intervals[pos + 1];
        if (current.stop >= next.stop) {
          this.intervals.splice(pos + 1, 1);
          this.reduce(pos);
        } else if (current.stop >= next.start) {
          this.intervals[pos] = new Interval(current.start, next.stop);
          this.intervals.splice(pos + 1, 1);
        }
      }
    }
    complement(start, stop) {
      const result = new IntervalSet();
      result.addInterval(new Interval(start, stop + 1));
      if (this.intervals !== null)
        this.intervals.forEach((toRemove) => result.removeRange(toRemove));
      return result;
    }
    contains(item) {
      if (this.intervals === null) {
        return false;
      } else {
        for (let k = 0; k < this.intervals.length; k++) {
          if (this.intervals[k].contains(item)) {
            return true;
          }
        }
        return false;
      }
    }
    removeRange(toRemove) {
      if (toRemove.start === toRemove.stop - 1) {
        this.removeOne(toRemove.start);
      } else if (this.intervals !== null) {
        let pos = 0;
        for (let n = 0; n < this.intervals.length; n++) {
          const existing = this.intervals[pos];
          if (toRemove.stop <= existing.start) {
            return;
          } else if (toRemove.start > existing.start && toRemove.stop < existing.stop) {
            this.intervals[pos] = new Interval(existing.start, toRemove.start);
            const x = new Interval(toRemove.stop, existing.stop);
            this.intervals.splice(pos, 0, x);
            return;
          } else if (toRemove.start <= existing.start && toRemove.stop >= existing.stop) {
            this.intervals.splice(pos, 1);
            pos = pos - 1;
          } else if (toRemove.start < existing.stop) {
            this.intervals[pos] = new Interval(existing.start, toRemove.start);
          } else if (toRemove.stop < existing.stop) {
            this.intervals[pos] = new Interval(toRemove.stop, existing.stop);
          }
          pos += 1;
        }
      }
    }
    removeOne(value) {
      if (this.intervals !== null) {
        for (let i = 0; i < this.intervals.length; i++) {
          const existing = this.intervals[i];
          if (value < existing.start) {
            return;
          } else if (value === existing.start && value === existing.stop - 1) {
            this.intervals.splice(i, 1);
            return;
          } else if (value === existing.start) {
            this.intervals[i] = new Interval(existing.start + 1, existing.stop);
            return;
          } else if (value === existing.stop - 1) {
            this.intervals[i] = new Interval(existing.start, existing.stop - 1);
            return;
          } else if (value < existing.stop - 1) {
            const replace = new Interval(existing.start, value);
            existing.start = value + 1;
            this.intervals.splice(i, 0, replace);
            return;
          }
        }
      }
    }
    toString(literalNames, symbolicNames, elemsAreChar) {
      literalNames = literalNames || null;
      symbolicNames = symbolicNames || null;
      elemsAreChar = elemsAreChar || false;
      if (this.intervals === null) {
        return "{}";
      } else if (literalNames !== null || symbolicNames !== null) {
        return this.toTokenString(literalNames, symbolicNames);
      } else if (elemsAreChar) {
        return this.toCharString();
      } else {
        return this.toIndexString();
      }
    }
    toCharString() {
      const names = [];
      for (let i = 0; i < this.intervals.length; i++) {
        const existing = this.intervals[i];
        if (existing.stop === existing.start + 1) {
          if (existing.start === Token2.EOF) {
            names.push("<EOF>");
          } else {
            names.push("'" + String.fromCharCode(existing.start) + "'");
          }
        } else {
          names.push("'" + String.fromCharCode(existing.start) + "'..'" + String.fromCharCode(existing.stop - 1) + "'");
        }
      }
      if (names.length > 1) {
        return "{" + names.join(", ") + "}";
      } else {
        return names[0];
      }
    }
    toIndexString() {
      const names = [];
      for (let i = 0; i < this.intervals.length; i++) {
        const existing = this.intervals[i];
        if (existing.stop === existing.start + 1) {
          if (existing.start === Token2.EOF) {
            names.push("<EOF>");
          } else {
            names.push(existing.start.toString());
          }
        } else {
          names.push(existing.start.toString() + ".." + (existing.stop - 1).toString());
        }
      }
      if (names.length > 1) {
        return "{" + names.join(", ") + "}";
      } else {
        return names[0];
      }
    }
    toTokenString(literalNames, symbolicNames) {
      const names = [];
      for (let i = 0; i < this.intervals.length; i++) {
        const existing = this.intervals[i];
        for (let j = existing.start; j < existing.stop; j++) {
          names.push(this.elementName(literalNames, symbolicNames, j));
        }
      }
      if (names.length > 1) {
        return "{" + names.join(", ") + "}";
      } else {
        return names[0];
      }
    }
    elementName(literalNames, symbolicNames, token) {
      if (token === Token2.EOF) {
        return "<EOF>";
      } else if (token === Token2.EPSILON) {
        return "<EPSILON>";
      } else {
        return literalNames[token] || symbolicNames[token];
      }
    }
    get length() {
      return this.intervals.map((interval) => interval.length).reduce((acc, val) => acc + val);
    }
  };
  module2.exports = {
    Interval,
    IntervalSet
  };
});

// node_modules/antlr4/src/antlr4/atn/Transition.js
var require_Transition2 = __commonJS((exports, module2) => {
  var {Token: Token2} = require_Token2();
  var {IntervalSet} = require_IntervalSet2();
  var {Predicate, PrecedencePredicate} = require_SemanticContext2();
  var Transition = class {
    constructor(target) {
      if (target === void 0 || target === null) {
        throw "target cannot be null.";
      }
      this.target = target;
      this.isEpsilon = false;
      this.label = null;
    }
  };
  Transition.EPSILON = 1;
  Transition.RANGE = 2;
  Transition.RULE = 3;
  Transition.PREDICATE = 4;
  Transition.ATOM = 5;
  Transition.ACTION = 6;
  Transition.SET = 7;
  Transition.NOT_SET = 8;
  Transition.WILDCARD = 9;
  Transition.PRECEDENCE = 10;
  Transition.serializationNames = [
    "INVALID",
    "EPSILON",
    "RANGE",
    "RULE",
    "PREDICATE",
    "ATOM",
    "ACTION",
    "SET",
    "NOT_SET",
    "WILDCARD",
    "PRECEDENCE"
  ];
  Transition.serializationTypes = {
    EpsilonTransition: Transition.EPSILON,
    RangeTransition: Transition.RANGE,
    RuleTransition: Transition.RULE,
    PredicateTransition: Transition.PREDICATE,
    AtomTransition: Transition.ATOM,
    ActionTransition: Transition.ACTION,
    SetTransition: Transition.SET,
    NotSetTransition: Transition.NOT_SET,
    WildcardTransition: Transition.WILDCARD,
    PrecedencePredicateTransition: Transition.PRECEDENCE
  };
  var AtomTransition2 = class extends Transition {
    constructor(target, label) {
      super(target);
      this.label_ = label;
      this.label = this.makeLabel();
      this.serializationType = Transition.ATOM;
    }
    makeLabel() {
      const s = new IntervalSet();
      s.addOne(this.label_);
      return s;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return this.label_ === symbol;
    }
    toString() {
      return this.label_;
    }
  };
  var RuleTransition = class extends Transition {
    constructor(ruleStart, ruleIndex, precedence, followState) {
      super(ruleStart);
      this.ruleIndex = ruleIndex;
      this.precedence = precedence;
      this.followState = followState;
      this.serializationType = Transition.RULE;
      this.isEpsilon = true;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return false;
    }
  };
  var EpsilonTransition = class extends Transition {
    constructor(target, outermostPrecedenceReturn) {
      super(target);
      this.serializationType = Transition.EPSILON;
      this.isEpsilon = true;
      this.outermostPrecedenceReturn = outermostPrecedenceReturn;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return false;
    }
    toString() {
      return "epsilon";
    }
  };
  var RangeTransition = class extends Transition {
    constructor(target, start, stop) {
      super(target);
      this.serializationType = Transition.RANGE;
      this.start = start;
      this.stop = stop;
      this.label = this.makeLabel();
    }
    makeLabel() {
      const s = new IntervalSet();
      s.addRange(this.start, this.stop);
      return s;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return symbol >= this.start && symbol <= this.stop;
    }
    toString() {
      return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
    }
  };
  var AbstractPredicateTransition = class extends Transition {
    constructor(target) {
      super(target);
    }
  };
  var PredicateTransition = class extends AbstractPredicateTransition {
    constructor(target, ruleIndex, predIndex, isCtxDependent) {
      super(target);
      this.serializationType = Transition.PREDICATE;
      this.ruleIndex = ruleIndex;
      this.predIndex = predIndex;
      this.isCtxDependent = isCtxDependent;
      this.isEpsilon = true;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return false;
    }
    getPredicate() {
      return new Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
    }
    toString() {
      return "pred_" + this.ruleIndex + ":" + this.predIndex;
    }
  };
  var ActionTransition = class extends Transition {
    constructor(target, ruleIndex, actionIndex, isCtxDependent) {
      super(target);
      this.serializationType = Transition.ACTION;
      this.ruleIndex = ruleIndex;
      this.actionIndex = actionIndex === void 0 ? -1 : actionIndex;
      this.isCtxDependent = isCtxDependent === void 0 ? false : isCtxDependent;
      this.isEpsilon = true;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return false;
    }
    toString() {
      return "action_" + this.ruleIndex + ":" + this.actionIndex;
    }
  };
  var SetTransition = class extends Transition {
    constructor(target, set) {
      super(target);
      this.serializationType = Transition.SET;
      if (set !== void 0 && set !== null) {
        this.label = set;
      } else {
        this.label = new IntervalSet();
        this.label.addOne(Token2.INVALID_TYPE);
      }
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return this.label.contains(symbol);
    }
    toString() {
      return this.label.toString();
    }
  };
  var NotSetTransition = class extends SetTransition {
    constructor(target, set) {
      super(target, set);
      this.serializationType = Transition.NOT_SET;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !super.matches(symbol, minVocabSymbol, maxVocabSymbol);
    }
    toString() {
      return "~" + super.toString();
    }
  };
  var WildcardTransition = class extends Transition {
    constructor(target) {
      super(target);
      this.serializationType = Transition.WILDCARD;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
    }
    toString() {
      return ".";
    }
  };
  var PrecedencePredicateTransition = class extends AbstractPredicateTransition {
    constructor(target, precedence) {
      super(target);
      this.serializationType = Transition.PRECEDENCE;
      this.precedence = precedence;
      this.isEpsilon = true;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
      return false;
    }
    getPredicate() {
      return new PrecedencePredicate(this.precedence);
    }
    toString() {
      return this.precedence + " >= _p";
    }
  };
  module2.exports = {
    Transition,
    AtomTransition: AtomTransition2,
    SetTransition,
    NotSetTransition,
    RuleTransition,
    ActionTransition,
    EpsilonTransition,
    RangeTransition,
    WildcardTransition,
    PredicateTransition,
    PrecedencePredicateTransition,
    AbstractPredicateTransition
  };
});

// node_modules/antlr4/src/antlr4/tree/Tree.js
var require_Tree = __commonJS((exports, module2) => {
  var {Token: Token2} = require_Token2();
  var {Interval} = require_IntervalSet2();
  var INVALID_INTERVAL = new Interval(-1, -2);
  var Tree = class {
  };
  var SyntaxTree = class extends Tree {
    constructor() {
      super();
    }
  };
  var ParseTree = class extends SyntaxTree {
    constructor() {
      super();
    }
  };
  var RuleNode = class extends ParseTree {
    constructor() {
      super();
    }
    getRuleContext() {
      throw new Error("missing interface implementation");
    }
  };
  var TerminalNode = class extends ParseTree {
    constructor() {
      super();
    }
  };
  var ErrorNode2 = class extends TerminalNode {
    constructor() {
      super();
    }
  };
  var ParseTreeVisitor = class {
    visit(ctx) {
      if (Array.isArray(ctx)) {
        return ctx.map(function(child) {
          return child.accept(this);
        }, this);
      } else {
        return ctx.accept(this);
      }
    }
    visitChildren(ctx) {
      if (ctx.children) {
        return this.visit(ctx.children);
      } else {
        return null;
      }
    }
    visitTerminal(node) {
    }
    visitErrorNode(node) {
    }
  };
  var ParseTreeListener = class {
    visitTerminal(node) {
    }
    visitErrorNode(node) {
    }
    enterEveryRule(node) {
    }
    exitEveryRule(node) {
    }
  };
  var TerminalNodeImpl = class extends TerminalNode {
    constructor(symbol) {
      super();
      this.parentCtx = null;
      this.symbol = symbol;
    }
    getChild(i) {
      return null;
    }
    getSymbol() {
      return this.symbol;
    }
    getParent() {
      return this.parentCtx;
    }
    getPayload() {
      return this.symbol;
    }
    getSourceInterval() {
      if (this.symbol === null) {
        return INVALID_INTERVAL;
      }
      const tokenIndex = this.symbol.tokenIndex;
      return new Interval(tokenIndex, tokenIndex);
    }
    getChildCount() {
      return 0;
    }
    accept(visitor) {
      return visitor.visitTerminal(this);
    }
    getText() {
      return this.symbol.text;
    }
    toString() {
      if (this.symbol.type === Token2.EOF) {
        return "<EOF>";
      } else {
        return this.symbol.text;
      }
    }
  };
  var ErrorNodeImpl = class extends TerminalNodeImpl {
    constructor(token) {
      super(token);
    }
    isErrorNode() {
      return true;
    }
    accept(visitor) {
      return visitor.visitErrorNode(this);
    }
  };
  var ParseTreeWalker = class {
    walk(listener, t) {
      const errorNode = t instanceof ErrorNode2 || t.isErrorNode !== void 0 && t.isErrorNode();
      if (errorNode) {
        listener.visitErrorNode(t);
      } else if (t instanceof TerminalNode) {
        listener.visitTerminal(t);
      } else {
        this.enterRule(listener, t);
        for (let i = 0; i < t.getChildCount(); i++) {
          const child = t.getChild(i);
          this.walk(listener, child);
        }
        this.exitRule(listener, t);
      }
    }
    enterRule(listener, r) {
      const ctx = r.getRuleContext();
      listener.enterEveryRule(ctx);
      ctx.enterRule(listener);
    }
    exitRule(listener, r) {
      const ctx = r.getRuleContext();
      ctx.exitRule(listener);
      listener.exitEveryRule(ctx);
    }
  };
  ParseTreeWalker.DEFAULT = new ParseTreeWalker();
  module2.exports = {
    RuleNode,
    ErrorNode: ErrorNode2,
    TerminalNode,
    ErrorNodeImpl,
    TerminalNodeImpl,
    ParseTreeListener,
    ParseTreeVisitor,
    ParseTreeWalker,
    INVALID_INTERVAL
  };
});

// node_modules/antlr4/src/antlr4/tree/Trees.js
var require_Trees2 = __commonJS((exports, module2) => {
  var Utils3 = require_Utils2();
  var {Token: Token2} = require_Token2();
  var {ErrorNode: ErrorNode2, TerminalNode, RuleNode} = require_Tree();
  var Trees = {
    toStringTree: function(tree, ruleNames, recog) {
      ruleNames = ruleNames || null;
      recog = recog || null;
      if (recog !== null) {
        ruleNames = recog.ruleNames;
      }
      let s = Trees.getNodeText(tree, ruleNames);
      s = Utils3.escapeWhitespace(s, false);
      const c = tree.getChildCount();
      if (c === 0) {
        return s;
      }
      let res = "(" + s + " ";
      if (c > 0) {
        s = Trees.toStringTree(tree.getChild(0), ruleNames);
        res = res.concat(s);
      }
      for (let i = 1; i < c; i++) {
        s = Trees.toStringTree(tree.getChild(i), ruleNames);
        res = res.concat(" " + s);
      }
      res = res.concat(")");
      return res;
    },
    getNodeText: function(t, ruleNames, recog) {
      ruleNames = ruleNames || null;
      recog = recog || null;
      if (recog !== null) {
        ruleNames = recog.ruleNames;
      }
      if (ruleNames !== null) {
        if (t instanceof RuleNode) {
          const context = t.getRuleContext();
          const altNumber = context.getAltNumber();
          if (altNumber != 0) {
            return ruleNames[t.ruleIndex] + ":" + altNumber;
          }
          return ruleNames[t.ruleIndex];
        } else if (t instanceof ErrorNode2) {
          return t.toString();
        } else if (t instanceof TerminalNode) {
          if (t.symbol !== null) {
            return t.symbol.text;
          }
        }
      }
      const payload = t.getPayload();
      if (payload instanceof Token2) {
        return payload.text;
      }
      return t.getPayload().toString();
    },
    getChildren: function(t) {
      const list = [];
      for (let i = 0; i < t.getChildCount(); i++) {
        list.push(t.getChild(i));
      }
      return list;
    },
    getAncestors: function(t) {
      let ancestors = [];
      t = t.getParent();
      while (t !== null) {
        ancestors = [t].concat(ancestors);
        t = t.getParent();
      }
      return ancestors;
    },
    findAllTokenNodes: function(t, ttype) {
      return Trees.findAllNodes(t, ttype, true);
    },
    findAllRuleNodes: function(t, ruleIndex) {
      return Trees.findAllNodes(t, ruleIndex, false);
    },
    findAllNodes: function(t, index, findTokens) {
      const nodes = [];
      Trees._findAllNodes(t, index, findTokens, nodes);
      return nodes;
    },
    _findAllNodes: function(t, index, findTokens, nodes) {
      if (findTokens && t instanceof TerminalNode) {
        if (t.symbol.type === index) {
          nodes.push(t);
        }
      } else if (!findTokens && t instanceof RuleNode) {
        if (t.ruleIndex === index) {
          nodes.push(t);
        }
      }
      for (let i = 0; i < t.getChildCount(); i++) {
        Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);
      }
    },
    descendants: function(t) {
      let nodes = [t];
      for (let i = 0; i < t.getChildCount(); i++) {
        nodes = nodes.concat(Trees.descendants(t.getChild(i)));
      }
      return nodes;
    }
  };
  module2.exports = Trees;
});

// node_modules/antlr4/src/antlr4/RuleContext.js
var require_RuleContext2 = __commonJS((exports, module2) => {
  var {RuleNode} = require_Tree();
  var {INVALID_INTERVAL} = require_Tree();
  var Trees = require_Trees2();
  var RuleContext = class extends RuleNode {
    constructor(parent, invokingState) {
      super();
      this.parentCtx = parent || null;
      this.invokingState = invokingState || -1;
    }
    depth() {
      let n = 0;
      let p = this;
      while (p !== null) {
        p = p.parentCtx;
        n += 1;
      }
      return n;
    }
    isEmpty() {
      return this.invokingState === -1;
    }
    getSourceInterval() {
      return INVALID_INTERVAL;
    }
    getRuleContext() {
      return this;
    }
    getPayload() {
      return this;
    }
    getText() {
      if (this.getChildCount() === 0) {
        return "";
      } else {
        return this.children.map(function(child) {
          return child.getText();
        }).join("");
      }
    }
    getAltNumber() {
      return 0;
    }
    setAltNumber(altNumber) {
    }
    getChild(i) {
      return null;
    }
    getChildCount() {
      return 0;
    }
    accept(visitor) {
      return visitor.visitChildren(this);
    }
    toStringTree(ruleNames, recog) {
      return Trees.toStringTree(this, ruleNames, recog);
    }
    toString(ruleNames, stop) {
      ruleNames = ruleNames || null;
      stop = stop || null;
      let p = this;
      let s = "[";
      while (p !== null && p !== stop) {
        if (ruleNames === null) {
          if (!p.isEmpty()) {
            s += p.invokingState;
          }
        } else {
          const ri = p.ruleIndex;
          const ruleName = ri >= 0 && ri < ruleNames.length ? ruleNames[ri] : "" + ri;
          s += ruleName;
        }
        if (p.parentCtx !== null && (ruleNames !== null || !p.parentCtx.isEmpty())) {
          s += " ";
        }
        p = p.parentCtx;
      }
      s += "]";
      return s;
    }
  };
  module2.exports = RuleContext;
});

// node_modules/antlr4/src/antlr4/PredictionContext.js
var require_PredictionContext2 = __commonJS((exports, module2) => {
  var RuleContext = require_RuleContext2();
  var {Hash: Hash2, Map: Map2, equalArrays} = require_Utils2();
  var PredictionContext = class {
    constructor(cachedHashCode) {
      this.cachedHashCode = cachedHashCode;
    }
    isEmpty() {
      return this === PredictionContext.EMPTY;
    }
    hasEmptyPath() {
      return this.getReturnState(this.length - 1) === PredictionContext.EMPTY_RETURN_STATE;
    }
    hashCode() {
      return this.cachedHashCode;
    }
    updateHashCode(hash) {
      hash.update(this.cachedHashCode);
    }
  };
  PredictionContext.EMPTY = null;
  PredictionContext.EMPTY_RETURN_STATE = 2147483647;
  PredictionContext.globalNodeCount = 1;
  PredictionContext.id = PredictionContext.globalNodeCount;
  var PredictionContextCache = class {
    constructor() {
      this.cache = new Map2();
    }
    add(ctx) {
      if (ctx === PredictionContext.EMPTY) {
        return PredictionContext.EMPTY;
      }
      const existing = this.cache.get(ctx) || null;
      if (existing !== null) {
        return existing;
      }
      this.cache.put(ctx, ctx);
      return ctx;
    }
    get(ctx) {
      return this.cache.get(ctx) || null;
    }
    get length() {
      return this.cache.length;
    }
  };
  var SingletonPredictionContext = class extends PredictionContext {
    constructor(parent, returnState) {
      let hashCode = 0;
      const hash = new Hash2();
      if (parent !== null) {
        hash.update(parent, returnState);
      } else {
        hash.update(1);
      }
      hashCode = hash.finish();
      super(hashCode);
      this.parentCtx = parent;
      this.returnState = returnState;
    }
    getParent(index) {
      return this.parentCtx;
    }
    getReturnState(index) {
      return this.returnState;
    }
    equals(other) {
      if (this === other) {
        return true;
      } else if (!(other instanceof SingletonPredictionContext)) {
        return false;
      } else if (this.hashCode() !== other.hashCode()) {
        return false;
      } else {
        if (this.returnState !== other.returnState)
          return false;
        else if (this.parentCtx == null)
          return other.parentCtx == null;
        else
          return this.parentCtx.equals(other.parentCtx);
      }
    }
    toString() {
      const up = this.parentCtx === null ? "" : this.parentCtx.toString();
      if (up.length === 0) {
        if (this.returnState === PredictionContext.EMPTY_RETURN_STATE) {
          return "$";
        } else {
          return "" + this.returnState;
        }
      } else {
        return "" + this.returnState + " " + up;
      }
    }
    get length() {
      return 1;
    }
    static create(parent, returnState) {
      if (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {
        return PredictionContext.EMPTY;
      } else {
        return new SingletonPredictionContext(parent, returnState);
      }
    }
  };
  var EmptyPredictionContext = class extends SingletonPredictionContext {
    constructor() {
      super(null, PredictionContext.EMPTY_RETURN_STATE);
    }
    isEmpty() {
      return true;
    }
    getParent(index) {
      return null;
    }
    getReturnState(index) {
      return this.returnState;
    }
    equals(other) {
      return this === other;
    }
    toString() {
      return "$";
    }
  };
  PredictionContext.EMPTY = new EmptyPredictionContext();
  var ArrayPredictionContext = class extends PredictionContext {
    constructor(parents, returnStates) {
      const h = new Hash2();
      h.update(parents, returnStates);
      const hashCode = h.finish();
      super(hashCode);
      this.parents = parents;
      this.returnStates = returnStates;
      return this;
    }
    isEmpty() {
      return this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;
    }
    getParent(index) {
      return this.parents[index];
    }
    getReturnState(index) {
      return this.returnStates[index];
    }
    equals(other) {
      if (this === other) {
        return true;
      } else if (!(other instanceof ArrayPredictionContext)) {
        return false;
      } else if (this.hashCode() !== other.hashCode()) {
        return false;
      } else {
        return equalArrays(this.returnStates, other.returnStates) && equalArrays(this.parents, other.parents);
      }
    }
    toString() {
      if (this.isEmpty()) {
        return "[]";
      } else {
        let s = "[";
        for (let i = 0; i < this.returnStates.length; i++) {
          if (i > 0) {
            s = s + ", ";
          }
          if (this.returnStates[i] === PredictionContext.EMPTY_RETURN_STATE) {
            s = s + "$";
            continue;
          }
          s = s + this.returnStates[i];
          if (this.parents[i] !== null) {
            s = s + " " + this.parents[i];
          } else {
            s = s + "null";
          }
        }
        return s + "]";
      }
    }
    get length() {
      return this.returnStates.length;
    }
  };
  function predictionContextFromRuleContext(atn, outerContext) {
    if (outerContext === void 0 || outerContext === null) {
      outerContext = RuleContext.EMPTY;
    }
    if (outerContext.parentCtx === null || outerContext === RuleContext.EMPTY) {
      return PredictionContext.EMPTY;
    }
    const parent = predictionContextFromRuleContext(atn, outerContext.parentCtx);
    const state = atn.states[outerContext.invokingState];
    const transition = state.transitions[0];
    return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
  }
  function merge(a, b, rootIsWildcard, mergeCache) {
    if (a === b) {
      return a;
    }
    if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
      return mergeSingletons(a, b, rootIsWildcard, mergeCache);
    }
    if (rootIsWildcard) {
      if (a instanceof EmptyPredictionContext) {
        return a;
      }
      if (b instanceof EmptyPredictionContext) {
        return b;
      }
    }
    if (a instanceof SingletonPredictionContext) {
      a = new ArrayPredictionContext([a.getParent()], [a.returnState]);
    }
    if (b instanceof SingletonPredictionContext) {
      b = new ArrayPredictionContext([b.getParent()], [b.returnState]);
    }
    return mergeArrays(a, b, rootIsWildcard, mergeCache);
  }
  function mergeSingletons(a, b, rootIsWildcard, mergeCache) {
    if (mergeCache !== null) {
      let previous = mergeCache.get(a, b);
      if (previous !== null) {
        return previous;
      }
      previous = mergeCache.get(b, a);
      if (previous !== null) {
        return previous;
      }
    }
    const rootMerge = mergeRoot(a, b, rootIsWildcard);
    if (rootMerge !== null) {
      if (mergeCache !== null) {
        mergeCache.set(a, b, rootMerge);
      }
      return rootMerge;
    }
    if (a.returnState === b.returnState) {
      const parent = merge(a.parentCtx, b.parentCtx, rootIsWildcard, mergeCache);
      if (parent === a.parentCtx) {
        return a;
      }
      if (parent === b.parentCtx) {
        return b;
      }
      const spc = SingletonPredictionContext.create(parent, a.returnState);
      if (mergeCache !== null) {
        mergeCache.set(a, b, spc);
      }
      return spc;
    } else {
      let singleParent = null;
      if (a === b || a.parentCtx !== null && a.parentCtx === b.parentCtx) {
        singleParent = a.parentCtx;
      }
      if (singleParent !== null) {
        const payloads2 = [a.returnState, b.returnState];
        if (a.returnState > b.returnState) {
          payloads2[0] = b.returnState;
          payloads2[1] = a.returnState;
        }
        const parents2 = [singleParent, singleParent];
        const apc = new ArrayPredictionContext(parents2, payloads2);
        if (mergeCache !== null) {
          mergeCache.set(a, b, apc);
        }
        return apc;
      }
      const payloads = [a.returnState, b.returnState];
      let parents = [a.parentCtx, b.parentCtx];
      if (a.returnState > b.returnState) {
        payloads[0] = b.returnState;
        payloads[1] = a.returnState;
        parents = [b.parentCtx, a.parentCtx];
      }
      const a_ = new ArrayPredictionContext(parents, payloads);
      if (mergeCache !== null) {
        mergeCache.set(a, b, a_);
      }
      return a_;
    }
  }
  function mergeRoot(a, b, rootIsWildcard) {
    if (rootIsWildcard) {
      if (a === PredictionContext.EMPTY) {
        return PredictionContext.EMPTY;
      }
      if (b === PredictionContext.EMPTY) {
        return PredictionContext.EMPTY;
      }
    } else {
      if (a === PredictionContext.EMPTY && b === PredictionContext.EMPTY) {
        return PredictionContext.EMPTY;
      } else if (a === PredictionContext.EMPTY) {
        const payloads = [
          b.returnState,
          PredictionContext.EMPTY_RETURN_STATE
        ];
        const parents = [b.parentCtx, null];
        return new ArrayPredictionContext(parents, payloads);
      } else if (b === PredictionContext.EMPTY) {
        const payloads = [a.returnState, PredictionContext.EMPTY_RETURN_STATE];
        const parents = [a.parentCtx, null];
        return new ArrayPredictionContext(parents, payloads);
      }
    }
    return null;
  }
  function mergeArrays(a, b, rootIsWildcard, mergeCache) {
    if (mergeCache !== null) {
      let previous = mergeCache.get(a, b);
      if (previous !== null) {
        return previous;
      }
      previous = mergeCache.get(b, a);
      if (previous !== null) {
        return previous;
      }
    }
    let i = 0;
    let j = 0;
    let k = 0;
    let mergedReturnStates = [];
    let mergedParents = [];
    while (i < a.returnStates.length && j < b.returnStates.length) {
      const a_parent = a.parents[i];
      const b_parent = b.parents[j];
      if (a.returnStates[i] === b.returnStates[j]) {
        const payload = a.returnStates[i];
        const bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE && a_parent === null && b_parent === null;
        const ax_ax = a_parent !== null && b_parent !== null && a_parent === b_parent;
        if (bothDollars || ax_ax) {
          mergedParents[k] = a_parent;
          mergedReturnStates[k] = payload;
        } else {
          mergedParents[k] = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
          mergedReturnStates[k] = payload;
        }
        i += 1;
        j += 1;
      } else if (a.returnStates[i] < b.returnStates[j]) {
        mergedParents[k] = a_parent;
        mergedReturnStates[k] = a.returnStates[i];
        i += 1;
      } else {
        mergedParents[k] = b_parent;
        mergedReturnStates[k] = b.returnStates[j];
        j += 1;
      }
      k += 1;
    }
    if (i < a.returnStates.length) {
      for (let p = i; p < a.returnStates.length; p++) {
        mergedParents[k] = a.parents[p];
        mergedReturnStates[k] = a.returnStates[p];
        k += 1;
      }
    } else {
      for (let p = j; p < b.returnStates.length; p++) {
        mergedParents[k] = b.parents[p];
        mergedReturnStates[k] = b.returnStates[p];
        k += 1;
      }
    }
    if (k < mergedParents.length) {
      if (k === 1) {
        const a_ = SingletonPredictionContext.create(mergedParents[0], mergedReturnStates[0]);
        if (mergeCache !== null) {
          mergeCache.set(a, b, a_);
        }
        return a_;
      }
      mergedParents = mergedParents.slice(0, k);
      mergedReturnStates = mergedReturnStates.slice(0, k);
    }
    const M = new ArrayPredictionContext(mergedParents, mergedReturnStates);
    if (M === a) {
      if (mergeCache !== null) {
        mergeCache.set(a, b, a);
      }
      return a;
    }
    if (M === b) {
      if (mergeCache !== null) {
        mergeCache.set(a, b, b);
      }
      return b;
    }
    combineCommonParents(mergedParents);
    if (mergeCache !== null) {
      mergeCache.set(a, b, M);
    }
    return M;
  }
  function combineCommonParents(parents) {
    const uniqueParents = new Map2();
    for (let p = 0; p < parents.length; p++) {
      const parent = parents[p];
      if (!uniqueParents.containsKey(parent)) {
        uniqueParents.put(parent, parent);
      }
    }
    for (let q = 0; q < parents.length; q++) {
      parents[q] = uniqueParents.get(parents[q]);
    }
  }
  function getCachedPredictionContext(context, contextCache, visited) {
    if (context.isEmpty()) {
      return context;
    }
    let existing = visited.get(context) || null;
    if (existing !== null) {
      return existing;
    }
    existing = contextCache.get(context);
    if (existing !== null) {
      visited.put(context, existing);
      return existing;
    }
    let changed = false;
    let parents = [];
    for (let i = 0; i < parents.length; i++) {
      const parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);
      if (changed || parent !== context.getParent(i)) {
        if (!changed) {
          parents = [];
          for (let j = 0; j < context.length; j++) {
            parents[j] = context.getParent(j);
          }
          changed = true;
        }
        parents[i] = parent;
      }
    }
    if (!changed) {
      contextCache.add(context);
      visited.put(context, context);
      return context;
    }
    let updated = null;
    if (parents.length === 0) {
      updated = PredictionContext.EMPTY;
    } else if (parents.length === 1) {
      updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));
    } else {
      updated = new ArrayPredictionContext(parents, context.returnStates);
    }
    contextCache.add(updated);
    visited.put(updated, updated);
    visited.put(context, updated);
    return updated;
  }
  module2.exports = {
    merge,
    PredictionContext,
    PredictionContextCache,
    SingletonPredictionContext,
    predictionContextFromRuleContext,
    getCachedPredictionContext
  };
});

// node_modules/antlr4/src/antlr4/LL1Analyzer.js
var require_LL1Analyzer2 = __commonJS((exports, module2) => {
  var {Set: Set2, BitSet} = require_Utils2();
  var {Token: Token2} = require_Token2();
  var {ATNConfig} = require_ATNConfig2();
  var {IntervalSet} = require_IntervalSet2();
  var {RuleStopState} = require_ATNState2();
  var {RuleTransition, NotSetTransition, WildcardTransition, AbstractPredicateTransition} = require_Transition2();
  var {predictionContextFromRuleContext, PredictionContext, SingletonPredictionContext} = require_PredictionContext2();
  var LL1Analyzer = class {
    constructor(atn) {
      this.atn = atn;
    }
    getDecisionLookahead(s) {
      if (s === null) {
        return null;
      }
      const count = s.transitions.length;
      const look = [];
      for (let alt = 0; alt < count; alt++) {
        look[alt] = new IntervalSet();
        const lookBusy = new Set2();
        const seeThruPreds = false;
        this._LOOK(s.transition(alt).target, null, PredictionContext.EMPTY, look[alt], lookBusy, new BitSet(), seeThruPreds, false);
        if (look[alt].length === 0 || look[alt].contains(LL1Analyzer.HIT_PRED)) {
          look[alt] = null;
        }
      }
      return look;
    }
    LOOK(s, stopState, ctx) {
      const r = new IntervalSet();
      const seeThruPreds = true;
      ctx = ctx || null;
      const lookContext = ctx !== null ? predictionContextFromRuleContext(s.atn, ctx) : null;
      this._LOOK(s, stopState, lookContext, r, new Set2(), new BitSet(), seeThruPreds, true);
      return r;
    }
    _LOOK(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
      const c = new ATNConfig({state: s, alt: 0, context: ctx}, null);
      if (lookBusy.contains(c)) {
        return;
      }
      lookBusy.add(c);
      if (s === stopState) {
        if (ctx === null) {
          look.addOne(Token2.EPSILON);
          return;
        } else if (ctx.isEmpty() && addEOF) {
          look.addOne(Token2.EOF);
          return;
        }
      }
      if (s instanceof RuleStopState) {
        if (ctx === null) {
          look.addOne(Token2.EPSILON);
          return;
        } else if (ctx.isEmpty() && addEOF) {
          look.addOne(Token2.EOF);
          return;
        }
        if (ctx !== PredictionContext.EMPTY) {
          const removed = calledRuleStack.contains(s.ruleIndex);
          try {
            calledRuleStack.remove(s.ruleIndex);
            for (let i = 0; i < ctx.length; i++) {
              const returnState = this.atn.states[ctx.getReturnState(i)];
              this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            }
          } finally {
            if (removed) {
              calledRuleStack.add(s.ruleIndex);
            }
          }
          return;
        }
      }
      for (let j = 0; j < s.transitions.length; j++) {
        const t = s.transitions[j];
        if (t.constructor === RuleTransition) {
          if (calledRuleStack.contains(t.target.ruleIndex)) {
            continue;
          }
          const newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);
          try {
            calledRuleStack.add(t.target.ruleIndex);
            this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
          } finally {
            calledRuleStack.remove(t.target.ruleIndex);
          }
        } else if (t instanceof AbstractPredicateTransition) {
          if (seeThruPreds) {
            this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
          } else {
            look.addOne(LL1Analyzer.HIT_PRED);
          }
        } else if (t.isEpsilon) {
          this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
        } else if (t.constructor === WildcardTransition) {
          look.addRange(Token2.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
        } else {
          let set = t.label;
          if (set !== null) {
            if (t instanceof NotSetTransition) {
              set = set.complement(Token2.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
            }
            look.addSet(set);
          }
        }
      }
    }
  };
  LL1Analyzer.HIT_PRED = Token2.INVALID_TYPE;
  module2.exports = LL1Analyzer;
});

// node_modules/antlr4/src/antlr4/atn/ATN.js
var require_ATN2 = __commonJS((exports, module2) => {
  var LL1Analyzer = require_LL1Analyzer2();
  var {IntervalSet} = require_IntervalSet2();
  var {Token: Token2} = require_Token2();
  var ATN2 = class {
    constructor(grammarType, maxTokenType) {
      this.grammarType = grammarType;
      this.maxTokenType = maxTokenType;
      this.states = [];
      this.decisionToState = [];
      this.ruleToStartState = [];
      this.ruleToStopState = null;
      this.modeNameToStartState = {};
      this.ruleToTokenType = null;
      this.lexerActions = null;
      this.modeToStartState = [];
    }
    nextTokensInContext(s, ctx) {
      const anal = new LL1Analyzer(this);
      return anal.LOOK(s, null, ctx);
    }
    nextTokensNoContext(s) {
      if (s.nextTokenWithinRule !== null) {
        return s.nextTokenWithinRule;
      }
      s.nextTokenWithinRule = this.nextTokensInContext(s, null);
      s.nextTokenWithinRule.readOnly = true;
      return s.nextTokenWithinRule;
    }
    nextTokens(s, ctx) {
      if (ctx === void 0) {
        return this.nextTokensNoContext(s);
      } else {
        return this.nextTokensInContext(s, ctx);
      }
    }
    addState(state) {
      if (state !== null) {
        state.atn = this;
        state.stateNumber = this.states.length;
      }
      this.states.push(state);
    }
    removeState(state) {
      this.states[state.stateNumber] = null;
    }
    defineDecisionState(s) {
      this.decisionToState.push(s);
      s.decision = this.decisionToState.length - 1;
      return s.decision;
    }
    getDecisionState(decision) {
      if (this.decisionToState.length === 0) {
        return null;
      } else {
        return this.decisionToState[decision];
      }
    }
    getExpectedTokens(stateNumber, ctx) {
      if (stateNumber < 0 || stateNumber >= this.states.length) {
        throw "Invalid state number.";
      }
      const s = this.states[stateNumber];
      let following = this.nextTokens(s);
      if (!following.contains(Token2.EPSILON)) {
        return following;
      }
      const expected = new IntervalSet();
      expected.addSet(following);
      expected.removeOne(Token2.EPSILON);
      while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token2.EPSILON)) {
        const invokingState = this.states[ctx.invokingState];
        const rt = invokingState.transitions[0];
        following = this.nextTokens(rt.followState);
        expected.addSet(following);
        expected.removeOne(Token2.EPSILON);
        ctx = ctx.parentCtx;
      }
      if (following.contains(Token2.EPSILON)) {
        expected.addOne(Token2.EOF);
      }
      return expected;
    }
  };
  ATN2.INVALID_ALT_NUMBER = 0;
  module2.exports = ATN2;
});

// node_modules/antlr4/src/antlr4/atn/ATNType.js
var require_ATNType = __commonJS((exports, module2) => {
  module2.exports = {
    LEXER: 0,
    PARSER: 1
  };
});

// node_modules/antlr4/src/antlr4/atn/ATNDeserializationOptions.js
var require_ATNDeserializationOptions2 = __commonJS((exports, module2) => {
  var ATNDeserializationOptions = class {
    constructor(copyFrom) {
      if (copyFrom === void 0) {
        copyFrom = null;
      }
      this.readOnly = false;
      this.verifyATN = copyFrom === null ? true : copyFrom.verifyATN;
      this.generateRuleBypassTransitions = copyFrom === null ? false : copyFrom.generateRuleBypassTransitions;
    }
  };
  ATNDeserializationOptions.defaultOptions = new ATNDeserializationOptions();
  ATNDeserializationOptions.defaultOptions.readOnly = true;
  module2.exports = ATNDeserializationOptions;
});

// node_modules/antlr4/src/antlr4/atn/LexerAction.js
var require_LexerAction = __commonJS((exports, module2) => {
  var LexerActionType = {
    CHANNEL: 0,
    CUSTOM: 1,
    MODE: 2,
    MORE: 3,
    POP_MODE: 4,
    PUSH_MODE: 5,
    SKIP: 6,
    TYPE: 7
  };
  var LexerAction = class {
    constructor(action) {
      this.actionType = action;
      this.isPositionDependent = false;
    }
    hashCode() {
      const hash = new Hash();
      this.updateHashCode(hash);
      return hash.finish();
    }
    updateHashCode(hash) {
      hash.update(this.actionType);
    }
    equals(other) {
      return this === other;
    }
  };
  var LexerSkipAction = class extends LexerAction {
    constructor() {
      super(LexerActionType.SKIP);
    }
    execute(lexer) {
      lexer.skip();
    }
    toString() {
      return "skip";
    }
  };
  LexerSkipAction.INSTANCE = new LexerSkipAction();
  var LexerTypeAction = class extends LexerAction {
    constructor(type) {
      super(LexerActionType.TYPE);
      this.type = type;
    }
    execute(lexer) {
      lexer.type = this.type;
    }
    updateHashCode(hash) {
      hash.update(this.actionType, this.type);
    }
    equals(other) {
      if (this === other) {
        return true;
      } else if (!(other instanceof LexerTypeAction)) {
        return false;
      } else {
        return this.type === other.type;
      }
    }
    toString() {
      return "type(" + this.type + ")";
    }
  };
  var LexerPushModeAction = class extends LexerAction {
    constructor(mode) {
      super(LexerActionType.PUSH_MODE);
      this.mode = mode;
    }
    execute(lexer) {
      lexer.pushMode(this.mode);
    }
    updateHashCode(hash) {
      hash.update(this.actionType, this.mode);
    }
    equals(other) {
      if (this === other) {
        return true;
      } else if (!(other instanceof LexerPushModeAction)) {
        return false;
      } else {
        return this.mode === other.mode;
      }
    }
    toString() {
      return "pushMode(" + this.mode + ")";
    }
  };
  var LexerPopModeAction = class extends LexerAction {
    constructor() {
      super(LexerActionType.POP_MODE);
    }
    execute(lexer) {
      lexer.popMode();
    }
    toString() {
      return "popMode";
    }
  };
  LexerPopModeAction.INSTANCE = new LexerPopModeAction();
  var LexerMoreAction = class extends LexerAction {
    constructor() {
      super(LexerActionType.MORE);
    }
    execute(lexer) {
      lexer.more();
    }
    toString() {
      return "more";
    }
  };
  LexerMoreAction.INSTANCE = new LexerMoreAction();
  var LexerModeAction = class extends LexerAction {
    constructor(mode) {
      super(LexerActionType.MODE);
      this.mode = mode;
    }
    execute(lexer) {
      lexer.mode(this.mode);
    }
    updateHashCode(hash) {
      hash.update(this.actionType, this.mode);
    }
    equals(other) {
      if (this === other) {
        return true;
      } else if (!(other instanceof LexerModeAction)) {
        return false;
      } else {
        return this.mode === other.mode;
      }
    }
    toString() {
      return "mode(" + this.mode + ")";
    }
  };
  var LexerCustomAction = class extends LexerAction {
    constructor(ruleIndex, actionIndex) {
      super(LexerActionType.CUSTOM);
      this.ruleIndex = ruleIndex;
      this.actionIndex = actionIndex;
      this.isPositionDependent = true;
    }
    execute(lexer) {
      lexer.action(null, this.ruleIndex, this.actionIndex);
    }
    updateHashCode(hash) {
      hash.update(this.actionType, this.ruleIndex, this.actionIndex);
    }
    equals(other) {
      if (this === other) {
        return true;
      } else if (!(other instanceof LexerCustomAction)) {
        return false;
      } else {
        return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;
      }
    }
  };
  var LexerChannelAction = class extends LexerAction {
    constructor(channel) {
      super(LexerActionType.CHANNEL);
      this.channel = channel;
    }
    execute(lexer) {
      lexer._channel = this.channel;
    }
    updateHashCode(hash) {
      hash.update(this.actionType, this.channel);
    }
    equals(other) {
      if (this === other) {
        return true;
      } else if (!(other instanceof LexerChannelAction)) {
        return false;
      } else {
        return this.channel === other.channel;
      }
    }
    toString() {
      return "channel(" + this.channel + ")";
    }
  };
  var LexerIndexedCustomAction = class extends LexerAction {
    constructor(offset, action) {
      super(action.actionType);
      this.offset = offset;
      this.action = action;
      this.isPositionDependent = true;
    }
    execute(lexer) {
      this.action.execute(lexer);
    }
    updateHashCode(hash) {
      hash.update(this.actionType, this.offset, this.action);
    }
    equals(other) {
      if (this === other) {
        return true;
      } else if (!(other instanceof LexerIndexedCustomAction)) {
        return false;
      } else {
        return this.offset === other.offset && this.action === other.action;
      }
    }
  };
  module2.exports = {
    LexerActionType,
    LexerSkipAction,
    LexerChannelAction,
    LexerCustomAction,
    LexerIndexedCustomAction,
    LexerMoreAction,
    LexerTypeAction,
    LexerPushModeAction,
    LexerPopModeAction,
    LexerModeAction
  };
});

// node_modules/antlr4/src/antlr4/atn/ATNDeserializer.js
var require_ATNDeserializer2 = __commonJS((exports, module2) => {
  var {Token: Token2} = require_Token2();
  var ATN2 = require_ATN2();
  var ATNType = require_ATNType();
  var {
    ATNState,
    BasicState,
    DecisionState,
    BlockStartState,
    BlockEndState,
    LoopEndState,
    RuleStartState,
    RuleStopState,
    TokensStartState,
    PlusLoopbackState,
    StarLoopbackState,
    StarLoopEntryState,
    PlusBlockStartState,
    StarBlockStartState,
    BasicBlockStartState
  } = require_ATNState2();
  var {
    Transition,
    AtomTransition: AtomTransition2,
    SetTransition,
    NotSetTransition,
    RuleTransition,
    RangeTransition,
    ActionTransition,
    EpsilonTransition,
    WildcardTransition,
    PredicateTransition,
    PrecedencePredicateTransition
  } = require_Transition2();
  var {IntervalSet} = require_IntervalSet2();
  var ATNDeserializationOptions = require_ATNDeserializationOptions2();
  var {
    LexerActionType,
    LexerSkipAction,
    LexerChannelAction,
    LexerCustomAction,
    LexerMoreAction,
    LexerTypeAction,
    LexerPushModeAction,
    LexerPopModeAction,
    LexerModeAction
  } = require_LexerAction();
  var BASE_SERIALIZED_UUID = "AADB8D7E-AEEF-4415-AD2B-8204D6CF042E";
  var ADDED_UNICODE_SMP = "59627784-3BE5-417A-B9EB-8131A7286089";
  var SUPPORTED_UUIDS = [BASE_SERIALIZED_UUID, ADDED_UNICODE_SMP];
  var SERIALIZED_VERSION = 3;
  var SERIALIZED_UUID = ADDED_UNICODE_SMP;
  function initArray(length, value) {
    const tmp = [];
    tmp[length - 1] = value;
    return tmp.map(function(i) {
      return value;
    });
  }
  var ATNDeserializer3 = class {
    constructor(options) {
      if (options === void 0 || options === null) {
        options = ATNDeserializationOptions.defaultOptions;
      }
      this.deserializationOptions = options;
      this.stateFactories = null;
      this.actionFactories = null;
    }
    isFeatureSupported(feature, actualUuid) {
      const idx1 = SUPPORTED_UUIDS.indexOf(feature);
      if (idx1 < 0) {
        return false;
      }
      const idx2 = SUPPORTED_UUIDS.indexOf(actualUuid);
      return idx2 >= idx1;
    }
    deserialize(data) {
      this.reset(data);
      this.checkVersion();
      this.checkUUID();
      const atn = this.readATN();
      this.readStates(atn);
      this.readRules(atn);
      this.readModes(atn);
      const sets = [];
      this.readSets(atn, sets, this.readInt.bind(this));
      if (this.isFeatureSupported(ADDED_UNICODE_SMP, this.uuid)) {
        this.readSets(atn, sets, this.readInt32.bind(this));
      }
      this.readEdges(atn, sets);
      this.readDecisions(atn);
      this.readLexerActions(atn);
      this.markPrecedenceDecisions(atn);
      this.verifyATN(atn);
      if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === ATNType.PARSER) {
        this.generateRuleBypassTransitions(atn);
        this.verifyATN(atn);
      }
      return atn;
    }
    reset(data) {
      const adjust = function(c) {
        const v = c.charCodeAt(0);
        return v > 1 ? v - 2 : v + 65534;
      };
      const temp = data.split("").map(adjust);
      temp[0] = data.charCodeAt(0);
      this.data = temp;
      this.pos = 0;
    }
    checkVersion() {
      const version = this.readInt();
      if (version !== SERIALIZED_VERSION) {
        throw "Could not deserialize ATN with version " + version + " (expected " + SERIALIZED_VERSION + ").";
      }
    }
    checkUUID() {
      const uuid = this.readUUID();
      if (SUPPORTED_UUIDS.indexOf(uuid) < 0) {
        throw "Could not deserialize ATN with UUID: " + uuid + " (expected " + SERIALIZED_UUID + " or a legacy UUID).", uuid, SERIALIZED_UUID;
      }
      this.uuid = uuid;
    }
    readATN() {
      const grammarType = this.readInt();
      const maxTokenType = this.readInt();
      return new ATN2(grammarType, maxTokenType);
    }
    readStates(atn) {
      let j, pair, stateNumber;
      const loopBackStateNumbers = [];
      const endStateNumbers = [];
      const nstates = this.readInt();
      for (let i = 0; i < nstates; i++) {
        const stype = this.readInt();
        if (stype === ATNState.INVALID_TYPE) {
          atn.addState(null);
          continue;
        }
        let ruleIndex = this.readInt();
        if (ruleIndex === 65535) {
          ruleIndex = -1;
        }
        const s = this.stateFactory(stype, ruleIndex);
        if (stype === ATNState.LOOP_END) {
          const loopBackStateNumber = this.readInt();
          loopBackStateNumbers.push([s, loopBackStateNumber]);
        } else if (s instanceof BlockStartState) {
          const endStateNumber = this.readInt();
          endStateNumbers.push([s, endStateNumber]);
        }
        atn.addState(s);
      }
      for (j = 0; j < loopBackStateNumbers.length; j++) {
        pair = loopBackStateNumbers[j];
        pair[0].loopBackState = atn.states[pair[1]];
      }
      for (j = 0; j < endStateNumbers.length; j++) {
        pair = endStateNumbers[j];
        pair[0].endState = atn.states[pair[1]];
      }
      let numNonGreedyStates = this.readInt();
      for (j = 0; j < numNonGreedyStates; j++) {
        stateNumber = this.readInt();
        atn.states[stateNumber].nonGreedy = true;
      }
      let numPrecedenceStates = this.readInt();
      for (j = 0; j < numPrecedenceStates; j++) {
        stateNumber = this.readInt();
        atn.states[stateNumber].isPrecedenceRule = true;
      }
    }
    readRules(atn) {
      let i;
      const nrules = this.readInt();
      if (atn.grammarType === ATNType.LEXER) {
        atn.ruleToTokenType = initArray(nrules, 0);
      }
      atn.ruleToStartState = initArray(nrules, 0);
      for (i = 0; i < nrules; i++) {
        const s = this.readInt();
        atn.ruleToStartState[i] = atn.states[s];
        if (atn.grammarType === ATNType.LEXER) {
          let tokenType = this.readInt();
          if (tokenType === 65535) {
            tokenType = Token2.EOF;
          }
          atn.ruleToTokenType[i] = tokenType;
        }
      }
      atn.ruleToStopState = initArray(nrules, 0);
      for (i = 0; i < atn.states.length; i++) {
        const state = atn.states[i];
        if (!(state instanceof RuleStopState)) {
          continue;
        }
        atn.ruleToStopState[state.ruleIndex] = state;
        atn.ruleToStartState[state.ruleIndex].stopState = state;
      }
    }
    readModes(atn) {
      const nmodes = this.readInt();
      for (let i = 0; i < nmodes; i++) {
        let s = this.readInt();
        atn.modeToStartState.push(atn.states[s]);
      }
    }
    readSets(atn, sets, readUnicode) {
      const m = this.readInt();
      for (let i = 0; i < m; i++) {
        const iset = new IntervalSet();
        sets.push(iset);
        const n = this.readInt();
        const containsEof = this.readInt();
        if (containsEof !== 0) {
          iset.addOne(-1);
        }
        for (let j = 0; j < n; j++) {
          const i1 = readUnicode();
          const i2 = readUnicode();
          iset.addRange(i1, i2);
        }
      }
    }
    readEdges(atn, sets) {
      let i, j, state, trans, target;
      const nedges = this.readInt();
      for (i = 0; i < nedges; i++) {
        const src = this.readInt();
        const trg = this.readInt();
        const ttype = this.readInt();
        const arg1 = this.readInt();
        const arg2 = this.readInt();
        const arg3 = this.readInt();
        trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);
        const srcState = atn.states[src];
        srcState.addTransition(trans);
      }
      for (i = 0; i < atn.states.length; i++) {
        state = atn.states[i];
        for (j = 0; j < state.transitions.length; j++) {
          const t = state.transitions[j];
          if (!(t instanceof RuleTransition)) {
            continue;
          }
          let outermostPrecedenceReturn = -1;
          if (atn.ruleToStartState[t.target.ruleIndex].isPrecedenceRule) {
            if (t.precedence === 0) {
              outermostPrecedenceReturn = t.target.ruleIndex;
            }
          }
          trans = new EpsilonTransition(t.followState, outermostPrecedenceReturn);
          atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);
        }
      }
      for (i = 0; i < atn.states.length; i++) {
        state = atn.states[i];
        if (state instanceof BlockStartState) {
          if (state.endState === null) {
            throw "IllegalState";
          }
          if (state.endState.startState !== null) {
            throw "IllegalState";
          }
          state.endState.startState = state;
        }
        if (state instanceof PlusLoopbackState) {
          for (j = 0; j < state.transitions.length; j++) {
            target = state.transitions[j].target;
            if (target instanceof PlusBlockStartState) {
              target.loopBackState = state;
            }
          }
        } else if (state instanceof StarLoopbackState) {
          for (j = 0; j < state.transitions.length; j++) {
            target = state.transitions[j].target;
            if (target instanceof StarLoopEntryState) {
              target.loopBackState = state;
            }
          }
        }
      }
    }
    readDecisions(atn) {
      const ndecisions = this.readInt();
      for (let i = 0; i < ndecisions; i++) {
        const s = this.readInt();
        const decState = atn.states[s];
        atn.decisionToState.push(decState);
        decState.decision = i;
      }
    }
    readLexerActions(atn) {
      if (atn.grammarType === ATNType.LEXER) {
        const count = this.readInt();
        atn.lexerActions = initArray(count, null);
        for (let i = 0; i < count; i++) {
          const actionType = this.readInt();
          let data1 = this.readInt();
          if (data1 === 65535) {
            data1 = -1;
          }
          let data2 = this.readInt();
          if (data2 === 65535) {
            data2 = -1;
          }
          atn.lexerActions[i] = this.lexerActionFactory(actionType, data1, data2);
        }
      }
    }
    generateRuleBypassTransitions(atn) {
      let i;
      const count = atn.ruleToStartState.length;
      for (i = 0; i < count; i++) {
        atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;
      }
      for (i = 0; i < count; i++) {
        this.generateRuleBypassTransition(atn, i);
      }
    }
    generateRuleBypassTransition(atn, idx) {
      let i, state;
      const bypassStart = new BasicBlockStartState();
      bypassStart.ruleIndex = idx;
      atn.addState(bypassStart);
      const bypassStop = new BlockEndState();
      bypassStop.ruleIndex = idx;
      atn.addState(bypassStop);
      bypassStart.endState = bypassStop;
      atn.defineDecisionState(bypassStart);
      bypassStop.startState = bypassStart;
      let excludeTransition = null;
      let endState = null;
      if (atn.ruleToStartState[idx].isPrecedenceRule) {
        endState = null;
        for (i = 0; i < atn.states.length; i++) {
          state = atn.states[i];
          if (this.stateIsEndStateFor(state, idx)) {
            endState = state;
            excludeTransition = state.loopBackState.transitions[0];
            break;
          }
        }
        if (excludeTransition === null) {
          throw "Couldn't identify final state of the precedence rule prefix section.";
        }
      } else {
        endState = atn.ruleToStopState[idx];
      }
      for (i = 0; i < atn.states.length; i++) {
        state = atn.states[i];
        for (let j = 0; j < state.transitions.length; j++) {
          const transition = state.transitions[j];
          if (transition === excludeTransition) {
            continue;
          }
          if (transition.target === endState) {
            transition.target = bypassStop;
          }
        }
      }
      const ruleToStartState = atn.ruleToStartState[idx];
      const count = ruleToStartState.transitions.length;
      while (count > 0) {
        bypassStart.addTransition(ruleToStartState.transitions[count - 1]);
        ruleToStartState.transitions = ruleToStartState.transitions.slice(-1);
      }
      atn.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));
      bypassStop.addTransition(new EpsilonTransition(endState));
      const matchState = new BasicState();
      atn.addState(matchState);
      matchState.addTransition(new AtomTransition2(bypassStop, atn.ruleToTokenType[idx]));
      bypassStart.addTransition(new EpsilonTransition(matchState));
    }
    stateIsEndStateFor(state, idx) {
      if (state.ruleIndex !== idx) {
        return null;
      }
      if (!(state instanceof StarLoopEntryState)) {
        return null;
      }
      const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
      if (!(maybeLoopEndState instanceof LoopEndState)) {
        return null;
      }
      if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {
        return state;
      } else {
        return null;
      }
    }
    markPrecedenceDecisions(atn) {
      for (let i = 0; i < atn.states.length; i++) {
        const state = atn.states[i];
        if (!(state instanceof StarLoopEntryState)) {
          continue;
        }
        if (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {
          const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
          if (maybeLoopEndState instanceof LoopEndState) {
            if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {
              state.isPrecedenceDecision = true;
            }
          }
        }
      }
    }
    verifyATN(atn) {
      if (!this.deserializationOptions.verifyATN) {
        return;
      }
      for (let i = 0; i < atn.states.length; i++) {
        const state = atn.states[i];
        if (state === null) {
          continue;
        }
        this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);
        if (state instanceof PlusBlockStartState) {
          this.checkCondition(state.loopBackState !== null);
        } else if (state instanceof StarLoopEntryState) {
          this.checkCondition(state.loopBackState !== null);
          this.checkCondition(state.transitions.length === 2);
          if (state.transitions[0].target instanceof StarBlockStartState) {
            this.checkCondition(state.transitions[1].target instanceof LoopEndState);
            this.checkCondition(!state.nonGreedy);
          } else if (state.transitions[0].target instanceof LoopEndState) {
            this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);
            this.checkCondition(state.nonGreedy);
          } else {
            throw "IllegalState";
          }
        } else if (state instanceof StarLoopbackState) {
          this.checkCondition(state.transitions.length === 1);
          this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);
        } else if (state instanceof LoopEndState) {
          this.checkCondition(state.loopBackState !== null);
        } else if (state instanceof RuleStartState) {
          this.checkCondition(state.stopState !== null);
        } else if (state instanceof BlockStartState) {
          this.checkCondition(state.endState !== null);
        } else if (state instanceof BlockEndState) {
          this.checkCondition(state.startState !== null);
        } else if (state instanceof DecisionState) {
          this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);
        } else {
          this.checkCondition(state.transitions.length <= 1 || state instanceof RuleStopState);
        }
      }
    }
    checkCondition(condition, message) {
      if (!condition) {
        if (message === void 0 || message === null) {
          message = "IllegalState";
        }
        throw message;
      }
    }
    readInt() {
      return this.data[this.pos++];
    }
    readInt32() {
      const low = this.readInt();
      const high = this.readInt();
      return low | high << 16;
    }
    readLong() {
      const low = this.readInt32();
      const high = this.readInt32();
      return low & 4294967295 | high << 32;
    }
    readUUID() {
      const bb = [];
      for (let i = 7; i >= 0; i--) {
        const int = this.readInt();
        bb[2 * i + 1] = int & 255;
        bb[2 * i] = int >> 8 & 255;
      }
      return byteToHex[bb[0]] + byteToHex[bb[1]] + byteToHex[bb[2]] + byteToHex[bb[3]] + "-" + byteToHex[bb[4]] + byteToHex[bb[5]] + "-" + byteToHex[bb[6]] + byteToHex[bb[7]] + "-" + byteToHex[bb[8]] + byteToHex[bb[9]] + "-" + byteToHex[bb[10]] + byteToHex[bb[11]] + byteToHex[bb[12]] + byteToHex[bb[13]] + byteToHex[bb[14]] + byteToHex[bb[15]];
    }
    edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {
      const target = atn.states[trg];
      switch (type) {
        case Transition.EPSILON:
          return new EpsilonTransition(target);
        case Transition.RANGE:
          return arg3 !== 0 ? new RangeTransition(target, Token2.EOF, arg2) : new RangeTransition(target, arg1, arg2);
        case Transition.RULE:
          return new RuleTransition(atn.states[arg1], arg2, arg3, target);
        case Transition.PREDICATE:
          return new PredicateTransition(target, arg1, arg2, arg3 !== 0);
        case Transition.PRECEDENCE:
          return new PrecedencePredicateTransition(target, arg1);
        case Transition.ATOM:
          return arg3 !== 0 ? new AtomTransition2(target, Token2.EOF) : new AtomTransition2(target, arg1);
        case Transition.ACTION:
          return new ActionTransition(target, arg1, arg2, arg3 !== 0);
        case Transition.SET:
          return new SetTransition(target, sets[arg1]);
        case Transition.NOT_SET:
          return new NotSetTransition(target, sets[arg1]);
        case Transition.WILDCARD:
          return new WildcardTransition(target);
        default:
          throw "The specified transition type: " + type + " is not valid.";
      }
    }
    stateFactory(type, ruleIndex) {
      if (this.stateFactories === null) {
        const sf = [];
        sf[ATNState.INVALID_TYPE] = null;
        sf[ATNState.BASIC] = () => new BasicState();
        sf[ATNState.RULE_START] = () => new RuleStartState();
        sf[ATNState.BLOCK_START] = () => new BasicBlockStartState();
        sf[ATNState.PLUS_BLOCK_START] = () => new PlusBlockStartState();
        sf[ATNState.STAR_BLOCK_START] = () => new StarBlockStartState();
        sf[ATNState.TOKEN_START] = () => new TokensStartState();
        sf[ATNState.RULE_STOP] = () => new RuleStopState();
        sf[ATNState.BLOCK_END] = () => new BlockEndState();
        sf[ATNState.STAR_LOOP_BACK] = () => new StarLoopbackState();
        sf[ATNState.STAR_LOOP_ENTRY] = () => new StarLoopEntryState();
        sf[ATNState.PLUS_LOOP_BACK] = () => new PlusLoopbackState();
        sf[ATNState.LOOP_END] = () => new LoopEndState();
        this.stateFactories = sf;
      }
      if (type > this.stateFactories.length || this.stateFactories[type] === null) {
        throw "The specified state type " + type + " is not valid.";
      } else {
        const s = this.stateFactories[type]();
        if (s !== null) {
          s.ruleIndex = ruleIndex;
          return s;
        }
      }
    }
    lexerActionFactory(type, data1, data2) {
      if (this.actionFactories === null) {
        const af = [];
        af[LexerActionType.CHANNEL] = (data12, data22) => new LexerChannelAction(data12);
        af[LexerActionType.CUSTOM] = (data12, data22) => new LexerCustomAction(data12, data22);
        af[LexerActionType.MODE] = (data12, data22) => new LexerModeAction(data12);
        af[LexerActionType.MORE] = (data12, data22) => LexerMoreAction.INSTANCE;
        af[LexerActionType.POP_MODE] = (data12, data22) => LexerPopModeAction.INSTANCE;
        af[LexerActionType.PUSH_MODE] = (data12, data22) => new LexerPushModeAction(data12);
        af[LexerActionType.SKIP] = (data12, data22) => LexerSkipAction.INSTANCE;
        af[LexerActionType.TYPE] = (data12, data22) => new LexerTypeAction(data12);
        this.actionFactories = af;
      }
      if (type > this.actionFactories.length || this.actionFactories[type] === null) {
        throw "The specified lexer action type " + type + " is not valid.";
      } else {
        return this.actionFactories[type](data1, data2);
      }
    }
  };
  function createByteToHex() {
    const bth = [];
    for (let i = 0; i < 256; i++) {
      bth[i] = (i + 256).toString(16).substr(1).toUpperCase();
    }
    return bth;
  }
  var byteToHex = createByteToHex();
  module2.exports = ATNDeserializer3;
});

// node_modules/antlr4/src/antlr4/error/ErrorListener.js
var require_ErrorListener = __commonJS((exports, module2) => {
  var ErrorListener2 = class {
    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
    }
    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
    }
    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
    }
    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
    }
  };
  var ConsoleErrorListener = class extends ErrorListener2 {
    constructor() {
      super();
    }
    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
      console.error("line " + line + ":" + column + " " + msg);
    }
  };
  ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();
  var ProxyErrorListener = class extends ErrorListener2 {
    constructor(delegates) {
      super();
      if (delegates === null) {
        throw "delegates";
      }
      this.delegates = delegates;
      return this;
    }
    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
      this.delegates.map((d) => d.syntaxError(recognizer, offendingSymbol, line, column, msg, e));
    }
    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
      this.delegates.map((d) => d.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs));
    }
    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
      this.delegates.map((d) => d.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs));
    }
    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
      this.delegates.map((d) => d.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs));
    }
  };
  module2.exports = {ErrorListener: ErrorListener2, ConsoleErrorListener, ProxyErrorListener};
});

// node_modules/antlr4/src/antlr4/Recognizer.js
var require_Recognizer2 = __commonJS((exports, module2) => {
  var {Token: Token2} = require_Token2();
  var {ConsoleErrorListener} = require_ErrorListener();
  var {ProxyErrorListener} = require_ErrorListener();
  var Recognizer = class {
    constructor() {
      this._listeners = [ConsoleErrorListener.INSTANCE];
      this._interp = null;
      this._stateNumber = -1;
    }
    checkVersion(toolVersion) {
      const runtimeVersion = "4.9.2";
      if (runtimeVersion !== toolVersion) {
        console.log("ANTLR runtime and generated code versions disagree: " + runtimeVersion + "!=" + toolVersion);
      }
    }
    addErrorListener(listener) {
      this._listeners.push(listener);
    }
    removeErrorListeners() {
      this._listeners = [];
    }
    getTokenTypeMap() {
      const tokenNames = this.getTokenNames();
      if (tokenNames === null) {
        throw "The current recognizer does not provide a list of token names.";
      }
      let result = this.tokenTypeMapCache[tokenNames];
      if (result === void 0) {
        result = tokenNames.reduce(function(o, k, i) {
          o[k] = i;
        });
        result.EOF = Token2.EOF;
        this.tokenTypeMapCache[tokenNames] = result;
      }
      return result;
    }
    getRuleIndexMap() {
      const ruleNames = this.ruleNames;
      if (ruleNames === null) {
        throw "The current recognizer does not provide a list of rule names.";
      }
      let result = this.ruleIndexMapCache[ruleNames];
      if (result === void 0) {
        result = ruleNames.reduce(function(o, k, i) {
          o[k] = i;
        });
        this.ruleIndexMapCache[ruleNames] = result;
      }
      return result;
    }
    getTokenType(tokenName) {
      const ttype = this.getTokenTypeMap()[tokenName];
      if (ttype !== void 0) {
        return ttype;
      } else {
        return Token2.INVALID_TYPE;
      }
    }
    getErrorHeader(e) {
      const line = e.getOffendingToken().line;
      const column = e.getOffendingToken().column;
      return "line " + line + ":" + column;
    }
    getTokenErrorDisplay(t) {
      if (t === null) {
        return "<no token>";
      }
      let s = t.text;
      if (s === null) {
        if (t.type === Token2.EOF) {
          s = "<EOF>";
        } else {
          s = "<" + t.type + ">";
        }
      }
      s = s.replace("\n", "\\n").replace("\r", "\\r").replace("	", "\\t");
      return "'" + s + "'";
    }
    getErrorListenerDispatch() {
      return new ProxyErrorListener(this._listeners);
    }
    sempred(localctx, ruleIndex, actionIndex) {
      return true;
    }
    precpred(localctx, precedence) {
      return true;
    }
    get state() {
      return this._stateNumber;
    }
    set state(state) {
      this._stateNumber = state;
    }
  };
  Recognizer.tokenTypeMapCache = {};
  Recognizer.ruleIndexMapCache = {};
  module2.exports = Recognizer;
});

// node_modules/antlr4/src/antlr4/CommonTokenFactory.js
var require_CommonTokenFactory2 = __commonJS((exports, module2) => {
  var CommonToken = require_Token2().CommonToken;
  var TokenFactory = class {
  };
  var CommonTokenFactory = class extends TokenFactory {
    constructor(copyText) {
      super();
      this.copyText = copyText === void 0 ? false : copyText;
    }
    create(source, type, text, channel, start, stop, line, column) {
      const t = new CommonToken(source, type, channel, start, stop);
      t.line = line;
      t.column = column;
      if (text !== null) {
        t.text = text;
      } else if (this.copyText && source[1] !== null) {
        t.text = source[1].getText(start, stop);
      }
      return t;
    }
    createThin(type, text) {
      const t = new CommonToken(null, type);
      t.text = text;
      return t;
    }
  };
  CommonTokenFactory.DEFAULT = new CommonTokenFactory();
  module2.exports = CommonTokenFactory;
});

// node_modules/antlr4/src/antlr4/error/Errors.js
var require_Errors = __commonJS((exports, module2) => {
  var {PredicateTransition} = require_Transition2();
  var {Interval} = require_IntervalSet2().Interval;
  var RecognitionException2 = class extends Error {
    constructor(params) {
      super(params.message);
      if (!!Error.captureStackTrace) {
        Error.captureStackTrace(this, RecognitionException2);
      } else {
        var stack = new Error().stack;
      }
      this.message = params.message;
      this.recognizer = params.recognizer;
      this.input = params.input;
      this.ctx = params.ctx;
      this.offendingToken = null;
      this.offendingState = -1;
      if (this.recognizer !== null) {
        this.offendingState = this.recognizer.state;
      }
    }
    getExpectedTokens() {
      if (this.recognizer !== null) {
        return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);
      } else {
        return null;
      }
    }
    toString() {
      return this.message;
    }
  };
  var LexerNoViableAltException = class extends RecognitionException2 {
    constructor(lexer, input, startIndex, deadEndConfigs) {
      super({message: "", recognizer: lexer, input, ctx: null});
      this.startIndex = startIndex;
      this.deadEndConfigs = deadEndConfigs;
    }
    toString() {
      let symbol = "";
      if (this.startIndex >= 0 && this.startIndex < this.input.size) {
        symbol = this.input.getText(new Interval(this.startIndex, this.startIndex));
      }
      return "LexerNoViableAltException" + symbol;
    }
  };
  var NoViableAltException2 = class extends RecognitionException2 {
    constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {
      ctx = ctx || recognizer._ctx;
      offendingToken = offendingToken || recognizer.getCurrentToken();
      startToken = startToken || recognizer.getCurrentToken();
      input = input || recognizer.getInputStream();
      super({message: "", recognizer, input, ctx});
      this.deadEndConfigs = deadEndConfigs;
      this.startToken = startToken;
      this.offendingToken = offendingToken;
    }
  };
  var InputMismatchException = class extends RecognitionException2 {
    constructor(recognizer) {
      super({message: "", recognizer, input: recognizer.getInputStream(), ctx: recognizer._ctx});
      this.offendingToken = recognizer.getCurrentToken();
    }
  };
  function formatMessage(predicate, message) {
    if (message !== null) {
      return message;
    } else {
      return "failed predicate: {" + predicate + "}?";
    }
  }
  var FailedPredicateException2 = class extends RecognitionException2 {
    constructor(recognizer, predicate, message) {
      super({
        message: formatMessage(predicate, message || null),
        recognizer,
        input: recognizer.getInputStream(),
        ctx: recognizer._ctx
      });
      const s = recognizer._interp.atn.states[recognizer.state];
      const trans = s.transitions[0];
      if (trans instanceof PredicateTransition) {
        this.ruleIndex = trans.ruleIndex;
        this.predicateIndex = trans.predIndex;
      } else {
        this.ruleIndex = 0;
        this.predicateIndex = 0;
      }
      this.predicate = predicate;
      this.offendingToken = recognizer.getCurrentToken();
    }
  };
  var ParseCancellationException = class extends Error {
    constructor() {
      super();
      Error.captureStackTrace(this, ParseCancellationException);
    }
  };
  module2.exports = {
    RecognitionException: RecognitionException2,
    NoViableAltException: NoViableAltException2,
    LexerNoViableAltException,
    InputMismatchException,
    FailedPredicateException: FailedPredicateException2,
    ParseCancellationException
  };
});

// node_modules/antlr4/src/antlr4/Lexer.js
var require_Lexer2 = __commonJS((exports, module2) => {
  var {Token: Token2} = require_Token2();
  var Recognizer = require_Recognizer2();
  var CommonTokenFactory = require_CommonTokenFactory2();
  var {RecognitionException: RecognitionException2} = require_Errors();
  var {LexerNoViableAltException} = require_Errors();
  var Lexer2 = class extends Recognizer {
    constructor(input) {
      super();
      this._input = input;
      this._factory = CommonTokenFactory.DEFAULT;
      this._tokenFactorySourcePair = [this, input];
      this._interp = null;
      this._token = null;
      this._tokenStartCharIndex = -1;
      this._tokenStartLine = -1;
      this._tokenStartColumn = -1;
      this._hitEOF = false;
      this._channel = Token2.DEFAULT_CHANNEL;
      this._type = Token2.INVALID_TYPE;
      this._modeStack = [];
      this._mode = Lexer2.DEFAULT_MODE;
      this._text = null;
    }
    reset() {
      if (this._input !== null) {
        this._input.seek(0);
      }
      this._token = null;
      this._type = Token2.INVALID_TYPE;
      this._channel = Token2.DEFAULT_CHANNEL;
      this._tokenStartCharIndex = -1;
      this._tokenStartColumn = -1;
      this._tokenStartLine = -1;
      this._text = null;
      this._hitEOF = false;
      this._mode = Lexer2.DEFAULT_MODE;
      this._modeStack = [];
      this._interp.reset();
    }
    nextToken() {
      if (this._input === null) {
        throw "nextToken requires a non-null input stream.";
      }
      const tokenStartMarker = this._input.mark();
      try {
        while (true) {
          if (this._hitEOF) {
            this.emitEOF();
            return this._token;
          }
          this._token = null;
          this._channel = Token2.DEFAULT_CHANNEL;
          this._tokenStartCharIndex = this._input.index;
          this._tokenStartColumn = this._interp.column;
          this._tokenStartLine = this._interp.line;
          this._text = null;
          let continueOuter = false;
          while (true) {
            this._type = Token2.INVALID_TYPE;
            let ttype = Lexer2.SKIP;
            try {
              ttype = this._interp.match(this._input, this._mode);
            } catch (e) {
              if (e instanceof RecognitionException2) {
                this.notifyListeners(e);
                this.recover(e);
              } else {
                console.log(e.stack);
                throw e;
              }
            }
            if (this._input.LA(1) === Token2.EOF) {
              this._hitEOF = true;
            }
            if (this._type === Token2.INVALID_TYPE) {
              this._type = ttype;
            }
            if (this._type === Lexer2.SKIP) {
              continueOuter = true;
              break;
            }
            if (this._type !== Lexer2.MORE) {
              break;
            }
          }
          if (continueOuter) {
            continue;
          }
          if (this._token === null) {
            this.emit();
          }
          return this._token;
        }
      } finally {
        this._input.release(tokenStartMarker);
      }
    }
    skip() {
      this._type = Lexer2.SKIP;
    }
    more() {
      this._type = Lexer2.MORE;
    }
    mode(m) {
      this._mode = m;
    }
    pushMode(m) {
      if (this._interp.debug) {
        console.log("pushMode " + m);
      }
      this._modeStack.push(this._mode);
      this.mode(m);
    }
    popMode() {
      if (this._modeStack.length === 0) {
        throw "Empty Stack";
      }
      if (this._interp.debug) {
        console.log("popMode back to " + this._modeStack.slice(0, -1));
      }
      this.mode(this._modeStack.pop());
      return this._mode;
    }
    emitToken(token) {
      this._token = token;
    }
    emit() {
      const t = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.getCharIndex() - 1, this._tokenStartLine, this._tokenStartColumn);
      this.emitToken(t);
      return t;
    }
    emitEOF() {
      const cpos = this.column;
      const lpos = this.line;
      const eof = this._factory.create(this._tokenFactorySourcePair, Token2.EOF, null, Token2.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, lpos, cpos);
      this.emitToken(eof);
      return eof;
    }
    getCharIndex() {
      return this._input.index;
    }
    getAllTokens() {
      const tokens2 = [];
      let t = this.nextToken();
      while (t.type !== Token2.EOF) {
        tokens2.push(t);
        t = this.nextToken();
      }
      return tokens2;
    }
    notifyListeners(e) {
      const start = this._tokenStartCharIndex;
      const stop = this._input.index;
      const text = this._input.getText(start, stop);
      const msg = "token recognition error at: '" + this.getErrorDisplay(text) + "'";
      const listener = this.getErrorListenerDispatch();
      listener.syntaxError(this, null, this._tokenStartLine, this._tokenStartColumn, msg, e);
    }
    getErrorDisplay(s) {
      const d = [];
      for (let i = 0; i < s.length; i++) {
        d.push(s[i]);
      }
      return d.join("");
    }
    getErrorDisplayForChar(c) {
      if (c.charCodeAt(0) === Token2.EOF) {
        return "<EOF>";
      } else if (c === "\n") {
        return "\\n";
      } else if (c === "	") {
        return "\\t";
      } else if (c === "\r") {
        return "\\r";
      } else {
        return c;
      }
    }
    getCharErrorDisplay(c) {
      return "'" + this.getErrorDisplayForChar(c) + "'";
    }
    recover(re) {
      if (this._input.LA(1) !== Token2.EOF) {
        if (re instanceof LexerNoViableAltException) {
          this._interp.consume(this._input);
        } else {
          this._input.consume();
        }
      }
    }
    get inputStream() {
      return this._input;
    }
    set inputStream(input) {
      this._input = null;
      this._tokenFactorySourcePair = [this, this._input];
      this.reset();
      this._input = input;
      this._tokenFactorySourcePair = [this, this._input];
    }
    get sourceName() {
      return this._input.sourceName;
    }
    get type() {
      return this.type;
    }
    set type(type) {
      this._type = type;
    }
    get line() {
      return this._interp.line;
    }
    set line(line) {
      this._interp.line = line;
    }
    get column() {
      return this._interp.column;
    }
    set column(column) {
      this._interp.column = column;
    }
    get text() {
      if (this._text !== null) {
        return this._text;
      } else {
        return this._interp.getText(this._input);
      }
    }
    set text(text) {
      this._text = text;
    }
  };
  Lexer2.DEFAULT_MODE = 0;
  Lexer2.MORE = -2;
  Lexer2.SKIP = -3;
  Lexer2.DEFAULT_TOKEN_CHANNEL = Token2.DEFAULT_CHANNEL;
  Lexer2.HIDDEN = Token2.HIDDEN_CHANNEL;
  Lexer2.MIN_CHAR_VALUE = 0;
  Lexer2.MAX_CHAR_VALUE = 1114111;
  module2.exports = Lexer2;
});

// node_modules/antlr4/src/antlr4/atn/ATNConfigSet.js
var require_ATNConfigSet2 = __commonJS((exports, module2) => {
  var ATN2 = require_ATN2();
  var Utils3 = require_Utils2();
  var {SemanticContext} = require_SemanticContext2();
  var {merge} = require_PredictionContext2();
  function hashATNConfig(c) {
    return c.hashCodeForConfigSet();
  }
  function equalATNConfigs(a, b) {
    if (a === b) {
      return true;
    } else if (a === null || b === null) {
      return false;
    } else
      return a.equalsForConfigSet(b);
  }
  var ATNConfigSet = class {
    constructor(fullCtx) {
      this.configLookup = new Utils3.Set(hashATNConfig, equalATNConfigs);
      this.fullCtx = fullCtx === void 0 ? true : fullCtx;
      this.readOnly = false;
      this.configs = [];
      this.uniqueAlt = 0;
      this.conflictingAlts = null;
      this.hasSemanticContext = false;
      this.dipsIntoOuterContext = false;
      this.cachedHashCode = -1;
    }
    add(config, mergeCache) {
      if (mergeCache === void 0) {
        mergeCache = null;
      }
      if (this.readOnly) {
        throw "This set is readonly";
      }
      if (config.semanticContext !== SemanticContext.NONE) {
        this.hasSemanticContext = true;
      }
      if (config.reachesIntoOuterContext > 0) {
        this.dipsIntoOuterContext = true;
      }
      const existing = this.configLookup.add(config);
      if (existing === config) {
        this.cachedHashCode = -1;
        this.configs.push(config);
        return true;
      }
      const rootIsWildcard = !this.fullCtx;
      const merged = merge(existing.context, config.context, rootIsWildcard, mergeCache);
      existing.reachesIntoOuterContext = Math.max(existing.reachesIntoOuterContext, config.reachesIntoOuterContext);
      if (config.precedenceFilterSuppressed) {
        existing.precedenceFilterSuppressed = true;
      }
      existing.context = merged;
      return true;
    }
    getStates() {
      const states = new Utils3.Set();
      for (let i = 0; i < this.configs.length; i++) {
        states.add(this.configs[i].state);
      }
      return states;
    }
    getPredicates() {
      const preds = [];
      for (let i = 0; i < this.configs.length; i++) {
        const c = this.configs[i].semanticContext;
        if (c !== SemanticContext.NONE) {
          preds.push(c.semanticContext);
        }
      }
      return preds;
    }
    optimizeConfigs(interpreter) {
      if (this.readOnly) {
        throw "This set is readonly";
      }
      if (this.configLookup.length === 0) {
        return;
      }
      for (let i = 0; i < this.configs.length; i++) {
        const config = this.configs[i];
        config.context = interpreter.getCachedContext(config.context);
      }
    }
    addAll(coll) {
      for (let i = 0; i < coll.length; i++) {
        this.add(coll[i]);
      }
      return false;
    }
    equals(other) {
      return this === other || other instanceof ATNConfigSet && Utils3.equalArrays(this.configs, other.configs) && this.fullCtx === other.fullCtx && this.uniqueAlt === other.uniqueAlt && this.conflictingAlts === other.conflictingAlts && this.hasSemanticContext === other.hasSemanticContext && this.dipsIntoOuterContext === other.dipsIntoOuterContext;
    }
    hashCode() {
      const hash = new Utils3.Hash();
      hash.update(this.configs);
      return hash.finish();
    }
    updateHashCode(hash) {
      if (this.readOnly) {
        if (this.cachedHashCode === -1) {
          this.cachedHashCode = this.hashCode();
        }
        hash.update(this.cachedHashCode);
      } else {
        hash.update(this.hashCode());
      }
    }
    isEmpty() {
      return this.configs.length === 0;
    }
    contains(item) {
      if (this.configLookup === null) {
        throw "This method is not implemented for readonly sets.";
      }
      return this.configLookup.contains(item);
    }
    containsFast(item) {
      if (this.configLookup === null) {
        throw "This method is not implemented for readonly sets.";
      }
      return this.configLookup.containsFast(item);
    }
    clear() {
      if (this.readOnly) {
        throw "This set is readonly";
      }
      this.configs = [];
      this.cachedHashCode = -1;
      this.configLookup = new Utils3.Set();
    }
    setReadonly(readOnly) {
      this.readOnly = readOnly;
      if (readOnly) {
        this.configLookup = null;
      }
    }
    toString() {
      return Utils3.arrayToString(this.configs) + (this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") + (this.uniqueAlt !== ATN2.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") + (this.conflictingAlts !== null ? ",conflictingAlts=" + this.conflictingAlts : "") + (this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
    }
    get items() {
      return this.configs;
    }
    get length() {
      return this.configs.length;
    }
  };
  var OrderedATNConfigSet = class extends ATNConfigSet {
    constructor() {
      super();
      this.configLookup = new Utils3.Set();
    }
  };
  module2.exports = {
    ATNConfigSet,
    OrderedATNConfigSet
  };
});

// node_modules/antlr4/src/antlr4/dfa/DFAState.js
var require_DFAState2 = __commonJS((exports, module2) => {
  var {ATNConfigSet} = require_ATNConfigSet2();
  var {Hash: Hash2, Set: Set2} = require_Utils2();
  var PredPrediction = class {
    constructor(pred, alt) {
      this.alt = alt;
      this.pred = pred;
    }
    toString() {
      return "(" + this.pred + ", " + this.alt + ")";
    }
  };
  var DFAState = class {
    constructor(stateNumber, configs) {
      if (stateNumber === null) {
        stateNumber = -1;
      }
      if (configs === null) {
        configs = new ATNConfigSet();
      }
      this.stateNumber = stateNumber;
      this.configs = configs;
      this.edges = null;
      this.isAcceptState = false;
      this.prediction = 0;
      this.lexerActionExecutor = null;
      this.requiresFullContext = false;
      this.predicates = null;
      return this;
    }
    getAltSet() {
      const alts = new Set2();
      if (this.configs !== null) {
        for (let i = 0; i < this.configs.length; i++) {
          const c = this.configs[i];
          alts.add(c.alt);
        }
      }
      if (alts.length === 0) {
        return null;
      } else {
        return alts;
      }
    }
    equals(other) {
      return this === other || other instanceof DFAState && this.configs.equals(other.configs);
    }
    toString() {
      let s = "" + this.stateNumber + ":" + this.configs;
      if (this.isAcceptState) {
        s = s + "=>";
        if (this.predicates !== null)
          s = s + this.predicates;
        else
          s = s + this.prediction;
      }
      return s;
    }
    hashCode() {
      const hash = new Hash2();
      hash.update(this.configs);
      return hash.finish();
    }
  };
  module2.exports = {DFAState, PredPrediction};
});

// node_modules/antlr4/src/antlr4/atn/ATNSimulator.js
var require_ATNSimulator2 = __commonJS((exports, module2) => {
  var {DFAState} = require_DFAState2();
  var {ATNConfigSet} = require_ATNConfigSet2();
  var {getCachedPredictionContext} = require_PredictionContext2();
  var {Map: Map2} = require_Utils2();
  var ATNSimulator = class {
    constructor(atn, sharedContextCache) {
      this.atn = atn;
      this.sharedContextCache = sharedContextCache;
      return this;
    }
    getCachedContext(context) {
      if (this.sharedContextCache === null) {
        return context;
      }
      const visited = new Map2();
      return getCachedPredictionContext(context, this.sharedContextCache, visited);
    }
  };
  ATNSimulator.ERROR = new DFAState(2147483647, new ATNConfigSet());
  module2.exports = ATNSimulator;
});

// node_modules/antlr4/src/antlr4/atn/LexerActionExecutor.js
var require_LexerActionExecutor2 = __commonJS((exports, module2) => {
  var {hashStuff} = require_Utils2();
  var {LexerIndexedCustomAction} = require_LexerAction();
  var LexerActionExecutor = class {
    constructor(lexerActions) {
      this.lexerActions = lexerActions === null ? [] : lexerActions;
      this.cachedHashCode = hashStuff(lexerActions);
      return this;
    }
    fixOffsetBeforeMatch(offset) {
      let updatedLexerActions = null;
      for (let i = 0; i < this.lexerActions.length; i++) {
        if (this.lexerActions[i].isPositionDependent && !(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {
          if (updatedLexerActions === null) {
            updatedLexerActions = this.lexerActions.concat([]);
          }
          updatedLexerActions[i] = new LexerIndexedCustomAction(offset, this.lexerActions[i]);
        }
      }
      if (updatedLexerActions === null) {
        return this;
      } else {
        return new LexerActionExecutor(updatedLexerActions);
      }
    }
    execute(lexer, input, startIndex) {
      let requiresSeek = false;
      const stopIndex = input.index;
      try {
        for (let i = 0; i < this.lexerActions.length; i++) {
          let lexerAction = this.lexerActions[i];
          if (lexerAction instanceof LexerIndexedCustomAction) {
            const offset = lexerAction.offset;
            input.seek(startIndex + offset);
            lexerAction = lexerAction.action;
            requiresSeek = startIndex + offset !== stopIndex;
          } else if (lexerAction.isPositionDependent) {
            input.seek(stopIndex);
            requiresSeek = false;
          }
          lexerAction.execute(lexer);
        }
      } finally {
        if (requiresSeek) {
          input.seek(stopIndex);
        }
      }
    }
    hashCode() {
      return this.cachedHashCode;
    }
    updateHashCode(hash) {
      hash.update(this.cachedHashCode);
    }
    equals(other) {
      if (this === other) {
        return true;
      } else if (!(other instanceof LexerActionExecutor)) {
        return false;
      } else if (this.cachedHashCode != other.cachedHashCode) {
        return false;
      } else if (this.lexerActions.length != other.lexerActions.length) {
        return false;
      } else {
        const numActions = this.lexerActions.length;
        for (let idx = 0; idx < numActions; ++idx) {
          if (!this.lexerActions[idx].equals(other.lexerActions[idx])) {
            return false;
          }
        }
        return true;
      }
    }
    static append(lexerActionExecutor, lexerAction) {
      if (lexerActionExecutor === null) {
        return new LexerActionExecutor([lexerAction]);
      }
      const lexerActions = lexerActionExecutor.lexerActions.concat([lexerAction]);
      return new LexerActionExecutor(lexerActions);
    }
  };
  module2.exports = LexerActionExecutor;
});

// node_modules/antlr4/src/antlr4/atn/LexerATNSimulator.js
var require_LexerATNSimulator2 = __commonJS((exports, module2) => {
  var {Token: Token2} = require_Token2();
  var Lexer2 = require_Lexer2();
  var ATN2 = require_ATN2();
  var ATNSimulator = require_ATNSimulator2();
  var {DFAState} = require_DFAState2();
  var {OrderedATNConfigSet} = require_ATNConfigSet2();
  var {PredictionContext} = require_PredictionContext2();
  var {SingletonPredictionContext} = require_PredictionContext2();
  var {RuleStopState} = require_ATNState2();
  var {LexerATNConfig} = require_ATNConfig2();
  var {Transition} = require_Transition2();
  var LexerActionExecutor = require_LexerActionExecutor2();
  var {LexerNoViableAltException} = require_Errors();
  function resetSimState(sim) {
    sim.index = -1;
    sim.line = 0;
    sim.column = -1;
    sim.dfaState = null;
  }
  var SimState = class {
    constructor() {
      resetSimState(this);
    }
    reset() {
      resetSimState(this);
    }
  };
  var LexerATNSimulator2 = class extends ATNSimulator {
    constructor(recog, atn, decisionToDFA, sharedContextCache) {
      super(atn, sharedContextCache);
      this.decisionToDFA = decisionToDFA;
      this.recog = recog;
      this.startIndex = -1;
      this.line = 1;
      this.column = 0;
      this.mode = Lexer2.DEFAULT_MODE;
      this.prevAccept = new SimState();
    }
    copyState(simulator) {
      this.column = simulator.column;
      this.line = simulator.line;
      this.mode = simulator.mode;
      this.startIndex = simulator.startIndex;
    }
    match(input, mode) {
      this.match_calls += 1;
      this.mode = mode;
      const mark = input.mark();
      try {
        this.startIndex = input.index;
        this.prevAccept.reset();
        const dfa = this.decisionToDFA[mode];
        if (dfa.s0 === null) {
          return this.matchATN(input);
        } else {
          return this.execATN(input, dfa.s0);
        }
      } finally {
        input.release(mark);
      }
    }
    reset() {
      this.prevAccept.reset();
      this.startIndex = -1;
      this.line = 1;
      this.column = 0;
      this.mode = Lexer2.DEFAULT_MODE;
    }
    matchATN(input) {
      const startState = this.atn.modeToStartState[this.mode];
      if (LexerATNSimulator2.debug) {
        console.log("matchATN mode " + this.mode + " start: " + startState);
      }
      const old_mode = this.mode;
      const s0_closure = this.computeStartState(input, startState);
      const suppressEdge = s0_closure.hasSemanticContext;
      s0_closure.hasSemanticContext = false;
      const next = this.addDFAState(s0_closure);
      if (!suppressEdge) {
        this.decisionToDFA[this.mode].s0 = next;
      }
      const predict = this.execATN(input, next);
      if (LexerATNSimulator2.debug) {
        console.log("DFA after matchATN: " + this.decisionToDFA[old_mode].toLexerString());
      }
      return predict;
    }
    execATN(input, ds0) {
      if (LexerATNSimulator2.debug) {
        console.log("start state closure=" + ds0.configs);
      }
      if (ds0.isAcceptState) {
        this.captureSimState(this.prevAccept, input, ds0);
      }
      let t = input.LA(1);
      let s = ds0;
      while (true) {
        if (LexerATNSimulator2.debug) {
          console.log("execATN loop starting closure: " + s.configs);
        }
        let target = this.getExistingTargetState(s, t);
        if (target === null) {
          target = this.computeTargetState(input, s, t);
        }
        if (target === ATNSimulator.ERROR) {
          break;
        }
        if (t !== Token2.EOF) {
          this.consume(input);
        }
        if (target.isAcceptState) {
          this.captureSimState(this.prevAccept, input, target);
          if (t === Token2.EOF) {
            break;
          }
        }
        t = input.LA(1);
        s = target;
      }
      return this.failOrAccept(this.prevAccept, input, s.configs, t);
    }
    getExistingTargetState(s, t) {
      if (s.edges === null || t < LexerATNSimulator2.MIN_DFA_EDGE || t > LexerATNSimulator2.MAX_DFA_EDGE) {
        return null;
      }
      let target = s.edges[t - LexerATNSimulator2.MIN_DFA_EDGE];
      if (target === void 0) {
        target = null;
      }
      if (LexerATNSimulator2.debug && target !== null) {
        console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
      }
      return target;
    }
    computeTargetState(input, s, t) {
      const reach = new OrderedATNConfigSet();
      this.getReachableConfigSet(input, s.configs, reach, t);
      if (reach.items.length === 0) {
        if (!reach.hasSemanticContext) {
          this.addDFAEdge(s, t, ATNSimulator.ERROR);
        }
        return ATNSimulator.ERROR;
      }
      return this.addDFAEdge(s, t, null, reach);
    }
    failOrAccept(prevAccept, input, reach, t) {
      if (this.prevAccept.dfaState !== null) {
        const lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;
        this.accept(input, lexerActionExecutor, this.startIndex, prevAccept.index, prevAccept.line, prevAccept.column);
        return prevAccept.dfaState.prediction;
      } else {
        if (t === Token2.EOF && input.index === this.startIndex) {
          return Token2.EOF;
        }
        throw new LexerNoViableAltException(this.recog, input, this.startIndex, reach);
      }
    }
    getReachableConfigSet(input, closure, reach, t) {
      let skipAlt = ATN2.INVALID_ALT_NUMBER;
      for (let i = 0; i < closure.items.length; i++) {
        const cfg = closure.items[i];
        const currentAltReachedAcceptState = cfg.alt === skipAlt;
        if (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {
          continue;
        }
        if (LexerATNSimulator2.debug) {
          console.log("testing %s at %s\n", this.getTokenName(t), cfg.toString(this.recog, true));
        }
        for (let j = 0; j < cfg.state.transitions.length; j++) {
          const trans = cfg.state.transitions[j];
          const target = this.getReachableTarget(trans, t);
          if (target !== null) {
            let lexerActionExecutor = cfg.lexerActionExecutor;
            if (lexerActionExecutor !== null) {
              lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
            }
            const treatEofAsEpsilon = t === Token2.EOF;
            const config = new LexerATNConfig({state: target, lexerActionExecutor}, cfg);
            if (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {
              skipAlt = cfg.alt;
            }
          }
        }
      }
    }
    accept(input, lexerActionExecutor, startIndex, index, line, charPos) {
      if (LexerATNSimulator2.debug) {
        console.log("ACTION %s\n", lexerActionExecutor);
      }
      input.seek(index);
      this.line = line;
      this.column = charPos;
      if (lexerActionExecutor !== null && this.recog !== null) {
        lexerActionExecutor.execute(this.recog, input, startIndex);
      }
    }
    getReachableTarget(trans, t) {
      if (trans.matches(t, 0, Lexer2.MAX_CHAR_VALUE)) {
        return trans.target;
      } else {
        return null;
      }
    }
    computeStartState(input, p) {
      const initialContext = PredictionContext.EMPTY;
      const configs = new OrderedATNConfigSet();
      for (let i = 0; i < p.transitions.length; i++) {
        const target = p.transitions[i].target;
        const cfg = new LexerATNConfig({state: target, alt: i + 1, context: initialContext}, null);
        this.closure(input, cfg, configs, false, false, false);
      }
      return configs;
    }
    closure(input, config, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
      let cfg = null;
      if (LexerATNSimulator2.debug) {
        console.log("closure(" + config.toString(this.recog, true) + ")");
      }
      if (config.state instanceof RuleStopState) {
        if (LexerATNSimulator2.debug) {
          if (this.recog !== null) {
            console.log("closure at %s rule stop %s\n", this.recog.ruleNames[config.state.ruleIndex], config);
          } else {
            console.log("closure at rule stop %s\n", config);
          }
        }
        if (config.context === null || config.context.hasEmptyPath()) {
          if (config.context === null || config.context.isEmpty()) {
            configs.add(config);
            return true;
          } else {
            configs.add(new LexerATNConfig({state: config.state, context: PredictionContext.EMPTY}, config));
            currentAltReachedAcceptState = true;
          }
        }
        if (config.context !== null && !config.context.isEmpty()) {
          for (let i = 0; i < config.context.length; i++) {
            if (config.context.getReturnState(i) !== PredictionContext.EMPTY_RETURN_STATE) {
              const newContext = config.context.getParent(i);
              const returnState = this.atn.states[config.context.getReturnState(i)];
              cfg = new LexerATNConfig({state: returnState, context: newContext}, config);
              currentAltReachedAcceptState = this.closure(input, cfg, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
            }
          }
        }
        return currentAltReachedAcceptState;
      }
      if (!config.state.epsilonOnlyTransitions) {
        if (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {
          configs.add(config);
        }
      }
      for (let j = 0; j < config.state.transitions.length; j++) {
        const trans = config.state.transitions[j];
        cfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);
        if (cfg !== null) {
          currentAltReachedAcceptState = this.closure(input, cfg, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
        }
      }
      return currentAltReachedAcceptState;
    }
    getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon) {
      let cfg = null;
      if (trans.serializationType === Transition.RULE) {
        const newContext = SingletonPredictionContext.create(config.context, trans.followState.stateNumber);
        cfg = new LexerATNConfig({state: trans.target, context: newContext}, config);
      } else if (trans.serializationType === Transition.PRECEDENCE) {
        throw "Precedence predicates are not supported in lexers.";
      } else if (trans.serializationType === Transition.PREDICATE) {
        if (LexerATNSimulator2.debug) {
          console.log("EVAL rule " + trans.ruleIndex + ":" + trans.predIndex);
        }
        configs.hasSemanticContext = true;
        if (this.evaluatePredicate(input, trans.ruleIndex, trans.predIndex, speculative)) {
          cfg = new LexerATNConfig({state: trans.target}, config);
        }
      } else if (trans.serializationType === Transition.ACTION) {
        if (config.context === null || config.context.hasEmptyPath()) {
          const lexerActionExecutor = LexerActionExecutor.append(config.lexerActionExecutor, this.atn.lexerActions[trans.actionIndex]);
          cfg = new LexerATNConfig({state: trans.target, lexerActionExecutor}, config);
        } else {
          cfg = new LexerATNConfig({state: trans.target}, config);
        }
      } else if (trans.serializationType === Transition.EPSILON) {
        cfg = new LexerATNConfig({state: trans.target}, config);
      } else if (trans.serializationType === Transition.ATOM || trans.serializationType === Transition.RANGE || trans.serializationType === Transition.SET) {
        if (treatEofAsEpsilon) {
          if (trans.matches(Token2.EOF, 0, Lexer2.MAX_CHAR_VALUE)) {
            cfg = new LexerATNConfig({state: trans.target}, config);
          }
        }
      }
      return cfg;
    }
    evaluatePredicate(input, ruleIndex, predIndex, speculative) {
      if (this.recog === null) {
        return true;
      }
      if (!speculative) {
        return this.recog.sempred(null, ruleIndex, predIndex);
      }
      const savedcolumn = this.column;
      const savedLine = this.line;
      const index = input.index;
      const marker = input.mark();
      try {
        this.consume(input);
        return this.recog.sempred(null, ruleIndex, predIndex);
      } finally {
        this.column = savedcolumn;
        this.line = savedLine;
        input.seek(index);
        input.release(marker);
      }
    }
    captureSimState(settings, input, dfaState) {
      settings.index = input.index;
      settings.line = this.line;
      settings.column = this.column;
      settings.dfaState = dfaState;
    }
    addDFAEdge(from_, tk, to, cfgs) {
      if (to === void 0) {
        to = null;
      }
      if (cfgs === void 0) {
        cfgs = null;
      }
      if (to === null && cfgs !== null) {
        const suppressEdge = cfgs.hasSemanticContext;
        cfgs.hasSemanticContext = false;
        to = this.addDFAState(cfgs);
        if (suppressEdge) {
          return to;
        }
      }
      if (tk < LexerATNSimulator2.MIN_DFA_EDGE || tk > LexerATNSimulator2.MAX_DFA_EDGE) {
        return to;
      }
      if (LexerATNSimulator2.debug) {
        console.log("EDGE " + from_ + " -> " + to + " upon " + tk);
      }
      if (from_.edges === null) {
        from_.edges = [];
      }
      from_.edges[tk - LexerATNSimulator2.MIN_DFA_EDGE] = to;
      return to;
    }
    addDFAState(configs) {
      const proposed = new DFAState(null, configs);
      let firstConfigWithRuleStopState = null;
      for (let i = 0; i < configs.items.length; i++) {
        const cfg = configs.items[i];
        if (cfg.state instanceof RuleStopState) {
          firstConfigWithRuleStopState = cfg;
          break;
        }
      }
      if (firstConfigWithRuleStopState !== null) {
        proposed.isAcceptState = true;
        proposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
        proposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
      }
      const dfa = this.decisionToDFA[this.mode];
      const existing = dfa.states.get(proposed);
      if (existing !== null) {
        return existing;
      }
      const newState = proposed;
      newState.stateNumber = dfa.states.length;
      configs.setReadonly(true);
      newState.configs = configs;
      dfa.states.add(newState);
      return newState;
    }
    getDFA(mode) {
      return this.decisionToDFA[mode];
    }
    getText(input) {
      return input.getText(this.startIndex, input.index - 1);
    }
    consume(input) {
      const curChar = input.LA(1);
      if (curChar === "\n".charCodeAt(0)) {
        this.line += 1;
        this.column = 0;
      } else {
        this.column += 1;
      }
      input.consume();
    }
    getTokenName(tt) {
      if (tt === -1) {
        return "EOF";
      } else {
        return "'" + String.fromCharCode(tt) + "'";
      }
    }
  };
  LexerATNSimulator2.debug = false;
  LexerATNSimulator2.dfa_debug = false;
  LexerATNSimulator2.MIN_DFA_EDGE = 0;
  LexerATNSimulator2.MAX_DFA_EDGE = 127;
  LexerATNSimulator2.match_calls = 0;
  module2.exports = LexerATNSimulator2;
});

// node_modules/antlr4/src/antlr4/atn/PredictionMode.js
var require_PredictionMode2 = __commonJS((exports, module2) => {
  var {Map: Map2, BitSet, AltDict, hashStuff} = require_Utils2();
  var ATN2 = require_ATN2();
  var {RuleStopState} = require_ATNState2();
  var {ATNConfigSet} = require_ATNConfigSet2();
  var {ATNConfig} = require_ATNConfig2();
  var {SemanticContext} = require_SemanticContext2();
  var PredictionMode = {
    SLL: 0,
    LL: 1,
    LL_EXACT_AMBIG_DETECTION: 2,
    hasSLLConflictTerminatingPrediction: function(mode, configs) {
      if (PredictionMode.allConfigsInRuleStopStates(configs)) {
        return true;
      }
      if (mode === PredictionMode.SLL) {
        if (configs.hasSemanticContext) {
          const dup = new ATNConfigSet();
          for (let i = 0; i < configs.items.length; i++) {
            let c = configs.items[i];
            c = new ATNConfig({semanticContext: SemanticContext.NONE}, c);
            dup.add(c);
          }
          configs = dup;
        }
      }
      const altsets = PredictionMode.getConflictingAltSubsets(configs);
      return PredictionMode.hasConflictingAltSet(altsets) && !PredictionMode.hasStateAssociatedWithOneAlt(configs);
    },
    hasConfigInRuleStopState: function(configs) {
      for (let i = 0; i < configs.items.length; i++) {
        const c = configs.items[i];
        if (c.state instanceof RuleStopState) {
          return true;
        }
      }
      return false;
    },
    allConfigsInRuleStopStates: function(configs) {
      for (let i = 0; i < configs.items.length; i++) {
        const c = configs.items[i];
        if (!(c.state instanceof RuleStopState)) {
          return false;
        }
      }
      return true;
    },
    resolvesToJustOneViableAlt: function(altsets) {
      return PredictionMode.getSingleViableAlt(altsets);
    },
    allSubsetsConflict: function(altsets) {
      return !PredictionMode.hasNonConflictingAltSet(altsets);
    },
    hasNonConflictingAltSet: function(altsets) {
      for (let i = 0; i < altsets.length; i++) {
        const alts = altsets[i];
        if (alts.length === 1) {
          return true;
        }
      }
      return false;
    },
    hasConflictingAltSet: function(altsets) {
      for (let i = 0; i < altsets.length; i++) {
        const alts = altsets[i];
        if (alts.length > 1) {
          return true;
        }
      }
      return false;
    },
    allSubsetsEqual: function(altsets) {
      let first = null;
      for (let i = 0; i < altsets.length; i++) {
        const alts = altsets[i];
        if (first === null) {
          first = alts;
        } else if (alts !== first) {
          return false;
        }
      }
      return true;
    },
    getUniqueAlt: function(altsets) {
      const all = PredictionMode.getAlts(altsets);
      if (all.length === 1) {
        return all.minValue();
      } else {
        return ATN2.INVALID_ALT_NUMBER;
      }
    },
    getAlts: function(altsets) {
      const all = new BitSet();
      altsets.map(function(alts) {
        all.or(alts);
      });
      return all;
    },
    getConflictingAltSubsets: function(configs) {
      const configToAlts = new Map2();
      configToAlts.hashFunction = function(cfg) {
        hashStuff(cfg.state.stateNumber, cfg.context);
      };
      configToAlts.equalsFunction = function(c1, c2) {
        return c1.state.stateNumber === c2.state.stateNumber && c1.context.equals(c2.context);
      };
      configs.items.map(function(cfg) {
        let alts = configToAlts.get(cfg);
        if (alts === null) {
          alts = new BitSet();
          configToAlts.put(cfg, alts);
        }
        alts.add(cfg.alt);
      });
      return configToAlts.getValues();
    },
    getStateToAltMap: function(configs) {
      const m = new AltDict();
      configs.items.map(function(c) {
        let alts = m.get(c.state);
        if (alts === null) {
          alts = new BitSet();
          m.put(c.state, alts);
        }
        alts.add(c.alt);
      });
      return m;
    },
    hasStateAssociatedWithOneAlt: function(configs) {
      const values = PredictionMode.getStateToAltMap(configs).values();
      for (let i = 0; i < values.length; i++) {
        if (values[i].length === 1) {
          return true;
        }
      }
      return false;
    },
    getSingleViableAlt: function(altsets) {
      let result = null;
      for (let i = 0; i < altsets.length; i++) {
        const alts = altsets[i];
        const minAlt = alts.minValue();
        if (result === null) {
          result = minAlt;
        } else if (result !== minAlt) {
          return ATN2.INVALID_ALT_NUMBER;
        }
      }
      return result;
    }
  };
  module2.exports = PredictionMode;
});

// node_modules/antlr4/src/antlr4/ParserRuleContext.js
var require_ParserRuleContext2 = __commonJS((exports, module2) => {
  var RuleContext = require_RuleContext2();
  var Tree = require_Tree();
  var INVALID_INTERVAL = Tree.INVALID_INTERVAL;
  var TerminalNode = Tree.TerminalNode;
  var TerminalNodeImpl = Tree.TerminalNodeImpl;
  var ErrorNodeImpl = Tree.ErrorNodeImpl;
  var Interval = require_IntervalSet2().Interval;
  var ParserRuleContext2 = class extends RuleContext {
    constructor(parent, invokingStateNumber) {
      parent = parent || null;
      invokingStateNumber = invokingStateNumber || null;
      super(parent, invokingStateNumber);
      this.ruleIndex = -1;
      this.children = null;
      this.start = null;
      this.stop = null;
      this.exception = null;
    }
    copyFrom(ctx) {
      this.parentCtx = ctx.parentCtx;
      this.invokingState = ctx.invokingState;
      this.children = null;
      this.start = ctx.start;
      this.stop = ctx.stop;
      if (ctx.children) {
        this.children = [];
        ctx.children.map(function(child) {
          if (child instanceof ErrorNodeImpl) {
            this.children.push(child);
            child.parentCtx = this;
          }
        }, this);
      }
    }
    enterRule(listener) {
    }
    exitRule(listener) {
    }
    addChild(child) {
      if (this.children === null) {
        this.children = [];
      }
      this.children.push(child);
      return child;
    }
    removeLastChild() {
      if (this.children !== null) {
        this.children.pop();
      }
    }
    addTokenNode(token) {
      const node = new TerminalNodeImpl(token);
      this.addChild(node);
      node.parentCtx = this;
      return node;
    }
    addErrorNode(badToken) {
      const node = new ErrorNodeImpl(badToken);
      this.addChild(node);
      node.parentCtx = this;
      return node;
    }
    getChild(i, type) {
      type = type || null;
      if (this.children === null || i < 0 || i >= this.children.length) {
        return null;
      }
      if (type === null) {
        return this.children[i];
      } else {
        for (let j = 0; j < this.children.length; j++) {
          const child = this.children[j];
          if (child instanceof type) {
            if (i === 0) {
              return child;
            } else {
              i -= 1;
            }
          }
        }
        return null;
      }
    }
    getToken(ttype, i) {
      if (this.children === null || i < 0 || i >= this.children.length) {
        return null;
      }
      for (let j = 0; j < this.children.length; j++) {
        const child = this.children[j];
        if (child instanceof TerminalNode) {
          if (child.symbol.type === ttype) {
            if (i === 0) {
              return child;
            } else {
              i -= 1;
            }
          }
        }
      }
      return null;
    }
    getTokens(ttype) {
      if (this.children === null) {
        return [];
      } else {
        const tokens2 = [];
        for (let j = 0; j < this.children.length; j++) {
          const child = this.children[j];
          if (child instanceof TerminalNode) {
            if (child.symbol.type === ttype) {
              tokens2.push(child);
            }
          }
        }
        return tokens2;
      }
    }
    getTypedRuleContext(ctxType, i) {
      return this.getChild(i, ctxType);
    }
    getTypedRuleContexts(ctxType) {
      if (this.children === null) {
        return [];
      } else {
        const contexts = [];
        for (let j = 0; j < this.children.length; j++) {
          const child = this.children[j];
          if (child instanceof ctxType) {
            contexts.push(child);
          }
        }
        return contexts;
      }
    }
    getChildCount() {
      if (this.children === null) {
        return 0;
      } else {
        return this.children.length;
      }
    }
    getSourceInterval() {
      if (this.start === null || this.stop === null) {
        return INVALID_INTERVAL;
      } else {
        return new Interval(this.start.tokenIndex, this.stop.tokenIndex);
      }
    }
  };
  RuleContext.EMPTY = new ParserRuleContext2();
  module2.exports = ParserRuleContext2;
});

// node_modules/antlr4/src/antlr4/atn/ParserATNSimulator.js
var require_ParserATNSimulator2 = __commonJS((exports, module2) => {
  var Utils3 = require_Utils2();
  var {Set: Set2, BitSet, DoubleDict} = Utils3;
  var ATN2 = require_ATN2();
  var {ATNState, RuleStopState} = require_ATNState2();
  var {ATNConfig} = require_ATNConfig2();
  var {ATNConfigSet} = require_ATNConfigSet2();
  var {Token: Token2} = require_Token2();
  var {DFAState, PredPrediction} = require_DFAState2();
  var ATNSimulator = require_ATNSimulator2();
  var PredictionMode = require_PredictionMode2();
  var RuleContext = require_RuleContext2();
  var ParserRuleContext2 = require_ParserRuleContext2();
  var {SemanticContext} = require_SemanticContext2();
  var {PredictionContext} = require_PredictionContext2();
  var {Interval} = require_IntervalSet2();
  var {Transition, SetTransition, NotSetTransition, RuleTransition, ActionTransition} = require_Transition2();
  var {NoViableAltException: NoViableAltException2} = require_Errors();
  var {SingletonPredictionContext, predictionContextFromRuleContext} = require_PredictionContext2();
  var ParserATNSimulator2 = class extends ATNSimulator {
    constructor(parser, atn, decisionToDFA, sharedContextCache) {
      super(atn, sharedContextCache);
      this.parser = parser;
      this.decisionToDFA = decisionToDFA;
      this.predictionMode = PredictionMode.LL;
      this._input = null;
      this._startIndex = 0;
      this._outerContext = null;
      this._dfa = null;
      this.mergeCache = null;
      this.debug = false;
      this.debug_closure = false;
      this.debug_add = false;
      this.debug_list_atn_decisions = false;
      this.dfa_debug = false;
      this.retry_debug = false;
    }
    reset() {
    }
    adaptivePredict(input, decision, outerContext) {
      if (this.debug || this.debug_list_atn_decisions) {
        console.log("adaptivePredict decision " + decision + " exec LA(1)==" + this.getLookaheadName(input) + " line " + input.LT(1).line + ":" + input.LT(1).column);
      }
      this._input = input;
      this._startIndex = input.index;
      this._outerContext = outerContext;
      const dfa = this.decisionToDFA[decision];
      this._dfa = dfa;
      const m = input.mark();
      const index = input.index;
      try {
        let s0;
        if (dfa.precedenceDfa) {
          s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());
        } else {
          s0 = dfa.s0;
        }
        if (s0 === null) {
          if (outerContext === null) {
            outerContext = RuleContext.EMPTY;
          }
          if (this.debug || this.debug_list_atn_decisions) {
            console.log("predictATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this.parser.ruleNames));
          }
          const fullCtx = false;
          let s0_closure = this.computeStartState(dfa.atnStartState, RuleContext.EMPTY, fullCtx);
          if (dfa.precedenceDfa) {
            dfa.s0.configs = s0_closure;
            s0_closure = this.applyPrecedenceFilter(s0_closure);
            s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));
            dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);
          } else {
            s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));
            dfa.s0 = s0;
          }
        }
        const alt = this.execATN(dfa, s0, input, index, outerContext);
        if (this.debug) {
          console.log("DFA after predictATN: " + dfa.toString(this.parser.literalNames));
        }
        return alt;
      } finally {
        this._dfa = null;
        this.mergeCache = null;
        input.seek(index);
        input.release(m);
      }
    }
    execATN(dfa, s0, input, startIndex, outerContext) {
      if (this.debug || this.debug_list_atn_decisions) {
        console.log("execATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + " line " + input.LT(1).line + ":" + input.LT(1).column);
      }
      let alt;
      let previousD = s0;
      if (this.debug) {
        console.log("s0 = " + s0);
      }
      let t = input.LA(1);
      while (true) {
        let D = this.getExistingTargetState(previousD, t);
        if (D === null) {
          D = this.computeTargetState(dfa, previousD, t);
        }
        if (D === ATNSimulator.ERROR) {
          const e = this.noViableAlt(input, outerContext, previousD.configs, startIndex);
          input.seek(startIndex);
          alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousD.configs, outerContext);
          if (alt !== ATN2.INVALID_ALT_NUMBER) {
            return alt;
          } else {
            throw e;
          }
        }
        if (D.requiresFullContext && this.predictionMode !== PredictionMode.SLL) {
          let conflictingAlts = null;
          if (D.predicates !== null) {
            if (this.debug) {
              console.log("DFA state has preds in DFA sim LL failover");
            }
            const conflictIndex = input.index;
            if (conflictIndex !== startIndex) {
              input.seek(startIndex);
            }
            conflictingAlts = this.evalSemanticContext(D.predicates, outerContext, true);
            if (conflictingAlts.length === 1) {
              if (this.debug) {
                console.log("Full LL avoided");
              }
              return conflictingAlts.minValue();
            }
            if (conflictIndex !== startIndex) {
              input.seek(conflictIndex);
            }
          }
          if (this.dfa_debug) {
            console.log("ctx sensitive state " + outerContext + " in " + D);
          }
          const fullCtx = true;
          const s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);
          this.reportAttemptingFullContext(dfa, conflictingAlts, D.configs, startIndex, input.index);
          alt = this.execATNWithFullContext(dfa, D, s0_closure, input, startIndex, outerContext);
          return alt;
        }
        if (D.isAcceptState) {
          if (D.predicates === null) {
            return D.prediction;
          }
          const stopIndex = input.index;
          input.seek(startIndex);
          const alts = this.evalSemanticContext(D.predicates, outerContext, true);
          if (alts.length === 0) {
            throw this.noViableAlt(input, outerContext, D.configs, startIndex);
          } else if (alts.length === 1) {
            return alts.minValue();
          } else {
            this.reportAmbiguity(dfa, D, startIndex, stopIndex, false, alts, D.configs);
            return alts.minValue();
          }
        }
        previousD = D;
        if (t !== Token2.EOF) {
          input.consume();
          t = input.LA(1);
        }
      }
    }
    getExistingTargetState(previousD, t) {
      const edges = previousD.edges;
      if (edges === null) {
        return null;
      } else {
        return edges[t + 1] || null;
      }
    }
    computeTargetState(dfa, previousD, t) {
      const reach = this.computeReachSet(previousD.configs, t, false);
      if (reach === null) {
        this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);
        return ATNSimulator.ERROR;
      }
      let D = new DFAState(null, reach);
      const predictedAlt = this.getUniqueAlt(reach);
      if (this.debug) {
        const altSubSets = PredictionMode.getConflictingAltSubsets(reach);
        console.log("SLL altSubSets=" + Utils3.arrayToString(altSubSets) + ", previous=" + previousD.configs + ", configs=" + reach + ", predict=" + predictedAlt + ", allSubsetsConflict=" + PredictionMode.allSubsetsConflict(altSubSets) + ", conflictingAlts=" + this.getConflictingAlts(reach));
      }
      if (predictedAlt !== ATN2.INVALID_ALT_NUMBER) {
        D.isAcceptState = true;
        D.configs.uniqueAlt = predictedAlt;
        D.prediction = predictedAlt;
      } else if (PredictionMode.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {
        D.configs.conflictingAlts = this.getConflictingAlts(reach);
        D.requiresFullContext = true;
        D.isAcceptState = true;
        D.prediction = D.configs.conflictingAlts.minValue();
      }
      if (D.isAcceptState && D.configs.hasSemanticContext) {
        this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));
        if (D.predicates !== null) {
          D.prediction = ATN2.INVALID_ALT_NUMBER;
        }
      }
      D = this.addDFAEdge(dfa, previousD, t, D);
      return D;
    }
    predicateDFAState(dfaState, decisionState) {
      const nalts = decisionState.transitions.length;
      const altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);
      const altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, nalts);
      if (altToPred !== null) {
        dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);
        dfaState.prediction = ATN2.INVALID_ALT_NUMBER;
      } else {
        dfaState.prediction = altsToCollectPredsFrom.minValue();
      }
    }
    execATNWithFullContext(dfa, D, s0, input, startIndex, outerContext) {
      if (this.debug || this.debug_list_atn_decisions) {
        console.log("execATNWithFullContext " + s0);
      }
      const fullCtx = true;
      let foundExactAmbig = false;
      let reach;
      let previous = s0;
      input.seek(startIndex);
      let t = input.LA(1);
      let predictedAlt = -1;
      while (true) {
        reach = this.computeReachSet(previous, t, fullCtx);
        if (reach === null) {
          const e = this.noViableAlt(input, outerContext, previous, startIndex);
          input.seek(startIndex);
          const alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);
          if (alt !== ATN2.INVALID_ALT_NUMBER) {
            return alt;
          } else {
            throw e;
          }
        }
        const altSubSets = PredictionMode.getConflictingAltSubsets(reach);
        if (this.debug) {
          console.log("LL altSubSets=" + altSubSets + ", predict=" + PredictionMode.getUniqueAlt(altSubSets) + ", resolvesToJustOneViableAlt=" + PredictionMode.resolvesToJustOneViableAlt(altSubSets));
        }
        reach.uniqueAlt = this.getUniqueAlt(reach);
        if (reach.uniqueAlt !== ATN2.INVALID_ALT_NUMBER) {
          predictedAlt = reach.uniqueAlt;
          break;
        } else if (this.predictionMode !== PredictionMode.LL_EXACT_AMBIG_DETECTION) {
          predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);
          if (predictedAlt !== ATN2.INVALID_ALT_NUMBER) {
            break;
          }
        } else {
          if (PredictionMode.allSubsetsConflict(altSubSets) && PredictionMode.allSubsetsEqual(altSubSets)) {
            foundExactAmbig = true;
            predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);
            break;
          }
        }
        previous = reach;
        if (t !== Token2.EOF) {
          input.consume();
          t = input.LA(1);
        }
      }
      if (reach.uniqueAlt !== ATN2.INVALID_ALT_NUMBER) {
        this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);
        return predictedAlt;
      }
      this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, null, reach);
      return predictedAlt;
    }
    computeReachSet(closure, t, fullCtx) {
      if (this.debug) {
        console.log("in computeReachSet, starting closure: " + closure);
      }
      if (this.mergeCache === null) {
        this.mergeCache = new DoubleDict();
      }
      const intermediate = new ATNConfigSet(fullCtx);
      let skippedStopStates = null;
      for (let i = 0; i < closure.items.length; i++) {
        const c = closure.items[i];
        if (this.debug) {
          console.log("testing " + this.getTokenName(t) + " at " + c);
        }
        if (c.state instanceof RuleStopState) {
          if (fullCtx || t === Token2.EOF) {
            if (skippedStopStates === null) {
              skippedStopStates = [];
            }
            skippedStopStates.push(c);
            if (this.debug_add) {
              console.log("added " + c + " to skippedStopStates");
            }
          }
          continue;
        }
        for (let j = 0; j < c.state.transitions.length; j++) {
          const trans = c.state.transitions[j];
          const target = this.getReachableTarget(trans, t);
          if (target !== null) {
            const cfg = new ATNConfig({state: target}, c);
            intermediate.add(cfg, this.mergeCache);
            if (this.debug_add) {
              console.log("added " + cfg + " to intermediate");
            }
          }
        }
      }
      let reach = null;
      if (skippedStopStates === null && t !== Token2.EOF) {
        if (intermediate.items.length === 1) {
          reach = intermediate;
        } else if (this.getUniqueAlt(intermediate) !== ATN2.INVALID_ALT_NUMBER) {
          reach = intermediate;
        }
      }
      if (reach === null) {
        reach = new ATNConfigSet(fullCtx);
        const closureBusy = new Set2();
        const treatEofAsEpsilon = t === Token2.EOF;
        for (let k = 0; k < intermediate.items.length; k++) {
          this.closure(intermediate.items[k], reach, closureBusy, false, fullCtx, treatEofAsEpsilon);
        }
      }
      if (t === Token2.EOF) {
        reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);
      }
      if (skippedStopStates !== null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {
        for (let l = 0; l < skippedStopStates.length; l++) {
          reach.add(skippedStopStates[l], this.mergeCache);
        }
      }
      if (reach.items.length === 0) {
        return null;
      } else {
        return reach;
      }
    }
    removeAllConfigsNotInRuleStopState(configs, lookToEndOfRule) {
      if (PredictionMode.allConfigsInRuleStopStates(configs)) {
        return configs;
      }
      const result = new ATNConfigSet(configs.fullCtx);
      for (let i = 0; i < configs.items.length; i++) {
        const config = configs.items[i];
        if (config.state instanceof RuleStopState) {
          result.add(config, this.mergeCache);
          continue;
        }
        if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {
          const nextTokens = this.atn.nextTokens(config.state);
          if (nextTokens.contains(Token2.EPSILON)) {
            const endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];
            result.add(new ATNConfig({state: endOfRuleState}, config), this.mergeCache);
          }
        }
      }
      return result;
    }
    computeStartState(p, ctx, fullCtx) {
      const initialContext = predictionContextFromRuleContext(this.atn, ctx);
      const configs = new ATNConfigSet(fullCtx);
      for (let i = 0; i < p.transitions.length; i++) {
        const target = p.transitions[i].target;
        const c = new ATNConfig({state: target, alt: i + 1, context: initialContext}, null);
        const closureBusy = new Set2();
        this.closure(c, configs, closureBusy, true, fullCtx, false);
      }
      return configs;
    }
    applyPrecedenceFilter(configs) {
      let config;
      const statesFromAlt1 = [];
      const configSet = new ATNConfigSet(configs.fullCtx);
      for (let i = 0; i < configs.items.length; i++) {
        config = configs.items[i];
        if (config.alt !== 1) {
          continue;
        }
        const updatedContext = config.semanticContext.evalPrecedence(this.parser, this._outerContext);
        if (updatedContext === null) {
          continue;
        }
        statesFromAlt1[config.state.stateNumber] = config.context;
        if (updatedContext !== config.semanticContext) {
          configSet.add(new ATNConfig({semanticContext: updatedContext}, config), this.mergeCache);
        } else {
          configSet.add(config, this.mergeCache);
        }
      }
      for (let i = 0; i < configs.items.length; i++) {
        config = configs.items[i];
        if (config.alt === 1) {
          continue;
        }
        if (!config.precedenceFilterSuppressed) {
          const context = statesFromAlt1[config.state.stateNumber] || null;
          if (context !== null && context.equals(config.context)) {
            continue;
          }
        }
        configSet.add(config, this.mergeCache);
      }
      return configSet;
    }
    getReachableTarget(trans, ttype) {
      if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
        return trans.target;
      } else {
        return null;
      }
    }
    getPredsForAmbigAlts(ambigAlts, configs, nalts) {
      let altToPred = [];
      for (let i = 0; i < configs.items.length; i++) {
        const c = configs.items[i];
        if (ambigAlts.contains(c.alt)) {
          altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] || null, c.semanticContext);
        }
      }
      let nPredAlts = 0;
      for (let i = 1; i < nalts + 1; i++) {
        const pred = altToPred[i] || null;
        if (pred === null) {
          altToPred[i] = SemanticContext.NONE;
        } else if (pred !== SemanticContext.NONE) {
          nPredAlts += 1;
        }
      }
      if (nPredAlts === 0) {
        altToPred = null;
      }
      if (this.debug) {
        console.log("getPredsForAmbigAlts result " + Utils3.arrayToString(altToPred));
      }
      return altToPred;
    }
    getPredicatePredictions(ambigAlts, altToPred) {
      const pairs = [];
      let containsPredicate = false;
      for (let i = 1; i < altToPred.length; i++) {
        const pred = altToPred[i];
        if (ambigAlts !== null && ambigAlts.contains(i)) {
          pairs.push(new PredPrediction(pred, i));
        }
        if (pred !== SemanticContext.NONE) {
          containsPredicate = true;
        }
      }
      if (!containsPredicate) {
        return null;
      }
      return pairs;
    }
    getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(configs, outerContext) {
      const cfgs = this.splitAccordingToSemanticValidity(configs, outerContext);
      const semValidConfigs = cfgs[0];
      const semInvalidConfigs = cfgs[1];
      let alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);
      if (alt !== ATN2.INVALID_ALT_NUMBER) {
        return alt;
      }
      if (semInvalidConfigs.items.length > 0) {
        alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);
        if (alt !== ATN2.INVALID_ALT_NUMBER) {
          return alt;
        }
      }
      return ATN2.INVALID_ALT_NUMBER;
    }
    getAltThatFinishedDecisionEntryRule(configs) {
      const alts = [];
      for (let i = 0; i < configs.items.length; i++) {
        const c = configs.items[i];
        if (c.reachesIntoOuterContext > 0 || c.state instanceof RuleStopState && c.context.hasEmptyPath()) {
          if (alts.indexOf(c.alt) < 0) {
            alts.push(c.alt);
          }
        }
      }
      if (alts.length === 0) {
        return ATN2.INVALID_ALT_NUMBER;
      } else {
        return Math.min.apply(null, alts);
      }
    }
    splitAccordingToSemanticValidity(configs, outerContext) {
      const succeeded = new ATNConfigSet(configs.fullCtx);
      const failed = new ATNConfigSet(configs.fullCtx);
      for (let i = 0; i < configs.items.length; i++) {
        const c = configs.items[i];
        if (c.semanticContext !== SemanticContext.NONE) {
          const predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);
          if (predicateEvaluationResult) {
            succeeded.add(c);
          } else {
            failed.add(c);
          }
        } else {
          succeeded.add(c);
        }
      }
      return [succeeded, failed];
    }
    evalSemanticContext(predPredictions, outerContext, complete) {
      const predictions = new BitSet();
      for (let i = 0; i < predPredictions.length; i++) {
        const pair = predPredictions[i];
        if (pair.pred === SemanticContext.NONE) {
          predictions.add(pair.alt);
          if (!complete) {
            break;
          }
          continue;
        }
        const predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);
        if (this.debug || this.dfa_debug) {
          console.log("eval pred " + pair + "=" + predicateEvaluationResult);
        }
        if (predicateEvaluationResult) {
          if (this.debug || this.dfa_debug) {
            console.log("PREDICT " + pair.alt);
          }
          predictions.add(pair.alt);
          if (!complete) {
            break;
          }
        }
      }
      return predictions;
    }
    closure(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {
      const initialDepth = 0;
      this.closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, initialDepth, treatEofAsEpsilon);
    }
    closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
      if (this.debug || this.debug_closure) {
        console.log("closure(" + config.toString(this.parser, true) + ")");
        if (config.reachesIntoOuterContext > 50) {
          throw "problem";
        }
      }
      if (config.state instanceof RuleStopState) {
        if (!config.context.isEmpty()) {
          for (let i = 0; i < config.context.length; i++) {
            if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {
              if (fullCtx) {
                configs.add(new ATNConfig({state: config.state, context: PredictionContext.EMPTY}, config), this.mergeCache);
                continue;
              } else {
                if (this.debug) {
                  console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
                }
                this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);
              }
              continue;
            }
            const returnState = this.atn.states[config.context.getReturnState(i)];
            const newContext = config.context.getParent(i);
            const parms = {state: returnState, alt: config.alt, context: newContext, semanticContext: config.semanticContext};
            const c = new ATNConfig(parms, null);
            c.reachesIntoOuterContext = config.reachesIntoOuterContext;
            this.closureCheckingStopState(c, configs, closureBusy, collectPredicates, fullCtx, depth - 1, treatEofAsEpsilon);
          }
          return;
        } else if (fullCtx) {
          configs.add(config, this.mergeCache);
          return;
        } else {
          if (this.debug) {
            console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
          }
        }
      }
      this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);
    }
    closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
      const p = config.state;
      if (!p.epsilonOnlyTransitions) {
        configs.add(config, this.mergeCache);
      }
      for (let i = 0; i < p.transitions.length; i++) {
        if (i === 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config))
          continue;
        const t = p.transitions[i];
        const continueCollecting = collectPredicates && !(t instanceof ActionTransition);
        const c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);
        if (c !== null) {
          let newDepth = depth;
          if (config.state instanceof RuleStopState) {
            if (this._dfa !== null && this._dfa.precedenceDfa) {
              if (t.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex) {
                c.precedenceFilterSuppressed = true;
              }
            }
            c.reachesIntoOuterContext += 1;
            if (closureBusy.add(c) !== c) {
              continue;
            }
            configs.dipsIntoOuterContext = true;
            newDepth -= 1;
            if (this.debug) {
              console.log("dips into outer ctx: " + c);
            }
          } else {
            if (!t.isEpsilon && closureBusy.add(c) !== c) {
              continue;
            }
            if (t instanceof RuleTransition) {
              if (newDepth >= 0) {
                newDepth += 1;
              }
            }
          }
          this.closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);
        }
      }
    }
    canDropLoopEntryEdgeInLeftRecursiveRule(config) {
      const p = config.state;
      if (p.stateType !== ATNState.STAR_LOOP_ENTRY)
        return false;
      if (p.stateType !== ATNState.STAR_LOOP_ENTRY || !p.isPrecedenceDecision || config.context.isEmpty() || config.context.hasEmptyPath())
        return false;
      const numCtxs = config.context.length;
      for (let i = 0; i < numCtxs; i++) {
        const returnState = this.atn.states[config.context.getReturnState(i)];
        if (returnState.ruleIndex !== p.ruleIndex)
          return false;
      }
      const decisionStartState = p.transitions[0].target;
      const blockEndStateNum = decisionStartState.endState.stateNumber;
      const blockEndState = this.atn.states[blockEndStateNum];
      for (let i = 0; i < numCtxs; i++) {
        const returnStateNumber = config.context.getReturnState(i);
        const returnState = this.atn.states[returnStateNumber];
        if (returnState.transitions.length !== 1 || !returnState.transitions[0].isEpsilon)
          return false;
        const returnStateTarget = returnState.transitions[0].target;
        if (returnState.stateType === ATNState.BLOCK_END && returnStateTarget === p)
          continue;
        if (returnState === blockEndState)
          continue;
        if (returnStateTarget === blockEndState)
          continue;
        if (returnStateTarget.stateType === ATNState.BLOCK_END && returnStateTarget.transitions.length === 1 && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target === p)
          continue;
        return false;
      }
      return true;
    }
    getRuleName(index) {
      if (this.parser !== null && index >= 0) {
        return this.parser.ruleNames[index];
      } else {
        return "<rule " + index + ">";
      }
    }
    getEpsilonTarget(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {
      switch (t.serializationType) {
        case Transition.RULE:
          return this.ruleTransition(config, t);
        case Transition.PRECEDENCE:
          return this.precedenceTransition(config, t, collectPredicates, inContext, fullCtx);
        case Transition.PREDICATE:
          return this.predTransition(config, t, collectPredicates, inContext, fullCtx);
        case Transition.ACTION:
          return this.actionTransition(config, t);
        case Transition.EPSILON:
          return new ATNConfig({state: t.target}, config);
        case Transition.ATOM:
        case Transition.RANGE:
        case Transition.SET:
          if (treatEofAsEpsilon) {
            if (t.matches(Token2.EOF, 0, 1)) {
              return new ATNConfig({state: t.target}, config);
            }
          }
          return null;
        default:
          return null;
      }
    }
    actionTransition(config, t) {
      if (this.debug) {
        const index = t.actionIndex === -1 ? 65535 : t.actionIndex;
        console.log("ACTION edge " + t.ruleIndex + ":" + index);
      }
      return new ATNConfig({state: t.target}, config);
    }
    precedenceTransition(config, pt, collectPredicates, inContext, fullCtx) {
      if (this.debug) {
        console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.precedence + ">=_p, ctx dependent=true");
        if (this.parser !== null) {
          console.log("context surrounding pred is " + Utils3.arrayToString(this.parser.getRuleInvocationStack()));
        }
      }
      let c = null;
      if (collectPredicates && inContext) {
        if (fullCtx) {
          const currentPosition = this._input.index;
          this._input.seek(this._startIndex);
          const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);
          this._input.seek(currentPosition);
          if (predSucceeds) {
            c = new ATNConfig({state: pt.target}, config);
          }
        } else {
          const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
          c = new ATNConfig({state: pt.target, semanticContext: newSemCtx}, config);
        }
      } else {
        c = new ATNConfig({state: pt.target}, config);
      }
      if (this.debug) {
        console.log("config from pred transition=" + c);
      }
      return c;
    }
    predTransition(config, pt, collectPredicates, inContext, fullCtx) {
      if (this.debug) {
        console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex + ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
        if (this.parser !== null) {
          console.log("context surrounding pred is " + Utils3.arrayToString(this.parser.getRuleInvocationStack()));
        }
      }
      let c = null;
      if (collectPredicates && (pt.isCtxDependent && inContext || !pt.isCtxDependent)) {
        if (fullCtx) {
          const currentPosition = this._input.index;
          this._input.seek(this._startIndex);
          const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);
          this._input.seek(currentPosition);
          if (predSucceeds) {
            c = new ATNConfig({state: pt.target}, config);
          }
        } else {
          const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
          c = new ATNConfig({state: pt.target, semanticContext: newSemCtx}, config);
        }
      } else {
        c = new ATNConfig({state: pt.target}, config);
      }
      if (this.debug) {
        console.log("config from pred transition=" + c);
      }
      return c;
    }
    ruleTransition(config, t) {
      if (this.debug) {
        console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config.context);
      }
      const returnState = t.followState;
      const newContext = SingletonPredictionContext.create(config.context, returnState.stateNumber);
      return new ATNConfig({state: t.target, context: newContext}, config);
    }
    getConflictingAlts(configs) {
      const altsets = PredictionMode.getConflictingAltSubsets(configs);
      return PredictionMode.getAlts(altsets);
    }
    getConflictingAltsOrUniqueAlt(configs) {
      let conflictingAlts = null;
      if (configs.uniqueAlt !== ATN2.INVALID_ALT_NUMBER) {
        conflictingAlts = new BitSet();
        conflictingAlts.add(configs.uniqueAlt);
      } else {
        conflictingAlts = configs.conflictingAlts;
      }
      return conflictingAlts;
    }
    getTokenName(t) {
      if (t === Token2.EOF) {
        return "EOF";
      }
      if (this.parser !== null && this.parser.literalNames !== null) {
        if (t >= this.parser.literalNames.length && t >= this.parser.symbolicNames.length) {
          console.log("" + t + " ttype out of range: " + this.parser.literalNames);
          console.log("" + this.parser.getInputStream().getTokens());
        } else {
          const name = this.parser.literalNames[t] || this.parser.symbolicNames[t];
          return name + "<" + t + ">";
        }
      }
      return "" + t;
    }
    getLookaheadName(input) {
      return this.getTokenName(input.LA(1));
    }
    dumpDeadEndConfigs(nvae) {
      console.log("dead end configs: ");
      const decs = nvae.getDeadEndConfigs();
      for (let i = 0; i < decs.length; i++) {
        const c = decs[i];
        let trans = "no edges";
        if (c.state.transitions.length > 0) {
          const t = c.state.transitions[0];
          if (t instanceof AtomTransition) {
            trans = "Atom " + this.getTokenName(t.label);
          } else if (t instanceof SetTransition) {
            const neg = t instanceof NotSetTransition;
            trans = (neg ? "~" : "") + "Set " + t.set;
          }
        }
        console.error(c.toString(this.parser, true) + ":" + trans);
      }
    }
    noViableAlt(input, outerContext, configs, startIndex) {
      return new NoViableAltException2(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
    }
    getUniqueAlt(configs) {
      let alt = ATN2.INVALID_ALT_NUMBER;
      for (let i = 0; i < configs.items.length; i++) {
        const c = configs.items[i];
        if (alt === ATN2.INVALID_ALT_NUMBER) {
          alt = c.alt;
        } else if (c.alt !== alt) {
          return ATN2.INVALID_ALT_NUMBER;
        }
      }
      return alt;
    }
    addDFAEdge(dfa, from_, t, to) {
      if (this.debug) {
        console.log("EDGE " + from_ + " -> " + to + " upon " + this.getTokenName(t));
      }
      if (to === null) {
        return null;
      }
      to = this.addDFAState(dfa, to);
      if (from_ === null || t < -1 || t > this.atn.maxTokenType) {
        return to;
      }
      if (from_.edges === null) {
        from_.edges = [];
      }
      from_.edges[t + 1] = to;
      if (this.debug) {
        const literalNames = this.parser === null ? null : this.parser.literalNames;
        const symbolicNames = this.parser === null ? null : this.parser.symbolicNames;
        console.log("DFA=\n" + dfa.toString(literalNames, symbolicNames));
      }
      return to;
    }
    addDFAState(dfa, D) {
      if (D === ATNSimulator.ERROR) {
        return D;
      }
      const existing = dfa.states.get(D);
      if (existing !== null) {
        return existing;
      }
      D.stateNumber = dfa.states.length;
      if (!D.configs.readOnly) {
        D.configs.optimizeConfigs(this);
        D.configs.setReadonly(true);
      }
      dfa.states.add(D);
      if (this.debug) {
        console.log("adding new DFA state: " + D);
      }
      return D;
    }
    reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {
      if (this.debug || this.retry_debug) {
        const interval = new Interval(startIndex, stopIndex + 1);
        console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + configs + ", input=" + this.parser.getTokenStream().getText(interval));
      }
      if (this.parser !== null) {
        this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, dfa, startIndex, stopIndex, conflictingAlts, configs);
      }
    }
    reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {
      if (this.debug || this.retry_debug) {
        const interval = new Interval(startIndex, stopIndex + 1);
        console.log("reportContextSensitivity decision=" + dfa.decision + ":" + configs + ", input=" + this.parser.getTokenStream().getText(interval));
      }
      if (this.parser !== null) {
        this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, dfa, startIndex, stopIndex, prediction, configs);
      }
    }
    reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
      if (this.debug || this.retry_debug) {
        const interval = new Interval(startIndex, stopIndex + 1);
        console.log("reportAmbiguity " + ambigAlts + ":" + configs + ", input=" + this.parser.getTokenStream().getText(interval));
      }
      if (this.parser !== null) {
        this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
      }
    }
  };
  module2.exports = ParserATNSimulator2;
});

// node_modules/antlr4/src/antlr4/atn/index.js
var require_atn = __commonJS((exports) => {
  exports.ATN = require_ATN2();
  exports.ATNDeserializer = require_ATNDeserializer2();
  exports.LexerATNSimulator = require_LexerATNSimulator2();
  exports.ParserATNSimulator = require_ParserATNSimulator2();
  exports.PredictionMode = require_PredictionMode2();
});

// node_modules/antlr4/src/antlr4/polyfills/codepointat.js
var require_codepointat = __commonJS(() => {
  if (!String.prototype.codePointAt) {
    (function() {
      "use strict";
      var defineProperty = function() {
        let result;
        try {
          const object = {};
          const $defineProperty = Object.defineProperty;
          result = $defineProperty(object, object, object) && $defineProperty;
        } catch (error) {
        }
        return result;
      }();
      const codePointAt = function(position) {
        if (this == null) {
          throw TypeError();
        }
        const string = String(this);
        const size = string.length;
        let index = position ? Number(position) : 0;
        if (index !== index) {
          index = 0;
        }
        if (index < 0 || index >= size) {
          return void 0;
        }
        const first = string.charCodeAt(index);
        let second;
        if (first >= 55296 && first <= 56319 && size > index + 1) {
          second = string.charCodeAt(index + 1);
          if (second >= 56320 && second <= 57343) {
            return (first - 55296) * 1024 + second - 56320 + 65536;
          }
        }
        return first;
      };
      if (defineProperty) {
        defineProperty(String.prototype, "codePointAt", {
          value: codePointAt,
          configurable: true,
          writable: true
        });
      } else {
        String.prototype.codePointAt = codePointAt;
      }
    })();
  }
});

// node_modules/antlr4/src/antlr4/dfa/DFASerializer.js
var require_DFASerializer2 = __commonJS((exports, module2) => {
  var DFASerializer = class {
    constructor(dfa, literalNames, symbolicNames) {
      this.dfa = dfa;
      this.literalNames = literalNames || [];
      this.symbolicNames = symbolicNames || [];
    }
    toString() {
      if (this.dfa.s0 === null) {
        return null;
      }
      let buf = "";
      const states = this.dfa.sortedStates();
      for (let i = 0; i < states.length; i++) {
        const s = states[i];
        if (s.edges !== null) {
          const n = s.edges.length;
          for (let j = 0; j < n; j++) {
            const t = s.edges[j] || null;
            if (t !== null && t.stateNumber !== 2147483647) {
              buf = buf.concat(this.getStateString(s));
              buf = buf.concat("-");
              buf = buf.concat(this.getEdgeLabel(j));
              buf = buf.concat("->");
              buf = buf.concat(this.getStateString(t));
              buf = buf.concat("\n");
            }
          }
        }
      }
      return buf.length === 0 ? null : buf;
    }
    getEdgeLabel(i) {
      if (i === 0) {
        return "EOF";
      } else if (this.literalNames !== null || this.symbolicNames !== null) {
        return this.literalNames[i - 1] || this.symbolicNames[i - 1];
      } else {
        return String.fromCharCode(i - 1);
      }
    }
    getStateString(s) {
      const baseStateStr = (s.isAcceptState ? ":" : "") + "s" + s.stateNumber + (s.requiresFullContext ? "^" : "");
      if (s.isAcceptState) {
        if (s.predicates !== null) {
          return baseStateStr + "=>" + s.predicates.toString();
        } else {
          return baseStateStr + "=>" + s.prediction.toString();
        }
      } else {
        return baseStateStr;
      }
    }
  };
  var LexerDFASerializer = class extends DFASerializer {
    constructor(dfa) {
      super(dfa, null);
    }
    getEdgeLabel(i) {
      return "'" + String.fromCharCode(i) + "'";
    }
  };
  module2.exports = {DFASerializer, LexerDFASerializer};
});

// node_modules/antlr4/src/antlr4/dfa/DFA.js
var require_DFA2 = __commonJS((exports, module2) => {
  var {Set: Set2} = require_Utils2();
  var {DFAState} = require_DFAState2();
  var {StarLoopEntryState} = require_ATNState2();
  var {ATNConfigSet} = require_ATNConfigSet2();
  var {DFASerializer} = require_DFASerializer2();
  var {LexerDFASerializer} = require_DFASerializer2();
  var DFA = class {
    constructor(atnStartState, decision) {
      if (decision === void 0) {
        decision = 0;
      }
      this.atnStartState = atnStartState;
      this.decision = decision;
      this._states = new Set2();
      this.s0 = null;
      this.precedenceDfa = false;
      if (atnStartState instanceof StarLoopEntryState) {
        if (atnStartState.isPrecedenceDecision) {
          this.precedenceDfa = true;
          const precedenceState = new DFAState(null, new ATNConfigSet());
          precedenceState.edges = [];
          precedenceState.isAcceptState = false;
          precedenceState.requiresFullContext = false;
          this.s0 = precedenceState;
        }
      }
    }
    getPrecedenceStartState(precedence) {
      if (!this.precedenceDfa) {
        throw "Only precedence DFAs may contain a precedence start state.";
      }
      if (precedence < 0 || precedence >= this.s0.edges.length) {
        return null;
      }
      return this.s0.edges[precedence] || null;
    }
    setPrecedenceStartState(precedence, startState) {
      if (!this.precedenceDfa) {
        throw "Only precedence DFAs may contain a precedence start state.";
      }
      if (precedence < 0) {
        return;
      }
      this.s0.edges[precedence] = startState;
    }
    setPrecedenceDfa(precedenceDfa) {
      if (this.precedenceDfa !== precedenceDfa) {
        this._states = new Set2();
        if (precedenceDfa) {
          const precedenceState = new DFAState(null, new ATNConfigSet());
          precedenceState.edges = [];
          precedenceState.isAcceptState = false;
          precedenceState.requiresFullContext = false;
          this.s0 = precedenceState;
        } else {
          this.s0 = null;
        }
        this.precedenceDfa = precedenceDfa;
      }
    }
    sortedStates() {
      const list = this._states.values();
      return list.sort(function(a, b) {
        return a.stateNumber - b.stateNumber;
      });
    }
    toString(literalNames, symbolicNames) {
      literalNames = literalNames || null;
      symbolicNames = symbolicNames || null;
      if (this.s0 === null) {
        return "";
      }
      const serializer = new DFASerializer(this, literalNames, symbolicNames);
      return serializer.toString();
    }
    toLexerString() {
      if (this.s0 === null) {
        return "";
      }
      const serializer = new LexerDFASerializer(this);
      return serializer.toString();
    }
    get states() {
      return this._states;
    }
  };
  module2.exports = DFA;
});

// node_modules/antlr4/src/antlr4/dfa/index.js
var require_dfa = __commonJS((exports) => {
  exports.DFA = require_DFA2();
  exports.DFASerializer = require_DFASerializer2().DFASerializer;
  exports.LexerDFASerializer = require_DFASerializer2().LexerDFASerializer;
  exports.PredPrediction = require_DFAState2().PredPrediction;
});

// node_modules/antlr4/src/antlr4/polyfills/fromcodepoint.js
var require_fromcodepoint = __commonJS(() => {
  if (!String.fromCodePoint) {
    (function() {
      const defineProperty = function() {
        let result;
        try {
          const object = {};
          const $defineProperty = Object.defineProperty;
          result = $defineProperty(object, object, object) && $defineProperty;
        } catch (error) {
        }
        return result;
      }();
      const stringFromCharCode = String.fromCharCode;
      const floor = Math.floor;
      const fromCodePoint = function(_) {
        const MAX_SIZE = 16384;
        const codeUnits = [];
        let highSurrogate;
        let lowSurrogate;
        let index = -1;
        const length = arguments.length;
        if (!length) {
          return "";
        }
        let result = "";
        while (++index < length) {
          let codePoint = Number(arguments[index]);
          if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) {
            throw RangeError("Invalid code point: " + codePoint);
          }
          if (codePoint <= 65535) {
            codeUnits.push(codePoint);
          } else {
            codePoint -= 65536;
            highSurrogate = (codePoint >> 10) + 55296;
            lowSurrogate = codePoint % 1024 + 56320;
            codeUnits.push(highSurrogate, lowSurrogate);
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits);
            codeUnits.length = 0;
          }
        }
        return result;
      };
      if (defineProperty) {
        defineProperty(String, "fromCodePoint", {
          value: fromCodePoint,
          configurable: true,
          writable: true
        });
      } else {
        String.fromCodePoint = fromCodePoint;
      }
    })();
  }
});

// node_modules/antlr4/src/antlr4/tree/index.js
var require_tree = __commonJS((exports, module2) => {
  var Tree = require_Tree();
  var Trees = require_Trees2();
  module2.exports = __objSpread(__objSpread({}, Tree), {Trees});
});

// node_modules/antlr4/src/antlr4/error/DiagnosticErrorListener.js
var require_DiagnosticErrorListener2 = __commonJS((exports, module2) => {
  var {BitSet} = require_Utils2();
  var {ErrorListener: ErrorListener2} = require_ErrorListener();
  var {Interval} = require_IntervalSet2();
  var DiagnosticErrorListener = class extends ErrorListener2 {
    constructor(exactOnly) {
      super();
      exactOnly = exactOnly || true;
      this.exactOnly = exactOnly;
    }
    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
      if (this.exactOnly && !exact) {
        return;
      }
      const msg = "reportAmbiguity d=" + this.getDecisionDescription(recognizer, dfa) + ": ambigAlts=" + this.getConflictingAlts(ambigAlts, configs) + ", input='" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
      recognizer.notifyErrorListeners(msg);
    }
    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
      const msg = "reportAttemptingFullContext d=" + this.getDecisionDescription(recognizer, dfa) + ", input='" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
      recognizer.notifyErrorListeners(msg);
    }
    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
      const msg = "reportContextSensitivity d=" + this.getDecisionDescription(recognizer, dfa) + ", input='" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
      recognizer.notifyErrorListeners(msg);
    }
    getDecisionDescription(recognizer, dfa) {
      const decision = dfa.decision;
      const ruleIndex = dfa.atnStartState.ruleIndex;
      const ruleNames = recognizer.ruleNames;
      if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
        return "" + decision;
      }
      const ruleName = ruleNames[ruleIndex] || null;
      if (ruleName === null || ruleName.length === 0) {
        return "" + decision;
      }
      return `${decision} (${ruleName})`;
    }
    getConflictingAlts(reportedAlts, configs) {
      if (reportedAlts !== null) {
        return reportedAlts;
      }
      const result = new BitSet();
      for (let i = 0; i < configs.items.length; i++) {
        result.add(configs.items[i].alt);
      }
      return `{${result.values().join(", ")}}`;
    }
  };
  module2.exports = DiagnosticErrorListener;
});

// node_modules/antlr4/src/antlr4/error/ErrorStrategy.js
var require_ErrorStrategy = __commonJS((exports, module2) => {
  var {Token: Token2} = require_Token2();
  var {NoViableAltException: NoViableAltException2, InputMismatchException, FailedPredicateException: FailedPredicateException2, ParseCancellationException} = require_Errors();
  var {ATNState} = require_ATNState2();
  var {Interval, IntervalSet} = require_IntervalSet2();
  var ErrorStrategy = class {
    reset(recognizer) {
    }
    recoverInline(recognizer) {
    }
    recover(recognizer, e) {
    }
    sync(recognizer) {
    }
    inErrorRecoveryMode(recognizer) {
    }
    reportError(recognizer) {
    }
  };
  var DefaultErrorStrategy = class extends ErrorStrategy {
    constructor() {
      super();
      this.errorRecoveryMode = false;
      this.lastErrorIndex = -1;
      this.lastErrorStates = null;
      this.nextTokensContext = null;
      this.nextTokenState = 0;
    }
    reset(recognizer) {
      this.endErrorCondition(recognizer);
    }
    beginErrorCondition(recognizer) {
      this.errorRecoveryMode = true;
    }
    inErrorRecoveryMode(recognizer) {
      return this.errorRecoveryMode;
    }
    endErrorCondition(recognizer) {
      this.errorRecoveryMode = false;
      this.lastErrorStates = null;
      this.lastErrorIndex = -1;
    }
    reportMatch(recognizer) {
      this.endErrorCondition(recognizer);
    }
    reportError(recognizer, e) {
      if (this.inErrorRecoveryMode(recognizer)) {
        return;
      }
      this.beginErrorCondition(recognizer);
      if (e instanceof NoViableAltException2) {
        this.reportNoViableAlternative(recognizer, e);
      } else if (e instanceof InputMismatchException) {
        this.reportInputMismatch(recognizer, e);
      } else if (e instanceof FailedPredicateException2) {
        this.reportFailedPredicate(recognizer, e);
      } else {
        console.log("unknown recognition error type: " + e.constructor.name);
        console.log(e.stack);
        recognizer.notifyErrorListeners(e.getOffendingToken(), e.getMessage(), e);
      }
    }
    recover(recognizer, e) {
      if (this.lastErrorIndex === recognizer.getInputStream().index && this.lastErrorStates !== null && this.lastErrorStates.indexOf(recognizer.state) >= 0) {
        recognizer.consume();
      }
      this.lastErrorIndex = recognizer._input.index;
      if (this.lastErrorStates === null) {
        this.lastErrorStates = [];
      }
      this.lastErrorStates.push(recognizer.state);
      const followSet = this.getErrorRecoverySet(recognizer);
      this.consumeUntil(recognizer, followSet);
    }
    sync(recognizer) {
      if (this.inErrorRecoveryMode(recognizer)) {
        return;
      }
      const s = recognizer._interp.atn.states[recognizer.state];
      const la = recognizer.getTokenStream().LA(1);
      const nextTokens = recognizer.atn.nextTokens(s);
      if (nextTokens.contains(la)) {
        this.nextTokensContext = null;
        this.nextTokenState = ATNState.INVALID_STATE_NUMBER;
        return;
      } else if (nextTokens.contains(Token2.EPSILON)) {
        if (this.nextTokensContext === null) {
          this.nextTokensContext = recognizer._ctx;
          this.nextTokensState = recognizer._stateNumber;
        }
        return;
      }
      switch (s.stateType) {
        case ATNState.BLOCK_START:
        case ATNState.STAR_BLOCK_START:
        case ATNState.PLUS_BLOCK_START:
        case ATNState.STAR_LOOP_ENTRY:
          if (this.singleTokenDeletion(recognizer) !== null) {
            return;
          } else {
            throw new InputMismatchException(recognizer);
          }
        case ATNState.PLUS_LOOP_BACK:
        case ATNState.STAR_LOOP_BACK:
          this.reportUnwantedToken(recognizer);
          const expecting = new IntervalSet();
          expecting.addSet(recognizer.getExpectedTokens());
          const whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer));
          this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
          break;
        default:
      }
    }
    reportNoViableAlternative(recognizer, e) {
      const tokens2 = recognizer.getTokenStream();
      let input;
      if (tokens2 !== null) {
        if (e.startToken.type === Token2.EOF) {
          input = "<EOF>";
        } else {
          input = tokens2.getText(new Interval(e.startToken.tokenIndex, e.offendingToken.tokenIndex));
        }
      } else {
        input = "<unknown input>";
      }
      const msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
      recognizer.notifyErrorListeners(msg, e.offendingToken, e);
    }
    reportInputMismatch(recognizer, e) {
      const msg = "mismatched input " + this.getTokenErrorDisplay(e.offendingToken) + " expecting " + e.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames);
      recognizer.notifyErrorListeners(msg, e.offendingToken, e);
    }
    reportFailedPredicate(recognizer, e) {
      const ruleName = recognizer.ruleNames[recognizer._ctx.ruleIndex];
      const msg = "rule " + ruleName + " " + e.message;
      recognizer.notifyErrorListeners(msg, e.offendingToken, e);
    }
    reportUnwantedToken(recognizer) {
      if (this.inErrorRecoveryMode(recognizer)) {
        return;
      }
      this.beginErrorCondition(recognizer);
      const t = recognizer.getCurrentToken();
      const tokenName = this.getTokenErrorDisplay(t);
      const expecting = this.getExpectedTokens(recognizer);
      const msg = "extraneous input " + tokenName + " expecting " + expecting.toString(recognizer.literalNames, recognizer.symbolicNames);
      recognizer.notifyErrorListeners(msg, t, null);
    }
    reportMissingToken(recognizer) {
      if (this.inErrorRecoveryMode(recognizer)) {
        return;
      }
      this.beginErrorCondition(recognizer);
      const t = recognizer.getCurrentToken();
      const expecting = this.getExpectedTokens(recognizer);
      const msg = "missing " + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) + " at " + this.getTokenErrorDisplay(t);
      recognizer.notifyErrorListeners(msg, t, null);
    }
    recoverInline(recognizer) {
      const matchedSymbol = this.singleTokenDeletion(recognizer);
      if (matchedSymbol !== null) {
        recognizer.consume();
        return matchedSymbol;
      }
      if (this.singleTokenInsertion(recognizer)) {
        return this.getMissingSymbol(recognizer);
      }
      throw new InputMismatchException(recognizer);
    }
    singleTokenInsertion(recognizer) {
      const currentSymbolType = recognizer.getTokenStream().LA(1);
      const atn = recognizer._interp.atn;
      const currentState = atn.states[recognizer.state];
      const next = currentState.transitions[0].target;
      const expectingAtLL2 = atn.nextTokens(next, recognizer._ctx);
      if (expectingAtLL2.contains(currentSymbolType)) {
        this.reportMissingToken(recognizer);
        return true;
      } else {
        return false;
      }
    }
    singleTokenDeletion(recognizer) {
      const nextTokenType = recognizer.getTokenStream().LA(2);
      const expecting = this.getExpectedTokens(recognizer);
      if (expecting.contains(nextTokenType)) {
        this.reportUnwantedToken(recognizer);
        recognizer.consume();
        const matchedSymbol = recognizer.getCurrentToken();
        this.reportMatch(recognizer);
        return matchedSymbol;
      } else {
        return null;
      }
    }
    getMissingSymbol(recognizer) {
      const currentSymbol = recognizer.getCurrentToken();
      const expecting = this.getExpectedTokens(recognizer);
      const expectedTokenType = expecting.first();
      let tokenText;
      if (expectedTokenType === Token2.EOF) {
        tokenText = "<missing EOF>";
      } else {
        tokenText = "<missing " + recognizer.literalNames[expectedTokenType] + ">";
      }
      let current = currentSymbol;
      const lookback = recognizer.getTokenStream().LT(-1);
      if (current.type === Token2.EOF && lookback !== null) {
        current = lookback;
      }
      return recognizer.getTokenFactory().create(current.source, expectedTokenType, tokenText, Token2.DEFAULT_CHANNEL, -1, -1, current.line, current.column);
    }
    getExpectedTokens(recognizer) {
      return recognizer.getExpectedTokens();
    }
    getTokenErrorDisplay(t) {
      if (t === null) {
        return "<no token>";
      }
      let s = t.text;
      if (s === null) {
        if (t.type === Token2.EOF) {
          s = "<EOF>";
        } else {
          s = "<" + t.type + ">";
        }
      }
      return this.escapeWSAndQuote(s);
    }
    escapeWSAndQuote(s) {
      s = s.replace(/\n/g, "\\n");
      s = s.replace(/\r/g, "\\r");
      s = s.replace(/\t/g, "\\t");
      return "'" + s + "'";
    }
    getErrorRecoverySet(recognizer) {
      const atn = recognizer._interp.atn;
      let ctx = recognizer._ctx;
      const recoverSet = new IntervalSet();
      while (ctx !== null && ctx.invokingState >= 0) {
        const invokingState = atn.states[ctx.invokingState];
        const rt = invokingState.transitions[0];
        const follow = atn.nextTokens(rt.followState);
        recoverSet.addSet(follow);
        ctx = ctx.parentCtx;
      }
      recoverSet.removeOne(Token2.EPSILON);
      return recoverSet;
    }
    consumeUntil(recognizer, set) {
      let ttype = recognizer.getTokenStream().LA(1);
      while (ttype !== Token2.EOF && !set.contains(ttype)) {
        recognizer.consume();
        ttype = recognizer.getTokenStream().LA(1);
      }
    }
  };
  var BailErrorStrategy = class extends DefaultErrorStrategy {
    constructor() {
      super();
    }
    recover(recognizer, e) {
      let context = recognizer._ctx;
      while (context !== null) {
        context.exception = e;
        context = context.parentCtx;
      }
      throw new ParseCancellationException(e);
    }
    recoverInline(recognizer) {
      this.recover(recognizer, new InputMismatchException(recognizer));
    }
    sync(recognizer) {
    }
  };
  module2.exports = {BailErrorStrategy, DefaultErrorStrategy};
});

// node_modules/antlr4/src/antlr4/error/index.js
var require_error = __commonJS((exports, module2) => {
  module2.exports.RecognitionException = require_Errors().RecognitionException;
  module2.exports.NoViableAltException = require_Errors().NoViableAltException;
  module2.exports.LexerNoViableAltException = require_Errors().LexerNoViableAltException;
  module2.exports.InputMismatchException = require_Errors().InputMismatchException;
  module2.exports.FailedPredicateException = require_Errors().FailedPredicateException;
  module2.exports.DiagnosticErrorListener = require_DiagnosticErrorListener2();
  module2.exports.BailErrorStrategy = require_ErrorStrategy().BailErrorStrategy;
  module2.exports.DefaultErrorStrategy = require_ErrorStrategy().DefaultErrorStrategy;
  module2.exports.ErrorListener = require_ErrorListener().ErrorListener;
});

// node_modules/antlr4/src/antlr4/InputStream.js
var require_InputStream = __commonJS((exports, module2) => {
  var {Token: Token2} = require_Token2();
  require_codepointat();
  require_fromcodepoint();
  var InputStream = class {
    constructor(data, decodeToUnicodeCodePoints) {
      this.name = "<empty>";
      this.strdata = data;
      this.decodeToUnicodeCodePoints = decodeToUnicodeCodePoints || false;
      this._index = 0;
      this.data = [];
      if (this.decodeToUnicodeCodePoints) {
        for (let i = 0; i < this.strdata.length; ) {
          const codePoint = this.strdata.codePointAt(i);
          this.data.push(codePoint);
          i += codePoint <= 65535 ? 1 : 2;
        }
      } else {
        for (let i = 0; i < this.strdata.length; i++) {
          const codeUnit = this.strdata.charCodeAt(i);
          this.data.push(codeUnit);
        }
      }
      this._size = this.data.length;
    }
    reset() {
      this._index = 0;
    }
    consume() {
      if (this._index >= this._size) {
        throw "cannot consume EOF";
      }
      this._index += 1;
    }
    LA(offset) {
      if (offset === 0) {
        return 0;
      }
      if (offset < 0) {
        offset += 1;
      }
      const pos = this._index + offset - 1;
      if (pos < 0 || pos >= this._size) {
        return Token2.EOF;
      }
      return this.data[pos];
    }
    LT(offset) {
      return this.LA(offset);
    }
    mark() {
      return -1;
    }
    release(marker) {
    }
    seek(_index) {
      if (_index <= this._index) {
        this._index = _index;
        return;
      }
      this._index = Math.min(_index, this._size);
    }
    getText(start, stop) {
      if (stop >= this._size) {
        stop = this._size - 1;
      }
      if (start >= this._size) {
        return "";
      } else {
        if (this.decodeToUnicodeCodePoints) {
          let result = "";
          for (let i = start; i <= stop; i++) {
            result += String.fromCodePoint(this.data[i]);
          }
          return result;
        } else {
          return this.strdata.slice(start, stop + 1);
        }
      }
    }
    toString() {
      return this.strdata;
    }
    get index() {
      return this._index;
    }
    get size() {
      return this._size;
    }
  };
  module2.exports = InputStream;
});

// node_modules/antlr4/src/antlr4/CharStreams.js
var require_CharStreams2 = __commonJS((exports, module2) => {
  var InputStream = require_InputStream();
  var fs = __nccwpck_require__(7147);
  var CharStreams = {
    fromString: function(str) {
      return new InputStream(str, true);
    },
    fromBlob: function(blob, encoding, onLoad, onError) {
      const reader = new window.FileReader();
      reader.onload = function(e) {
        const is = new InputStream(e.target.result, true);
        onLoad(is);
      };
      reader.onerror = onError;
      reader.readAsText(blob, encoding);
    },
    fromBuffer: function(buffer, encoding) {
      return new InputStream(buffer.toString(encoding), true);
    },
    fromPath: function(path, encoding, callback) {
      fs.readFile(path, encoding, function(err, data) {
        let is = null;
        if (data !== null) {
          is = new InputStream(data, true);
        }
        callback(err, is);
      });
    },
    fromPathSync: function(path, encoding) {
      const data = fs.readFileSync(path, encoding);
      return new InputStream(data, true);
    }
  };
  module2.exports = CharStreams;
});

// node_modules/antlr4/src/antlr4/FileStream.js
var require_FileStream = __commonJS((exports, module2) => {
  var InputStream = require_InputStream();
  var fs = __nccwpck_require__(7147);
  var FileStream = class extends InputStream {
    constructor(fileName, decodeToUnicodeCodePoints) {
      const data = fs.readFileSync(fileName, "utf8");
      super(data, decodeToUnicodeCodePoints);
      this.fileName = fileName;
    }
  };
  module2.exports = FileStream;
});

// node_modules/antlr4/src/antlr4/BufferedTokenStream.js
var require_BufferedTokenStream2 = __commonJS((exports, module2) => {
  var {Token: Token2} = require_Token2();
  var Lexer2 = require_Lexer2();
  var {Interval} = require_IntervalSet2();
  var TokenStream = class {
  };
  var BufferedTokenStream = class extends TokenStream {
    constructor(tokenSource) {
      super();
      this.tokenSource = tokenSource;
      this.tokens = [];
      this.index = -1;
      this.fetchedEOF = false;
    }
    mark() {
      return 0;
    }
    release(marker) {
    }
    reset() {
      this.seek(0);
    }
    seek(index) {
      this.lazyInit();
      this.index = this.adjustSeekIndex(index);
    }
    get(index) {
      this.lazyInit();
      return this.tokens[index];
    }
    consume() {
      let skipEofCheck = false;
      if (this.index >= 0) {
        if (this.fetchedEOF) {
          skipEofCheck = this.index < this.tokens.length - 1;
        } else {
          skipEofCheck = this.index < this.tokens.length;
        }
      } else {
        skipEofCheck = false;
      }
      if (!skipEofCheck && this.LA(1) === Token2.EOF) {
        throw "cannot consume EOF";
      }
      if (this.sync(this.index + 1)) {
        this.index = this.adjustSeekIndex(this.index + 1);
      }
    }
    sync(i) {
      const n = i - this.tokens.length + 1;
      if (n > 0) {
        const fetched = this.fetch(n);
        return fetched >= n;
      }
      return true;
    }
    fetch(n) {
      if (this.fetchedEOF) {
        return 0;
      }
      for (let i = 0; i < n; i++) {
        const t = this.tokenSource.nextToken();
        t.tokenIndex = this.tokens.length;
        this.tokens.push(t);
        if (t.type === Token2.EOF) {
          this.fetchedEOF = true;
          return i + 1;
        }
      }
      return n;
    }
    getTokens(start, stop, types) {
      if (types === void 0) {
        types = null;
      }
      if (start < 0 || stop < 0) {
        return null;
      }
      this.lazyInit();
      const subset = [];
      if (stop >= this.tokens.length) {
        stop = this.tokens.length - 1;
      }
      for (let i = start; i < stop; i++) {
        const t = this.tokens[i];
        if (t.type === Token2.EOF) {
          break;
        }
        if (types === null || types.contains(t.type)) {
          subset.push(t);
        }
      }
      return subset;
    }
    LA(i) {
      return this.LT(i).type;
    }
    LB(k) {
      if (this.index - k < 0) {
        return null;
      }
      return this.tokens[this.index - k];
    }
    LT(k) {
      this.lazyInit();
      if (k === 0) {
        return null;
      }
      if (k < 0) {
        return this.LB(-k);
      }
      const i = this.index + k - 1;
      this.sync(i);
      if (i >= this.tokens.length) {
        return this.tokens[this.tokens.length - 1];
      }
      return this.tokens[i];
    }
    adjustSeekIndex(i) {
      return i;
    }
    lazyInit() {
      if (this.index === -1) {
        this.setup();
      }
    }
    setup() {
      this.sync(0);
      this.index = this.adjustSeekIndex(0);
    }
    setTokenSource(tokenSource) {
      this.tokenSource = tokenSource;
      this.tokens = [];
      this.index = -1;
      this.fetchedEOF = false;
    }
    nextTokenOnChannel(i, channel) {
      this.sync(i);
      if (i >= this.tokens.length) {
        return -1;
      }
      let token = this.tokens[i];
      while (token.channel !== this.channel) {
        if (token.type === Token2.EOF) {
          return -1;
        }
        i += 1;
        this.sync(i);
        token = this.tokens[i];
      }
      return i;
    }
    previousTokenOnChannel(i, channel) {
      while (i >= 0 && this.tokens[i].channel !== channel) {
        i -= 1;
      }
      return i;
    }
    getHiddenTokensToRight(tokenIndex, channel) {
      if (channel === void 0) {
        channel = -1;
      }
      this.lazyInit();
      if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
        throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
      }
      const nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer2.DEFAULT_TOKEN_CHANNEL);
      const from_ = tokenIndex + 1;
      const to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;
      return this.filterForChannel(from_, to, channel);
    }
    getHiddenTokensToLeft(tokenIndex, channel) {
      if (channel === void 0) {
        channel = -1;
      }
      this.lazyInit();
      if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
        throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
      }
      const prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer2.DEFAULT_TOKEN_CHANNEL);
      if (prevOnChannel === tokenIndex - 1) {
        return null;
      }
      const from_ = prevOnChannel + 1;
      const to = tokenIndex - 1;
      return this.filterForChannel(from_, to, channel);
    }
    filterForChannel(left, right, channel) {
      const hidden = [];
      for (let i = left; i < right + 1; i++) {
        const t = this.tokens[i];
        if (channel === -1) {
          if (t.channel !== Lexer2.DEFAULT_TOKEN_CHANNEL) {
            hidden.push(t);
          }
        } else if (t.channel === channel) {
          hidden.push(t);
        }
      }
      if (hidden.length === 0) {
        return null;
      }
      return hidden;
    }
    getSourceName() {
      return this.tokenSource.getSourceName();
    }
    getText(interval) {
      this.lazyInit();
      this.fill();
      if (interval === void 0 || interval === null) {
        interval = new Interval(0, this.tokens.length - 1);
      }
      let start = interval.start;
      if (start instanceof Token2) {
        start = start.tokenIndex;
      }
      let stop = interval.stop;
      if (stop instanceof Token2) {
        stop = stop.tokenIndex;
      }
      if (start === null || stop === null || start < 0 || stop < 0) {
        return "";
      }
      if (stop >= this.tokens.length) {
        stop = this.tokens.length - 1;
      }
      let s = "";
      for (let i = start; i < stop + 1; i++) {
        const t = this.tokens[i];
        if (t.type === Token2.EOF) {
          break;
        }
        s = s + t.text;
      }
      return s;
    }
    fill() {
      this.lazyInit();
      while (this.fetch(1e3) === 1e3) {
        continue;
      }
    }
  };
  module2.exports = BufferedTokenStream;
});

// node_modules/antlr4/src/antlr4/CommonTokenStream.js
var require_CommonTokenStream2 = __commonJS((exports, module2) => {
  var Token2 = require_Token2().Token;
  var BufferedTokenStream = require_BufferedTokenStream2();
  var CommonTokenStream2 = class extends BufferedTokenStream {
    constructor(lexer, channel) {
      super(lexer);
      this.channel = channel === void 0 ? Token2.DEFAULT_CHANNEL : channel;
    }
    adjustSeekIndex(i) {
      return this.nextTokenOnChannel(i, this.channel);
    }
    LB(k) {
      if (k === 0 || this.index - k < 0) {
        return null;
      }
      let i = this.index;
      let n = 1;
      while (n <= k) {
        i = this.previousTokenOnChannel(i - 1, this.channel);
        n += 1;
      }
      if (i < 0) {
        return null;
      }
      return this.tokens[i];
    }
    LT(k) {
      this.lazyInit();
      if (k === 0) {
        return null;
      }
      if (k < 0) {
        return this.LB(-k);
      }
      let i = this.index;
      let n = 1;
      while (n < k) {
        if (this.sync(i + 1)) {
          i = this.nextTokenOnChannel(i + 1, this.channel);
        }
        n += 1;
      }
      return this.tokens[i];
    }
    getNumberOfOnChannelTokens() {
      let n = 0;
      this.fill();
      for (let i = 0; i < this.tokens.length; i++) {
        const t = this.tokens[i];
        if (t.channel === this.channel) {
          n += 1;
        }
        if (t.type === Token2.EOF) {
          break;
        }
      }
      return n;
    }
  };
  module2.exports = CommonTokenStream2;
});

// node_modules/antlr4/src/antlr4/Parser.js
var require_Parser2 = __commonJS((exports, module2) => {
  var {Token: Token2} = require_Token2();
  var {ParseTreeListener, TerminalNode, ErrorNode: ErrorNode2} = require_Tree();
  var Recognizer = require_Recognizer2();
  var {DefaultErrorStrategy} = require_ErrorStrategy();
  var ATNDeserializer3 = require_ATNDeserializer2();
  var ATNDeserializationOptions = require_ATNDeserializationOptions2();
  var Lexer2 = require_Lexer2();
  var TraceListener = class extends ParseTreeListener {
    constructor(parser) {
      super();
      this.parser = parser;
    }
    enterEveryRule(ctx) {
      console.log("enter   " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
    }
    visitTerminal(node) {
      console.log("consume " + node.symbol + " rule " + this.parser.ruleNames[this.parser._ctx.ruleIndex]);
    }
    exitEveryRule(ctx) {
      console.log("exit    " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
    }
  };
  var Parser2 = class extends Recognizer {
    constructor(input) {
      super();
      this._input = null;
      this._errHandler = new DefaultErrorStrategy();
      this._precedenceStack = [];
      this._precedenceStack.push(0);
      this._ctx = null;
      this.buildParseTrees = true;
      this._tracer = null;
      this._parseListeners = null;
      this._syntaxErrors = 0;
      this.setInputStream(input);
    }
    reset() {
      if (this._input !== null) {
        this._input.seek(0);
      }
      this._errHandler.reset(this);
      this._ctx = null;
      this._syntaxErrors = 0;
      this.setTrace(false);
      this._precedenceStack = [];
      this._precedenceStack.push(0);
      if (this._interp !== null) {
        this._interp.reset();
      }
    }
    match(ttype) {
      let t = this.getCurrentToken();
      if (t.type === ttype) {
        this._errHandler.reportMatch(this);
        this.consume();
      } else {
        t = this._errHandler.recoverInline(this);
        if (this.buildParseTrees && t.tokenIndex === -1) {
          this._ctx.addErrorNode(t);
        }
      }
      return t;
    }
    matchWildcard() {
      let t = this.getCurrentToken();
      if (t.type > 0) {
        this._errHandler.reportMatch(this);
        this.consume();
      } else {
        t = this._errHandler.recoverInline(this);
        if (this._buildParseTrees && t.tokenIndex === -1) {
          this._ctx.addErrorNode(t);
        }
      }
      return t;
    }
    getParseListeners() {
      return this._parseListeners || [];
    }
    addParseListener(listener) {
      if (listener === null) {
        throw "listener";
      }
      if (this._parseListeners === null) {
        this._parseListeners = [];
      }
      this._parseListeners.push(listener);
    }
    removeParseListener(listener) {
      if (this._parseListeners !== null) {
        const idx = this._parseListeners.indexOf(listener);
        if (idx >= 0) {
          this._parseListeners.splice(idx, 1);
        }
        if (this._parseListeners.length === 0) {
          this._parseListeners = null;
        }
      }
    }
    removeParseListeners() {
      this._parseListeners = null;
    }
    triggerEnterRuleEvent() {
      if (this._parseListeners !== null) {
        const ctx = this._ctx;
        this._parseListeners.map(function(listener) {
          listener.enterEveryRule(ctx);
          ctx.enterRule(listener);
        });
      }
    }
    triggerExitRuleEvent() {
      if (this._parseListeners !== null) {
        const ctx = this._ctx;
        this._parseListeners.slice(0).reverse().map(function(listener) {
          ctx.exitRule(listener);
          listener.exitEveryRule(ctx);
        });
      }
    }
    getTokenFactory() {
      return this._input.tokenSource._factory;
    }
    setTokenFactory(factory) {
      this._input.tokenSource._factory = factory;
    }
    getATNWithBypassAlts() {
      const serializedAtn = this.getSerializedATN();
      if (serializedAtn === null) {
        throw "The current parser does not support an ATN with bypass alternatives.";
      }
      let result = this.bypassAltsAtnCache[serializedAtn];
      if (result === null) {
        const deserializationOptions = new ATNDeserializationOptions();
        deserializationOptions.generateRuleBypassTransitions = true;
        result = new ATNDeserializer3(deserializationOptions).deserialize(serializedAtn);
        this.bypassAltsAtnCache[serializedAtn] = result;
      }
      return result;
    }
    compileParseTreePattern(pattern, patternRuleIndex, lexer) {
      lexer = lexer || null;
      if (lexer === null) {
        if (this.getTokenStream() !== null) {
          const tokenSource = this.getTokenStream().tokenSource;
          if (tokenSource instanceof Lexer2) {
            lexer = tokenSource;
          }
        }
      }
      if (lexer === null) {
        throw "Parser can't discover a lexer to use";
      }
      const m = new ParseTreePatternMatcher(lexer, this);
      return m.compile(pattern, patternRuleIndex);
    }
    getInputStream() {
      return this.getTokenStream();
    }
    setInputStream(input) {
      this.setTokenStream(input);
    }
    getTokenStream() {
      return this._input;
    }
    setTokenStream(input) {
      this._input = null;
      this.reset();
      this._input = input;
    }
    getCurrentToken() {
      return this._input.LT(1);
    }
    notifyErrorListeners(msg, offendingToken, err) {
      offendingToken = offendingToken || null;
      err = err || null;
      if (offendingToken === null) {
        offendingToken = this.getCurrentToken();
      }
      this._syntaxErrors += 1;
      const line = offendingToken.line;
      const column = offendingToken.column;
      const listener = this.getErrorListenerDispatch();
      listener.syntaxError(this, offendingToken, line, column, msg, err);
    }
    consume() {
      const o = this.getCurrentToken();
      if (o.type !== Token2.EOF) {
        this.getInputStream().consume();
      }
      const hasListener = this._parseListeners !== null && this._parseListeners.length > 0;
      if (this.buildParseTrees || hasListener) {
        let node;
        if (this._errHandler.inErrorRecoveryMode(this)) {
          node = this._ctx.addErrorNode(o);
        } else {
          node = this._ctx.addTokenNode(o);
        }
        node.invokingState = this.state;
        if (hasListener) {
          this._parseListeners.map(function(listener) {
            if (node instanceof ErrorNode2 || node.isErrorNode !== void 0 && node.isErrorNode()) {
              listener.visitErrorNode(node);
            } else if (node instanceof TerminalNode) {
              listener.visitTerminal(node);
            }
          });
        }
      }
      return o;
    }
    addContextToParseTree() {
      if (this._ctx.parentCtx !== null) {
        this._ctx.parentCtx.addChild(this._ctx);
      }
    }
    enterRule(localctx, state, ruleIndex) {
      this.state = state;
      this._ctx = localctx;
      this._ctx.start = this._input.LT(1);
      if (this.buildParseTrees) {
        this.addContextToParseTree();
      }
      if (this._parseListeners !== null) {
        this.triggerEnterRuleEvent();
      }
    }
    exitRule() {
      this._ctx.stop = this._input.LT(-1);
      if (this._parseListeners !== null) {
        this.triggerExitRuleEvent();
      }
      this.state = this._ctx.invokingState;
      this._ctx = this._ctx.parentCtx;
    }
    enterOuterAlt(localctx, altNum) {
      localctx.setAltNumber(altNum);
      if (this.buildParseTrees && this._ctx !== localctx) {
        if (this._ctx.parentCtx !== null) {
          this._ctx.parentCtx.removeLastChild();
          this._ctx.parentCtx.addChild(localctx);
        }
      }
      this._ctx = localctx;
    }
    getPrecedence() {
      if (this._precedenceStack.length === 0) {
        return -1;
      } else {
        return this._precedenceStack[this._precedenceStack.length - 1];
      }
    }
    enterRecursionRule(localctx, state, ruleIndex, precedence) {
      this.state = state;
      this._precedenceStack.push(precedence);
      this._ctx = localctx;
      this._ctx.start = this._input.LT(1);
      if (this._parseListeners !== null) {
        this.triggerEnterRuleEvent();
      }
    }
    pushNewRecursionContext(localctx, state, ruleIndex) {
      const previous = this._ctx;
      previous.parentCtx = localctx;
      previous.invokingState = state;
      previous.stop = this._input.LT(-1);
      this._ctx = localctx;
      this._ctx.start = previous.start;
      if (this.buildParseTrees) {
        this._ctx.addChild(previous);
      }
      if (this._parseListeners !== null) {
        this.triggerEnterRuleEvent();
      }
    }
    unrollRecursionContexts(parentCtx) {
      this._precedenceStack.pop();
      this._ctx.stop = this._input.LT(-1);
      const retCtx = this._ctx;
      if (this._parseListeners !== null) {
        while (this._ctx !== parentCtx) {
          this.triggerExitRuleEvent();
          this._ctx = this._ctx.parentCtx;
        }
      } else {
        this._ctx = parentCtx;
      }
      retCtx.parentCtx = parentCtx;
      if (this.buildParseTrees && parentCtx !== null) {
        parentCtx.addChild(retCtx);
      }
    }
    getInvokingContext(ruleIndex) {
      let ctx = this._ctx;
      while (ctx !== null) {
        if (ctx.ruleIndex === ruleIndex) {
          return ctx;
        }
        ctx = ctx.parentCtx;
      }
      return null;
    }
    precpred(localctx, precedence) {
      return precedence >= this._precedenceStack[this._precedenceStack.length - 1];
    }
    inContext(context) {
      return false;
    }
    isExpectedToken(symbol) {
      const atn = this._interp.atn;
      let ctx = this._ctx;
      const s = atn.states[this.state];
      let following = atn.nextTokens(s);
      if (following.contains(symbol)) {
        return true;
      }
      if (!following.contains(Token2.EPSILON)) {
        return false;
      }
      while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token2.EPSILON)) {
        const invokingState = atn.states[ctx.invokingState];
        const rt = invokingState.transitions[0];
        following = atn.nextTokens(rt.followState);
        if (following.contains(symbol)) {
          return true;
        }
        ctx = ctx.parentCtx;
      }
      if (following.contains(Token2.EPSILON) && symbol === Token2.EOF) {
        return true;
      } else {
        return false;
      }
    }
    getExpectedTokens() {
      return this._interp.atn.getExpectedTokens(this.state, this._ctx);
    }
    getExpectedTokensWithinCurrentRule() {
      const atn = this._interp.atn;
      const s = atn.states[this.state];
      return atn.nextTokens(s);
    }
    getRuleIndex(ruleName) {
      const ruleIndex = this.getRuleIndexMap()[ruleName];
      if (ruleIndex !== null) {
        return ruleIndex;
      } else {
        return -1;
      }
    }
    getRuleInvocationStack(p) {
      p = p || null;
      if (p === null) {
        p = this._ctx;
      }
      const stack = [];
      while (p !== null) {
        const ruleIndex = p.ruleIndex;
        if (ruleIndex < 0) {
          stack.push("n/a");
        } else {
          stack.push(this.ruleNames[ruleIndex]);
        }
        p = p.parentCtx;
      }
      return stack;
    }
    getDFAStrings() {
      return this._interp.decisionToDFA.toString();
    }
    dumpDFA() {
      let seenOne = false;
      for (let i = 0; i < this._interp.decisionToDFA.length; i++) {
        const dfa = this._interp.decisionToDFA[i];
        if (dfa.states.length > 0) {
          if (seenOne) {
            console.log();
          }
          this.printer.println("Decision " + dfa.decision + ":");
          this.printer.print(dfa.toString(this.literalNames, this.symbolicNames));
          seenOne = true;
        }
      }
    }
    getSourceName() {
      return this._input.sourceName;
    }
    setTrace(trace) {
      if (!trace) {
        this.removeParseListener(this._tracer);
        this._tracer = null;
      } else {
        if (this._tracer !== null) {
          this.removeParseListener(this._tracer);
        }
        this._tracer = new TraceListener(this);
        this.addParseListener(this._tracer);
      }
    }
  };
  Parser2.bypassAltsAtnCache = {};
  module2.exports = Parser2;
});

// node_modules/antlr4/src/antlr4/index.js
var require_antlr4 = __commonJS((exports) => {
  exports.atn = require_atn();
  exports.codepointat = require_codepointat();
  exports.dfa = require_dfa();
  exports.fromcodepoint = require_fromcodepoint();
  exports.tree = require_tree();
  exports.error = require_error();
  exports.Token = require_Token2().Token;
  exports.CharStreams = require_CharStreams2();
  exports.CommonToken = require_Token2().CommonToken;
  exports.InputStream = require_InputStream();
  exports.FileStream = require_FileStream();
  exports.CommonTokenStream = require_CommonTokenStream2();
  exports.Lexer = require_Lexer2();
  exports.Parser = require_Parser2();
  var pc = require_PredictionContext2();
  exports.PredictionContextCache = pc.PredictionContextCache;
  exports.ParserRuleContext = require_ParserRuleContext2();
  exports.Interval = require_IntervalSet2().Interval;
  exports.IntervalSet = require_IntervalSet2().IntervalSet;
  exports.Utils = require_Utils2();
  exports.LL1Analyzer = require_LL1Analyzer2().LL1Analyzer;
});

// src/antlr/Solidity.tokens
var require_Solidity = __commonJS((exports, module2) => {
  module2.exports = "./Solidity-EZVQ6AE4.tokens";
});

// src/tokens-string.js
var require_tokens_string = __commonJS((exports, module2) => {
  if (typeof BROWSER !== "undefined") {
    module2.exports = require_Solidity();
  } else {
    module2.exports = (__nccwpck_require__(7147).readFileSync)(__nccwpck_require__.ab + "Solidity.tokens").toString();
  }
});

// src/index.ts
__markAsModule(exports);
__export(exports, {
  ParserError: () => ParserError,
  parse: () => parse,
  tokenize: () => tokenize,
  visit: () => visit
});

// src/parser.ts
var import_antlr4ts = __toModule(require_antlr4ts());

// src/antlr/SolidityLexer.ts
var import_ATNDeserializer = __toModule(require_ATNDeserializer());
var import_Lexer = __toModule(require_Lexer());
var import_LexerATNSimulator = __toModule(require_LexerATNSimulator());
var import_VocabularyImpl = __toModule(require_VocabularyImpl());
var Utils = __toModule(require_Utils());
var _SolidityLexer = class extends import_Lexer.Lexer {
  get vocabulary() {
    return _SolidityLexer.VOCABULARY;
  }
  constructor(input) {
    super(input);
    this._interp = new import_LexerATNSimulator.LexerATNSimulator(_SolidityLexer._ATN, this);
  }
  get grammarFileName() {
    return "Solidity.g4";
  }
  get ruleNames() {
    return _SolidityLexer.ruleNames;
  }
  get serializedATN() {
    return _SolidityLexer._serializedATN;
  }
  get channelNames() {
    return _SolidityLexer.channelNames;
  }
  get modeNames() {
    return _SolidityLexer.modeNames;
  }
  static get _ATN() {
    if (!_SolidityLexer.__ATN) {
      _SolidityLexer.__ATN = new import_ATNDeserializer.ATNDeserializer().deserialize(Utils.toCharArray(_SolidityLexer._serializedATN));
    }
    return _SolidityLexer.__ATN;
  }
};
var SolidityLexer = _SolidityLexer;
SolidityLexer.T__0 = 1;
SolidityLexer.T__1 = 2;
SolidityLexer.T__2 = 3;
SolidityLexer.T__3 = 4;
SolidityLexer.T__4 = 5;
SolidityLexer.T__5 = 6;
SolidityLexer.T__6 = 7;
SolidityLexer.T__7 = 8;
SolidityLexer.T__8 = 9;
SolidityLexer.T__9 = 10;
SolidityLexer.T__10 = 11;
SolidityLexer.T__11 = 12;
SolidityLexer.T__12 = 13;
SolidityLexer.T__13 = 14;
SolidityLexer.T__14 = 15;
SolidityLexer.T__15 = 16;
SolidityLexer.T__16 = 17;
SolidityLexer.T__17 = 18;
SolidityLexer.T__18 = 19;
SolidityLexer.T__19 = 20;
SolidityLexer.T__20 = 21;
SolidityLexer.T__21 = 22;
SolidityLexer.T__22 = 23;
SolidityLexer.T__23 = 24;
SolidityLexer.T__24 = 25;
SolidityLexer.T__25 = 26;
SolidityLexer.T__26 = 27;
SolidityLexer.T__27 = 28;
SolidityLexer.T__28 = 29;
SolidityLexer.T__29 = 30;
SolidityLexer.T__30 = 31;
SolidityLexer.T__31 = 32;
SolidityLexer.T__32 = 33;
SolidityLexer.T__33 = 34;
SolidityLexer.T__34 = 35;
SolidityLexer.T__35 = 36;
SolidityLexer.T__36 = 37;
SolidityLexer.T__37 = 38;
SolidityLexer.T__38 = 39;
SolidityLexer.T__39 = 40;
SolidityLexer.T__40 = 41;
SolidityLexer.T__41 = 42;
SolidityLexer.T__42 = 43;
SolidityLexer.T__43 = 44;
SolidityLexer.T__44 = 45;
SolidityLexer.T__45 = 46;
SolidityLexer.T__46 = 47;
SolidityLexer.T__47 = 48;
SolidityLexer.T__48 = 49;
SolidityLexer.T__49 = 50;
SolidityLexer.T__50 = 51;
SolidityLexer.T__51 = 52;
SolidityLexer.T__52 = 53;
SolidityLexer.T__53 = 54;
SolidityLexer.T__54 = 55;
SolidityLexer.T__55 = 56;
SolidityLexer.T__56 = 57;
SolidityLexer.T__57 = 58;
SolidityLexer.T__58 = 59;
SolidityLexer.T__59 = 60;
SolidityLexer.T__60 = 61;
SolidityLexer.T__61 = 62;
SolidityLexer.T__62 = 63;
SolidityLexer.T__63 = 64;
SolidityLexer.T__64 = 65;
SolidityLexer.T__65 = 66;
SolidityLexer.T__66 = 67;
SolidityLexer.T__67 = 68;
SolidityLexer.T__68 = 69;
SolidityLexer.T__69 = 70;
SolidityLexer.T__70 = 71;
SolidityLexer.T__71 = 72;
SolidityLexer.T__72 = 73;
SolidityLexer.T__73 = 74;
SolidityLexer.T__74 = 75;
SolidityLexer.T__75 = 76;
SolidityLexer.T__76 = 77;
SolidityLexer.T__77 = 78;
SolidityLexer.T__78 = 79;
SolidityLexer.T__79 = 80;
SolidityLexer.T__80 = 81;
SolidityLexer.T__81 = 82;
SolidityLexer.T__82 = 83;
SolidityLexer.T__83 = 84;
SolidityLexer.T__84 = 85;
SolidityLexer.T__85 = 86;
SolidityLexer.T__86 = 87;
SolidityLexer.T__87 = 88;
SolidityLexer.T__88 = 89;
SolidityLexer.T__89 = 90;
SolidityLexer.T__90 = 91;
SolidityLexer.T__91 = 92;
SolidityLexer.T__92 = 93;
SolidityLexer.T__93 = 94;
SolidityLexer.T__94 = 95;
SolidityLexer.T__95 = 96;
SolidityLexer.T__96 = 97;
SolidityLexer.Int = 98;
SolidityLexer.Uint = 99;
SolidityLexer.Byte = 100;
SolidityLexer.Fixed = 101;
SolidityLexer.Ufixed = 102;
SolidityLexer.BooleanLiteral = 103;
SolidityLexer.DecimalNumber = 104;
SolidityLexer.HexNumber = 105;
SolidityLexer.NumberUnit = 106;
SolidityLexer.HexLiteralFragment = 107;
SolidityLexer.ReservedKeyword = 108;
SolidityLexer.AnonymousKeyword = 109;
SolidityLexer.BreakKeyword = 110;
SolidityLexer.ConstantKeyword = 111;
SolidityLexer.ImmutableKeyword = 112;
SolidityLexer.ContinueKeyword = 113;
SolidityLexer.LeaveKeyword = 114;
SolidityLexer.ExternalKeyword = 115;
SolidityLexer.IndexedKeyword = 116;
SolidityLexer.InternalKeyword = 117;
SolidityLexer.PayableKeyword = 118;
SolidityLexer.PrivateKeyword = 119;
SolidityLexer.PublicKeyword = 120;
SolidityLexer.VirtualKeyword = 121;
SolidityLexer.PureKeyword = 122;
SolidityLexer.TypeKeyword = 123;
SolidityLexer.ViewKeyword = 124;
SolidityLexer.GlobalKeyword = 125;
SolidityLexer.ConstructorKeyword = 126;
SolidityLexer.FallbackKeyword = 127;
SolidityLexer.ReceiveKeyword = 128;
SolidityLexer.Identifier = 129;
SolidityLexer.StringLiteralFragment = 130;
SolidityLexer.VersionLiteral = 131;
SolidityLexer.WS = 132;
SolidityLexer.COMMENT = 133;
SolidityLexer.LINE_COMMENT = 134;
SolidityLexer.channelNames = [
  "DEFAULT_TOKEN_CHANNEL",
  "HIDDEN"
];
SolidityLexer.modeNames = [
  "DEFAULT_MODE"
];
SolidityLexer.ruleNames = [
  "T__0",
  "T__1",
  "T__2",
  "T__3",
  "T__4",
  "T__5",
  "T__6",
  "T__7",
  "T__8",
  "T__9",
  "T__10",
  "T__11",
  "T__12",
  "T__13",
  "T__14",
  "T__15",
  "T__16",
  "T__17",
  "T__18",
  "T__19",
  "T__20",
  "T__21",
  "T__22",
  "T__23",
  "T__24",
  "T__25",
  "T__26",
  "T__27",
  "T__28",
  "T__29",
  "T__30",
  "T__31",
  "T__32",
  "T__33",
  "T__34",
  "T__35",
  "T__36",
  "T__37",
  "T__38",
  "T__39",
  "T__40",
  "T__41",
  "T__42",
  "T__43",
  "T__44",
  "T__45",
  "T__46",
  "T__47",
  "T__48",
  "T__49",
  "T__50",
  "T__51",
  "T__52",
  "T__53",
  "T__54",
  "T__55",
  "T__56",
  "T__57",
  "T__58",
  "T__59",
  "T__60",
  "T__61",
  "T__62",
  "T__63",
  "T__64",
  "T__65",
  "T__66",
  "T__67",
  "T__68",
  "T__69",
  "T__70",
  "T__71",
  "T__72",
  "T__73",
  "T__74",
  "T__75",
  "T__76",
  "T__77",
  "T__78",
  "T__79",
  "T__80",
  "T__81",
  "T__82",
  "T__83",
  "T__84",
  "T__85",
  "T__86",
  "T__87",
  "T__88",
  "T__89",
  "T__90",
  "T__91",
  "T__92",
  "T__93",
  "T__94",
  "T__95",
  "T__96",
  "Int",
  "Uint",
  "Byte",
  "Fixed",
  "Ufixed",
  "BooleanLiteral",
  "DecimalNumber",
  "DecimalDigits",
  "HexNumber",
  "HexDigits",
  "NumberUnit",
  "HexLiteralFragment",
  "HexPair",
  "HexCharacter",
  "ReservedKeyword",
  "AnonymousKeyword",
  "BreakKeyword",
  "ConstantKeyword",
  "ImmutableKeyword",
  "ContinueKeyword",
  "LeaveKeyword",
  "ExternalKeyword",
  "IndexedKeyword",
  "InternalKeyword",
  "PayableKeyword",
  "PrivateKeyword",
  "PublicKeyword",
  "VirtualKeyword",
  "PureKeyword",
  "TypeKeyword",
  "ViewKeyword",
  "GlobalKeyword",
  "ConstructorKeyword",
  "FallbackKeyword",
  "ReceiveKeyword",
  "Identifier",
  "IdentifierStart",
  "IdentifierPart",
  "StringLiteralFragment",
  "DoubleQuotedStringCharacter",
  "SingleQuotedStringCharacter",
  "VersionLiteral",
  "WS",
  "COMMENT",
  "LINE_COMMENT"
];
SolidityLexer._LITERAL_NAMES = [
  void 0,
  "'pragma'",
  "';'",
  "'*'",
  "'||'",
  "'^'",
  "'~'",
  "'>='",
  "'>'",
  "'<'",
  "'<='",
  "'='",
  "'as'",
  "'import'",
  "'from'",
  "'{'",
  "','",
  "'}'",
  "'abstract'",
  "'contract'",
  "'interface'",
  "'library'",
  "'is'",
  "'('",
  "')'",
  "'error'",
  "'using'",
  "'for'",
  "'struct'",
  "'modifier'",
  "'function'",
  "'returns'",
  "'event'",
  "'enum'",
  "'['",
  "']'",
  "'address'",
  "'.'",
  "'mapping'",
  "'=>'",
  "'memory'",
  "'storage'",
  "'calldata'",
  "'if'",
  "'else'",
  "'try'",
  "'catch'",
  "'while'",
  "'unchecked'",
  "'assembly'",
  "'do'",
  "'return'",
  "'throw'",
  "'emit'",
  "'revert'",
  "'var'",
  "'bool'",
  "'string'",
  "'byte'",
  "'++'",
  "'--'",
  "'new'",
  "':'",
  "'+'",
  "'-'",
  "'after'",
  "'delete'",
  "'!'",
  "'**'",
  "'/'",
  "'%'",
  "'<<'",
  "'>>'",
  "'&'",
  "'|'",
  "'=='",
  "'!='",
  "'&&'",
  "'?'",
  "'|='",
  "'^='",
  "'&='",
  "'<<='",
  "'>>='",
  "'+='",
  "'-='",
  "'*='",
  "'/='",
  "'%='",
  "'let'",
  "':='",
  "'=:'",
  "'switch'",
  "'case'",
  "'default'",
  "'->'",
  "'callback'",
  "'override'",
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  "'anonymous'",
  "'break'",
  "'constant'",
  "'immutable'",
  "'continue'",
  "'leave'",
  "'external'",
  "'indexed'",
  "'internal'",
  "'payable'",
  "'private'",
  "'public'",
  "'virtual'",
  "'pure'",
  "'type'",
  "'view'",
  "'global'",
  "'constructor'",
  "'fallback'",
  "'receive'"
];
SolidityLexer._SYMBOLIC_NAMES = [
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  "Int",
  "Uint",
  "Byte",
  "Fixed",
  "Ufixed",
  "BooleanLiteral",
  "DecimalNumber",
  "HexNumber",
  "NumberUnit",
  "HexLiteralFragment",
  "ReservedKeyword",
  "AnonymousKeyword",
  "BreakKeyword",
  "ConstantKeyword",
  "ImmutableKeyword",
  "ContinueKeyword",
  "LeaveKeyword",
  "ExternalKeyword",
  "IndexedKeyword",
  "InternalKeyword",
  "PayableKeyword",
  "PrivateKeyword",
  "PublicKeyword",
  "VirtualKeyword",
  "PureKeyword",
  "TypeKeyword",
  "ViewKeyword",
  "GlobalKeyword",
  "ConstructorKeyword",
  "FallbackKeyword",
  "ReceiveKeyword",
  "Identifier",
  "StringLiteralFragment",
  "VersionLiteral",
  "WS",
  "COMMENT",
  "LINE_COMMENT"
];
SolidityLexer.VOCABULARY = new import_VocabularyImpl.VocabularyImpl(_SolidityLexer._LITERAL_NAMES, _SolidityLexer._SYMBOLIC_NAMES, []);
SolidityLexer._serializedATNSegments = 4;
SolidityLexer._serializedATNSegment0 = `\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\x88\u0757\b					\x07	\x07\b	\b			
	
\v	\v\f	\f\r	\r																		 	 !	!"	"#	#$	$%	%&	&'	'(	()	)*	*+	+,	,-	-.	./	/0	01	12	23	34	45	56	67	78	89	9:	:;	;<	<=	=>	>?	?@	@A	AB	BC	CD	DE	EF	FG	GH	HI	IJ	JK	KL	LM	MN	NO	OP	PQ	QR	RS	ST	TU	UV	VW	WX	XY	YZ	Z[	[\\	\\]	]^	^_	_\`	\`a	ab	bc	cd	de	ef	fg	gh	hi	ij	jk	kl	lm	mn	no	op	pq	qr	rs	st	tu	uv	vw	wx	xy	yz	z{	{|	|}	}~	~\x7F	\x7F\x80	\x80\x81	\x81\x82	\x82\x83	\x83\x84	\x84\x85	\x85\x86	\x86\x87	\x87\x88	\x88\x89	\x89\x8A	\x8A\x8B	\x8B\x8C	\x8C\x8D	\x8D\x8E	\x8E\x8F	\x8F\x07\x07\b\b\b		

\v\v\v\f\f\r\r\r        !!!!!!"""""##$$%%%%%%%%&&''''''''((()))))))********+++++++++,,,-----....//////00000011111111112222222223334444444555555666667777777888899999:::::::;;;;;<<<===>>>>??@@AABBBBBBCCCCCCCDDEEEFFGGHHHIIIJJKKLLLMMMNNNOOPPPQQQRRRSSSSTTTTUUUVVVWWWXXXYYYZZZZ[[[\\\\\\]]]]]]]^^^^^________\`\`\`aaaaaaaaabbbbbbbbbccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\u038B
cdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd\u0464
deeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\u0542
efffffffffffff\u0550
f\rff\u0551fff\u0556
f\rff\u0557f\u055A
fggggggggggggggg\u056A
g\rgg\u056Bggg\u0570
g\rgg\u0571g\u0574
ghhhhhhhhhh\u057F
hiii\u0583
iiii\u0587
iiii\u058B
ijjj\u058F
jj\x07j\u0592
j\fjj\u0595\vjkkkklll\u059D
ll\x07l\u05A0
l\fll\u05A3\vlmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm\u05DD
mnnnnnnn\u05E5
nnnnn\u05EA
nnn\u05ED
noooppqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\u064C
qrrrrrrrrrrsssssstttttttttuuuuuuuuuuvvvvvvvvvwwwwwwxxxxxxxxxyyyyyyyyzzzzzzzzz{{{{{{{{||||||||}}}}}}}~~~~~~~~\x7F\x7F\x7F\x7F\x7F\x80\x80\x80\x80\x80\x81\x81\x81\x81\x81\x82\x82\x82\x82\x82\x82\x82\x83\x83\x83\x83\x83\x83\x83\x83\x83\x83\x83\x83\x84\x84\x84\x84\x84\x84\x84\x84\x84\x85\x85\x85\x85\x85\x85\x85\x85\x86\x86\x07\x86\u06EE
\x86\f\x86\x86\u06F1\v\x86\x87\x87\x88\x88\x89\x89\x89\x89\x89\x89\x89\x89\u06FE
\x89\x89\x89\x07\x89\u0702
\x89\f\x89\x89\u0705\v\x89\x89\x89\x89\x89\x89\x89\x89\x89\x89\u070F
\x89\x89\x89\x07\x89\u0713
\x89\f\x89\x89\u0716\v\x89\x89\x89\u0719
\x89\x8A\x8A\x8A\x8A\u071E
\x8A\x8B\x8B\x8B\x8B\u0723
\x8B\x8C\x8C\u0726
\x8C\r\x8C\x8C\u0727\x8C\x8C\x8C\u072C
\x8C\r\x8C\x8C\u072D\x8C\x8C\x8C\u0732
\x8C\r\x8C\x8C\u0733\x8C\u0736
\x8C\x8D\x8D\u0739
\x8D\r\x8D\x8D\u073A\x8D\x8D\x8E\x8E\x8E\x8E\x07\x8E\u0743
\x8E\f\x8E\x8E\u0746\v\x8E\x8E\x8E\x8E\x8E\x8E\x8F\x8F\x8F\x8F\x07\x8F\u0751
\x8F\f\x8F\x8F\u0754\v\x8F\x8F\x8F\u0744\x90\x07	\v\x07\r\b	
\v\f\r!#%')+-/13579;= ?!A"C#E$G%I&K'M(O)Q*S+U,W-Y.[/]0_1a2c3e4g5i6k7m8o9q:s;u<w=y>{?}@\x7FA\x81B\x83C\x85D\x87E\x89F\x8BG\x8DH\x8FI\x91J\x93K\x95L\x97M\x99N\x9BO\x9DP\x9FQ\xA1R\xA3S\xA5T\xA7U\xA9V\xABW\xADX\xAFY\xB1Z\xB3[\xB5\\\xB7]\xB9^\xBB_\xBD\`\xBFa\xC1b\xC3c\xC5d\xC7e\xC9f\xCBg\xCDh\xCFi\xD1j\xD3\xD5k\xD7\xD9l\xDBm\xDD\xDF\xE1n\xE3o\xE5p\xE7q\xE9r\xEBs\xEDt\xEFu\xF1v\xF3w\xF5x\xF7y\xF9z\xFB{\xFD|\xFF}\u0101~\u0103\x7F\u0105\x80\u0107\x81\u0109\x82\u010B\x83\u010D\u010F\u0111\x84\u0113\u0115\u0117\x85\u0119\x86\u011B\x87\u011D\x88\f2;GGggZZzz2;CHch&&C\\aac|\x07&&2;C\\aac|\f\f$$^^\f\f))^^\v\f""\f\f\u07E8\x07	\v\r!#%')+-/13579;=?ACEGIKMOQSUWY[]_acegikmoqsuwy{}\x7F\x81\x83\x85\x87\x89\x8B\x8D\x8F\x91\x93\x95\x97\x99\x9B\x9D\x9F\xA1\xA3\xA5\xA7\xA9\xAB\xAD\xAF\xB1\xB3\xB5\xB7\xB9\xBB\xBD\xBF\xC1\xC3\xC5\xC7\xC9\xCB\xCD\xCF\xD1\xD5\xD9\xDB\xE1\xE3\xE5\xE7`;
SolidityLexer._serializedATNSegment1 = "\xE9\xEB\xED\xEF\xF1\xF3\xF5\xF7\xF9\xFB\xFD\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u0111\u0117\u0119\u011B\u011D\u011F\u0126\x07\u0128	\u012A\v\u012D\r\u012F\u0131\u0134\u0136\u0138\u013B\u013D\u0140\u0147\u014C!\u014E#\u0150%\u0152'\u015B)\u0164+\u016E-\u0176/\u01791\u017B3\u017D5\u01837\u01899\u018D;\u0194=\u019D?\u01A6A\u01AEC\u01B4E\u01B9G\u01BBI\u01BDK\u01C5M\u01C7O\u01CFQ\u01D2S\u01D9U\u01E1W\u01EAY\u01ED[\u01F2]\u01F6_\u01FCa\u0202c\u020Ce\u0215g\u0218i\u021Fk\u0225m\u022Ao\u0231q\u0235s\u023Au\u0241w\u0246y\u0249{\u024C}\u0250\x7F\u0252\x81\u0254\x83\u0256\x85\u025C\x87\u0263\x89\u0265\x8B\u0268\x8D\u026A\x8F\u026C\x91\u026F\x93\u0272\x95\u0274\x97\u0276\x99\u0279\x9B\u027C\x9D\u027F\x9F\u0281\xA1\u0284\xA3\u0287\xA5\u028A\xA7\u028E\xA9\u0292\xAB\u0295\xAD\u0298\xAF\u029B\xB1\u029E\xB3\u02A1\xB5\u02A5\xB7\u02A8\xB9\u02AB\xBB\u02B2\xBD\u02B7\xBF\u02BF\xC1\u02C2\xC3\u02CB\xC5\u038A\xC7\u0463\xC9\u0541\xCB\u0559\xCD\u0573\xCF\u057E\xD1\u0586\xD3\u058C\xD5\u0596\xD7\u059A\xD9\u05DC\xDB\u05DE\xDD\u05EE\xDF\u05F1\xE1\u064B\xE3\u064D\xE5\u0657\xE7\u065D\xE9\u0666\xEB\u0670\xED\u0679\xEF\u067F\xF1\u0688\xF3\u0690\xF5\u0699\xF7\u06A1\xF9\u06A9\xFB\u06B0\xFD\u06B8\xFF\u06BD\u0101\u06C2\u0103\u06C7\u0105\u06CE\u0107\u06DA\u0109\u06E3\u010B\u06EB\u010D\u06F2\u010F\u06F4\u0111\u0718\u0113\u071D\u0115\u0722\u0117\u0725\u0119\u0738\u011B\u073E\u011D\u074C\u011F\u0120\x07r\u0120\u0121\x07t\u0121\u0122\x07c\u0122\u0123\x07i\u0123\u0124\x07o\u0124\u0125\x07c\u0125\u0126\u0127\x07=\u0127\u0128\u0129\x07,\u0129\b\u012A\u012B\x07~\u012B\u012C\x07~\u012C\n\u012D\u012E\x07`\u012E\f\u012F\u0130\x07\x80\u0130\u0131\u0132\x07@\u0132\u0133\x07?\u0133\u0134\u0135\x07@\u0135\u0136\u0137\x07>\u0137\u0138\u0139\x07>\u0139\u013A\x07?\u013A\u013B\u013C\x07?\u013C\u013D\u013E\x07c\u013E\u013F\x07u\u013F\u0140\u0141\x07k\u0141\u0142\x07o\u0142\u0143\x07r\u0143\u0144\x07q\u0144\u0145\x07t\u0145\u0146\x07v\u0146\u0147\u0148\x07h\u0148\u0149\x07t\u0149\u014A\x07q\u014A\u014B\x07o\u014B\u014C\u014D\x07}\u014D \u014E\u014F\x07.\u014F\"\u0150\u0151\x07\x7F\u0151$\u0152\u0153\x07c\u0153\u0154\x07d\u0154\u0155\x07u\u0155\u0156\x07v\u0156\u0157\x07t\u0157\u0158\x07c\u0158\u0159\x07e\u0159\u015A\x07v\u015A&\u015B\u015C\x07e\u015C\u015D\x07q\u015D\u015E\x07p\u015E\u015F\x07v\u015F\u0160\x07t\u0160\u0161\x07c\u0161\u0162\x07e\u0162\u0163\x07v\u0163(\u0164\u0165\x07k\u0165\u0166\x07p\u0166\u0167\x07v\u0167\u0168\x07g\u0168\u0169\x07t\u0169\u016A\x07h\u016A\u016B\x07c\u016B\u016C\x07e\u016C\u016D\x07g\u016D*\u016E\u016F\x07n\u016F\u0170\x07k\u0170\u0171\x07d\u0171\u0172\x07t\u0172\u0173\x07c\u0173\u0174\x07t\u0174\u0175\x07{\u0175,\u0176\u0177\x07k\u0177\u0178\x07u\u0178.\u0179\u017A\x07*\u017A0\u017B\u017C\x07+\u017C2\u017D\u017E\x07g\u017E\u017F\x07t\u017F\u0180\x07t\u0180\u0181\x07q\u0181\u0182\x07t\u01824\u0183\u0184\x07w\u0184\u0185\x07u\u0185\u0186\x07k\u0186\u0187\x07p\u0187\u0188\x07i\u01886\u0189\u018A\x07h\u018A\u018B\x07q\u018B\u018C\x07t\u018C8\u018D\u018E\x07u\u018E\u018F\x07v\u018F\u0190\x07t\u0190\u0191\x07w\u0191\u0192\x07e\u0192\u0193\x07v\u0193:\u0194\u0195\x07o\u0195\u0196\x07q\u0196\u0197\x07f\u0197\u0198\x07k\u0198\u0199\x07h\u0199\u019A\x07k\u019A\u019B\x07g\u019B\u019C\x07t\u019C<\u019D\u019E\x07h\u019E\u019F\x07w\u019F\u01A0\x07p\u01A0\u01A1\x07e\u01A1\u01A2\x07v\u01A2\u01A3\x07k\u01A3\u01A4\x07q\u01A4\u01A5\x07p\u01A5>\u01A6\u01A7\x07t\u01A7\u01A8\x07g\u01A8\u01A9\x07v\u01A9\u01AA\x07w\u01AA\u01AB\x07t\u01AB\u01AC\x07p\u01AC\u01AD\x07u\u01AD@\u01AE\u01AF\x07g\u01AF\u01B0\x07x\u01B0\u01B1\x07g\u01B1\u01B2\x07p\u01B2\u01B3\x07v\u01B3B\u01B4\u01B5\x07g\u01B5\u01B6\x07p\u01B6\u01B7\x07w\u01B7\u01B8\x07o\u01B8D\u01B9\u01BA\x07]\u01BAF\u01BB\u01BC\x07_\u01BCH\u01BD\u01BE\x07c\u01BE\u01BF\x07f\u01BF\u01C0\x07f\u01C0\u01C1\x07t\u01C1\u01C2\x07g\u01C2\u01C3\x07u\u01C3\u01C4\x07u\u01C4J\u01C5\u01C6\x070\u01C6L\u01C7\u01C8\x07o\u01C8\u01C9\x07c\u01C9\u01CA\x07r\u01CA\u01CB\x07r\u01CB\u01CC\x07k\u01CC\u01CD\x07p\u01CD\u01CE\x07i\u01CEN\u01CF\u01D0\x07?\u01D0\u01D1\x07@\u01D1P\u01D2\u01D3\x07o\u01D3\u01D4\x07g\u01D4\u01D5\x07o\u01D5\u01D6\x07q\u01D6\u01D7\x07t\u01D7\u01D8\x07{\u01D8R\u01D9\u01DA\x07u\u01DA\u01DB\x07v\u01DB\u01DC\x07q\u01DC\u01DD\x07t\u01DD\u01DE\x07c\u01DE\u01DF\x07i\u01DF\u01E0\x07g\u01E0T\u01E1\u01E2\x07e\u01E2\u01E3\x07c\u01E3\u01E4\x07n\u01E4\u01E5\x07n\u01E5\u01E6\x07f\u01E6\u01E7\x07c\u01E7\u01E8\x07v\u01E8\u01E9\x07c\u01E9V\u01EA\u01EB\x07k\u01EB\u01EC\x07h\u01ECX\u01ED\u01EE\x07g\u01EE\u01EF\x07n\u01EF\u01F0\x07u\u01F0\u01F1\x07g\u01F1Z\u01F2\u01F3\x07v\u01F3\u01F4\x07t\u01F4\u01F5\x07{\u01F5\\\u01F6\u01F7\x07e\u01F7\u01F8\x07c\u01F8\u01F9\x07v\u01F9\u01FA\x07e\u01FA\u01FB\x07j\u01FB^\u01FC\u01FD\x07y\u01FD\u01FE\x07j\u01FE\u01FF\x07k\u01FF\u0200\x07n\u0200\u0201\x07g\u0201`\u0202\u0203\x07w\u0203\u0204\x07p\u0204\u0205\x07e\u0205\u0206\x07j\u0206\u0207\x07g\u0207\u0208\x07e\u0208\u0209\x07m\u0209\u020A\x07g\u020A\u020B\x07f\u020Bb\u020C\u020D\x07c\u020D\u020E\x07u\u020E\u020F\x07u\u020F\u0210\x07g\u0210\u0211\x07o\u0211\u0212\x07d\u0212\u0213\x07n\u0213\u0214\x07{\u0214d\u0215\u0216\x07f\u0216\u0217\x07q\u0217f\u0218\u0219\x07t\u0219\u021A\x07g\u021A\u021B\x07v\u021B\u021C\x07w\u021C\u021D\x07t\u021D\u021E\x07p\u021Eh\u021F\u0220\x07v\u0220\u0221\x07j\u0221\u0222\x07t\u0222\u0223\x07q\u0223\u0224\x07y\u0224j\u0225\u0226\x07g\u0226\u0227\x07o\u0227\u0228\x07k\u0228\u0229\x07v\u0229l\u022A\u022B\x07t\u022B\u022C\x07g\u022C\u022D\x07x\u022D\u022E\x07g\u022E\u022F\x07t\u022F\u0230\x07v\u0230n\u0231\u0232\x07x\u0232\u0233\x07c\u0233\u0234\x07t\u0234p\u0235\u0236\x07d\u0236\u0237\x07q\u0237\u0238\x07q\u0238\u0239\x07n\u0239r\u023A\u023B\x07u\u023B\u023C\x07v\u023C\u023D\x07t\u023D\u023E\x07k\u023E\u023F\x07p\u023F\u0240\x07i\u0240t\u0241\u0242\x07d\u0242\u0243\x07{\u0243\u0244\x07v\u0244\u0245\x07g\u0245v\u0246\u0247\x07-\u0247\u0248\x07-\u0248x\u0249\u024A\x07/\u024A\u024B\x07/\u024Bz\u024C\u024D\x07p\u024D\u024E\x07g\u024E\u024F\x07y\u024F|\u0250\u0251\x07<\u0251~\u0252\u0253\x07-\u0253\x80\u0254\u0255\x07/\u0255\x82\u0256\u0257\x07c\u0257\u0258\x07h\u0258\u0259\x07v\u0259\u025A\x07g\u025A\u025B\x07t\u025B\x84\u025C\u025D\x07f\u025D\u025E\x07g\u025E\u025F\x07n\u025F\u0260\x07g\u0260\u0261\x07v\u0261\u0262\x07g\u0262\x86\u0263\u0264\x07#\u0264\x88\u0265\u0266\x07,\u0266\u0267\x07,\u0267\x8A\u0268\u0269\x071\u0269\x8C\u026A\u026B\x07'\u026B\x8E\u026C\u026D\x07>\u026D\u026E\x07>\u026E\x90\u026F\u0270\x07@\u0270\u0271\x07@\u0271\x92\u0272\u0273\x07(\u0273\x94\u0274\u0275\x07~\u0275\x96\u0276\u0277\x07?\u0277\u0278\x07?\u0278\x98\u0279\u027A\x07#\u027A\u027B\x07?\u027B\x9A\u027C\u027D\x07(\u027D\u027E\x07(\u027E\x9C\u027F\u0280\x07A\u0280\x9E\u0281\u0282\x07~\u0282\u0283\x07?\u0283\xA0\u0284\u0285\x07`\u0285\u0286\x07?\u0286\xA2\u0287\u0288\x07(\u0288\u0289\x07?\u0289\xA4\u028A\u028B\x07>\u028B\u028C\x07>\u028C\u028D\x07?\u028D\xA6\u028E\u028F\x07@\u028F\u0290\x07@\u0290\u0291\x07?\u0291\xA8\u0292\u0293\x07-\u0293\u0294\x07?\u0294\xAA\u0295\u0296\x07/\u0296\u0297\x07?\u0297\xAC\u0298\u0299\x07,\u0299\u029A\x07?\u029A\xAE\u029B\u029C\x071\u029C\u029D\x07?\u029D\xB0\u029E\u029F\x07'\u029F\u02A0\x07?\u02A0\xB2\u02A1\u02A2\x07n\u02A2\u02A3\x07g\u02A3\u02A4\x07v\u02A4\xB4\u02A5\u02A6\x07<\u02A6\u02A7\x07?\u02A7\xB6\u02A8\u02A9\x07?\u02A9\u02AA\x07<\u02AA\xB8\u02AB\u02AC\x07u\u02AC\u02AD\x07y\u02AD\u02AE\x07k\u02AE\u02AF\x07v\u02AF\u02B0\x07e\u02B0\u02B1\x07j\u02B1\xBA\u02B2\u02B3\x07e\u02B3\u02B4\x07c\u02B4\u02B5\x07u\u02B5\u02B6\x07g\u02B6\xBC\u02B7\u02B8\x07f\u02B8\u02B9\x07g\u02B9\u02BA\x07h\u02BA\u02BB\x07c\u02BB\u02BC\x07w\u02BC\u02BD\x07n\u02BD\u02BE\x07v\u02BE\xBE\u02BF\u02C0\x07/\u02C0\u02C1\x07@\u02C1\xC0\u02C2\u02C3\x07e\u02C3\u02C4\x07c\u02C4\u02C5\x07n\u02C5\u02C6\x07n\u02C6\u02C7\x07d\u02C7\u02C8\x07c\u02C8\u02C9\x07e\u02C9\u02CA\x07m\u02CA\xC2\u02CB\u02CC\x07q\u02CC\u02CD\x07x\u02CD\u02CE\x07g\u02CE\u02CF\x07t\u02CF\u02D0\x07t\u02D0\u02D1\x07k\u02D1\u02D2\x07f\u02D2\u02D3\x07g\u02D3\xC4\u02D4\u02D5\x07k\u02D5\u02D6\x07p\u02D6\u038B\x07v\u02D7\u02D8\x07k\u02D8\u02D9\x07p\u02D9\u02DA\x07v\u02DA\u038B\x07:\u02DB\u02DC\x07k\u02DC\u02DD\x07p\u02DD\u02DE\x07v\u02DE\u02DF\x073\u02DF\u038B\x078\u02E0\u02E1\x07k\u02E1\u02E2\x07p\u02E2\u02E3\x07v\u02E3\u02E4\x074\u02E4\u038B\x076\u02E5\u02E6\x07k\u02E6\u02E7\x07p\u02E7\u02E8\x07v\u02E8\u02E9\x075\u02E9\u038B\x074\u02EA\u02EB\x07k\u02EB\u02EC\x07p\u02EC\u02ED\x07v\u02ED\u02EE\x076\u02EE\u038B\x072\u02EF\u02F0\x07k\u02F0\u02F1\x07p\u02F1\u02F2\x07v\u02F2\u02F3\x076\u02F3\u038B\x07:\u02F4\u02F5\x07k\u02F5\u02F6\x07p\u02F6\u02F7\x07v\u02F7\u02F8\x077\u02F8\u038B\x078\u02F9\u02FA\x07k\u02FA\u02FB\x07p\u02FB\u02FC\x07v\u02FC\u02FD\x078\u02FD\u038B\x076\u02FE\u02FF\x07k\u02FF\u0300\x07p\u0300\u0301\x07v\u0301\u0302\x079\u0302\u038B\x074\u0303\u0304\x07k\u0304\u0305\x07p\u0305\u0306\x07v\u0306\u0307\x07:\u0307\u038B\x072\u0308\u0309\x07k\u0309\u030A\x07p\u030A\u030B\x07v\u030B\u030C\x07:\u030C\u038B\x07:\u030D\u030E\x07k\u030E\u030F\x07p\u030F\u0310\x07v\u0310\u0311\x07;\u0311\u038B\x078\u0312\u0313\x07k\u0313\u0314\x07p\u0314\u0315\x07v\u0315\u0316\x073\u0316\u0317\x072\u0317\u038B\x076\u0318\u0319\x07k\u0319\u031A\x07p\u031A\u031B\x07v\u031B\u031C\x073\u031C\u031D\x073\u031D\u038B\x074\u031E\u031F\x07k\u031F\u0320\x07p\u0320\u0321\x07v\u0321\u0322\x073\u0322\u0323\x074\u0323\u038B\x072\u0324\u0325\x07k\u0325\u0326\x07p\u0326\u0327\x07v\u0327\u0328\x073\u0328\u0329\x074\u0329\u038B\x07:\u032A\u032B\x07k\u032B\u032C\x07p\u032C\u032D\x07v\u032D\u032E\x073\u032E\u032F\x075\u032F\u038B\x078\u0330\u0331\x07k\u0331\u0332\x07p\u0332\u0333\x07v\u0333\u0334\x073\u0334\u0335\x076\u0335\u038B\x076\u0336\u0337\x07k\u0337\u0338\x07p\u0338\u0339\x07v\u0339\u033A\x073\u033A\u033B\x077\u033B\u038B\x074\u033C\u033D\x07k\u033D\u033E\x07p\u033E\u033F\x07v\u033F\u0340\x073\u0340\u0341\x078\u0341\u038B\x072\u0342\u0343\x07k\u0343\u0344\x07p\u0344\u0345\x07v\u0345\u0346\x073\u0346\u0347\x078\u0347\u038B\x07:\u0348\u0349\x07k\u0349\u034A\x07p\u034A\u034B\x07v\u034B\u034C\x073\u034C\u034D\x079\u034D\u038B\x078\u034E\u034F\x07k\u034F\u0350\x07p\u0350\u0351\x07v\u0351\u0352\x073\u0352\u0353\x07:\u0353\u038B\x076\u0354\u0355\x07k\u0355\u0356\x07p\u0356\u0357\x07v\u0357\u0358\x073\u0358\u0359\x07;\u0359\u038B\x074\u035A\u035B\x07k\u035B\u035C\x07p\u035C\u035D\x07v\u035D\u035E\x074\u035E\u035F\x072\u035F\u038B\x072\u0360\u0361\x07k\u0361\u0362\x07p\u0362\u0363\x07v\u0363\u0364\x074\u0364\u0365\x072\u0365\u038B\x07:\u0366\u0367\x07k\u0367\u0368\x07p\u0368\u0369\x07v\u0369\u036A\x074\u036A\u036B\x073\u036B\u038B\x078\u036C\u036D\x07k\u036D\u036E\x07p\u036E\u036F\x07v\u036F\u0370\x074\u0370\u0371\x074\u0371\u038B\x076\u0372\u0373\x07k\u0373\u0374\x07p\u0374\u0375\x07v\u0375\u0376\x074\u0376\u0377\x075\u0377\u038B\x074\u0378\u0379\x07k\u0379\u037A\x07p\u037A\u037B\x07v\u037B\u037C\x074\u037C\u037D\x076\u037D\u038B\x072\u037E\u037F\x07k\u037F\u0380\x07p\u0380\u0381\x07v\u0381\u0382\x074\u0382\u0383\x076\u0383\u038B\x07:\u0384\u0385\x07k\u0385\u0386\x07p\u0386\u0387\x07v\u0387\u0388\x074\u0388\u0389\x077\u0389\u038B\x078\u038A\u02D4\u038A\u02D7\u038A\u02DB\u038A\u02E0\u038A\u02E5\u038A\u02EA\u038A\u02EF\u038A\u02F4\u038A\u02F9\u038A\u02FE\u038A\u0303\u038A\u0308\u038A\u030D\u038A\u0312\u038A\u0318\u038A\u031E\u038A\u0324\u038A\u032A\u038A\u0330\u038A\u0336\u038A\u033C\u038A\u0342\u038A\u0348\u038A\u034E\u038A\u0354\u038A\u035A\u038A\u0360\u038A\u0366\u038A\u036C\u038A\u0372\u038A\u0378\u038A\u037E\u038A\u0384\u038B\xC6\u038C\u038D\x07w\u038D\u038E\x07k\u038E\u038F\x07p\u038F\u0464\x07v\u0390\u0391\x07w\u0391\u0392\x07k\u0392\u0393\x07p\u0393\u0394\x07v\u0394\u0464\x07:\u0395\u0396\x07w\u0396\u0397\x07k\u0397\u0398\x07p\u0398\u0399\x07v\u0399\u039A\x073\u039A\u0464\x078\u039B\u039C";
SolidityLexer._serializedATNSegment2 = "\x07w\u039C\u039D\x07k\u039D\u039E\x07p\u039E\u039F\x07v\u039F\u03A0\x074\u03A0\u0464\x076\u03A1\u03A2\x07w\u03A2\u03A3\x07k\u03A3\u03A4\x07p\u03A4\u03A5\x07v\u03A5\u03A6\x075\u03A6\u0464\x074\u03A7\u03A8\x07w\u03A8\u03A9\x07k\u03A9\u03AA\x07p\u03AA\u03AB\x07v\u03AB\u03AC\x076\u03AC\u0464\x072\u03AD\u03AE\x07w\u03AE\u03AF\x07k\u03AF\u03B0\x07p\u03B0\u03B1\x07v\u03B1\u03B2\x076\u03B2\u0464\x07:\u03B3\u03B4\x07w\u03B4\u03B5\x07k\u03B5\u03B6\x07p\u03B6\u03B7\x07v\u03B7\u03B8\x077\u03B8\u0464\x078\u03B9\u03BA\x07w\u03BA\u03BB\x07k\u03BB\u03BC\x07p\u03BC\u03BD\x07v\u03BD\u03BE\x078\u03BE\u0464\x076\u03BF\u03C0\x07w\u03C0\u03C1\x07k\u03C1\u03C2\x07p\u03C2\u03C3\x07v\u03C3\u03C4\x079\u03C4\u0464\x074\u03C5\u03C6\x07w\u03C6\u03C7\x07k\u03C7\u03C8\x07p\u03C8\u03C9\x07v\u03C9\u03CA\x07:\u03CA\u0464\x072\u03CB\u03CC\x07w\u03CC\u03CD\x07k\u03CD\u03CE\x07p\u03CE\u03CF\x07v\u03CF\u03D0\x07:\u03D0\u0464\x07:\u03D1\u03D2\x07w\u03D2\u03D3\x07k\u03D3\u03D4\x07p\u03D4\u03D5\x07v\u03D5\u03D6\x07;\u03D6\u0464\x078\u03D7\u03D8\x07w\u03D8\u03D9\x07k\u03D9\u03DA\x07p\u03DA\u03DB\x07v\u03DB\u03DC\x073\u03DC\u03DD\x072\u03DD\u0464\x076\u03DE\u03DF\x07w\u03DF\u03E0\x07k\u03E0\u03E1\x07p\u03E1\u03E2\x07v\u03E2\u03E3\x073\u03E3\u03E4\x073\u03E4\u0464\x074\u03E5\u03E6\x07w\u03E6\u03E7\x07k\u03E7\u03E8\x07p\u03E8\u03E9\x07v\u03E9\u03EA\x073\u03EA\u03EB\x074\u03EB\u0464\x072\u03EC\u03ED\x07w\u03ED\u03EE\x07k\u03EE\u03EF\x07p\u03EF\u03F0\x07v\u03F0\u03F1\x073\u03F1\u03F2\x074\u03F2\u0464\x07:\u03F3\u03F4\x07w\u03F4\u03F5\x07k\u03F5\u03F6\x07p\u03F6\u03F7\x07v\u03F7\u03F8\x073\u03F8\u03F9\x075\u03F9\u0464\x078\u03FA\u03FB\x07w\u03FB\u03FC\x07k\u03FC\u03FD\x07p\u03FD\u03FE\x07v\u03FE\u03FF\x073\u03FF\u0400\x076\u0400\u0464\x076\u0401\u0402\x07w\u0402\u0403\x07k\u0403\u0404\x07p\u0404\u0405\x07v\u0405\u0406\x073\u0406\u0407\x077\u0407\u0464\x074\u0408\u0409\x07w\u0409\u040A\x07k\u040A\u040B\x07p\u040B\u040C\x07v\u040C\u040D\x073\u040D\u040E\x078\u040E\u0464\x072\u040F\u0410\x07w\u0410\u0411\x07k\u0411\u0412\x07p\u0412\u0413\x07v\u0413\u0414\x073\u0414\u0415\x078\u0415\u0464\x07:\u0416\u0417\x07w\u0417\u0418\x07k\u0418\u0419\x07p\u0419\u041A\x07v\u041A\u041B\x073\u041B\u041C\x079\u041C\u0464\x078\u041D\u041E\x07w\u041E\u041F\x07k\u041F\u0420\x07p\u0420\u0421\x07v\u0421\u0422\x073\u0422\u0423\x07:\u0423\u0464\x076\u0424\u0425\x07w\u0425\u0426\x07k\u0426\u0427\x07p\u0427\u0428\x07v\u0428\u0429\x073\u0429\u042A\x07;\u042A\u0464\x074\u042B\u042C\x07w\u042C\u042D\x07k\u042D\u042E\x07p\u042E\u042F\x07v\u042F\u0430\x074\u0430\u0431\x072\u0431\u0464\x072\u0432\u0433\x07w\u0433\u0434\x07k\u0434\u0435\x07p\u0435\u0436\x07v\u0436\u0437\x074\u0437\u0438\x072\u0438\u0464\x07:\u0439\u043A\x07w\u043A\u043B\x07k\u043B\u043C\x07p\u043C\u043D\x07v\u043D\u043E\x074\u043E\u043F\x073\u043F\u0464\x078\u0440\u0441\x07w\u0441\u0442\x07k\u0442\u0443\x07p\u0443\u0444\x07v\u0444\u0445\x074\u0445\u0446\x074\u0446\u0464\x076\u0447\u0448\x07w\u0448\u0449\x07k\u0449\u044A\x07p\u044A\u044B\x07v\u044B\u044C\x074\u044C\u044D\x075\u044D\u0464\x074\u044E\u044F\x07w\u044F\u0450\x07k\u0450\u0451\x07p\u0451\u0452\x07v\u0452\u0453\x074\u0453\u0454\x076\u0454\u0464\x072\u0455\u0456\x07w\u0456\u0457\x07k\u0457\u0458\x07p\u0458\u0459\x07v\u0459\u045A\x074\u045A\u045B\x076\u045B\u0464\x07:\u045C\u045D\x07w\u045D\u045E\x07k\u045E\u045F\x07p\u045F\u0460\x07v\u0460\u0461\x074\u0461\u0462\x077\u0462\u0464\x078\u0463\u038C\u0463\u0390\u0463\u0395\u0463\u039B\u0463\u03A1\u0463\u03A7\u0463\u03AD\u0463\u03B3\u0463\u03B9\u0463\u03BF\u0463\u03C5\u0463\u03CB\u0463\u03D1\u0463\u03D7\u0463\u03DE\u0463\u03E5\u0463\u03EC\u0463\u03F3\u0463\u03FA\u0463\u0401\u0463\u0408\u0463\u040F\u0463\u0416\u0463\u041D\u0463\u0424\u0463\u042B\u0463\u0432\u0463\u0439\u0463\u0440\u0463\u0447\u0463\u044E\u0463\u0455\u0463\u045C\u0464\xC8\u0465\u0466\x07d\u0466\u0467\x07{\u0467\u0468\x07v\u0468\u0469\x07g\u0469\u0542\x07u\u046A\u046B\x07d\u046B\u046C\x07{\u046C\u046D\x07v\u046D\u046E\x07g\u046E\u046F\x07u\u046F\u0542\x073\u0470\u0471\x07d\u0471\u0472\x07{\u0472\u0473\x07v\u0473\u0474\x07g\u0474\u0475\x07u\u0475\u0542\x074\u0476\u0477\x07d\u0477\u0478\x07{\u0478\u0479\x07v\u0479\u047A\x07g\u047A\u047B\x07u\u047B\u0542\x075\u047C\u047D\x07d\u047D\u047E\x07{\u047E\u047F\x07v\u047F\u0480\x07g\u0480\u0481\x07u\u0481\u0542\x076\u0482\u0483\x07d\u0483\u0484\x07{\u0484\u0485\x07v\u0485\u0486\x07g\u0486\u0487\x07u\u0487\u0542\x077\u0488\u0489\x07d\u0489\u048A\x07{\u048A\u048B\x07v\u048B\u048C\x07g\u048C\u048D\x07u\u048D\u0542\x078\u048E\u048F\x07d\u048F\u0490\x07{\u0490\u0491\x07v\u0491\u0492\x07g\u0492\u0493\x07u\u0493\u0542\x079\u0494\u0495\x07d\u0495\u0496\x07{\u0496\u0497\x07v\u0497\u0498\x07g\u0498\u0499\x07u\u0499\u0542\x07:\u049A\u049B\x07d\u049B\u049C\x07{\u049C\u049D\x07v\u049D\u049E\x07g\u049E\u049F\x07u\u049F\u0542\x07;\u04A0\u04A1\x07d\u04A1\u04A2\x07{\u04A2\u04A3\x07v\u04A3\u04A4\x07g\u04A4\u04A5\x07u\u04A5\u04A6\x073\u04A6\u0542\x072\u04A7\u04A8\x07d\u04A8\u04A9\x07{\u04A9\u04AA\x07v\u04AA\u04AB\x07g\u04AB\u04AC\x07u\u04AC\u04AD\x073\u04AD\u0542\x073\u04AE\u04AF\x07d\u04AF\u04B0\x07{\u04B0\u04B1\x07v\u04B1\u04B2\x07g\u04B2\u04B3\x07u\u04B3\u04B4\x073\u04B4\u0542\x074\u04B5\u04B6\x07d\u04B6\u04B7\x07{\u04B7\u04B8\x07v\u04B8\u04B9\x07g\u04B9\u04BA\x07u\u04BA\u04BB\x073\u04BB\u0542\x075\u04BC\u04BD\x07d\u04BD\u04BE\x07{\u04BE\u04BF\x07v\u04BF\u04C0\x07g\u04C0\u04C1\x07u\u04C1\u04C2\x073\u04C2\u0542\x076\u04C3\u04C4\x07d\u04C4\u04C5\x07{\u04C5\u04C6\x07v\u04C6\u04C7\x07g\u04C7\u04C8\x07u\u04C8\u04C9\x073\u04C9\u0542\x077\u04CA\u04CB\x07d\u04CB\u04CC\x07{\u04CC\u04CD\x07v\u04CD\u04CE\x07g\u04CE\u04CF\x07u\u04CF\u04D0\x073\u04D0\u0542\x078\u04D1\u04D2\x07d\u04D2\u04D3\x07{\u04D3\u04D4\x07v\u04D4\u04D5\x07g\u04D5\u04D6\x07u\u04D6\u04D7\x073\u04D7\u0542\x079\u04D8\u04D9\x07d\u04D9\u04DA\x07{\u04DA\u04DB\x07v\u04DB\u04DC\x07g\u04DC\u04DD\x07u\u04DD\u04DE\x073\u04DE\u0542\x07:\u04DF\u04E0\x07d\u04E0\u04E1\x07{\u04E1\u04E2\x07v\u04E2\u04E3\x07g\u04E3\u04E4\x07u\u04E4\u04E5\x073\u04E5\u0542\x07;\u04E6\u04E7\x07d\u04E7\u04E8\x07{\u04E8\u04E9\x07v\u04E9\u04EA\x07g\u04EA\u04EB\x07u\u04EB\u04EC\x074\u04EC\u0542\x072\u04ED\u04EE\x07d\u04EE\u04EF\x07{\u04EF\u04F0\x07v\u04F0\u04F1\x07g\u04F1\u04F2\x07u\u04F2\u04F3\x074\u04F3\u0542\x073\u04F4\u04F5\x07d\u04F5\u04F6\x07{\u04F6\u04F7\x07v\u04F7\u04F8\x07g\u04F8\u04F9\x07u\u04F9\u04FA\x074\u04FA\u0542\x074\u04FB\u04FC\x07d\u04FC\u04FD\x07{\u04FD\u04FE\x07v\u04FE\u04FF\x07g\u04FF\u0500\x07u\u0500\u0501\x074\u0501\u0542\x075\u0502\u0503\x07d\u0503\u0504\x07{\u0504\u0505\x07v\u0505\u0506\x07g\u0506\u0507\x07u\u0507\u0508\x074\u0508\u0542\x076\u0509\u050A\x07d\u050A\u050B\x07{\u050B\u050C\x07v\u050C\u050D\x07g\u050D\u050E\x07u\u050E\u050F\x074\u050F\u0542\x077\u0510\u0511\x07d\u0511\u0512\x07{\u0512\u0513\x07v\u0513\u0514\x07g\u0514\u0515\x07u\u0515\u0516\x074\u0516\u0542\x078\u0517\u0518\x07d\u0518\u0519\x07{\u0519\u051A\x07v\u051A\u051B\x07g\u051B\u051C\x07u\u051C\u051D\x074\u051D\u0542\x079\u051E\u051F\x07d\u051F\u0520\x07{\u0520\u0521\x07v\u0521\u0522\x07g\u0522\u0523\x07u\u0523\u0524\x074\u0524\u0542\x07:\u0525\u0526\x07d\u0526\u0527\x07{\u0527\u0528\x07v\u0528\u0529\x07g\u0529\u052A\x07u\u052A\u052B\x074\u052B\u0542\x07;\u052C\u052D\x07d\u052D\u052E\x07{\u052E\u052F\x07v\u052F\u0530\x07g\u0530\u0531\x07u\u0531\u0532\x075\u0532\u0542\x072\u0533\u0534\x07d\u0534\u0535\x07{\u0535\u0536\x07v\u0536\u0537\x07g\u0537\u0538\x07u\u0538\u0539\x075\u0539\u0542\x073\u053A\u053B\x07d\u053B\u053C\x07{\u053C\u053D\x07v\u053D\u053E\x07g\u053E\u053F\x07u\u053F\u0540\x075\u0540\u0542\x074\u0541\u0465\u0541\u046A\u0541\u0470\u0541\u0476\u0541\u047C\u0541\u0482\u0541\u0488\u0541\u048E\u0541\u0494\u0541\u049A\u0541\u04A0\u0541\u04A7\u0541\u04AE\u0541\u04B5\u0541\u04BC\u0541\u04C3\u0541\u04CA\u0541\u04D1\u0541\u04D8\u0541\u04DF\u0541\u04E6\u0541\u04ED\u0541\u04F4\u0541\u04FB\u0541\u0502\u0541\u0509\u0541\u0510\u0541\u0517\u0541\u051E\u0541\u0525\u0541\u052C\u0541\u0533\u0541\u053A\u0542\xCA\u0543\u0544\x07h\u0544\u0545\x07k\u0545\u0546\x07z\u0546\u0547\x07g\u0547\u055A\x07f\u0548\u0549\x07h\u0549\u054A\x07k\u054A\u054B\x07z\u054B\u054C\x07g\u054C\u054D\x07f\u054D\u054F\u054E\u0550	\u054F\u054E\u0550\u0551\u0551\u054F\u0551\u0552\u0552\u0553\u0553\u0555\x07z\u0554\u0556	\u0555\u0554\u0556\u0557\u0557\u0555\u0557\u0558\u0558\u055A\u0559\u0543\u0559\u0548\u055A\xCC\u055B\u055C\x07w\u055C\u055D\x07h\u055D\u055E\x07k\u055E\u055F\x07z\u055F\u0560\x07g\u0560\u0574\x07f\u0561\u0562\x07w\u0562\u0563\x07h\u0563\u0564\x07k\u0564\u0565\x07z\u0565\u0566\x07g\u0566\u0567\x07f\u0567\u0569\u0568\u056A	\u0569\u0568\u056A\u056B\u056B\u0569\u056B\u056C\u056C\u056D\u056D\u056F\x07z\u056E\u0570	\u056F\u056E\u0570\u0571\u0571\u056F\u0571\u0572\u0572\u0574\u0573\u055B\u0573\u0561\u0574\xCE\u0575\u0576\x07v\u0576\u0577\x07t\u0577\u0578\x07w\u0578\u057F\x07g\u0579\u057A\x07h\u057A\u057B\x07c\u057B\u057C\x07n\u057C\u057D\x07u\u057D\u057F\x07g\u057E\u0575\u057E\u0579\u057F\xD0\u0580\u0587\xD3j\u0581\u0583\xD3j\u0582\u0581\u0582\u0583\u0583\u0584\u0584\u0585\x070\u0585\u0587\xD3j\u0586\u0580\u0586\u0582\u0587\u058A\u0588\u0589	\u0589\u058B\xD3j\u058A\u0588\u058A\u058B\u058B\xD2\u058C\u0593	\u058D\u058F\x07a\u058E\u058D\u058E\u058F\u058F\u0590\u0590\u0592	\u0591\u058E\u0592\u0595\u0593\u0591\u0593\u0594\u0594\xD4\u0595\u0593\u0596\u0597\x072\u0597\u0598	\u0598\u0599\xD7l\u0599\xD6\u059A\u05A1\xDFp\u059B\u059D\x07a\u059C\u059B\u059C\u059D\u059D\u059E\u059E\u05A0\xDFp\u059F\u059C\u05A0\u05A3\u05A1\u059F\u05A1\u05A2\u05A2\xD8\u05A3\u05A1\u05A4\u05A5\x07y\u05A5\u05A6\x07g\u05A6\u05DD\x07k\u05A7\u05A8\x07i\u05A8\u05A9\x07y\u05A9\u05AA\x07g\u05AA\u05DD\x07k\u05AB\u05AC\x07u\u05AC\u05AD\x07|\u05AD\u05AE\x07c\u05AE\u05AF\x07d\u05AF\u05DD\x07q\u05B0\u05B1\x07h\u05B1\u05B2\x07k\u05B2\u05B3\x07p\u05B3\u05B4\x07p\u05B4\u05B5\x07g\u05B5\u05DD\x07{\u05B6\u05B7\x07g\u05B7\u05B8\x07v\u05B8\u05B9\x07j\u05B9\u05BA\x07g\u05BA\u05DD\x07t\u05BB\u05BC\x07u\u05BC\u05BD\x07g\u05BD\u05BE\x07e\u05BE\u05BF\x07q\u05BF\u05C0\x07p\u05C0\u05C1\x07f\u05C1\u05DD\x07u\u05C2\u05C3\x07o\u05C3\u05C4\x07k\u05C4\u05C5\x07p\u05C5\u05C6\x07w\u05C6\u05C7\x07v\u05C7\u05C8\x07g\u05C8\u05DD\x07u\u05C9\u05CA\x07j\u05CA\u05CB\x07q\u05CB\u05CC\x07w\u05CC\u05CD\x07t\u05CD\u05DD\x07u\u05CE\u05CF\x07f\u05CF\u05D0\x07c\u05D0\u05D1\x07{\u05D1\u05DD\x07u\u05D2\u05D3\x07y\u05D3\u05D4\x07g\u05D4\u05D5\x07g\u05D5\u05D6\x07m\u05D6\u05DD\x07u\u05D7\u05D8\x07{\u05D8\u05D9\x07g\u05D9\u05DA\x07c\u05DA\u05DB\x07t\u05DB\u05DD\x07u\u05DC\u05A4\u05DC\u05A7\u05DC\u05AB\u05DC\u05B0\u05DC\u05B6\u05DC\u05BB\u05DC\u05C2\u05DC\u05C9\u05DC\u05CE\u05DC\u05D2\u05DC\u05D7\u05DD\xDA\u05DE\u05DF\x07j\u05DF\u05E0\x07g\u05E0\u05E1\x07z\u05E1\u05EC\u05E2\u05E4\x07$\u05E3\u05E5\xD7l\u05E4\u05E3\u05E4\u05E5\u05E5\u05E6\u05E6\u05ED\x07$\u05E7\u05E9\x07)\u05E8\u05EA\xD7l\u05E9\u05E8\u05E9\u05EA\u05EA\u05EB\u05EB\u05ED\x07)\u05EC\u05E2\u05EC\u05E7\u05ED\xDC\u05EE\u05EF\xDFp\u05EF\u05F0\xDFp\u05F0\xDE\u05F1\u05F2	\u05F2\xE0\u05F3\u05F4\x07c\u05F4\u05F5\x07d\u05F5\u05F6\x07u\u05F6\u05F7\x07v\u05F7\u05F8\x07t\u05F8\u05F9\x07c\u05F9\u05FA\x07e\u05FA\u064C\x07v\u05FB\u05FC\x07c\u05FC\u05FD\x07h\u05FD\u05FE\x07v\u05FE\u05FF\x07g\u05FF\u064C\x07t\u0600\u0601\x07e\u0601\u0602\x07c\u0602\u0603\x07u\u0603\u064C\x07g\u0604\u0605\x07e\u0605\u0606\x07c\u0606\u0607\x07v\u0607\u0608\x07e\u0608\u064C\x07j\u0609\u060A\x07f\u060A\u060B\x07g\u060B\u060C\x07h\u060C\u060D\x07c\u060D\u060E\x07w\u060E\u060F\x07n\u060F\u064C\x07v\u0610\u0611\x07h\u0611\u0612\x07k\u0612\u0613\x07p\u0613\u0614\x07c\u0614\u064C\x07n\u0615\u0616\x07k\u0616\u064C\x07p\u0617\u0618\x07k\u0618\u0619\x07p\u0619\u061A\x07n\u061A\u061B\x07k\u061B\u061C\x07p\u061C\u064C\x07g\u061D\u061E\x07n\u061E\u061F\x07g\u061F\u064C\x07v\u0620\u0621\x07o\u0621\u0622\x07c\u0622\u0623\x07v\u0623\u0624\x07e\u0624\u064C\x07j\u0625\u0626\x07p\u0626\u0627\x07w\u0627\u0628\x07n\u0628\u064C\x07n\u0629\u062A\x07q\u062A\u064C\x07h\u062B\u062C\x07t\u062C\u062D\x07g\u062D\u062E\x07n\u062E\u062F\x07q\u062F\u0630\x07e\u0630\u0631\x07c\u0631\u0632\x07v\u0632\u0633\x07c\u0633\u0634\x07d\u0634\u0635\x07n\u0635\u064C\x07g\u0636\u0637\x07u\u0637\u0638\x07v\u0638\u0639\x07c\u0639\u063A\x07v\u063A\u063B\x07k\u063B\u064C\x07e\u063C\u063D\x07u\u063D\u063E\x07y\u063E\u063F\x07k\u063F\u0640\x07v\u0640\u0641\x07e\u0641\u064C\x07j\u0642\u0643\x07v\u0643\u0644\x07t\u0644\u064C\x07{\u0645\u0646\x07v\u0646\u0647\x07{\u0647\u0648\x07r\u0648\u0649\x07g\u0649\u064A\x07q\u064A\u064C\x07h\u064B\u05F3\u064B\u05FB\u064B\u0600\u064B\u0604\u064B\u0609\u064B\u0610\u064B\u0615\u064B\u0617\u064B\u061D\u064B\u0620\u064B\u0625\u064B\u0629\u064B\u062B\u064B\u0636\u064B\u063C\u064B\u0642\u064B\u0645\u064C\xE2\u064D\u064E\x07c\u064E\u064F\x07p\u064F\u0650\x07q\u0650\u0651\x07p\u0651\u0652\x07{\u0652\u0653\x07o\u0653\u0654\x07q\u0654\u0655\x07w\u0655\u0656\x07u\u0656\xE4\u0657\u0658\x07d\u0658\u0659\x07t\u0659\u065A\x07g\u065A\u065B\x07c\u065B\u065C\x07m\u065C\xE6\u065D\u065E\x07e\u065E\u065F\x07q\u065F\u0660\x07p\u0660\u0661\x07u\u0661\u0662\x07v\u0662\u0663\x07c\u0663\u0664\x07p\u0664\u0665\x07v\u0665\xE8\u0666\u0667\x07k\u0667\u0668\x07o\u0668\u0669\x07o\u0669\u066A\x07w\u066A\u066B\x07v\u066B\u066C\x07c\u066C\u066D\x07d\u066D\u066E\x07n\u066E\u066F\x07g\u066F\xEA\u0670\u0671\x07e\u0671\u0672\x07q";
SolidityLexer._serializedATNSegment3 = "\u0672\u0673\x07p\u0673\u0674\x07v\u0674\u0675\x07k\u0675\u0676\x07p\u0676\u0677\x07w\u0677\u0678\x07g\u0678\xEC\u0679\u067A\x07n\u067A\u067B\x07g\u067B\u067C\x07c\u067C\u067D\x07x\u067D\u067E\x07g\u067E\xEE\u067F\u0680\x07g\u0680\u0681\x07z\u0681\u0682\x07v\u0682\u0683\x07g\u0683\u0684\x07t\u0684\u0685\x07p\u0685\u0686\x07c\u0686\u0687\x07n\u0687\xF0\u0688\u0689\x07k\u0689\u068A\x07p\u068A\u068B\x07f\u068B\u068C\x07g\u068C\u068D\x07z\u068D\u068E\x07g\u068E\u068F\x07f\u068F\xF2\u0690\u0691\x07k\u0691\u0692\x07p\u0692\u0693\x07v\u0693\u0694\x07g\u0694\u0695\x07t\u0695\u0696\x07p\u0696\u0697\x07c\u0697\u0698\x07n\u0698\xF4\u0699\u069A\x07r\u069A\u069B\x07c\u069B\u069C\x07{\u069C\u069D\x07c\u069D\u069E\x07d\u069E\u069F\x07n\u069F\u06A0\x07g\u06A0\xF6\u06A1\u06A2\x07r\u06A2\u06A3\x07t\u06A3\u06A4\x07k\u06A4\u06A5\x07x\u06A5\u06A6\x07c\u06A6\u06A7\x07v\u06A7\u06A8\x07g\u06A8\xF8\u06A9\u06AA\x07r\u06AA\u06AB\x07w\u06AB\u06AC\x07d\u06AC\u06AD\x07n\u06AD\u06AE\x07k\u06AE\u06AF\x07e\u06AF\xFA\u06B0\u06B1\x07x\u06B1\u06B2\x07k\u06B2\u06B3\x07t\u06B3\u06B4\x07v\u06B4\u06B5\x07w\u06B5\u06B6\x07c\u06B6\u06B7\x07n\u06B7\xFC\u06B8\u06B9\x07r\u06B9\u06BA\x07w\u06BA\u06BB\x07t\u06BB\u06BC\x07g\u06BC\xFE\u06BD\u06BE\x07v\u06BE\u06BF\x07{\u06BF\u06C0\x07r\u06C0\u06C1\x07g\u06C1\u0100\u06C2\u06C3\x07x\u06C3\u06C4\x07k\u06C4\u06C5\x07g\u06C5\u06C6\x07y\u06C6\u0102\u06C7\u06C8\x07i\u06C8\u06C9\x07n\u06C9\u06CA\x07q\u06CA\u06CB\x07d\u06CB\u06CC\x07c\u06CC\u06CD\x07n\u06CD\u0104\u06CE\u06CF\x07e\u06CF\u06D0\x07q\u06D0\u06D1\x07p\u06D1\u06D2\x07u\u06D2\u06D3\x07v\u06D3\u06D4\x07t\u06D4\u06D5\x07w\u06D5\u06D6\x07e\u06D6\u06D7\x07v\u06D7\u06D8\x07q\u06D8\u06D9\x07t\u06D9\u0106\u06DA\u06DB\x07h\u06DB\u06DC\x07c\u06DC\u06DD\x07n\u06DD\u06DE\x07n\u06DE\u06DF\x07d\u06DF\u06E0\x07c\u06E0\u06E1\x07e\u06E1\u06E2\x07m\u06E2\u0108\u06E3\u06E4\x07t\u06E4\u06E5\x07g\u06E5\u06E6\x07e\u06E6\u06E7\x07g\u06E7\u06E8\x07k\u06E8\u06E9\x07x\u06E9\u06EA\x07g\u06EA\u010A\u06EB\u06EF\u010D\x87\u06EC\u06EE\u010F\x88\u06ED\u06EC\u06EE\u06F1\u06EF\u06ED\u06EF\u06F0\u06F0\u010C\u06F1\u06EF\u06F2\u06F3	\u06F3\u010E\u06F4\u06F5	\x07\u06F5\u0110\u06F6\u06F7\x07w\u06F7\u06F8\x07p\u06F8\u06F9\x07k\u06F9\u06FA\x07e\u06FA\u06FB\x07q\u06FB\u06FC\x07f\u06FC\u06FE\x07g\u06FD\u06F6\u06FD\u06FE\u06FE\u06FF\u06FF\u0703\x07$\u0700\u0702\u0113\x8A\u0701\u0700\u0702\u0705\u0703\u0701\u0703\u0704\u0704\u0706\u0705\u0703\u0706\u0719\x07$\u0707\u0708\x07w\u0708\u0709\x07p\u0709\u070A\x07k\u070A\u070B\x07e\u070B\u070C\x07q\u070C\u070D\x07f\u070D\u070F\x07g\u070E\u0707\u070E\u070F\u070F\u0710\u0710\u0714\x07)\u0711\u0713\u0115\x8B\u0712\u0711\u0713\u0716\u0714\u0712\u0714\u0715\u0715\u0717\u0716\u0714\u0717\u0719\x07)\u0718\u06FD\u0718\u070E\u0719\u0112\u071A\u071E\n\b\u071B\u071C\x07^\u071C\u071E\v\u071D\u071A\u071D\u071B\u071E\u0114\u071F\u0723\n	\u0720\u0721\x07^\u0721\u0723\v\u0722\u071F\u0722\u0720\u0723\u0116\u0724\u0726	\u0725\u0724\u0726\u0727\u0727\u0725\u0727\u0728\u0728\u0729\u0729\u072B\x070\u072A\u072C	\u072B\u072A\u072C\u072D\u072D\u072B\u072D\u072E\u072E\u0735\u072F\u0731\x070\u0730\u0732	\u0731\u0730\u0732\u0733\u0733\u0731\u0733\u0734\u0734\u0736\u0735\u072F\u0735\u0736\u0736\u0118\u0737\u0739	\n\u0738\u0737\u0739\u073A\u073A\u0738\u073A\u073B\u073B\u073C\u073C\u073D\b\x8D\u073D\u011A\u073E\u073F\x071\u073F\u0740\x07,\u0740\u0744\u0741\u0743\v\u0742\u0741\u0743\u0746\u0744\u0745\u0744\u0742\u0745\u0747\u0746\u0744\u0747\u0748\x07,\u0748\u0749\x071\u0749\u074A\u074A\u074B\b\x8E\u074B\u011C\u074C\u074D\x071\u074D\u074E\x071\u074E\u0752\u074F\u0751\n\v\u0750\u074F\u0751\u0754\u0752\u0750\u0752\u0753\u0753\u0755\u0754\u0752\u0755\u0756\b\x8F\u0756\u011E(\u038A\u0463\u0541\u0551\u0557\u0559\u056B\u0571\u0573\u057E\u0582\u0586\u058A\u058E\u0593\u059C\u05A1\u05DC\u05E4\u05E9\u05EC\u064B\u06EF\u06FD\u0703\u070E\u0714\u0718\u071D\u0722\u0727\u072D\u0733\u0735\u073A\u0744\u0752\b";
SolidityLexer._serializedATN = Utils.join([
  _SolidityLexer._serializedATNSegment0,
  _SolidityLexer._serializedATNSegment1,
  _SolidityLexer._serializedATNSegment2,
  _SolidityLexer._serializedATNSegment3
], "");

// src/antlr/SolidityParser.ts
var import_ATN = __toModule(require_ATN());
var import_ATNDeserializer2 = __toModule(require_ATNDeserializer());
var import_FailedPredicateException = __toModule(require_FailedPredicateException());
var import_NoViableAltException = __toModule(require_NoViableAltException());
var import_Parser = __toModule(require_Parser());
var import_ParserRuleContext = __toModule(require_ParserRuleContext());
var import_ParserATNSimulator = __toModule(require_ParserATNSimulator());
var import_RecognitionException = __toModule(require_RecognitionException());
var import_Token = __toModule(require_Token());
var import_VocabularyImpl2 = __toModule(require_VocabularyImpl());
var Utils2 = __toModule(require_Utils());
var _SolidityParser = class extends import_Parser.Parser {
  get vocabulary() {
    return _SolidityParser.VOCABULARY;
  }
  get grammarFileName() {
    return "Solidity.g4";
  }
  get ruleNames() {
    return _SolidityParser.ruleNames;
  }
  get serializedATN() {
    return _SolidityParser._serializedATN;
  }
  createFailedPredicateException(predicate, message) {
    return new import_FailedPredicateException.FailedPredicateException(this, predicate, message);
  }
  constructor(input) {
    super(input);
    this._interp = new import_ParserATNSimulator.ParserATNSimulator(_SolidityParser._ATN, this);
  }
  sourceUnit() {
    let _localctx = new SourceUnitContext(this._ctx, this.state);
    this.enterRule(_localctx, 0, _SolidityParser.RULE_sourceUnit);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 208;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__0 | 1 << _SolidityParser.T__12 | 1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__17 | 1 << _SolidityParser.T__18 | 1 << _SolidityParser.T__19 | 1 << _SolidityParser.T__20 | 1 << _SolidityParser.T__24 | 1 << _SolidityParser.T__25 | 1 << _SolidityParser.T__27 | 1 << _SolidityParser.T__29)) !== 0 || (_la - 33 & ~31) === 0 && (1 << _la - 33 & (1 << _SolidityParser.T__32 - 33 | 1 << _SolidityParser.T__35 - 33 | 1 << _SolidityParser.T__37 - 33 | 1 << _SolidityParser.T__41 - 33 | 1 << _SolidityParser.T__53 - 33 | 1 << _SolidityParser.T__54 - 33 | 1 << _SolidityParser.T__55 - 33 | 1 << _SolidityParser.T__56 - 33 | 1 << _SolidityParser.T__57 - 33)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96 | 1 << _SolidityParser.FallbackKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {
          {
            this.state = 206;
            this._errHandler.sync(this);
            switch (this.interpreter.adaptivePredict(this._input, 0, this._ctx)) {
              case 1:
                {
                  this.state = 196;
                  this.pragmaDirective();
                }
                break;
              case 2:
                {
                  this.state = 197;
                  this.importDirective();
                }
                break;
              case 3:
                {
                  this.state = 198;
                  this.contractDefinition();
                }
                break;
              case 4:
                {
                  this.state = 199;
                  this.enumDefinition();
                }
                break;
              case 5:
                {
                  this.state = 200;
                  this.structDefinition();
                }
                break;
              case 6:
                {
                  this.state = 201;
                  this.functionDefinition();
                }
                break;
              case 7:
                {
                  this.state = 202;
                  this.fileLevelConstant();
                }
                break;
              case 8:
                {
                  this.state = 203;
                  this.customErrorDefinition();
                }
                break;
              case 9:
                {
                  this.state = 204;
                  this.typeDefinition();
                }
                break;
              case 10:
                {
                  this.state = 205;
                  this.usingForDeclaration();
                }
                break;
            }
          }
          this.state = 210;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 211;
        this.match(_SolidityParser.EOF);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  pragmaDirective() {
    let _localctx = new PragmaDirectiveContext(this._ctx, this.state);
    this.enterRule(_localctx, 2, _SolidityParser.RULE_pragmaDirective);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 213;
        this.match(_SolidityParser.T__0);
        this.state = 214;
        this.pragmaName();
        this.state = 215;
        this.pragmaValue();
        this.state = 216;
        this.match(_SolidityParser.T__1);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  pragmaName() {
    let _localctx = new PragmaNameContext(this._ctx, this.state);
    this.enterRule(_localctx, 4, _SolidityParser.RULE_pragmaName);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 218;
        this.identifier();
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  pragmaValue() {
    let _localctx = new PragmaValueContext(this._ctx, this.state);
    this.enterRule(_localctx, 6, _SolidityParser.RULE_pragmaValue);
    try {
      this.state = 223;
      this._errHandler.sync(this);
      switch (this.interpreter.adaptivePredict(this._input, 2, this._ctx)) {
        case 1:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 220;
            this.match(_SolidityParser.T__2);
          }
          break;
        case 2:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 221;
            this.version();
          }
          break;
        case 3:
          this.enterOuterAlt(_localctx, 3);
          {
            this.state = 222;
            this.expression(0);
          }
          break;
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  version() {
    let _localctx = new VersionContext(this._ctx, this.state);
    this.enterRule(_localctx, 8, _SolidityParser.RULE_version);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 225;
        this.versionConstraint();
        this.state = 232;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__3 | 1 << _SolidityParser.T__4 | 1 << _SolidityParser.T__5 | 1 << _SolidityParser.T__6 | 1 << _SolidityParser.T__7 | 1 << _SolidityParser.T__8 | 1 << _SolidityParser.T__9 | 1 << _SolidityParser.T__10)) !== 0 || _la === _SolidityParser.DecimalNumber || _la === _SolidityParser.VersionLiteral) {
          {
            {
              this.state = 227;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _SolidityParser.T__3) {
                {
                  this.state = 226;
                  this.match(_SolidityParser.T__3);
                }
              }
              this.state = 229;
              this.versionConstraint();
            }
          }
          this.state = 234;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  versionOperator() {
    let _localctx = new VersionOperatorContext(this._ctx, this.state);
    this.enterRule(_localctx, 10, _SolidityParser.RULE_versionOperator);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 235;
        _la = this._input.LA(1);
        if (!((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__4 | 1 << _SolidityParser.T__5 | 1 << _SolidityParser.T__6 | 1 << _SolidityParser.T__7 | 1 << _SolidityParser.T__8 | 1 << _SolidityParser.T__9 | 1 << _SolidityParser.T__10)) !== 0)) {
          this._errHandler.recoverInline(this);
        } else {
          if (this._input.LA(1) === import_Token.Token.EOF) {
            this.matchedEOF = true;
          }
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  versionConstraint() {
    let _localctx = new VersionConstraintContext(this._ctx, this.state);
    this.enterRule(_localctx, 12, _SolidityParser.RULE_versionConstraint);
    let _la;
    try {
      this.state = 245;
      this._errHandler.sync(this);
      switch (this.interpreter.adaptivePredict(this._input, 7, this._ctx)) {
        case 1:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 238;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__4 | 1 << _SolidityParser.T__5 | 1 << _SolidityParser.T__6 | 1 << _SolidityParser.T__7 | 1 << _SolidityParser.T__8 | 1 << _SolidityParser.T__9 | 1 << _SolidityParser.T__10)) !== 0) {
              {
                this.state = 237;
                this.versionOperator();
              }
            }
            this.state = 240;
            this.match(_SolidityParser.VersionLiteral);
          }
          break;
        case 2:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 242;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__4 | 1 << _SolidityParser.T__5 | 1 << _SolidityParser.T__6 | 1 << _SolidityParser.T__7 | 1 << _SolidityParser.T__8 | 1 << _SolidityParser.T__9 | 1 << _SolidityParser.T__10)) !== 0) {
              {
                this.state = 241;
                this.versionOperator();
              }
            }
            this.state = 244;
            this.match(_SolidityParser.DecimalNumber);
          }
          break;
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  importDeclaration() {
    let _localctx = new ImportDeclarationContext(this._ctx, this.state);
    this.enterRule(_localctx, 14, _SolidityParser.RULE_importDeclaration);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 247;
        this.identifier();
        this.state = 250;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.T__11) {
          {
            this.state = 248;
            this.match(_SolidityParser.T__11);
            this.state = 249;
            this.identifier();
          }
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  importDirective() {
    let _localctx = new ImportDirectiveContext(this._ctx, this.state);
    this.enterRule(_localctx, 16, _SolidityParser.RULE_importDirective);
    let _la;
    try {
      this.state = 288;
      this._errHandler.sync(this);
      switch (this.interpreter.adaptivePredict(this._input, 13, this._ctx)) {
        case 1:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 252;
            this.match(_SolidityParser.T__12);
            this.state = 253;
            this.importPath();
            this.state = 256;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _SolidityParser.T__11) {
              {
                this.state = 254;
                this.match(_SolidityParser.T__11);
                this.state = 255;
                this.identifier();
              }
            }
            this.state = 258;
            this.match(_SolidityParser.T__1);
          }
          break;
        case 2:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 260;
            this.match(_SolidityParser.T__12);
            this.state = 263;
            this._errHandler.sync(this);
            switch (this._input.LA(1)) {
              case _SolidityParser.T__2:
                {
                  this.state = 261;
                  this.match(_SolidityParser.T__2);
                }
                break;
              case _SolidityParser.T__13:
              case _SolidityParser.T__24:
              case _SolidityParser.T__35:
              case _SolidityParser.T__41:
              case _SolidityParser.T__53:
              case _SolidityParser.T__95:
              case _SolidityParser.LeaveKeyword:
              case _SolidityParser.PayableKeyword:
              case _SolidityParser.ConstructorKeyword:
              case _SolidityParser.ReceiveKeyword:
              case _SolidityParser.Identifier:
                {
                  this.state = 262;
                  this.identifier();
                }
                break;
              default:
                throw new import_NoViableAltException.NoViableAltException(this);
            }
            this.state = 267;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _SolidityParser.T__11) {
              {
                this.state = 265;
                this.match(_SolidityParser.T__11);
                this.state = 266;
                this.identifier();
              }
            }
            this.state = 269;
            this.match(_SolidityParser.T__13);
            this.state = 270;
            this.importPath();
            this.state = 271;
            this.match(_SolidityParser.T__1);
          }
          break;
        case 3:
          this.enterOuterAlt(_localctx, 3);
          {
            this.state = 273;
            this.match(_SolidityParser.T__12);
            this.state = 274;
            this.match(_SolidityParser.T__14);
            this.state = 275;
            this.importDeclaration();
            this.state = 280;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _SolidityParser.T__15) {
              {
                {
                  this.state = 276;
                  this.match(_SolidityParser.T__15);
                  this.state = 277;
                  this.importDeclaration();
                }
              }
              this.state = 282;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 283;
            this.match(_SolidityParser.T__16);
            this.state = 284;
            this.match(_SolidityParser.T__13);
            this.state = 285;
            this.importPath();
            this.state = 286;
            this.match(_SolidityParser.T__1);
          }
          break;
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  importPath() {
    let _localctx = new ImportPathContext(this._ctx, this.state);
    this.enterRule(_localctx, 18, _SolidityParser.RULE_importPath);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 290;
        this.match(_SolidityParser.StringLiteralFragment);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  contractDefinition() {
    let _localctx = new ContractDefinitionContext(this._ctx, this.state);
    this.enterRule(_localctx, 20, _SolidityParser.RULE_contractDefinition);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 293;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.T__17) {
          {
            this.state = 292;
            this.match(_SolidityParser.T__17);
          }
        }
        this.state = 295;
        _la = this._input.LA(1);
        if (!((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__18 | 1 << _SolidityParser.T__19 | 1 << _SolidityParser.T__20)) !== 0)) {
          this._errHandler.recoverInline(this);
        } else {
          if (this._input.LA(1) === import_Token.Token.EOF) {
            this.matchedEOF = true;
          }
          this._errHandler.reportMatch(this);
          this.consume();
        }
        this.state = 296;
        this.identifier();
        this.state = 306;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.T__21) {
          {
            this.state = 297;
            this.match(_SolidityParser.T__21);
            this.state = 298;
            this.inheritanceSpecifier();
            this.state = 303;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _SolidityParser.T__15) {
              {
                {
                  this.state = 299;
                  this.match(_SolidityParser.T__15);
                  this.state = 300;
                  this.inheritanceSpecifier();
                }
              }
              this.state = 305;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        }
        this.state = 308;
        this.match(_SolidityParser.T__14);
        this.state = 312;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__24 | 1 << _SolidityParser.T__25 | 1 << _SolidityParser.T__27 | 1 << _SolidityParser.T__28 | 1 << _SolidityParser.T__29)) !== 0 || (_la - 32 & ~31) === 0 && (1 << _la - 32 & (1 << _SolidityParser.T__31 - 32 | 1 << _SolidityParser.T__32 - 32 | 1 << _SolidityParser.T__35 - 32 | 1 << _SolidityParser.T__37 - 32 | 1 << _SolidityParser.T__41 - 32 | 1 << _SolidityParser.T__53 - 32 | 1 << _SolidityParser.T__54 - 32 | 1 << _SolidityParser.T__55 - 32 | 1 << _SolidityParser.T__56 - 32 | 1 << _SolidityParser.T__57 - 32)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96 | 1 << _SolidityParser.FallbackKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {
          {
            {
              this.state = 309;
              this.contractPart();
            }
          }
          this.state = 314;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 315;
        this.match(_SolidityParser.T__16);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  inheritanceSpecifier() {
    let _localctx = new InheritanceSpecifierContext(this._ctx, this.state);
    this.enterRule(_localctx, 22, _SolidityParser.RULE_inheritanceSpecifier);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 317;
        this.userDefinedTypeName();
        this.state = 323;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.T__22) {
          {
            this.state = 318;
            this.match(_SolidityParser.T__22);
            this.state = 320;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {
              {
                this.state = 319;
                this.expressionList();
              }
            }
            this.state = 322;
            this.match(_SolidityParser.T__23);
          }
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  contractPart() {
    let _localctx = new ContractPartContext(this._ctx, this.state);
    this.enterRule(_localctx, 24, _SolidityParser.RULE_contractPart);
    try {
      this.state = 334;
      this._errHandler.sync(this);
      switch (this.interpreter.adaptivePredict(this._input, 20, this._ctx)) {
        case 1:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 325;
            this.stateVariableDeclaration();
          }
          break;
        case 2:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 326;
            this.usingForDeclaration();
          }
          break;
        case 3:
          this.enterOuterAlt(_localctx, 3);
          {
            this.state = 327;
            this.structDefinition();
          }
          break;
        case 4:
          this.enterOuterAlt(_localctx, 4);
          {
            this.state = 328;
            this.modifierDefinition();
          }
          break;
        case 5:
          this.enterOuterAlt(_localctx, 5);
          {
            this.state = 329;
            this.functionDefinition();
          }
          break;
        case 6:
          this.enterOuterAlt(_localctx, 6);
          {
            this.state = 330;
            this.eventDefinition();
          }
          break;
        case 7:
          this.enterOuterAlt(_localctx, 7);
          {
            this.state = 331;
            this.enumDefinition();
          }
          break;
        case 8:
          this.enterOuterAlt(_localctx, 8);
          {
            this.state = 332;
            this.customErrorDefinition();
          }
          break;
        case 9:
          this.enterOuterAlt(_localctx, 9);
          {
            this.state = 333;
            this.typeDefinition();
          }
          break;
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  stateVariableDeclaration() {
    let _localctx = new StateVariableDeclarationContext(this._ctx, this.state);
    this.enterRule(_localctx, 26, _SolidityParser.RULE_stateVariableDeclaration);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 336;
        this.typeName(0);
        this.state = 345;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while ((_la - 97 & ~31) === 0 && (1 << _la - 97 & (1 << _SolidityParser.T__96 - 97 | 1 << _SolidityParser.ConstantKeyword - 97 | 1 << _SolidityParser.ImmutableKeyword - 97 | 1 << _SolidityParser.InternalKeyword - 97 | 1 << _SolidityParser.PrivateKeyword - 97 | 1 << _SolidityParser.PublicKeyword - 97)) !== 0) {
          {
            this.state = 343;
            this._errHandler.sync(this);
            switch (this._input.LA(1)) {
              case _SolidityParser.PublicKeyword:
                {
                  this.state = 337;
                  this.match(_SolidityParser.PublicKeyword);
                }
                break;
              case _SolidityParser.InternalKeyword:
                {
                  this.state = 338;
                  this.match(_SolidityParser.InternalKeyword);
                }
                break;
              case _SolidityParser.PrivateKeyword:
                {
                  this.state = 339;
                  this.match(_SolidityParser.PrivateKeyword);
                }
                break;
              case _SolidityParser.ConstantKeyword:
                {
                  this.state = 340;
                  this.match(_SolidityParser.ConstantKeyword);
                }
                break;
              case _SolidityParser.ImmutableKeyword:
                {
                  this.state = 341;
                  this.match(_SolidityParser.ImmutableKeyword);
                }
                break;
              case _SolidityParser.T__96:
                {
                  this.state = 342;
                  this.overrideSpecifier();
                }
                break;
              default:
                throw new import_NoViableAltException.NoViableAltException(this);
            }
          }
          this.state = 347;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 348;
        this.identifier();
        this.state = 351;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.T__10) {
          {
            this.state = 349;
            this.match(_SolidityParser.T__10);
            this.state = 350;
            this.expression(0);
          }
        }
        this.state = 353;
        this.match(_SolidityParser.T__1);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  fileLevelConstant() {
    let _localctx = new FileLevelConstantContext(this._ctx, this.state);
    this.enterRule(_localctx, 28, _SolidityParser.RULE_fileLevelConstant);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 355;
        this.typeName(0);
        this.state = 356;
        this.match(_SolidityParser.ConstantKeyword);
        this.state = 357;
        this.identifier();
        this.state = 358;
        this.match(_SolidityParser.T__10);
        this.state = 359;
        this.expression(0);
        this.state = 360;
        this.match(_SolidityParser.T__1);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  customErrorDefinition() {
    let _localctx = new CustomErrorDefinitionContext(this._ctx, this.state);
    this.enterRule(_localctx, 30, _SolidityParser.RULE_customErrorDefinition);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 362;
        this.match(_SolidityParser.T__24);
        this.state = 363;
        this.identifier();
        this.state = 364;
        this.parameterList();
        this.state = 365;
        this.match(_SolidityParser.T__1);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  typeDefinition() {
    let _localctx = new TypeDefinitionContext(this._ctx, this.state);
    this.enterRule(_localctx, 32, _SolidityParser.RULE_typeDefinition);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 367;
        this.match(_SolidityParser.TypeKeyword);
        this.state = 368;
        this.identifier();
        this.state = 369;
        this.match(_SolidityParser.T__21);
        this.state = 370;
        this.elementaryTypeName();
        this.state = 371;
        this.match(_SolidityParser.T__1);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  usingForDeclaration() {
    let _localctx = new UsingForDeclarationContext(this._ctx, this.state);
    this.enterRule(_localctx, 34, _SolidityParser.RULE_usingForDeclaration);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 373;
        this.match(_SolidityParser.T__25);
        this.state = 374;
        this.usingForObject();
        this.state = 375;
        this.match(_SolidityParser.T__26);
        this.state = 378;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case _SolidityParser.T__2:
            {
              this.state = 376;
              this.match(_SolidityParser.T__2);
            }
            break;
          case _SolidityParser.T__13:
          case _SolidityParser.T__24:
          case _SolidityParser.T__29:
          case _SolidityParser.T__35:
          case _SolidityParser.T__37:
          case _SolidityParser.T__41:
          case _SolidityParser.T__53:
          case _SolidityParser.T__54:
          case _SolidityParser.T__55:
          case _SolidityParser.T__56:
          case _SolidityParser.T__57:
          case _SolidityParser.T__95:
          case _SolidityParser.Int:
          case _SolidityParser.Uint:
          case _SolidityParser.Byte:
          case _SolidityParser.Fixed:
          case _SolidityParser.Ufixed:
          case _SolidityParser.LeaveKeyword:
          case _SolidityParser.PayableKeyword:
          case _SolidityParser.ConstructorKeyword:
          case _SolidityParser.ReceiveKeyword:
          case _SolidityParser.Identifier:
            {
              this.state = 377;
              this.typeName(0);
            }
            break;
          default:
            throw new import_NoViableAltException.NoViableAltException(this);
        }
        this.state = 381;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.GlobalKeyword) {
          {
            this.state = 380;
            this.match(_SolidityParser.GlobalKeyword);
          }
        }
        this.state = 383;
        this.match(_SolidityParser.T__1);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  usingForObject() {
    let _localctx = new UsingForObjectContext(this._ctx, this.state);
    this.enterRule(_localctx, 36, _SolidityParser.RULE_usingForObject);
    let _la;
    try {
      this.state = 397;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _SolidityParser.T__13:
        case _SolidityParser.T__24:
        case _SolidityParser.T__35:
        case _SolidityParser.T__41:
        case _SolidityParser.T__53:
        case _SolidityParser.T__95:
        case _SolidityParser.LeaveKeyword:
        case _SolidityParser.PayableKeyword:
        case _SolidityParser.ConstructorKeyword:
        case _SolidityParser.ReceiveKeyword:
        case _SolidityParser.Identifier:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 385;
            this.userDefinedTypeName();
          }
          break;
        case _SolidityParser.T__14:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 386;
            this.match(_SolidityParser.T__14);
            this.state = 387;
            this.userDefinedTypeName();
            this.state = 392;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _SolidityParser.T__15) {
              {
                {
                  this.state = 388;
                  this.match(_SolidityParser.T__15);
                  this.state = 389;
                  this.userDefinedTypeName();
                }
              }
              this.state = 394;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 395;
            this.match(_SolidityParser.T__16);
          }
          break;
        default:
          throw new import_NoViableAltException.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  structDefinition() {
    let _localctx = new StructDefinitionContext(this._ctx, this.state);
    this.enterRule(_localctx, 38, _SolidityParser.RULE_structDefinition);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 399;
        this.match(_SolidityParser.T__27);
        this.state = 400;
        this.identifier();
        this.state = 401;
        this.match(_SolidityParser.T__14);
        this.state = 412;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__24 | 1 << _SolidityParser.T__29)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__37 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36 | 1 << _SolidityParser.T__54 - 36 | 1 << _SolidityParser.T__55 - 36 | 1 << _SolidityParser.T__56 - 36 | 1 << _SolidityParser.T__57 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {
          {
            this.state = 402;
            this.variableDeclaration();
            this.state = 403;
            this.match(_SolidityParser.T__1);
            this.state = 409;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__24 | 1 << _SolidityParser.T__29)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__37 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36 | 1 << _SolidityParser.T__54 - 36 | 1 << _SolidityParser.T__55 - 36 | 1 << _SolidityParser.T__56 - 36 | 1 << _SolidityParser.T__57 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {
              {
                {
                  this.state = 404;
                  this.variableDeclaration();
                  this.state = 405;
                  this.match(_SolidityParser.T__1);
                }
              }
              this.state = 411;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        }
        this.state = 414;
        this.match(_SolidityParser.T__16);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  modifierDefinition() {
    let _localctx = new ModifierDefinitionContext(this._ctx, this.state);
    this.enterRule(_localctx, 40, _SolidityParser.RULE_modifierDefinition);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 416;
        this.match(_SolidityParser.T__28);
        this.state = 417;
        this.identifier();
        this.state = 419;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.T__22) {
          {
            this.state = 418;
            this.parameterList();
          }
        }
        this.state = 425;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === _SolidityParser.T__96 || _la === _SolidityParser.VirtualKeyword) {
          {
            this.state = 423;
            this._errHandler.sync(this);
            switch (this._input.LA(1)) {
              case _SolidityParser.VirtualKeyword:
                {
                  this.state = 421;
                  this.match(_SolidityParser.VirtualKeyword);
                }
                break;
              case _SolidityParser.T__96:
                {
                  this.state = 422;
                  this.overrideSpecifier();
                }
                break;
              default:
                throw new import_NoViableAltException.NoViableAltException(this);
            }
          }
          this.state = 427;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 430;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case _SolidityParser.T__1:
            {
              this.state = 428;
              this.match(_SolidityParser.T__1);
            }
            break;
          case _SolidityParser.T__14:
            {
              this.state = 429;
              this.block();
            }
            break;
          default:
            throw new import_NoViableAltException.NoViableAltException(this);
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  modifierInvocation() {
    let _localctx = new ModifierInvocationContext(this._ctx, this.state);
    this.enterRule(_localctx, 42, _SolidityParser.RULE_modifierInvocation);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 432;
        this.identifier();
        this.state = 438;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.T__22) {
          {
            this.state = 433;
            this.match(_SolidityParser.T__22);
            this.state = 435;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {
              {
                this.state = 434;
                this.expressionList();
              }
            }
            this.state = 437;
            this.match(_SolidityParser.T__23);
          }
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  functionDefinition() {
    let _localctx = new FunctionDefinitionContext(this._ctx, this.state);
    this.enterRule(_localctx, 44, _SolidityParser.RULE_functionDefinition);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 440;
        this.functionDescriptor();
        this.state = 441;
        this.parameterList();
        this.state = 442;
        this.modifierList();
        this.state = 444;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.T__30) {
          {
            this.state = 443;
            this.returnParameters();
          }
        }
        this.state = 448;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case _SolidityParser.T__1:
            {
              this.state = 446;
              this.match(_SolidityParser.T__1);
            }
            break;
          case _SolidityParser.T__14:
            {
              this.state = 447;
              this.block();
            }
            break;
          default:
            throw new import_NoViableAltException.NoViableAltException(this);
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  functionDescriptor() {
    let _localctx = new FunctionDescriptorContext(this._ctx, this.state);
    this.enterRule(_localctx, 46, _SolidityParser.RULE_functionDescriptor);
    let _la;
    try {
      this.state = 457;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _SolidityParser.T__29:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 450;
            this.match(_SolidityParser.T__29);
            this.state = 452;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {
              {
                this.state = 451;
                this.identifier();
              }
            }
          }
          break;
        case _SolidityParser.ConstructorKeyword:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 454;
            this.match(_SolidityParser.ConstructorKeyword);
          }
          break;
        case _SolidityParser.FallbackKeyword:
          this.enterOuterAlt(_localctx, 3);
          {
            this.state = 455;
            this.match(_SolidityParser.FallbackKeyword);
          }
          break;
        case _SolidityParser.ReceiveKeyword:
          this.enterOuterAlt(_localctx, 4);
          {
            this.state = 456;
            this.match(_SolidityParser.ReceiveKeyword);
          }
          break;
        default:
          throw new import_NoViableAltException.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  returnParameters() {
    let _localctx = new ReturnParametersContext(this._ctx, this.state);
    this.enterRule(_localctx, 48, _SolidityParser.RULE_returnParameters);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 459;
        this.match(_SolidityParser.T__30);
        this.state = 460;
        this.parameterList();
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  modifierList() {
    let _localctx = new ModifierListContext(this._ctx, this.state);
    this.enterRule(_localctx, 50, _SolidityParser.RULE_modifierList);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 472;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.T__96 - 96 | 1 << _SolidityParser.ConstantKeyword - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.ExternalKeyword - 96 | 1 << _SolidityParser.InternalKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.PrivateKeyword - 96 | 1 << _SolidityParser.PublicKeyword - 96 | 1 << _SolidityParser.VirtualKeyword - 96 | 1 << _SolidityParser.PureKeyword - 96 | 1 << _SolidityParser.ViewKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {
          {
            this.state = 470;
            this._errHandler.sync(this);
            switch (this.interpreter.adaptivePredict(this._input, 40, this._ctx)) {
              case 1:
                {
                  this.state = 462;
                  this.match(_SolidityParser.ExternalKeyword);
                }
                break;
              case 2:
                {
                  this.state = 463;
                  this.match(_SolidityParser.PublicKeyword);
                }
                break;
              case 3:
                {
                  this.state = 464;
                  this.match(_SolidityParser.InternalKeyword);
                }
                break;
              case 4:
                {
                  this.state = 465;
                  this.match(_SolidityParser.PrivateKeyword);
                }
                break;
              case 5:
                {
                  this.state = 466;
                  this.match(_SolidityParser.VirtualKeyword);
                }
                break;
              case 6:
                {
                  this.state = 467;
                  this.stateMutability();
                }
                break;
              case 7:
                {
                  this.state = 468;
                  this.modifierInvocation();
                }
                break;
              case 8:
                {
                  this.state = 469;
                  this.overrideSpecifier();
                }
                break;
            }
          }
          this.state = 474;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  eventDefinition() {
    let _localctx = new EventDefinitionContext(this._ctx, this.state);
    this.enterRule(_localctx, 52, _SolidityParser.RULE_eventDefinition);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 475;
        this.match(_SolidityParser.T__31);
        this.state = 476;
        this.identifier();
        this.state = 477;
        this.eventParameterList();
        this.state = 479;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.AnonymousKeyword) {
          {
            this.state = 478;
            this.match(_SolidityParser.AnonymousKeyword);
          }
        }
        this.state = 481;
        this.match(_SolidityParser.T__1);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  enumValue() {
    let _localctx = new EnumValueContext(this._ctx, this.state);
    this.enterRule(_localctx, 54, _SolidityParser.RULE_enumValue);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 483;
        this.identifier();
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  enumDefinition() {
    let _localctx = new EnumDefinitionContext(this._ctx, this.state);
    this.enterRule(_localctx, 56, _SolidityParser.RULE_enumDefinition);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 485;
        this.match(_SolidityParser.T__32);
        this.state = 486;
        this.identifier();
        this.state = 487;
        this.match(_SolidityParser.T__14);
        this.state = 489;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {
          {
            this.state = 488;
            this.enumValue();
          }
        }
        this.state = 495;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === _SolidityParser.T__15) {
          {
            {
              this.state = 491;
              this.match(_SolidityParser.T__15);
              this.state = 492;
              this.enumValue();
            }
          }
          this.state = 497;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 498;
        this.match(_SolidityParser.T__16);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  parameterList() {
    let _localctx = new ParameterListContext(this._ctx, this.state);
    this.enterRule(_localctx, 58, _SolidityParser.RULE_parameterList);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 500;
        this.match(_SolidityParser.T__22);
        this.state = 509;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__24 | 1 << _SolidityParser.T__29)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__37 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36 | 1 << _SolidityParser.T__54 - 36 | 1 << _SolidityParser.T__55 - 36 | 1 << _SolidityParser.T__56 - 36 | 1 << _SolidityParser.T__57 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {
          {
            this.state = 501;
            this.parameter();
            this.state = 506;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _SolidityParser.T__15) {
              {
                {
                  this.state = 502;
                  this.match(_SolidityParser.T__15);
                  this.state = 503;
                  this.parameter();
                }
              }
              this.state = 508;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        }
        this.state = 511;
        this.match(_SolidityParser.T__23);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  parameter() {
    let _localctx = new ParameterContext(this._ctx, this.state);
    this.enterRule(_localctx, 60, _SolidityParser.RULE_parameter);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 513;
        this.typeName(0);
        this.state = 515;
        this._errHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this._input, 47, this._ctx)) {
          case 1:
            {
              this.state = 514;
              this.storageLocation();
            }
            break;
        }
        this.state = 518;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {
          {
            this.state = 517;
            this.identifier();
          }
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  eventParameterList() {
    let _localctx = new EventParameterListContext(this._ctx, this.state);
    this.enterRule(_localctx, 62, _SolidityParser.RULE_eventParameterList);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 520;
        this.match(_SolidityParser.T__22);
        this.state = 529;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__24 | 1 << _SolidityParser.T__29)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__37 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36 | 1 << _SolidityParser.T__54 - 36 | 1 << _SolidityParser.T__55 - 36 | 1 << _SolidityParser.T__56 - 36 | 1 << _SolidityParser.T__57 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {
          {
            this.state = 521;
            this.eventParameter();
            this.state = 526;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _SolidityParser.T__15) {
              {
                {
                  this.state = 522;
                  this.match(_SolidityParser.T__15);
                  this.state = 523;
                  this.eventParameter();
                }
              }
              this.state = 528;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        }
        this.state = 531;
        this.match(_SolidityParser.T__23);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  eventParameter() {
    let _localctx = new EventParameterContext(this._ctx, this.state);
    this.enterRule(_localctx, 64, _SolidityParser.RULE_eventParameter);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 533;
        this.typeName(0);
        this.state = 535;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.IndexedKeyword) {
          {
            this.state = 534;
            this.match(_SolidityParser.IndexedKeyword);
          }
        }
        this.state = 538;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {
          {
            this.state = 537;
            this.identifier();
          }
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  functionTypeParameterList() {
    let _localctx = new FunctionTypeParameterListContext(this._ctx, this.state);
    this.enterRule(_localctx, 66, _SolidityParser.RULE_functionTypeParameterList);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 540;
        this.match(_SolidityParser.T__22);
        this.state = 549;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__24 | 1 << _SolidityParser.T__29)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__37 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36 | 1 << _SolidityParser.T__54 - 36 | 1 << _SolidityParser.T__55 - 36 | 1 << _SolidityParser.T__56 - 36 | 1 << _SolidityParser.T__57 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {
          {
            this.state = 541;
            this.functionTypeParameter();
            this.state = 546;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _SolidityParser.T__15) {
              {
                {
                  this.state = 542;
                  this.match(_SolidityParser.T__15);
                  this.state = 543;
                  this.functionTypeParameter();
                }
              }
              this.state = 548;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
          }
        }
        this.state = 551;
        this.match(_SolidityParser.T__23);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  functionTypeParameter() {
    let _localctx = new FunctionTypeParameterContext(this._ctx, this.state);
    this.enterRule(_localctx, 68, _SolidityParser.RULE_functionTypeParameter);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 553;
        this.typeName(0);
        this.state = 555;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if ((_la - 40 & ~31) === 0 && (1 << _la - 40 & (1 << _SolidityParser.T__39 - 40 | 1 << _SolidityParser.T__40 - 40 | 1 << _SolidityParser.T__41 - 40)) !== 0) {
          {
            this.state = 554;
            this.storageLocation();
          }
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  variableDeclaration() {
    let _localctx = new VariableDeclarationContext(this._ctx, this.state);
    this.enterRule(_localctx, 70, _SolidityParser.RULE_variableDeclaration);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 557;
        this.typeName(0);
        this.state = 559;
        this._errHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this._input, 56, this._ctx)) {
          case 1:
            {
              this.state = 558;
              this.storageLocation();
            }
            break;
        }
        this.state = 561;
        this.identifier();
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  typeName(_p) {
    if (_p === void 0) {
      _p = 0;
    }
    let _parentctx = this._ctx;
    let _parentState = this.state;
    let _localctx = new TypeNameContext(this._ctx, _parentState);
    let _prevctx = _localctx;
    let _startState = 72;
    this.enterRecursionRule(_localctx, 72, _SolidityParser.RULE_typeName, _p);
    let _la;
    try {
      let _alt;
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 570;
        this._errHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this._input, 57, this._ctx)) {
          case 1:
            {
              this.state = 564;
              this.elementaryTypeName();
            }
            break;
          case 2:
            {
              this.state = 565;
              this.userDefinedTypeName();
            }
            break;
          case 3:
            {
              this.state = 566;
              this.mapping();
            }
            break;
          case 4:
            {
              this.state = 567;
              this.functionTypeName();
            }
            break;
          case 5:
            {
              this.state = 568;
              this.match(_SolidityParser.T__35);
              this.state = 569;
              this.match(_SolidityParser.PayableKeyword);
            }
            break;
        }
        this._ctx._stop = this._input.tryLT(-1);
        this.state = 580;
        this._errHandler.sync(this);
        _alt = this.interpreter.adaptivePredict(this._input, 59, this._ctx);
        while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            if (this._parseListeners != null) {
              this.triggerExitRuleEvent();
            }
            _prevctx = _localctx;
            {
              {
                _localctx = new TypeNameContext(_parentctx, _parentState);
                this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_typeName);
                this.state = 572;
                if (!this.precpred(this._ctx, 3)) {
                  throw this.createFailedPredicateException("this.precpred(this._ctx, 3)");
                }
                this.state = 573;
                this.match(_SolidityParser.T__33);
                this.state = 575;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {
                  {
                    this.state = 574;
                    this.expression(0);
                  }
                }
                this.state = 577;
                this.match(_SolidityParser.T__34);
              }
            }
          }
          this.state = 582;
          this._errHandler.sync(this);
          _alt = this.interpreter.adaptivePredict(this._input, 59, this._ctx);
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.unrollRecursionContexts(_parentctx);
    }
    return _localctx;
  }
  userDefinedTypeName() {
    let _localctx = new UserDefinedTypeNameContext(this._ctx, this.state);
    this.enterRule(_localctx, 74, _SolidityParser.RULE_userDefinedTypeName);
    try {
      let _alt;
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 583;
        this.identifier();
        this.state = 588;
        this._errHandler.sync(this);
        _alt = this.interpreter.adaptivePredict(this._input, 60, this._ctx);
        while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            {
              {
                this.state = 584;
                this.match(_SolidityParser.T__36);
                this.state = 585;
                this.identifier();
              }
            }
          }
          this.state = 590;
          this._errHandler.sync(this);
          _alt = this.interpreter.adaptivePredict(this._input, 60, this._ctx);
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  mappingKey() {
    let _localctx = new MappingKeyContext(this._ctx, this.state);
    this.enterRule(_localctx, 76, _SolidityParser.RULE_mappingKey);
    try {
      this.state = 593;
      this._errHandler.sync(this);
      switch (this.interpreter.adaptivePredict(this._input, 61, this._ctx)) {
        case 1:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 591;
            this.elementaryTypeName();
          }
          break;
        case 2:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 592;
            this.userDefinedTypeName();
          }
          break;
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  mapping() {
    let _localctx = new MappingContext(this._ctx, this.state);
    this.enterRule(_localctx, 78, _SolidityParser.RULE_mapping);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 595;
        this.match(_SolidityParser.T__37);
        this.state = 596;
        this.match(_SolidityParser.T__22);
        this.state = 597;
        this.mappingKey();
        this.state = 598;
        this.match(_SolidityParser.T__38);
        this.state = 599;
        this.typeName(0);
        this.state = 600;
        this.match(_SolidityParser.T__23);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  functionTypeName() {
    let _localctx = new FunctionTypeNameContext(this._ctx, this.state);
    this.enterRule(_localctx, 80, _SolidityParser.RULE_functionTypeName);
    try {
      let _alt;
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 602;
        this.match(_SolidityParser.T__29);
        this.state = 603;
        this.functionTypeParameterList();
        this.state = 609;
        this._errHandler.sync(this);
        _alt = this.interpreter.adaptivePredict(this._input, 63, this._ctx);
        while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            {
              this.state = 607;
              this._errHandler.sync(this);
              switch (this._input.LA(1)) {
                case _SolidityParser.InternalKeyword:
                  {
                    this.state = 604;
                    this.match(_SolidityParser.InternalKeyword);
                  }
                  break;
                case _SolidityParser.ExternalKeyword:
                  {
                    this.state = 605;
                    this.match(_SolidityParser.ExternalKeyword);
                  }
                  break;
                case _SolidityParser.ConstantKeyword:
                case _SolidityParser.PayableKeyword:
                case _SolidityParser.PureKeyword:
                case _SolidityParser.ViewKeyword:
                  {
                    this.state = 606;
                    this.stateMutability();
                  }
                  break;
                default:
                  throw new import_NoViableAltException.NoViableAltException(this);
              }
            }
          }
          this.state = 611;
          this._errHandler.sync(this);
          _alt = this.interpreter.adaptivePredict(this._input, 63, this._ctx);
        }
        this.state = 614;
        this._errHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this._input, 64, this._ctx)) {
          case 1:
            {
              this.state = 612;
              this.match(_SolidityParser.T__30);
              this.state = 613;
              this.functionTypeParameterList();
            }
            break;
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  storageLocation() {
    let _localctx = new StorageLocationContext(this._ctx, this.state);
    this.enterRule(_localctx, 82, _SolidityParser.RULE_storageLocation);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 616;
        _la = this._input.LA(1);
        if (!((_la - 40 & ~31) === 0 && (1 << _la - 40 & (1 << _SolidityParser.T__39 - 40 | 1 << _SolidityParser.T__40 - 40 | 1 << _SolidityParser.T__41 - 40)) !== 0)) {
          this._errHandler.recoverInline(this);
        } else {
          if (this._input.LA(1) === import_Token.Token.EOF) {
            this.matchedEOF = true;
          }
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  stateMutability() {
    let _localctx = new StateMutabilityContext(this._ctx, this.state);
    this.enterRule(_localctx, 84, _SolidityParser.RULE_stateMutability);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 618;
        _la = this._input.LA(1);
        if (!((_la - 111 & ~31) === 0 && (1 << _la - 111 & (1 << _SolidityParser.ConstantKeyword - 111 | 1 << _SolidityParser.PayableKeyword - 111 | 1 << _SolidityParser.PureKeyword - 111 | 1 << _SolidityParser.ViewKeyword - 111)) !== 0)) {
          this._errHandler.recoverInline(this);
        } else {
          if (this._input.LA(1) === import_Token.Token.EOF) {
            this.matchedEOF = true;
          }
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  block() {
    let _localctx = new BlockContext(this._ctx, this.state);
    this.enterRule(_localctx, 86, _SolidityParser.RULE_block);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 620;
        this.match(_SolidityParser.T__14);
        this.state = 624;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__14 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__26 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__42 - 38 | 1 << _SolidityParser.T__44 - 38 | 1 << _SolidityParser.T__46 - 38 | 1 << _SolidityParser.T__47 - 38 | 1 << _SolidityParser.T__48 - 38 | 1 << _SolidityParser.T__49 - 38 | 1 << _SolidityParser.T__50 - 38 | 1 << _SolidityParser.T__51 - 38 | 1 << _SolidityParser.T__52 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.BreakKeyword - 96 | 1 << _SolidityParser.ContinueKeyword - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {
          {
            {
              this.state = 621;
              this.statement();
            }
          }
          this.state = 626;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 627;
        this.match(_SolidityParser.T__16);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  statement() {
    let _localctx = new StatementContext(this._ctx, this.state);
    this.enterRule(_localctx, 88, _SolidityParser.RULE_statement);
    try {
      this.state = 644;
      this._errHandler.sync(this);
      switch (this.interpreter.adaptivePredict(this._input, 66, this._ctx)) {
        case 1:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 629;
            this.ifStatement();
          }
          break;
        case 2:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 630;
            this.tryStatement();
          }
          break;
        case 3:
          this.enterOuterAlt(_localctx, 3);
          {
            this.state = 631;
            this.whileStatement();
          }
          break;
        case 4:
          this.enterOuterAlt(_localctx, 4);
          {
            this.state = 632;
            this.forStatement();
          }
          break;
        case 5:
          this.enterOuterAlt(_localctx, 5);
          {
            this.state = 633;
            this.block();
          }
          break;
        case 6:
          this.enterOuterAlt(_localctx, 6);
          {
            this.state = 634;
            this.inlineAssemblyStatement();
          }
          break;
        case 7:
          this.enterOuterAlt(_localctx, 7);
          {
            this.state = 635;
            this.doWhileStatement();
          }
          break;
        case 8:
          this.enterOuterAlt(_localctx, 8);
          {
            this.state = 636;
            this.continueStatement();
          }
          break;
        case 9:
          this.enterOuterAlt(_localctx, 9);
          {
            this.state = 637;
            this.breakStatement();
          }
          break;
        case 10:
          this.enterOuterAlt(_localctx, 10);
          {
            this.state = 638;
            this.returnStatement();
          }
          break;
        case 11:
          this.enterOuterAlt(_localctx, 11);
          {
            this.state = 639;
            this.throwStatement();
          }
          break;
        case 12:
          this.enterOuterAlt(_localctx, 12);
          {
            this.state = 640;
            this.emitStatement();
          }
          break;
        case 13:
          this.enterOuterAlt(_localctx, 13);
          {
            this.state = 641;
            this.simpleStatement();
          }
          break;
        case 14:
          this.enterOuterAlt(_localctx, 14);
          {
            this.state = 642;
            this.uncheckedStatement();
          }
          break;
        case 15:
          this.enterOuterAlt(_localctx, 15);
          {
            this.state = 643;
            this.revertStatement();
          }
          break;
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  expressionStatement() {
    let _localctx = new ExpressionStatementContext(this._ctx, this.state);
    this.enterRule(_localctx, 90, _SolidityParser.RULE_expressionStatement);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 646;
        this.expression(0);
        this.state = 647;
        this.match(_SolidityParser.T__1);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  ifStatement() {
    let _localctx = new IfStatementContext(this._ctx, this.state);
    this.enterRule(_localctx, 92, _SolidityParser.RULE_ifStatement);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 649;
        this.match(_SolidityParser.T__42);
        this.state = 650;
        this.match(_SolidityParser.T__22);
        this.state = 651;
        this.expression(0);
        this.state = 652;
        this.match(_SolidityParser.T__23);
        this.state = 653;
        this.statement();
        this.state = 656;
        this._errHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this._input, 67, this._ctx)) {
          case 1:
            {
              this.state = 654;
              this.match(_SolidityParser.T__43);
              this.state = 655;
              this.statement();
            }
            break;
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  tryStatement() {
    let _localctx = new TryStatementContext(this._ctx, this.state);
    this.enterRule(_localctx, 94, _SolidityParser.RULE_tryStatement);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 658;
        this.match(_SolidityParser.T__44);
        this.state = 659;
        this.expression(0);
        this.state = 661;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.T__30) {
          {
            this.state = 660;
            this.returnParameters();
          }
        }
        this.state = 663;
        this.block();
        this.state = 665;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        do {
          {
            {
              this.state = 664;
              this.catchClause();
            }
          }
          this.state = 667;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        } while (_la === _SolidityParser.T__45);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  catchClause() {
    let _localctx = new CatchClauseContext(this._ctx, this.state);
    this.enterRule(_localctx, 96, _SolidityParser.RULE_catchClause);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 669;
        this.match(_SolidityParser.T__45);
        this.state = 674;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__22 | 1 << _SolidityParser.T__24)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {
          {
            this.state = 671;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {
              {
                this.state = 670;
                this.identifier();
              }
            }
            this.state = 673;
            this.parameterList();
          }
        }
        this.state = 676;
        this.block();
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  whileStatement() {
    let _localctx = new WhileStatementContext(this._ctx, this.state);
    this.enterRule(_localctx, 98, _SolidityParser.RULE_whileStatement);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 678;
        this.match(_SolidityParser.T__46);
        this.state = 679;
        this.match(_SolidityParser.T__22);
        this.state = 680;
        this.expression(0);
        this.state = 681;
        this.match(_SolidityParser.T__23);
        this.state = 682;
        this.statement();
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  simpleStatement() {
    let _localctx = new SimpleStatementContext(this._ctx, this.state);
    this.enterRule(_localctx, 100, _SolidityParser.RULE_simpleStatement);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 686;
        this._errHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this._input, 72, this._ctx)) {
          case 1:
            {
              this.state = 684;
              this.variableDeclarationStatement();
            }
            break;
          case 2:
            {
              this.state = 685;
              this.expressionStatement();
            }
            break;
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  uncheckedStatement() {
    let _localctx = new UncheckedStatementContext(this._ctx, this.state);
    this.enterRule(_localctx, 102, _SolidityParser.RULE_uncheckedStatement);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 688;
        this.match(_SolidityParser.T__47);
        this.state = 689;
        this.block();
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  forStatement() {
    let _localctx = new ForStatementContext(this._ctx, this.state);
    this.enterRule(_localctx, 104, _SolidityParser.RULE_forStatement);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 691;
        this.match(_SolidityParser.T__26);
        this.state = 692;
        this.match(_SolidityParser.T__22);
        this.state = 695;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case _SolidityParser.T__5:
          case _SolidityParser.T__13:
          case _SolidityParser.T__22:
          case _SolidityParser.T__24:
          case _SolidityParser.T__29:
          case _SolidityParser.T__33:
          case _SolidityParser.T__35:
          case _SolidityParser.T__37:
          case _SolidityParser.T__41:
          case _SolidityParser.T__53:
          case _SolidityParser.T__54:
          case _SolidityParser.T__55:
          case _SolidityParser.T__56:
          case _SolidityParser.T__57:
          case _SolidityParser.T__58:
          case _SolidityParser.T__59:
          case _SolidityParser.T__60:
          case _SolidityParser.T__62:
          case _SolidityParser.T__63:
          case _SolidityParser.T__64:
          case _SolidityParser.T__65:
          case _SolidityParser.T__66:
          case _SolidityParser.T__95:
          case _SolidityParser.Int:
          case _SolidityParser.Uint:
          case _SolidityParser.Byte:
          case _SolidityParser.Fixed:
          case _SolidityParser.Ufixed:
          case _SolidityParser.BooleanLiteral:
          case _SolidityParser.DecimalNumber:
          case _SolidityParser.HexNumber:
          case _SolidityParser.HexLiteralFragment:
          case _SolidityParser.LeaveKeyword:
          case _SolidityParser.PayableKeyword:
          case _SolidityParser.TypeKeyword:
          case _SolidityParser.ConstructorKeyword:
          case _SolidityParser.ReceiveKeyword:
          case _SolidityParser.Identifier:
          case _SolidityParser.StringLiteralFragment:
            {
              this.state = 693;
              this.simpleStatement();
            }
            break;
          case _SolidityParser.T__1:
            {
              this.state = 694;
              this.match(_SolidityParser.T__1);
            }
            break;
          default:
            throw new import_NoViableAltException.NoViableAltException(this);
        }
        this.state = 699;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case _SolidityParser.T__5:
          case _SolidityParser.T__13:
          case _SolidityParser.T__22:
          case _SolidityParser.T__24:
          case _SolidityParser.T__29:
          case _SolidityParser.T__33:
          case _SolidityParser.T__35:
          case _SolidityParser.T__37:
          case _SolidityParser.T__41:
          case _SolidityParser.T__53:
          case _SolidityParser.T__54:
          case _SolidityParser.T__55:
          case _SolidityParser.T__56:
          case _SolidityParser.T__57:
          case _SolidityParser.T__58:
          case _SolidityParser.T__59:
          case _SolidityParser.T__60:
          case _SolidityParser.T__62:
          case _SolidityParser.T__63:
          case _SolidityParser.T__64:
          case _SolidityParser.T__65:
          case _SolidityParser.T__66:
          case _SolidityParser.T__95:
          case _SolidityParser.Int:
          case _SolidityParser.Uint:
          case _SolidityParser.Byte:
          case _SolidityParser.Fixed:
          case _SolidityParser.Ufixed:
          case _SolidityParser.BooleanLiteral:
          case _SolidityParser.DecimalNumber:
          case _SolidityParser.HexNumber:
          case _SolidityParser.HexLiteralFragment:
          case _SolidityParser.LeaveKeyword:
          case _SolidityParser.PayableKeyword:
          case _SolidityParser.TypeKeyword:
          case _SolidityParser.ConstructorKeyword:
          case _SolidityParser.ReceiveKeyword:
          case _SolidityParser.Identifier:
          case _SolidityParser.StringLiteralFragment:
            {
              this.state = 697;
              this.expressionStatement();
            }
            break;
          case _SolidityParser.T__1:
            {
              this.state = 698;
              this.match(_SolidityParser.T__1);
            }
            break;
          default:
            throw new import_NoViableAltException.NoViableAltException(this);
        }
        this.state = 702;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {
          {
            this.state = 701;
            this.expression(0);
          }
        }
        this.state = 704;
        this.match(_SolidityParser.T__23);
        this.state = 705;
        this.statement();
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  inlineAssemblyStatement() {
    let _localctx = new InlineAssemblyStatementContext(this._ctx, this.state);
    this.enterRule(_localctx, 106, _SolidityParser.RULE_inlineAssemblyStatement);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 707;
        this.match(_SolidityParser.T__48);
        this.state = 709;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.StringLiteralFragment) {
          {
            this.state = 708;
            this.match(_SolidityParser.StringLiteralFragment);
          }
        }
        this.state = 715;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.T__22) {
          {
            this.state = 711;
            this.match(_SolidityParser.T__22);
            this.state = 712;
            this.inlineAssemblyStatementFlag();
            this.state = 713;
            this.match(_SolidityParser.T__23);
          }
        }
        this.state = 717;
        this.assemblyBlock();
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  inlineAssemblyStatementFlag() {
    let _localctx = new InlineAssemblyStatementFlagContext(this._ctx, this.state);
    this.enterRule(_localctx, 108, _SolidityParser.RULE_inlineAssemblyStatementFlag);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 719;
        this.stringLiteral();
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  doWhileStatement() {
    let _localctx = new DoWhileStatementContext(this._ctx, this.state);
    this.enterRule(_localctx, 110, _SolidityParser.RULE_doWhileStatement);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 721;
        this.match(_SolidityParser.T__49);
        this.state = 722;
        this.statement();
        this.state = 723;
        this.match(_SolidityParser.T__46);
        this.state = 724;
        this.match(_SolidityParser.T__22);
        this.state = 725;
        this.expression(0);
        this.state = 726;
        this.match(_SolidityParser.T__23);
        this.state = 727;
        this.match(_SolidityParser.T__1);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  continueStatement() {
    let _localctx = new ContinueStatementContext(this._ctx, this.state);
    this.enterRule(_localctx, 112, _SolidityParser.RULE_continueStatement);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 729;
        this.match(_SolidityParser.ContinueKeyword);
        this.state = 730;
        this.match(_SolidityParser.T__1);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  breakStatement() {
    let _localctx = new BreakStatementContext(this._ctx, this.state);
    this.enterRule(_localctx, 114, _SolidityParser.RULE_breakStatement);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 732;
        this.match(_SolidityParser.BreakKeyword);
        this.state = 733;
        this.match(_SolidityParser.T__1);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  returnStatement() {
    let _localctx = new ReturnStatementContext(this._ctx, this.state);
    this.enterRule(_localctx, 116, _SolidityParser.RULE_returnStatement);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 735;
        this.match(_SolidityParser.T__50);
        this.state = 737;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {
          {
            this.state = 736;
            this.expression(0);
          }
        }
        this.state = 739;
        this.match(_SolidityParser.T__1);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  throwStatement() {
    let _localctx = new ThrowStatementContext(this._ctx, this.state);
    this.enterRule(_localctx, 118, _SolidityParser.RULE_throwStatement);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 741;
        this.match(_SolidityParser.T__51);
        this.state = 742;
        this.match(_SolidityParser.T__1);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  emitStatement() {
    let _localctx = new EmitStatementContext(this._ctx, this.state);
    this.enterRule(_localctx, 120, _SolidityParser.RULE_emitStatement);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 744;
        this.match(_SolidityParser.T__52);
        this.state = 745;
        this.functionCall();
        this.state = 746;
        this.match(_SolidityParser.T__1);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  revertStatement() {
    let _localctx = new RevertStatementContext(this._ctx, this.state);
    this.enterRule(_localctx, 122, _SolidityParser.RULE_revertStatement);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 748;
        this.match(_SolidityParser.T__53);
        this.state = 749;
        this.functionCall();
        this.state = 750;
        this.match(_SolidityParser.T__1);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  variableDeclarationStatement() {
    let _localctx = new VariableDeclarationStatementContext(this._ctx, this.state);
    this.enterRule(_localctx, 124, _SolidityParser.RULE_variableDeclarationStatement);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 759;
        this._errHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this._input, 79, this._ctx)) {
          case 1:
            {
              this.state = 752;
              this.match(_SolidityParser.T__54);
              this.state = 753;
              this.identifierList();
            }
            break;
          case 2:
            {
              this.state = 754;
              this.variableDeclaration();
            }
            break;
          case 3:
            {
              this.state = 755;
              this.match(_SolidityParser.T__22);
              this.state = 756;
              this.variableDeclarationList();
              this.state = 757;
              this.match(_SolidityParser.T__23);
            }
            break;
        }
        this.state = 763;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.T__10) {
          {
            this.state = 761;
            this.match(_SolidityParser.T__10);
            this.state = 762;
            this.expression(0);
          }
        }
        this.state = 765;
        this.match(_SolidityParser.T__1);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  variableDeclarationList() {
    let _localctx = new VariableDeclarationListContext(this._ctx, this.state);
    this.enterRule(_localctx, 126, _SolidityParser.RULE_variableDeclarationList);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 768;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__24 | 1 << _SolidityParser.T__29)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__37 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36 | 1 << _SolidityParser.T__54 - 36 | 1 << _SolidityParser.T__55 - 36 | 1 << _SolidityParser.T__56 - 36 | 1 << _SolidityParser.T__57 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {
          {
            this.state = 767;
            this.variableDeclaration();
          }
        }
        this.state = 776;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === _SolidityParser.T__15) {
          {
            {
              this.state = 770;
              this.match(_SolidityParser.T__15);
              this.state = 772;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__24 | 1 << _SolidityParser.T__29)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__37 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36 | 1 << _SolidityParser.T__54 - 36 | 1 << _SolidityParser.T__55 - 36 | 1 << _SolidityParser.T__56 - 36 | 1 << _SolidityParser.T__57 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {
                {
                  this.state = 771;
                  this.variableDeclaration();
                }
              }
            }
          }
          this.state = 778;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  identifierList() {
    let _localctx = new IdentifierListContext(this._ctx, this.state);
    this.enterRule(_localctx, 128, _SolidityParser.RULE_identifierList);
    let _la;
    try {
      let _alt;
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 779;
        this.match(_SolidityParser.T__22);
        this.state = 786;
        this._errHandler.sync(this);
        _alt = this.interpreter.adaptivePredict(this._input, 85, this._ctx);
        while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            {
              {
                this.state = 781;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                if (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {
                  {
                    this.state = 780;
                    this.identifier();
                  }
                }
                this.state = 783;
                this.match(_SolidityParser.T__15);
              }
            }
          }
          this.state = 788;
          this._errHandler.sync(this);
          _alt = this.interpreter.adaptivePredict(this._input, 85, this._ctx);
        }
        this.state = 790;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {
          {
            this.state = 789;
            this.identifier();
          }
        }
        this.state = 792;
        this.match(_SolidityParser.T__23);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  elementaryTypeName() {
    let _localctx = new ElementaryTypeNameContext(this._ctx, this.state);
    this.enterRule(_localctx, 130, _SolidityParser.RULE_elementaryTypeName);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 794;
        _la = this._input.LA(1);
        if (!((_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__54 - 36 | 1 << _SolidityParser.T__55 - 36 | 1 << _SolidityParser.T__56 - 36 | 1 << _SolidityParser.T__57 - 36)) !== 0 || (_la - 98 & ~31) === 0 && (1 << _la - 98 & (1 << _SolidityParser.Int - 98 | 1 << _SolidityParser.Uint - 98 | 1 << _SolidityParser.Byte - 98 | 1 << _SolidityParser.Fixed - 98 | 1 << _SolidityParser.Ufixed - 98)) !== 0)) {
          this._errHandler.recoverInline(this);
        } else {
          if (this._input.LA(1) === import_Token.Token.EOF) {
            this.matchedEOF = true;
          }
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  expression(_p) {
    if (_p === void 0) {
      _p = 0;
    }
    let _parentctx = this._ctx;
    let _parentState = this.state;
    let _localctx = new ExpressionContext(this._ctx, _parentState);
    let _prevctx = _localctx;
    let _startState = 132;
    this.enterRecursionRule(_localctx, 132, _SolidityParser.RULE_expression, _p);
    let _la;
    try {
      let _alt;
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 814;
        this._errHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this._input, 87, this._ctx)) {
          case 1:
            {
              this.state = 797;
              this.match(_SolidityParser.T__60);
              this.state = 798;
              this.typeName(0);
            }
            break;
          case 2:
            {
              this.state = 799;
              this.match(_SolidityParser.T__22);
              this.state = 800;
              this.expression(0);
              this.state = 801;
              this.match(_SolidityParser.T__23);
            }
            break;
          case 3:
            {
              this.state = 803;
              _la = this._input.LA(1);
              if (!(_la === _SolidityParser.T__58 || _la === _SolidityParser.T__59)) {
                this._errHandler.recoverInline(this);
              } else {
                if (this._input.LA(1) === import_Token.Token.EOF) {
                  this.matchedEOF = true;
                }
                this._errHandler.reportMatch(this);
                this.consume();
              }
              this.state = 804;
              this.expression(19);
            }
            break;
          case 4:
            {
              this.state = 805;
              _la = this._input.LA(1);
              if (!(_la === _SolidityParser.T__62 || _la === _SolidityParser.T__63)) {
                this._errHandler.recoverInline(this);
              } else {
                if (this._input.LA(1) === import_Token.Token.EOF) {
                  this.matchedEOF = true;
                }
                this._errHandler.reportMatch(this);
                this.consume();
              }
              this.state = 806;
              this.expression(18);
            }
            break;
          case 5:
            {
              this.state = 807;
              _la = this._input.LA(1);
              if (!(_la === _SolidityParser.T__64 || _la === _SolidityParser.T__65)) {
                this._errHandler.recoverInline(this);
              } else {
                if (this._input.LA(1) === import_Token.Token.EOF) {
                  this.matchedEOF = true;
                }
                this._errHandler.reportMatch(this);
                this.consume();
              }
              this.state = 808;
              this.expression(17);
            }
            break;
          case 6:
            {
              this.state = 809;
              this.match(_SolidityParser.T__66);
              this.state = 810;
              this.expression(16);
            }
            break;
          case 7:
            {
              this.state = 811;
              this.match(_SolidityParser.T__5);
              this.state = 812;
              this.expression(15);
            }
            break;
          case 8:
            {
              this.state = 813;
              this.primaryExpression();
            }
            break;
        }
        this._ctx._stop = this._input.tryLT(-1);
        this.state = 890;
        this._errHandler.sync(this);
        _alt = this.interpreter.adaptivePredict(this._input, 91, this._ctx);
        while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            if (this._parseListeners != null) {
              this.triggerExitRuleEvent();
            }
            _prevctx = _localctx;
            {
              this.state = 888;
              this._errHandler.sync(this);
              switch (this.interpreter.adaptivePredict(this._input, 90, this._ctx)) {
                case 1:
                  {
                    _localctx = new ExpressionContext(_parentctx, _parentState);
                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);
                    this.state = 816;
                    if (!this.precpred(this._ctx, 14)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 14)");
                    }
                    this.state = 817;
                    this.match(_SolidityParser.T__67);
                    this.state = 818;
                    this.expression(15);
                  }
                  break;
                case 2:
                  {
                    _localctx = new ExpressionContext(_parentctx, _parentState);
                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);
                    this.state = 819;
                    if (!this.precpred(this._ctx, 13)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 13)");
                    }
                    this.state = 820;
                    _la = this._input.LA(1);
                    if (!(_la === _SolidityParser.T__2 || _la === _SolidityParser.T__68 || _la === _SolidityParser.T__69)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      if (this._input.LA(1) === import_Token.Token.EOF) {
                        this.matchedEOF = true;
                      }
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                    this.state = 821;
                    this.expression(14);
                  }
                  break;
                case 3:
                  {
                    _localctx = new ExpressionContext(_parentctx, _parentState);
                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);
                    this.state = 822;
                    if (!this.precpred(this._ctx, 12)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 12)");
                    }
                    this.state = 823;
                    _la = this._input.LA(1);
                    if (!(_la === _SolidityParser.T__62 || _la === _SolidityParser.T__63)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      if (this._input.LA(1) === import_Token.Token.EOF) {
                        this.matchedEOF = true;
                      }
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                    this.state = 824;
                    this.expression(13);
                  }
                  break;
                case 4:
                  {
                    _localctx = new ExpressionContext(_parentctx, _parentState);
                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);
                    this.state = 825;
                    if (!this.precpred(this._ctx, 11)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 11)");
                    }
                    this.state = 826;
                    _la = this._input.LA(1);
                    if (!(_la === _SolidityParser.T__70 || _la === _SolidityParser.T__71)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      if (this._input.LA(1) === import_Token.Token.EOF) {
                        this.matchedEOF = true;
                      }
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                    this.state = 827;
                    this.expression(12);
                  }
                  break;
                case 5:
                  {
                    _localctx = new ExpressionContext(_parentctx, _parentState);
                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);
                    this.state = 828;
                    if (!this.precpred(this._ctx, 10)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 10)");
                    }
                    this.state = 829;
                    this.match(_SolidityParser.T__72);
                    this.state = 830;
                    this.expression(11);
                  }
                  break;
                case 6:
                  {
                    _localctx = new ExpressionContext(_parentctx, _parentState);
                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);
                    this.state = 831;
                    if (!this.precpred(this._ctx, 9)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 9)");
                    }
                    this.state = 832;
                    this.match(_SolidityParser.T__4);
                    this.state = 833;
                    this.expression(10);
                  }
                  break;
                case 7:
                  {
                    _localctx = new ExpressionContext(_parentctx, _parentState);
                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);
                    this.state = 834;
                    if (!this.precpred(this._ctx, 8)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 8)");
                    }
                    this.state = 835;
                    this.match(_SolidityParser.T__73);
                    this.state = 836;
                    this.expression(9);
                  }
                  break;
                case 8:
                  {
                    _localctx = new ExpressionContext(_parentctx, _parentState);
                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);
                    this.state = 837;
                    if (!this.precpred(this._ctx, 7)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 7)");
                    }
                    this.state = 838;
                    _la = this._input.LA(1);
                    if (!((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__6 | 1 << _SolidityParser.T__7 | 1 << _SolidityParser.T__8 | 1 << _SolidityParser.T__9)) !== 0)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      if (this._input.LA(1) === import_Token.Token.EOF) {
                        this.matchedEOF = true;
                      }
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                    this.state = 839;
                    this.expression(8);
                  }
                  break;
                case 9:
                  {
                    _localctx = new ExpressionContext(_parentctx, _parentState);
                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);
                    this.state = 840;
                    if (!this.precpred(this._ctx, 6)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 6)");
                    }
                    this.state = 841;
                    _la = this._input.LA(1);
                    if (!(_la === _SolidityParser.T__74 || _la === _SolidityParser.T__75)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      if (this._input.LA(1) === import_Token.Token.EOF) {
                        this.matchedEOF = true;
                      }
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                    this.state = 842;
                    this.expression(7);
                  }
                  break;
                case 10:
                  {
                    _localctx = new ExpressionContext(_parentctx, _parentState);
                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);
                    this.state = 843;
                    if (!this.precpred(this._ctx, 5)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 5)");
                    }
                    this.state = 844;
                    this.match(_SolidityParser.T__76);
                    this.state = 845;
                    this.expression(6);
                  }
                  break;
                case 11:
                  {
                    _localctx = new ExpressionContext(_parentctx, _parentState);
                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);
                    this.state = 846;
                    if (!this.precpred(this._ctx, 4)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 4)");
                    }
                    this.state = 847;
                    this.match(_SolidityParser.T__3);
                    this.state = 848;
                    this.expression(5);
                  }
                  break;
                case 12:
                  {
                    _localctx = new ExpressionContext(_parentctx, _parentState);
                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);
                    this.state = 849;
                    if (!this.precpred(this._ctx, 3)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 3)");
                    }
                    this.state = 850;
                    this.match(_SolidityParser.T__77);
                    this.state = 851;
                    this.expression(0);
                    this.state = 852;
                    this.match(_SolidityParser.T__61);
                    this.state = 853;
                    this.expression(4);
                  }
                  break;
                case 13:
                  {
                    _localctx = new ExpressionContext(_parentctx, _parentState);
                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);
                    this.state = 855;
                    if (!this.precpred(this._ctx, 2)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 2)");
                    }
                    this.state = 856;
                    _la = this._input.LA(1);
                    if (!(_la === _SolidityParser.T__10 || (_la - 79 & ~31) === 0 && (1 << _la - 79 & (1 << _SolidityParser.T__78 - 79 | 1 << _SolidityParser.T__79 - 79 | 1 << _SolidityParser.T__80 - 79 | 1 << _SolidityParser.T__81 - 79 | 1 << _SolidityParser.T__82 - 79 | 1 << _SolidityParser.T__83 - 79 | 1 << _SolidityParser.T__84 - 79 | 1 << _SolidityParser.T__85 - 79 | 1 << _SolidityParser.T__86 - 79 | 1 << _SolidityParser.T__87 - 79)) !== 0)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      if (this._input.LA(1) === import_Token.Token.EOF) {
                        this.matchedEOF = true;
                      }
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                    this.state = 857;
                    this.expression(3);
                  }
                  break;
                case 14:
                  {
                    _localctx = new ExpressionContext(_parentctx, _parentState);
                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);
                    this.state = 858;
                    if (!this.precpred(this._ctx, 27)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 27)");
                    }
                    this.state = 859;
                    _la = this._input.LA(1);
                    if (!(_la === _SolidityParser.T__58 || _la === _SolidityParser.T__59)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      if (this._input.LA(1) === import_Token.Token.EOF) {
                        this.matchedEOF = true;
                      }
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                  }
                  break;
                case 15:
                  {
                    _localctx = new ExpressionContext(_parentctx, _parentState);
                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);
                    this.state = 860;
                    if (!this.precpred(this._ctx, 25)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 25)");
                    }
                    this.state = 861;
                    this.match(_SolidityParser.T__33);
                    this.state = 862;
                    this.expression(0);
                    this.state = 863;
                    this.match(_SolidityParser.T__34);
                  }
                  break;
                case 16:
                  {
                    _localctx = new ExpressionContext(_parentctx, _parentState);
                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);
                    this.state = 865;
                    if (!this.precpred(this._ctx, 24)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 24)");
                    }
                    this.state = 866;
                    this.match(_SolidityParser.T__33);
                    this.state = 868;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                    if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {
                      {
                        this.state = 867;
                        this.expression(0);
                      }
                    }
                    this.state = 870;
                    this.match(_SolidityParser.T__61);
                    this.state = 872;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                    if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {
                      {
                        this.state = 871;
                        this.expression(0);
                      }
                    }
                    this.state = 874;
                    this.match(_SolidityParser.T__34);
                  }
                  break;
                case 17:
                  {
                    _localctx = new ExpressionContext(_parentctx, _parentState);
                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);
                    this.state = 875;
                    if (!this.precpred(this._ctx, 23)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 23)");
                    }
                    this.state = 876;
                    this.match(_SolidityParser.T__36);
                    this.state = 877;
                    this.identifier();
                  }
                  break;
                case 18:
                  {
                    _localctx = new ExpressionContext(_parentctx, _parentState);
                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);
                    this.state = 878;
                    if (!this.precpred(this._ctx, 22)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 22)");
                    }
                    this.state = 879;
                    this.match(_SolidityParser.T__14);
                    this.state = 880;
                    this.nameValueList();
                    this.state = 881;
                    this.match(_SolidityParser.T__16);
                  }
                  break;
                case 19:
                  {
                    _localctx = new ExpressionContext(_parentctx, _parentState);
                    this.pushNewRecursionContext(_localctx, _startState, _SolidityParser.RULE_expression);
                    this.state = 883;
                    if (!this.precpred(this._ctx, 21)) {
                      throw this.createFailedPredicateException("this.precpred(this._ctx, 21)");
                    }
                    this.state = 884;
                    this.match(_SolidityParser.T__22);
                    this.state = 885;
                    this.functionCallArguments();
                    this.state = 886;
                    this.match(_SolidityParser.T__23);
                  }
                  break;
              }
            }
          }
          this.state = 892;
          this._errHandler.sync(this);
          _alt = this.interpreter.adaptivePredict(this._input, 91, this._ctx);
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.unrollRecursionContexts(_parentctx);
    }
    return _localctx;
  }
  primaryExpression() {
    let _localctx = new PrimaryExpressionContext(this._ctx, this.state);
    this.enterRule(_localctx, 134, _SolidityParser.RULE_primaryExpression);
    try {
      this.state = 902;
      this._errHandler.sync(this);
      switch (this.interpreter.adaptivePredict(this._input, 92, this._ctx)) {
        case 1:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 893;
            this.match(_SolidityParser.BooleanLiteral);
          }
          break;
        case 2:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 894;
            this.numberLiteral();
          }
          break;
        case 3:
          this.enterOuterAlt(_localctx, 3);
          {
            this.state = 895;
            this.hexLiteral();
          }
          break;
        case 4:
          this.enterOuterAlt(_localctx, 4);
          {
            this.state = 896;
            this.stringLiteral();
          }
          break;
        case 5:
          this.enterOuterAlt(_localctx, 5);
          {
            this.state = 897;
            this.identifier();
          }
          break;
        case 6:
          this.enterOuterAlt(_localctx, 6);
          {
            this.state = 898;
            this.match(_SolidityParser.TypeKeyword);
          }
          break;
        case 7:
          this.enterOuterAlt(_localctx, 7);
          {
            this.state = 899;
            this.match(_SolidityParser.PayableKeyword);
          }
          break;
        case 8:
          this.enterOuterAlt(_localctx, 8);
          {
            this.state = 900;
            this.tupleExpression();
          }
          break;
        case 9:
          this.enterOuterAlt(_localctx, 9);
          {
            this.state = 901;
            this.typeName(0);
          }
          break;
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  expressionList() {
    let _localctx = new ExpressionListContext(this._ctx, this.state);
    this.enterRule(_localctx, 136, _SolidityParser.RULE_expressionList);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 904;
        this.expression(0);
        this.state = 909;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === _SolidityParser.T__15) {
          {
            {
              this.state = 905;
              this.match(_SolidityParser.T__15);
              this.state = 906;
              this.expression(0);
            }
          }
          this.state = 911;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  nameValueList() {
    let _localctx = new NameValueListContext(this._ctx, this.state);
    this.enterRule(_localctx, 138, _SolidityParser.RULE_nameValueList);
    let _la;
    try {
      let _alt;
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 912;
        this.nameValue();
        this.state = 917;
        this._errHandler.sync(this);
        _alt = this.interpreter.adaptivePredict(this._input, 94, this._ctx);
        while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            {
              {
                this.state = 913;
                this.match(_SolidityParser.T__15);
                this.state = 914;
                this.nameValue();
              }
            }
          }
          this.state = 919;
          this._errHandler.sync(this);
          _alt = this.interpreter.adaptivePredict(this._input, 94, this._ctx);
        }
        this.state = 921;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.T__15) {
          {
            this.state = 920;
            this.match(_SolidityParser.T__15);
          }
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  nameValue() {
    let _localctx = new NameValueContext(this._ctx, this.state);
    this.enterRule(_localctx, 140, _SolidityParser.RULE_nameValue);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 923;
        this.identifier();
        this.state = 924;
        this.match(_SolidityParser.T__61);
        this.state = 925;
        this.expression(0);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  functionCallArguments() {
    let _localctx = new FunctionCallArgumentsContext(this._ctx, this.state);
    this.enterRule(_localctx, 142, _SolidityParser.RULE_functionCallArguments);
    let _la;
    try {
      this.state = 935;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _SolidityParser.T__14:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 927;
            this.match(_SolidityParser.T__14);
            this.state = 929;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {
              {
                this.state = 928;
                this.nameValueList();
              }
            }
            this.state = 931;
            this.match(_SolidityParser.T__16);
          }
          break;
        case _SolidityParser.T__5:
        case _SolidityParser.T__13:
        case _SolidityParser.T__22:
        case _SolidityParser.T__23:
        case _SolidityParser.T__24:
        case _SolidityParser.T__29:
        case _SolidityParser.T__33:
        case _SolidityParser.T__35:
        case _SolidityParser.T__37:
        case _SolidityParser.T__41:
        case _SolidityParser.T__53:
        case _SolidityParser.T__54:
        case _SolidityParser.T__55:
        case _SolidityParser.T__56:
        case _SolidityParser.T__57:
        case _SolidityParser.T__58:
        case _SolidityParser.T__59:
        case _SolidityParser.T__60:
        case _SolidityParser.T__62:
        case _SolidityParser.T__63:
        case _SolidityParser.T__64:
        case _SolidityParser.T__65:
        case _SolidityParser.T__66:
        case _SolidityParser.T__95:
        case _SolidityParser.Int:
        case _SolidityParser.Uint:
        case _SolidityParser.Byte:
        case _SolidityParser.Fixed:
        case _SolidityParser.Ufixed:
        case _SolidityParser.BooleanLiteral:
        case _SolidityParser.DecimalNumber:
        case _SolidityParser.HexNumber:
        case _SolidityParser.HexLiteralFragment:
        case _SolidityParser.LeaveKeyword:
        case _SolidityParser.PayableKeyword:
        case _SolidityParser.TypeKeyword:
        case _SolidityParser.ConstructorKeyword:
        case _SolidityParser.ReceiveKeyword:
        case _SolidityParser.Identifier:
        case _SolidityParser.StringLiteralFragment:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 933;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {
              {
                this.state = 932;
                this.expressionList();
              }
            }
          }
          break;
        default:
          throw new import_NoViableAltException.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  functionCall() {
    let _localctx = new FunctionCallContext(this._ctx, this.state);
    this.enterRule(_localctx, 144, _SolidityParser.RULE_functionCall);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 937;
        this.expression(0);
        this.state = 938;
        this.match(_SolidityParser.T__22);
        this.state = 939;
        this.functionCallArguments();
        this.state = 940;
        this.match(_SolidityParser.T__23);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  assemblyBlock() {
    let _localctx = new AssemblyBlockContext(this._ctx, this.state);
    this.enterRule(_localctx, 146, _SolidityParser.RULE_assemblyBlock);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 942;
        this.match(_SolidityParser.T__14);
        this.state = 946;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while ((_la & ~31) === 0 && (1 << _la & (1 << _SolidityParser.T__13 | 1 << _SolidityParser.T__14 | 1 << _SolidityParser.T__22 | 1 << _SolidityParser.T__24 | 1 << _SolidityParser.T__26 | 1 << _SolidityParser.T__29)) !== 0 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__42 - 36 | 1 << _SolidityParser.T__48 - 36 | 1 << _SolidityParser.T__50 - 36 | 1 << _SolidityParser.T__53 - 36 | 1 << _SolidityParser.T__57 - 36)) !== 0 || (_la - 89 & ~31) === 0 && (1 << _la - 89 & (1 << _SolidityParser.T__88 - 89 | 1 << _SolidityParser.T__91 - 89 | 1 << _SolidityParser.T__95 - 89 | 1 << _SolidityParser.BooleanLiteral - 89 | 1 << _SolidityParser.DecimalNumber - 89 | 1 << _SolidityParser.HexNumber - 89 | 1 << _SolidityParser.HexLiteralFragment - 89 | 1 << _SolidityParser.BreakKeyword - 89 | 1 << _SolidityParser.ContinueKeyword - 89 | 1 << _SolidityParser.LeaveKeyword - 89 | 1 << _SolidityParser.PayableKeyword - 89)) !== 0 || (_la - 126 & ~31) === 0 && (1 << _la - 126 & (1 << _SolidityParser.ConstructorKeyword - 126 | 1 << _SolidityParser.ReceiveKeyword - 126 | 1 << _SolidityParser.Identifier - 126 | 1 << _SolidityParser.StringLiteralFragment - 126)) !== 0) {
          {
            {
              this.state = 943;
              this.assemblyItem();
            }
          }
          this.state = 948;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 949;
        this.match(_SolidityParser.T__16);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  assemblyItem() {
    let _localctx = new AssemblyItemContext(this._ctx, this.state);
    this.enterRule(_localctx, 148, _SolidityParser.RULE_assemblyItem);
    try {
      this.state = 969;
      this._errHandler.sync(this);
      switch (this.interpreter.adaptivePredict(this._input, 100, this._ctx)) {
        case 1:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 951;
            this.identifier();
          }
          break;
        case 2:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 952;
            this.assemblyBlock();
          }
          break;
        case 3:
          this.enterOuterAlt(_localctx, 3);
          {
            this.state = 953;
            this.assemblyExpression();
          }
          break;
        case 4:
          this.enterOuterAlt(_localctx, 4);
          {
            this.state = 954;
            this.assemblyLocalDefinition();
          }
          break;
        case 5:
          this.enterOuterAlt(_localctx, 5);
          {
            this.state = 955;
            this.assemblyAssignment();
          }
          break;
        case 6:
          this.enterOuterAlt(_localctx, 6);
          {
            this.state = 956;
            this.assemblyStackAssignment();
          }
          break;
        case 7:
          this.enterOuterAlt(_localctx, 7);
          {
            this.state = 957;
            this.labelDefinition();
          }
          break;
        case 8:
          this.enterOuterAlt(_localctx, 8);
          {
            this.state = 958;
            this.assemblySwitch();
          }
          break;
        case 9:
          this.enterOuterAlt(_localctx, 9);
          {
            this.state = 959;
            this.assemblyFunctionDefinition();
          }
          break;
        case 10:
          this.enterOuterAlt(_localctx, 10);
          {
            this.state = 960;
            this.assemblyFor();
          }
          break;
        case 11:
          this.enterOuterAlt(_localctx, 11);
          {
            this.state = 961;
            this.assemblyIf();
          }
          break;
        case 12:
          this.enterOuterAlt(_localctx, 12);
          {
            this.state = 962;
            this.match(_SolidityParser.BreakKeyword);
          }
          break;
        case 13:
          this.enterOuterAlt(_localctx, 13);
          {
            this.state = 963;
            this.match(_SolidityParser.ContinueKeyword);
          }
          break;
        case 14:
          this.enterOuterAlt(_localctx, 14);
          {
            this.state = 964;
            this.match(_SolidityParser.LeaveKeyword);
          }
          break;
        case 15:
          this.enterOuterAlt(_localctx, 15);
          {
            this.state = 965;
            this.subAssembly();
          }
          break;
        case 16:
          this.enterOuterAlt(_localctx, 16);
          {
            this.state = 966;
            this.numberLiteral();
          }
          break;
        case 17:
          this.enterOuterAlt(_localctx, 17);
          {
            this.state = 967;
            this.stringLiteral();
          }
          break;
        case 18:
          this.enterOuterAlt(_localctx, 18);
          {
            this.state = 968;
            this.hexLiteral();
          }
          break;
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  assemblyExpression() {
    let _localctx = new AssemblyExpressionContext(this._ctx, this.state);
    this.enterRule(_localctx, 150, _SolidityParser.RULE_assemblyExpression);
    try {
      this.state = 974;
      this._errHandler.sync(this);
      switch (this.interpreter.adaptivePredict(this._input, 101, this._ctx)) {
        case 1:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 971;
            this.assemblyCall();
          }
          break;
        case 2:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 972;
            this.assemblyLiteral();
          }
          break;
        case 3:
          this.enterOuterAlt(_localctx, 3);
          {
            this.state = 973;
            this.assemblyMember();
          }
          break;
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  assemblyMember() {
    let _localctx = new AssemblyMemberContext(this._ctx, this.state);
    this.enterRule(_localctx, 152, _SolidityParser.RULE_assemblyMember);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 976;
        this.identifier();
        this.state = 977;
        this.match(_SolidityParser.T__36);
        this.state = 978;
        this.identifier();
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  assemblyCall() {
    let _localctx = new AssemblyCallContext(this._ctx, this.state);
    this.enterRule(_localctx, 154, _SolidityParser.RULE_assemblyCall);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 984;
        this._errHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this._input, 102, this._ctx)) {
          case 1:
            {
              this.state = 980;
              this.match(_SolidityParser.T__50);
            }
            break;
          case 2:
            {
              this.state = 981;
              this.match(_SolidityParser.T__35);
            }
            break;
          case 3:
            {
              this.state = 982;
              this.match(_SolidityParser.T__57);
            }
            break;
          case 4:
            {
              this.state = 983;
              this.identifier();
            }
            break;
        }
        this.state = 998;
        this._errHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this._input, 105, this._ctx)) {
          case 1:
            {
              this.state = 986;
              this.match(_SolidityParser.T__22);
              this.state = 988;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__50 - 36 | 1 << _SolidityParser.T__53 - 36 | 1 << _SolidityParser.T__57 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {
                {
                  this.state = 987;
                  this.assemblyExpression();
                }
              }
              this.state = 994;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === _SolidityParser.T__15) {
                {
                  {
                    this.state = 990;
                    this.match(_SolidityParser.T__15);
                    this.state = 991;
                    this.assemblyExpression();
                  }
                }
                this.state = 996;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
              this.state = 997;
              this.match(_SolidityParser.T__23);
            }
            break;
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  assemblyLocalDefinition() {
    let _localctx = new AssemblyLocalDefinitionContext(this._ctx, this.state);
    this.enterRule(_localctx, 156, _SolidityParser.RULE_assemblyLocalDefinition);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 1e3;
        this.match(_SolidityParser.T__88);
        this.state = 1001;
        this.assemblyIdentifierOrList();
        this.state = 1004;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.T__89) {
          {
            this.state = 1002;
            this.match(_SolidityParser.T__89);
            this.state = 1003;
            this.assemblyExpression();
          }
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  assemblyAssignment() {
    let _localctx = new AssemblyAssignmentContext(this._ctx, this.state);
    this.enterRule(_localctx, 158, _SolidityParser.RULE_assemblyAssignment);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 1006;
        this.assemblyIdentifierOrList();
        this.state = 1007;
        this.match(_SolidityParser.T__89);
        this.state = 1008;
        this.assemblyExpression();
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  assemblyIdentifierOrList() {
    let _localctx = new AssemblyIdentifierOrListContext(this._ctx, this.state);
    this.enterRule(_localctx, 160, _SolidityParser.RULE_assemblyIdentifierOrList);
    try {
      this.state = 1017;
      this._errHandler.sync(this);
      switch (this.interpreter.adaptivePredict(this._input, 107, this._ctx)) {
        case 1:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1010;
            this.identifier();
          }
          break;
        case 2:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 1011;
            this.assemblyMember();
          }
          break;
        case 3:
          this.enterOuterAlt(_localctx, 3);
          {
            this.state = 1012;
            this.assemblyIdentifierList();
          }
          break;
        case 4:
          this.enterOuterAlt(_localctx, 4);
          {
            this.state = 1013;
            this.match(_SolidityParser.T__22);
            this.state = 1014;
            this.assemblyIdentifierList();
            this.state = 1015;
            this.match(_SolidityParser.T__23);
          }
          break;
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  assemblyIdentifierList() {
    let _localctx = new AssemblyIdentifierListContext(this._ctx, this.state);
    this.enterRule(_localctx, 162, _SolidityParser.RULE_assemblyIdentifierList);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 1019;
        this.identifier();
        this.state = 1024;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === _SolidityParser.T__15) {
          {
            {
              this.state = 1020;
              this.match(_SolidityParser.T__15);
              this.state = 1021;
              this.identifier();
            }
          }
          this.state = 1026;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  assemblyStackAssignment() {
    let _localctx = new AssemblyStackAssignmentContext(this._ctx, this.state);
    this.enterRule(_localctx, 164, _SolidityParser.RULE_assemblyStackAssignment);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 1027;
        this.assemblyExpression();
        this.state = 1028;
        this.match(_SolidityParser.T__90);
        this.state = 1029;
        this.identifier();
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  labelDefinition() {
    let _localctx = new LabelDefinitionContext(this._ctx, this.state);
    this.enterRule(_localctx, 166, _SolidityParser.RULE_labelDefinition);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 1031;
        this.identifier();
        this.state = 1032;
        this.match(_SolidityParser.T__61);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  assemblySwitch() {
    let _localctx = new AssemblySwitchContext(this._ctx, this.state);
    this.enterRule(_localctx, 168, _SolidityParser.RULE_assemblySwitch);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 1034;
        this.match(_SolidityParser.T__91);
        this.state = 1035;
        this.assemblyExpression();
        this.state = 1039;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === _SolidityParser.T__92 || _la === _SolidityParser.T__93) {
          {
            {
              this.state = 1036;
              this.assemblyCase();
            }
          }
          this.state = 1041;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  assemblyCase() {
    let _localctx = new AssemblyCaseContext(this._ctx, this.state);
    this.enterRule(_localctx, 170, _SolidityParser.RULE_assemblyCase);
    try {
      this.state = 1048;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _SolidityParser.T__92:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1042;
            this.match(_SolidityParser.T__92);
            this.state = 1043;
            this.assemblyLiteral();
            this.state = 1044;
            this.assemblyBlock();
          }
          break;
        case _SolidityParser.T__93:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 1046;
            this.match(_SolidityParser.T__93);
            this.state = 1047;
            this.assemblyBlock();
          }
          break;
        default:
          throw new import_NoViableAltException.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  assemblyFunctionDefinition() {
    let _localctx = new AssemblyFunctionDefinitionContext(this._ctx, this.state);
    this.enterRule(_localctx, 172, _SolidityParser.RULE_assemblyFunctionDefinition);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 1050;
        this.match(_SolidityParser.T__29);
        this.state = 1051;
        this.identifier();
        this.state = 1052;
        this.match(_SolidityParser.T__22);
        this.state = 1054;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier) {
          {
            this.state = 1053;
            this.assemblyIdentifierList();
          }
        }
        this.state = 1056;
        this.match(_SolidityParser.T__23);
        this.state = 1058;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.T__94) {
          {
            this.state = 1057;
            this.assemblyFunctionReturns();
          }
        }
        this.state = 1060;
        this.assemblyBlock();
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  assemblyFunctionReturns() {
    let _localctx = new AssemblyFunctionReturnsContext(this._ctx, this.state);
    this.enterRule(_localctx, 174, _SolidityParser.RULE_assemblyFunctionReturns);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        {
          this.state = 1062;
          this.match(_SolidityParser.T__94);
          this.state = 1063;
          this.assemblyIdentifierList();
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  assemblyFor() {
    let _localctx = new AssemblyForContext(this._ctx, this.state);
    this.enterRule(_localctx, 176, _SolidityParser.RULE_assemblyFor);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 1065;
        this.match(_SolidityParser.T__26);
        this.state = 1068;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case _SolidityParser.T__14:
            {
              this.state = 1066;
              this.assemblyBlock();
            }
            break;
          case _SolidityParser.T__13:
          case _SolidityParser.T__24:
          case _SolidityParser.T__35:
          case _SolidityParser.T__41:
          case _SolidityParser.T__50:
          case _SolidityParser.T__53:
          case _SolidityParser.T__57:
          case _SolidityParser.T__95:
          case _SolidityParser.BooleanLiteral:
          case _SolidityParser.DecimalNumber:
          case _SolidityParser.HexNumber:
          case _SolidityParser.HexLiteralFragment:
          case _SolidityParser.LeaveKeyword:
          case _SolidityParser.PayableKeyword:
          case _SolidityParser.ConstructorKeyword:
          case _SolidityParser.ReceiveKeyword:
          case _SolidityParser.Identifier:
          case _SolidityParser.StringLiteralFragment:
            {
              this.state = 1067;
              this.assemblyExpression();
            }
            break;
          default:
            throw new import_NoViableAltException.NoViableAltException(this);
        }
        this.state = 1070;
        this.assemblyExpression();
        this.state = 1073;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case _SolidityParser.T__14:
            {
              this.state = 1071;
              this.assemblyBlock();
            }
            break;
          case _SolidityParser.T__13:
          case _SolidityParser.T__24:
          case _SolidityParser.T__35:
          case _SolidityParser.T__41:
          case _SolidityParser.T__50:
          case _SolidityParser.T__53:
          case _SolidityParser.T__57:
          case _SolidityParser.T__95:
          case _SolidityParser.BooleanLiteral:
          case _SolidityParser.DecimalNumber:
          case _SolidityParser.HexNumber:
          case _SolidityParser.HexLiteralFragment:
          case _SolidityParser.LeaveKeyword:
          case _SolidityParser.PayableKeyword:
          case _SolidityParser.ConstructorKeyword:
          case _SolidityParser.ReceiveKeyword:
          case _SolidityParser.Identifier:
          case _SolidityParser.StringLiteralFragment:
            {
              this.state = 1072;
              this.assemblyExpression();
            }
            break;
          default:
            throw new import_NoViableAltException.NoViableAltException(this);
        }
        this.state = 1075;
        this.assemblyBlock();
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  assemblyIf() {
    let _localctx = new AssemblyIfContext(this._ctx, this.state);
    this.enterRule(_localctx, 178, _SolidityParser.RULE_assemblyIf);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 1077;
        this.match(_SolidityParser.T__42);
        this.state = 1078;
        this.assemblyExpression();
        this.state = 1079;
        this.assemblyBlock();
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  assemblyLiteral() {
    let _localctx = new AssemblyLiteralContext(this._ctx, this.state);
    this.enterRule(_localctx, 180, _SolidityParser.RULE_assemblyLiteral);
    try {
      this.state = 1086;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _SolidityParser.StringLiteralFragment:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1081;
            this.stringLiteral();
          }
          break;
        case _SolidityParser.DecimalNumber:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 1082;
            this.match(_SolidityParser.DecimalNumber);
          }
          break;
        case _SolidityParser.HexNumber:
          this.enterOuterAlt(_localctx, 3);
          {
            this.state = 1083;
            this.match(_SolidityParser.HexNumber);
          }
          break;
        case _SolidityParser.HexLiteralFragment:
          this.enterOuterAlt(_localctx, 4);
          {
            this.state = 1084;
            this.hexLiteral();
          }
          break;
        case _SolidityParser.BooleanLiteral:
          this.enterOuterAlt(_localctx, 5);
          {
            this.state = 1085;
            this.match(_SolidityParser.BooleanLiteral);
          }
          break;
        default:
          throw new import_NoViableAltException.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  subAssembly() {
    let _localctx = new SubAssemblyContext(this._ctx, this.state);
    this.enterRule(_localctx, 182, _SolidityParser.RULE_subAssembly);
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 1088;
        this.match(_SolidityParser.T__48);
        this.state = 1089;
        this.identifier();
        this.state = 1090;
        this.assemblyBlock();
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  tupleExpression() {
    let _localctx = new TupleExpressionContext(this._ctx, this.state);
    this.enterRule(_localctx, 184, _SolidityParser.RULE_tupleExpression);
    let _la;
    try {
      this.state = 1118;
      this._errHandler.sync(this);
      switch (this._input.LA(1)) {
        case _SolidityParser.T__22:
          this.enterOuterAlt(_localctx, 1);
          {
            this.state = 1092;
            this.match(_SolidityParser.T__22);
            {
              this.state = 1094;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {
                {
                  this.state = 1093;
                  this.expression(0);
                }
              }
              this.state = 1102;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === _SolidityParser.T__15) {
                {
                  {
                    this.state = 1096;
                    this.match(_SolidityParser.T__15);
                    this.state = 1098;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                    if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {
                      {
                        this.state = 1097;
                        this.expression(0);
                      }
                    }
                  }
                }
                this.state = 1104;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
            }
            this.state = 1105;
            this.match(_SolidityParser.T__23);
          }
          break;
        case _SolidityParser.T__33:
          this.enterOuterAlt(_localctx, 2);
          {
            this.state = 1106;
            this.match(_SolidityParser.T__33);
            this.state = 1115;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if ((_la - 6 & ~31) === 0 && (1 << _la - 6 & (1 << _SolidityParser.T__5 - 6 | 1 << _SolidityParser.T__13 - 6 | 1 << _SolidityParser.T__22 - 6 | 1 << _SolidityParser.T__24 - 6 | 1 << _SolidityParser.T__29 - 6 | 1 << _SolidityParser.T__33 - 6 | 1 << _SolidityParser.T__35 - 6)) !== 0 || (_la - 38 & ~31) === 0 && (1 << _la - 38 & (1 << _SolidityParser.T__37 - 38 | 1 << _SolidityParser.T__41 - 38 | 1 << _SolidityParser.T__53 - 38 | 1 << _SolidityParser.T__54 - 38 | 1 << _SolidityParser.T__55 - 38 | 1 << _SolidityParser.T__56 - 38 | 1 << _SolidityParser.T__57 - 38 | 1 << _SolidityParser.T__58 - 38 | 1 << _SolidityParser.T__59 - 38 | 1 << _SolidityParser.T__60 - 38 | 1 << _SolidityParser.T__62 - 38 | 1 << _SolidityParser.T__63 - 38 | 1 << _SolidityParser.T__64 - 38 | 1 << _SolidityParser.T__65 - 38 | 1 << _SolidityParser.T__66 - 38)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.Int - 96 | 1 << _SolidityParser.Uint - 96 | 1 << _SolidityParser.Byte - 96 | 1 << _SolidityParser.Fixed - 96 | 1 << _SolidityParser.Ufixed - 96 | 1 << _SolidityParser.BooleanLiteral - 96 | 1 << _SolidityParser.DecimalNumber - 96 | 1 << _SolidityParser.HexNumber - 96 | 1 << _SolidityParser.HexLiteralFragment - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.TypeKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || (_la - 128 & ~31) === 0 && (1 << _la - 128 & (1 << _SolidityParser.ReceiveKeyword - 128 | 1 << _SolidityParser.Identifier - 128 | 1 << _SolidityParser.StringLiteralFragment - 128)) !== 0) {
              {
                this.state = 1107;
                this.expression(0);
                this.state = 1112;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while (_la === _SolidityParser.T__15) {
                  {
                    {
                      this.state = 1108;
                      this.match(_SolidityParser.T__15);
                      this.state = 1109;
                      this.expression(0);
                    }
                  }
                  this.state = 1114;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
              }
            }
            this.state = 1117;
            this.match(_SolidityParser.T__34);
          }
          break;
        default:
          throw new import_NoViableAltException.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  numberLiteral() {
    let _localctx = new NumberLiteralContext(this._ctx, this.state);
    this.enterRule(_localctx, 186, _SolidityParser.RULE_numberLiteral);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 1120;
        _la = this._input.LA(1);
        if (!(_la === _SolidityParser.DecimalNumber || _la === _SolidityParser.HexNumber)) {
          this._errHandler.recoverInline(this);
        } else {
          if (this._input.LA(1) === import_Token.Token.EOF) {
            this.matchedEOF = true;
          }
          this._errHandler.reportMatch(this);
          this.consume();
        }
        this.state = 1122;
        this._errHandler.sync(this);
        switch (this.interpreter.adaptivePredict(this._input, 122, this._ctx)) {
          case 1:
            {
              this.state = 1121;
              this.match(_SolidityParser.NumberUnit);
            }
            break;
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  identifier() {
    let _localctx = new IdentifierContext(this._ctx, this.state);
    this.enterRule(_localctx, 188, _SolidityParser.RULE_identifier);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 1124;
        _la = this._input.LA(1);
        if (!(_la === _SolidityParser.T__13 || _la === _SolidityParser.T__24 || (_la - 36 & ~31) === 0 && (1 << _la - 36 & (1 << _SolidityParser.T__35 - 36 | 1 << _SolidityParser.T__41 - 36 | 1 << _SolidityParser.T__53 - 36)) !== 0 || (_la - 96 & ~31) === 0 && (1 << _la - 96 & (1 << _SolidityParser.T__95 - 96 | 1 << _SolidityParser.LeaveKeyword - 96 | 1 << _SolidityParser.PayableKeyword - 96 | 1 << _SolidityParser.ConstructorKeyword - 96)) !== 0 || _la === _SolidityParser.ReceiveKeyword || _la === _SolidityParser.Identifier)) {
          this._errHandler.recoverInline(this);
        } else {
          if (this._input.LA(1) === import_Token.Token.EOF) {
            this.matchedEOF = true;
          }
          this._errHandler.reportMatch(this);
          this.consume();
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  hexLiteral() {
    let _localctx = new HexLiteralContext(this._ctx, this.state);
    this.enterRule(_localctx, 190, _SolidityParser.RULE_hexLiteral);
    try {
      let _alt;
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 1127;
        this._errHandler.sync(this);
        _alt = 1;
        do {
          switch (_alt) {
            case 1:
              {
                {
                  this.state = 1126;
                  this.match(_SolidityParser.HexLiteralFragment);
                }
              }
              break;
            default:
              throw new import_NoViableAltException.NoViableAltException(this);
          }
          this.state = 1129;
          this._errHandler.sync(this);
          _alt = this.interpreter.adaptivePredict(this._input, 123, this._ctx);
        } while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  overrideSpecifier() {
    let _localctx = new OverrideSpecifierContext(this._ctx, this.state);
    this.enterRule(_localctx, 192, _SolidityParser.RULE_overrideSpecifier);
    let _la;
    try {
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 1131;
        this.match(_SolidityParser.T__96);
        this.state = 1143;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === _SolidityParser.T__22) {
          {
            this.state = 1132;
            this.match(_SolidityParser.T__22);
            this.state = 1133;
            this.userDefinedTypeName();
            this.state = 1138;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === _SolidityParser.T__15) {
              {
                {
                  this.state = 1134;
                  this.match(_SolidityParser.T__15);
                  this.state = 1135;
                  this.userDefinedTypeName();
                }
              }
              this.state = 1140;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 1141;
            this.match(_SolidityParser.T__23);
          }
        }
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  stringLiteral() {
    let _localctx = new StringLiteralContext(this._ctx, this.state);
    this.enterRule(_localctx, 194, _SolidityParser.RULE_stringLiteral);
    try {
      let _alt;
      this.enterOuterAlt(_localctx, 1);
      {
        this.state = 1146;
        this._errHandler.sync(this);
        _alt = 1;
        do {
          switch (_alt) {
            case 1:
              {
                {
                  this.state = 1145;
                  this.match(_SolidityParser.StringLiteralFragment);
                }
              }
              break;
            default:
              throw new import_NoViableAltException.NoViableAltException(this);
          }
          this.state = 1148;
          this._errHandler.sync(this);
          _alt = this.interpreter.adaptivePredict(this._input, 126, this._ctx);
        } while (_alt !== 2 && _alt !== import_ATN.ATN.INVALID_ALT_NUMBER);
      }
    } catch (re) {
      if (re instanceof import_RecognitionException.RecognitionException) {
        _localctx.exception = re;
        this._errHandler.reportError(this, re);
        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }
    return _localctx;
  }
  sempred(_localctx, ruleIndex, predIndex) {
    switch (ruleIndex) {
      case 36:
        return this.typeName_sempred(_localctx, predIndex);
      case 66:
        return this.expression_sempred(_localctx, predIndex);
    }
    return true;
  }
  typeName_sempred(_localctx, predIndex) {
    switch (predIndex) {
      case 0:
        return this.precpred(this._ctx, 3);
    }
    return true;
  }
  expression_sempred(_localctx, predIndex) {
    switch (predIndex) {
      case 1:
        return this.precpred(this._ctx, 14);
      case 2:
        return this.precpred(this._ctx, 13);
      case 3:
        return this.precpred(this._ctx, 12);
      case 4:
        return this.precpred(this._ctx, 11);
      case 5:
        return this.precpred(this._ctx, 10);
      case 6:
        return this.precpred(this._ctx, 9);
      case 7:
        return this.precpred(this._ctx, 8);
      case 8:
        return this.precpred(this._ctx, 7);
      case 9:
        return this.precpred(this._ctx, 6);
      case 10:
        return this.precpred(this._ctx, 5);
      case 11:
        return this.precpred(this._ctx, 4);
      case 12:
        return this.precpred(this._ctx, 3);
      case 13:
        return this.precpred(this._ctx, 2);
      case 14:
        return this.precpred(this._ctx, 27);
      case 15:
        return this.precpred(this._ctx, 25);
      case 16:
        return this.precpred(this._ctx, 24);
      case 17:
        return this.precpred(this._ctx, 23);
      case 18:
        return this.precpred(this._ctx, 22);
      case 19:
        return this.precpred(this._ctx, 21);
    }
    return true;
  }
  static get _ATN() {
    if (!_SolidityParser.__ATN) {
      _SolidityParser.__ATN = new import_ATNDeserializer2.ATNDeserializer().deserialize(Utils2.toCharArray(_SolidityParser._serializedATN));
    }
    return _SolidityParser.__ATN;
  }
};
var SolidityParser = _SolidityParser;
SolidityParser.T__0 = 1;
SolidityParser.T__1 = 2;
SolidityParser.T__2 = 3;
SolidityParser.T__3 = 4;
SolidityParser.T__4 = 5;
SolidityParser.T__5 = 6;
SolidityParser.T__6 = 7;
SolidityParser.T__7 = 8;
SolidityParser.T__8 = 9;
SolidityParser.T__9 = 10;
SolidityParser.T__10 = 11;
SolidityParser.T__11 = 12;
SolidityParser.T__12 = 13;
SolidityParser.T__13 = 14;
SolidityParser.T__14 = 15;
SolidityParser.T__15 = 16;
SolidityParser.T__16 = 17;
SolidityParser.T__17 = 18;
SolidityParser.T__18 = 19;
SolidityParser.T__19 = 20;
SolidityParser.T__20 = 21;
SolidityParser.T__21 = 22;
SolidityParser.T__22 = 23;
SolidityParser.T__23 = 24;
SolidityParser.T__24 = 25;
SolidityParser.T__25 = 26;
SolidityParser.T__26 = 27;
SolidityParser.T__27 = 28;
SolidityParser.T__28 = 29;
SolidityParser.T__29 = 30;
SolidityParser.T__30 = 31;
SolidityParser.T__31 = 32;
SolidityParser.T__32 = 33;
SolidityParser.T__33 = 34;
SolidityParser.T__34 = 35;
SolidityParser.T__35 = 36;
SolidityParser.T__36 = 37;
SolidityParser.T__37 = 38;
SolidityParser.T__38 = 39;
SolidityParser.T__39 = 40;
SolidityParser.T__40 = 41;
SolidityParser.T__41 = 42;
SolidityParser.T__42 = 43;
SolidityParser.T__43 = 44;
SolidityParser.T__44 = 45;
SolidityParser.T__45 = 46;
SolidityParser.T__46 = 47;
SolidityParser.T__47 = 48;
SolidityParser.T__48 = 49;
SolidityParser.T__49 = 50;
SolidityParser.T__50 = 51;
SolidityParser.T__51 = 52;
SolidityParser.T__52 = 53;
SolidityParser.T__53 = 54;
SolidityParser.T__54 = 55;
SolidityParser.T__55 = 56;
SolidityParser.T__56 = 57;
SolidityParser.T__57 = 58;
SolidityParser.T__58 = 59;
SolidityParser.T__59 = 60;
SolidityParser.T__60 = 61;
SolidityParser.T__61 = 62;
SolidityParser.T__62 = 63;
SolidityParser.T__63 = 64;
SolidityParser.T__64 = 65;
SolidityParser.T__65 = 66;
SolidityParser.T__66 = 67;
SolidityParser.T__67 = 68;
SolidityParser.T__68 = 69;
SolidityParser.T__69 = 70;
SolidityParser.T__70 = 71;
SolidityParser.T__71 = 72;
SolidityParser.T__72 = 73;
SolidityParser.T__73 = 74;
SolidityParser.T__74 = 75;
SolidityParser.T__75 = 76;
SolidityParser.T__76 = 77;
SolidityParser.T__77 = 78;
SolidityParser.T__78 = 79;
SolidityParser.T__79 = 80;
SolidityParser.T__80 = 81;
SolidityParser.T__81 = 82;
SolidityParser.T__82 = 83;
SolidityParser.T__83 = 84;
SolidityParser.T__84 = 85;
SolidityParser.T__85 = 86;
SolidityParser.T__86 = 87;
SolidityParser.T__87 = 88;
SolidityParser.T__88 = 89;
SolidityParser.T__89 = 90;
SolidityParser.T__90 = 91;
SolidityParser.T__91 = 92;
SolidityParser.T__92 = 93;
SolidityParser.T__93 = 94;
SolidityParser.T__94 = 95;
SolidityParser.T__95 = 96;
SolidityParser.T__96 = 97;
SolidityParser.Int = 98;
SolidityParser.Uint = 99;
SolidityParser.Byte = 100;
SolidityParser.Fixed = 101;
SolidityParser.Ufixed = 102;
SolidityParser.BooleanLiteral = 103;
SolidityParser.DecimalNumber = 104;
SolidityParser.HexNumber = 105;
SolidityParser.NumberUnit = 106;
SolidityParser.HexLiteralFragment = 107;
SolidityParser.ReservedKeyword = 108;
SolidityParser.AnonymousKeyword = 109;
SolidityParser.BreakKeyword = 110;
SolidityParser.ConstantKeyword = 111;
SolidityParser.ImmutableKeyword = 112;
SolidityParser.ContinueKeyword = 113;
SolidityParser.LeaveKeyword = 114;
SolidityParser.ExternalKeyword = 115;
SolidityParser.IndexedKeyword = 116;
SolidityParser.InternalKeyword = 117;
SolidityParser.PayableKeyword = 118;
SolidityParser.PrivateKeyword = 119;
SolidityParser.PublicKeyword = 120;
SolidityParser.VirtualKeyword = 121;
SolidityParser.PureKeyword = 122;
SolidityParser.TypeKeyword = 123;
SolidityParser.ViewKeyword = 124;
SolidityParser.GlobalKeyword = 125;
SolidityParser.ConstructorKeyword = 126;
SolidityParser.FallbackKeyword = 127;
SolidityParser.ReceiveKeyword = 128;
SolidityParser.Identifier = 129;
SolidityParser.StringLiteralFragment = 130;
SolidityParser.VersionLiteral = 131;
SolidityParser.WS = 132;
SolidityParser.COMMENT = 133;
SolidityParser.LINE_COMMENT = 134;
SolidityParser.RULE_sourceUnit = 0;
SolidityParser.RULE_pragmaDirective = 1;
SolidityParser.RULE_pragmaName = 2;
SolidityParser.RULE_pragmaValue = 3;
SolidityParser.RULE_version = 4;
SolidityParser.RULE_versionOperator = 5;
SolidityParser.RULE_versionConstraint = 6;
SolidityParser.RULE_importDeclaration = 7;
SolidityParser.RULE_importDirective = 8;
SolidityParser.RULE_importPath = 9;
SolidityParser.RULE_contractDefinition = 10;
SolidityParser.RULE_inheritanceSpecifier = 11;
SolidityParser.RULE_contractPart = 12;
SolidityParser.RULE_stateVariableDeclaration = 13;
SolidityParser.RULE_fileLevelConstant = 14;
SolidityParser.RULE_customErrorDefinition = 15;
SolidityParser.RULE_typeDefinition = 16;
SolidityParser.RULE_usingForDeclaration = 17;
SolidityParser.RULE_usingForObject = 18;
SolidityParser.RULE_structDefinition = 19;
SolidityParser.RULE_modifierDefinition = 20;
SolidityParser.RULE_modifierInvocation = 21;
SolidityParser.RULE_functionDefinition = 22;
SolidityParser.RULE_functionDescriptor = 23;
SolidityParser.RULE_returnParameters = 24;
SolidityParser.RULE_modifierList = 25;
SolidityParser.RULE_eventDefinition = 26;
SolidityParser.RULE_enumValue = 27;
SolidityParser.RULE_enumDefinition = 28;
SolidityParser.RULE_parameterList = 29;
SolidityParser.RULE_parameter = 30;
SolidityParser.RULE_eventParameterList = 31;
SolidityParser.RULE_eventParameter = 32;
SolidityParser.RULE_functionTypeParameterList = 33;
SolidityParser.RULE_functionTypeParameter = 34;
SolidityParser.RULE_variableDeclaration = 35;
SolidityParser.RULE_typeName = 36;
SolidityParser.RULE_userDefinedTypeName = 37;
SolidityParser.RULE_mappingKey = 38;
SolidityParser.RULE_mapping = 39;
SolidityParser.RULE_functionTypeName = 40;
SolidityParser.RULE_storageLocation = 41;
SolidityParser.RULE_stateMutability = 42;
SolidityParser.RULE_block = 43;
SolidityParser.RULE_statement = 44;
SolidityParser.RULE_expressionStatement = 45;
SolidityParser.RULE_ifStatement = 46;
SolidityParser.RULE_tryStatement = 47;
SolidityParser.RULE_catchClause = 48;
SolidityParser.RULE_whileStatement = 49;
SolidityParser.RULE_simpleStatement = 50;
SolidityParser.RULE_uncheckedStatement = 51;
SolidityParser.RULE_forStatement = 52;
SolidityParser.RULE_inlineAssemblyStatement = 53;
SolidityParser.RULE_inlineAssemblyStatementFlag = 54;
SolidityParser.RULE_doWhileStatement = 55;
SolidityParser.RULE_continueStatement = 56;
SolidityParser.RULE_breakStatement = 57;
SolidityParser.RULE_returnStatement = 58;
SolidityParser.RULE_throwStatement = 59;
SolidityParser.RULE_emitStatement = 60;
SolidityParser.RULE_revertStatement = 61;
SolidityParser.RULE_variableDeclarationStatement = 62;
SolidityParser.RULE_variableDeclarationList = 63;
SolidityParser.RULE_identifierList = 64;
SolidityParser.RULE_elementaryTypeName = 65;
SolidityParser.RULE_expression = 66;
SolidityParser.RULE_primaryExpression = 67;
SolidityParser.RULE_expressionList = 68;
SolidityParser.RULE_nameValueList = 69;
SolidityParser.RULE_nameValue = 70;
SolidityParser.RULE_functionCallArguments = 71;
SolidityParser.RULE_functionCall = 72;
SolidityParser.RULE_assemblyBlock = 73;
SolidityParser.RULE_assemblyItem = 74;
SolidityParser.RULE_assemblyExpression = 75;
SolidityParser.RULE_assemblyMember = 76;
SolidityParser.RULE_assemblyCall = 77;
SolidityParser.RULE_assemblyLocalDefinition = 78;
SolidityParser.RULE_assemblyAssignment = 79;
SolidityParser.RULE_assemblyIdentifierOrList = 80;
SolidityParser.RULE_assemblyIdentifierList = 81;
SolidityParser.RULE_assemblyStackAssignment = 82;
SolidityParser.RULE_labelDefinition = 83;
SolidityParser.RULE_assemblySwitch = 84;
SolidityParser.RULE_assemblyCase = 85;
SolidityParser.RULE_assemblyFunctionDefinition = 86;
SolidityParser.RULE_assemblyFunctionReturns = 87;
SolidityParser.RULE_assemblyFor = 88;
SolidityParser.RULE_assemblyIf = 89;
SolidityParser.RULE_assemblyLiteral = 90;
SolidityParser.RULE_subAssembly = 91;
SolidityParser.RULE_tupleExpression = 92;
SolidityParser.RULE_numberLiteral = 93;
SolidityParser.RULE_identifier = 94;
SolidityParser.RULE_hexLiteral = 95;
SolidityParser.RULE_overrideSpecifier = 96;
SolidityParser.RULE_stringLiteral = 97;
SolidityParser.ruleNames = [
  "sourceUnit",
  "pragmaDirective",
  "pragmaName",
  "pragmaValue",
  "version",
  "versionOperator",
  "versionConstraint",
  "importDeclaration",
  "importDirective",
  "importPath",
  "contractDefinition",
  "inheritanceSpecifier",
  "contractPart",
  "stateVariableDeclaration",
  "fileLevelConstant",
  "customErrorDefinition",
  "typeDefinition",
  "usingForDeclaration",
  "usingForObject",
  "structDefinition",
  "modifierDefinition",
  "modifierInvocation",
  "functionDefinition",
  "functionDescriptor",
  "returnParameters",
  "modifierList",
  "eventDefinition",
  "enumValue",
  "enumDefinition",
  "parameterList",
  "parameter",
  "eventParameterList",
  "eventParameter",
  "functionTypeParameterList",
  "functionTypeParameter",
  "variableDeclaration",
  "typeName",
  "userDefinedTypeName",
  "mappingKey",
  "mapping",
  "functionTypeName",
  "storageLocation",
  "stateMutability",
  "block",
  "statement",
  "expressionStatement",
  "ifStatement",
  "tryStatement",
  "catchClause",
  "whileStatement",
  "simpleStatement",
  "uncheckedStatement",
  "forStatement",
  "inlineAssemblyStatement",
  "inlineAssemblyStatementFlag",
  "doWhileStatement",
  "continueStatement",
  "breakStatement",
  "returnStatement",
  "throwStatement",
  "emitStatement",
  "revertStatement",
  "variableDeclarationStatement",
  "variableDeclarationList",
  "identifierList",
  "elementaryTypeName",
  "expression",
  "primaryExpression",
  "expressionList",
  "nameValueList",
  "nameValue",
  "functionCallArguments",
  "functionCall",
  "assemblyBlock",
  "assemblyItem",
  "assemblyExpression",
  "assemblyMember",
  "assemblyCall",
  "assemblyLocalDefinition",
  "assemblyAssignment",
  "assemblyIdentifierOrList",
  "assemblyIdentifierList",
  "assemblyStackAssignment",
  "labelDefinition",
  "assemblySwitch",
  "assemblyCase",
  "assemblyFunctionDefinition",
  "assemblyFunctionReturns",
  "assemblyFor",
  "assemblyIf",
  "assemblyLiteral",
  "subAssembly",
  "tupleExpression",
  "numberLiteral",
  "identifier",
  "hexLiteral",
  "overrideSpecifier",
  "stringLiteral"
];
SolidityParser._LITERAL_NAMES = [
  void 0,
  "'pragma'",
  "';'",
  "'*'",
  "'||'",
  "'^'",
  "'~'",
  "'>='",
  "'>'",
  "'<'",
  "'<='",
  "'='",
  "'as'",
  "'import'",
  "'from'",
  "'{'",
  "','",
  "'}'",
  "'abstract'",
  "'contract'",
  "'interface'",
  "'library'",
  "'is'",
  "'('",
  "')'",
  "'error'",
  "'using'",
  "'for'",
  "'struct'",
  "'modifier'",
  "'function'",
  "'returns'",
  "'event'",
  "'enum'",
  "'['",
  "']'",
  "'address'",
  "'.'",
  "'mapping'",
  "'=>'",
  "'memory'",
  "'storage'",
  "'calldata'",
  "'if'",
  "'else'",
  "'try'",
  "'catch'",
  "'while'",
  "'unchecked'",
  "'assembly'",
  "'do'",
  "'return'",
  "'throw'",
  "'emit'",
  "'revert'",
  "'var'",
  "'bool'",
  "'string'",
  "'byte'",
  "'++'",
  "'--'",
  "'new'",
  "':'",
  "'+'",
  "'-'",
  "'after'",
  "'delete'",
  "'!'",
  "'**'",
  "'/'",
  "'%'",
  "'<<'",
  "'>>'",
  "'&'",
  "'|'",
  "'=='",
  "'!='",
  "'&&'",
  "'?'",
  "'|='",
  "'^='",
  "'&='",
  "'<<='",
  "'>>='",
  "'+='",
  "'-='",
  "'*='",
  "'/='",
  "'%='",
  "'let'",
  "':='",
  "'=:'",
  "'switch'",
  "'case'",
  "'default'",
  "'->'",
  "'callback'",
  "'override'",
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  "'anonymous'",
  "'break'",
  "'constant'",
  "'immutable'",
  "'continue'",
  "'leave'",
  "'external'",
  "'indexed'",
  "'internal'",
  "'payable'",
  "'private'",
  "'public'",
  "'virtual'",
  "'pure'",
  "'type'",
  "'view'",
  "'global'",
  "'constructor'",
  "'fallback'",
  "'receive'"
];
SolidityParser._SYMBOLIC_NAMES = [
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  void 0,
  "Int",
  "Uint",
  "Byte",
  "Fixed",
  "Ufixed",
  "BooleanLiteral",
  "DecimalNumber",
  "HexNumber",
  "NumberUnit",
  "HexLiteralFragment",
  "ReservedKeyword",
  "AnonymousKeyword",
  "BreakKeyword",
  "ConstantKeyword",
  "ImmutableKeyword",
  "ContinueKeyword",
  "LeaveKeyword",
  "ExternalKeyword",
  "IndexedKeyword",
  "InternalKeyword",
  "PayableKeyword",
  "PrivateKeyword",
  "PublicKeyword",
  "VirtualKeyword",
  "PureKeyword",
  "TypeKeyword",
  "ViewKeyword",
  "GlobalKeyword",
  "ConstructorKeyword",
  "FallbackKeyword",
  "ReceiveKeyword",
  "Identifier",
  "StringLiteralFragment",
  "VersionLiteral",
  "WS",
  "COMMENT",
  "LINE_COMMENT"
];
SolidityParser.VOCABULARY = new import_VocabularyImpl2.VocabularyImpl(_SolidityParser._LITERAL_NAMES, _SolidityParser._SYMBOLIC_NAMES, []);
SolidityParser._serializedATNSegments = 3;
SolidityParser._serializedATNSegment0 = "\uC91D\uCABA\u058D\uAFBA\u4F53\u0607\uEA8B\uC241\x88\u0481					\x07	\x07\b	\b			\n	\n\v	\v\f	\f\r	\r																		 	 !	!\"	\"#	#$	$%	%&	&'	'(	()	)*	*+	+,	,-	-.	./	/0	01	12	23	34	45	56	67	78	89	9:	:;	;<	<=	=>	>?	?@	@A	AB	BC	CD	DE	EF	FG	GH	HI	IJ	JK	KL	LM	MN	NO	OP	PQ	QR	RS	ST	TU	UV	VW	WX	XY	YZ	Z[	[\\	\\]	]^	^_	_`	`a	ab	bc	c\x07\xD1\n\f\xD4\v\xE2\n\xE6\n\x07\xE9\n\f\xEC\v\x07\x07\b\b\xF1\n\b\b\b\b\xF5\n\b\b\b\xF8\n\b				\xFD\n	\n\n\n\n\n\u0103\n\n\n\n\n\n\n\n\u010A\n\n\n\n\n\u010E\n\n\n\n\n\n\n\n\n\n\n\x07\n\u0119\n\n\f\n\n\u011C\v\n\n\n\n\n\n\n\u0123\n\n\v\v\f\f\u0128\n\f\f\f\f\f\f\f\x07\f\u0130\n\f\f\f\f\u0133\v\f\f\u0135\n\f\f\f\x07\f\u0139\n\f\f\f\f\u013C\v\f\f\f\r\r\r\r\u0143\n\r\r\r\u0146\n\r\u0151\n\x07\u015A\n\f\u015D\v\u0162\n\u017D\n\u0180\n\x07\u0189\n\f\u018C\v\u0190\n\x07\u019A\n\f\u019D\v\u019F\n\u01A6\n\x07\u01AA\n\f\u01AD\v\u01B1\n\u01B6\n\u01B9\n\u01BF\n\u01C3\n\u01C7\n\u01CC\n\x07\u01D9\n\f\u01DC\v\u01E2\n\u01EC\n\x07\u01F0\n\f\u01F3\v\x07\u01FB\n\f\u01FE\v\u0200\n   \u0206\n   \u0209\n !!!!\x07!\u020F\n!\f!!\u0212\v!!\u0214\n!!!\"\"\"\u021A\n\"\"\"\u021D\n\"####\x07#\u0223\n#\f##\u0226\v##\u0228\n###$$$\u022E\n$%%%\u0232\n%%%&&&&&&&&\u023D\n&&&&&\u0242\n&&\x07&\u0245\n&\f&&\u0248\v&'''\x07'\u024D\n'\f''\u0250\v'(((\u0254\n()))))))*****\x07*\u0262\n*\f**\u0265\v****\u0269\n*++,,--\x07-\u0271\n-\f--\u0274\v---................\u0287\n.///00000000\u0293\n01111\u0298\n1111\u029C\n1\r11\u029D222\u02A2\n222\u02A5\n222333333444\u02B1\n455566666\u02BA\n6666\u02BE\n666\u02C1\n6666777\u02C8\n777777\u02CE\n7778899999999:::;;;<<<\u02E4\n<<<===>>>>????@@@@@@@@\u02FA\n@@@@\u02FE\n@@@AA\u0303\nAAAA\u0307\nA\x07A\u0309\nA\fAA\u030C\vABBB\u0310\nBB\x07B\u0313\nB\fBB\u0316\vBBB\u0319\nBBBCCDDDDDDDDDDDDDDDDDDD\u0331\nDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD\u0367\nDDDD\u036B\nDDDDDDDDDDDDDDD\x07D\u037B\nD\fDD\u037E\vDEEEEEEEEEE\u0389\nEFFF\x07F\u038E\nF\fFF\u0391\vFGGG\x07G\u0396\nG\fGG\u0399\vGGG\u039C\nGHHHHIII\u03A4\nIIII\u03A8\nII\u03AA\nIJJJJJKK\x07K\u03B3\nK\fKK\u03B6\vKKKLLLLLLLLLLLLLLLLLLL\u03CC\nLMMMM\u03D1\nMNNNNOOOOO\u03DB\nOOOO\u03DF\nOOO\x07O\u03E3\nO\fOO\u03E6\vOOO\u03E9\nOPPPPP\u03EF\nPQQQQRRRRRRRR\u03FC\nRSSS\x07S\u0401\nS\fSS\u0404\vSTTTTUUUVVV\x07V\u0410\nV\fVV\u0413\vVWWWWWWW\u041B\nWXXXXX\u0421\nXXXX\u0425\nXXXYYYZZZZ\u042F\nZZZZZ\u0434\nZZZ[[[[\\\\\\\\\\\\\u0441\n\\]]]]^^^\u0449\n^^^^\u044D\n^\x07^\u044F\n^\f^^\u0452\v^^^^^^\x07^\u0459\n^\f^^\u045C\v^^\u045E\n^^^\u0461\n^___\u0465\n_``aa\u046A\na\raa\u046Bbbbbb\x07b\u0473\nb\fbb\u0476\vbbbb\u047A\nbcc\u047D\nc\rcc\u047EcJ\x86d\b\n\f \"$&(*,.02468:<>@BDFHJLNPRTVXZ\\^`bdfhjlnprtvxz|~\x80\x82\x84\x86\x88\x8A\x8C\x8E\x90\x92\x94\x96\x98\x9A\x9C\x9E\xA0\xA2\xA4\xA6\xA8\xAA\xAC\xAE\xB0\xB2\xB4\xB6\xB8\xBA\xBC\xBE\xC0\xC2\xC4\x07\r*,qqxx||~~&&9<dh=>ABCDGHIJ	\fMN\r\rQZjk\f&&,,88bbttxx\x80\x80\x82\x83\u0502\xD2\xD7\xDC\b\xE1\n\xE3\f\xED\xF7\xF9\u0122\u0124\u0127\u013F\u0150\u0152\u0165 \u016C\"\u0171$\u0177&\u018F(\u0191*\u01A2,\u01B2.\u01BA0\u01CB2\u01CD4\u01DA6\u01DD8\u01E5:\u01E7<\u01F6>\u0203@\u020AB\u0217D\u021EF\u022BH\u022FJ\u023CL\u0249N\u0253P\u0255R\u025CT\u026AV\u026CX\u026EZ\u0286\\\u0288^\u028B`\u0294b\u029Fd\u02A8f\u02B0h\u02B2j\u02B5l\u02C5n\u02D1p\u02D3r\u02DBt\u02DEv\u02E1x\u02E7z\u02EA|\u02EE~\u02F9\x80\u0302\x82\u030D\x84\u031C\x86\u0330\x88\u0388\x8A\u038A\x8C\u0392\x8E\u039D\x90\u03A9\x92\u03AB\x94\u03B0\x96\u03CB\x98\u03D0\x9A\u03D2\x9C\u03DA\x9E\u03EA\xA0\u03F0\xA2\u03FB\xA4\u03FD\xA6\u0405\xA8\u0409\xAA\u040C\xAC\u041A\xAE\u041C\xB0\u0428\xB2\u042B\xB4\u0437\xB6\u0440\xB8\u0442\xBA\u0460\xBC\u0462\xBE\u0466\xC0\u0469\xC2\u046D\xC4\u047C\xC6\xD1\xC7\xD1\n\xC8\xD1\f\xC9\xD1:\xCA\xD1(\xCB\xD1.\xCC\xD1\xCD\xD1 \xCE\xD1\"\xCF\xD1$\xD0\xC6\xD0\xC7\xD0\xC8\xD0\xC9\xD0\xCA\xD0\xCB\xD0\xCC\xD0\xCD\xD0\xCE\xD0\xCF\xD1\xD4\xD2\xD0\xD2\xD3\xD3\xD5\xD4\xD2\xD5\xD6\x07\xD6\xD7\xD8\x07\xD8\xD9\xD9\xDA\b\xDA\xDB\x07\xDB\xDC\xDD\xBE`\xDD\x07\xDE\xE2\x07\xDF\xE2\n\xE0\xE2\x86D\xE1\xDE\xE1\xDF\xE1\xE0\xE2	\xE3\xEA\b\xE4\xE6\x07\xE5\xE4\xE5\xE6\xE6\xE7\xE7\xE9\b\xE8\xE5\xE9\xEC\xEA\xE8\xEA\xEB\xEB\v\xEC\xEA\xED\xEE	\xEE\r\xEF\xF1\f\x07\xF0\xEF\xF0\xF1\xF1\xF2\xF2\xF8\x07\x85\xF3\xF5\f\x07\xF4\xF3\xF4\xF5\xF5\xF6\xF6\xF8\x07j\xF7\xF0\xF7\xF4\xF8\xF9\xFC\xBE`\xFA\xFB\x07\xFB\xFD\xBE`\xFC\xFA\xFC\xFD\xFD\xFE\xFF\x07\xFF\u0102\v\u0100\u0101\x07\u0101\u0103\xBE`\u0102\u0100\u0102\u0103\u0103\u0104\u0104\u0105\x07\u0105\u0123\u0106\u0109\x07\u0107\u010A\x07\u0108\u010A\xBE`\u0109\u0107\u0109\u0108\u010A\u010D\u010B\u010C\x07\u010C\u010E\xBE`\u010D\u010B\u010D\u010E\u010E\u010F\u010F\u0110\x07\u0110\u0111\v\u0111\u0112\x07\u0112\u0123\u0113\u0114\x07\u0114\u0115\x07\u0115\u011A	\u0116\u0117\x07\u0117\u0119	\u0118\u0116\u0119\u011C\u011A\u0118\u011A\u011B\u011B\u011D\u011C\u011A\u011D\u011E\x07\u011E\u011F\x07\u011F\u0120\v\u0120\u0121\x07\u0121\u0123\u0122\xFE\u0122\u0106\u0122\u0113\u0123\u0124\u0125\x07\x84\u0125\u0126\u0128\x07\u0127\u0126\u0127\u0128\u0128\u0129\u0129\u012A	\u012A\u0134\xBE`\u012B\u012C\x07\u012C\u0131\r\u012D\u012E\x07\u012E\u0130\r\u012F\u012D\u0130\u0133\u0131\u012F\u0131\u0132\u0132\u0135\u0133\u0131\u0134\u012B\u0134\u0135\u0135\u0136\u0136\u013A\x07\u0137\u0139\u0138\u0137\u0139\u013C\u013A\u0138\u013A\u013B\u013B\u013D\u013C\u013A\u013D\u013E\x07\u013E\u013F\u0145L'\u0140\u0142\x07\u0141\u0143\x8AF\u0142\u0141\u0142\u0143\u0143\u0144\u0144\u0146\x07\u0145\u0140\u0145\u0146\u0146\u0147\u0151\u0148\u0151$\u0149\u0151(\u014A\u0151*\u014B\u0151.\u014C\u01516\u014D\u0151:\u014E\u0151 \u014F\u0151\"\u0150\u0147\u0150\u0148\u0150\u0149\u0150\u014A\u0150\u014B\u0150\u014C\u0150\u014D\u0150\u014E\u0150\u014F\u0151\u0152\u015BJ&\u0153\u015A\x07z\u0154\u015A\x07w\u0155\u015A\x07y\u0156\u015A\x07q\u0157\u015A\x07r\u0158\u015A\xC2b\u0159\u0153\u0159\u0154\u0159\u0155\u0159\u0156\u0159\u0157\u0159\u0158\u015A\u015D\u015B\u0159\u015B\u015C\u015C\u015E\u015D\u015B\u015E\u0161\xBE`\u015F\u0160\x07\r\u0160\u0162\x86D\u0161\u015F\u0161\u0162\u0162\u0163\u0163\u0164\x07\u0164\u0165\u0166J&\u0166\u0167\x07q\u0167\u0168\xBE`\u0168\u0169\x07\r\u0169\u016A\x86D\u016A\u016B\x07\u016B\u016C\u016D\x07\u016D\u016E\xBE`\u016E\u016F<\u016F\u0170\x07\u0170!\u0171\u0172\x07}\u0172\u0173\xBE`\u0173\u0174\x07\u0174\u0175\x84C\u0175\u0176\x07\u0176#\u0177\u0178\x07\u0178\u0179&\u0179\u017C\x07\u017A\u017D\x07\u017B\u017DJ&\u017C\u017A\u017C\u017B\u017D\u017F\u017E\u0180\x07\x7F\u017F\u017E\u017F\u0180\u0180\u0181\u0181\u0182\x07\u0182%\u0183\u0190L'\u0184\u0185\x07\u0185\u018AL'\u0186\u0187\x07\u0187\u0189L'\u0188\u0186\u0189\u018C\u018A\u0188\u018A\u018B\u018B\u018D\u018C\u018A\u018D\u018E\x07\u018E\u0190\u018F\u0183\u018F\u0184\u0190'\u0191\u0192\x07\u0192\u0193\xBE`\u0193\u019E\x07\u0194\u0195H%\u0195\u019B\x07\u0196\u0197H%\u0197\u0198\x07\u0198\u019A\u0199\u0196\u019A\u019D\u019B\u0199\u019B\u019C\u019C\u019F\u019D\u019B\u019E\u0194\u019E\u019F\u019F\u01A0\u01A0\u01A1\x07\u01A1)\u01A2\u01A3\x07\u01A3\u01A5\xBE`\u01A4\u01A6<\u01A5\u01A4";
SolidityParser._serializedATNSegment1 = "\u01A5\u01A6\u01A6\u01AB\u01A7\u01AA\x07{\u01A8\u01AA\xC2b\u01A9\u01A7\u01A9\u01A8\u01AA\u01AD\u01AB\u01A9\u01AB\u01AC\u01AC\u01B0\u01AD\u01AB\u01AE\u01B1\x07\u01AF\u01B1X-\u01B0\u01AE\u01B0\u01AF\u01B1+\u01B2\u01B8\xBE`\u01B3\u01B5\x07\u01B4\u01B6\x8AF\u01B5\u01B4\u01B5\u01B6\u01B6\u01B7\u01B7\u01B9\x07\u01B8\u01B3\u01B8\u01B9\u01B9-\u01BA\u01BB0\u01BB\u01BC<\u01BC\u01BE4\u01BD\u01BF2\u01BE\u01BD\u01BE\u01BF\u01BF\u01C2\u01C0\u01C3\x07\u01C1\u01C3X-\u01C2\u01C0\u01C2\u01C1\u01C3/\u01C4\u01C6\x07 \u01C5\u01C7\xBE`\u01C6\u01C5\u01C6\u01C7\u01C7\u01CC\u01C8\u01CC\x07\x80\u01C9\u01CC\x07\x81\u01CA\u01CC\x07\x82\u01CB\u01C4\u01CB\u01C8\u01CB\u01C9\u01CB\u01CA\u01CC1\u01CD\u01CE\x07!\u01CE\u01CF<\u01CF3\u01D0\u01D9\x07u\u01D1\u01D9\x07z\u01D2\u01D9\x07w\u01D3\u01D9\x07y\u01D4\u01D9\x07{\u01D5\u01D9V,\u01D6\u01D9,\u01D7\u01D9\xC2b\u01D8\u01D0\u01D8\u01D1\u01D8\u01D2\u01D8\u01D3\u01D8\u01D4\u01D8\u01D5\u01D8\u01D6\u01D8\u01D7\u01D9\u01DC\u01DA\u01D8\u01DA\u01DB\u01DB5\u01DC\u01DA\u01DD\u01DE\x07\"\u01DE\u01DF\xBE`\u01DF\u01E1@!\u01E0\u01E2\x07o\u01E1\u01E0\u01E1\u01E2\u01E2\u01E3\u01E3\u01E4\x07\u01E47\u01E5\u01E6\xBE`\u01E69\u01E7\u01E8\x07#\u01E8\u01E9\xBE`\u01E9\u01EB\x07\u01EA\u01EC8\u01EB\u01EA\u01EB\u01EC\u01EC\u01F1\u01ED\u01EE\x07\u01EE\u01F08\u01EF\u01ED\u01F0\u01F3\u01F1\u01EF\u01F1\u01F2\u01F2\u01F4\u01F3\u01F1\u01F4\u01F5\x07\u01F5;\u01F6\u01FF\x07\u01F7\u01FC> \u01F8\u01F9\x07\u01F9\u01FB> \u01FA\u01F8\u01FB\u01FE\u01FC\u01FA\u01FC\u01FD\u01FD\u0200\u01FE\u01FC\u01FF\u01F7\u01FF\u0200\u0200\u0201\u0201\u0202\x07\u0202=\u0203\u0205J&\u0204\u0206T+\u0205\u0204\u0205\u0206\u0206\u0208\u0207\u0209\xBE`\u0208\u0207\u0208\u0209\u0209?\u020A\u0213\x07\u020B\u0210B\"\u020C\u020D\x07\u020D\u020FB\"\u020E\u020C\u020F\u0212\u0210\u020E\u0210\u0211\u0211\u0214\u0212\u0210\u0213\u020B\u0213\u0214\u0214\u0215\u0215\u0216\x07\u0216A\u0217\u0219J&\u0218\u021A\x07v\u0219\u0218\u0219\u021A\u021A\u021C\u021B\u021D\xBE`\u021C\u021B\u021C\u021D\u021DC\u021E\u0227\x07\u021F\u0224F$\u0220\u0221\x07\u0221\u0223F$\u0222\u0220\u0223\u0226\u0224\u0222\u0224\u0225\u0225\u0228\u0226\u0224\u0227\u021F\u0227\u0228\u0228\u0229\u0229\u022A\x07\u022AE\u022B\u022DJ&\u022C\u022ET+\u022D\u022C\u022D\u022E\u022EG\u022F\u0231J&\u0230\u0232T+\u0231\u0230\u0231\u0232\u0232\u0233\u0233\u0234\xBE`\u0234I\u0235\u0236\b&\u0236\u023D\x84C\u0237\u023DL'\u0238\u023DP)\u0239\u023DR*\u023A\u023B\x07&\u023B\u023D\x07x\u023C\u0235\u023C\u0237\u023C\u0238\u023C\u0239\u023C\u023A\u023D\u0246\u023E\u023F\f\u023F\u0241\x07$\u0240\u0242\x86D\u0241\u0240\u0241\u0242\u0242\u0243\u0243\u0245\x07%\u0244\u023E\u0245\u0248\u0246\u0244\u0246\u0247\u0247K\u0248\u0246\u0249\u024E\xBE`\u024A\u024B\x07'\u024B\u024D\xBE`\u024C\u024A\u024D\u0250\u024E\u024C\u024E\u024F\u024FM\u0250\u024E\u0251\u0254\x84C\u0252\u0254L'\u0253\u0251\u0253\u0252\u0254O\u0255\u0256\x07(\u0256\u0257\x07\u0257\u0258N(\u0258\u0259\x07)\u0259\u025AJ&\u025A\u025B\x07\u025BQ\u025C\u025D\x07 \u025D\u0263D#\u025E\u0262\x07w\u025F\u0262\x07u\u0260\u0262V,\u0261\u025E\u0261\u025F\u0261\u0260\u0262\u0265\u0263\u0261\u0263\u0264\u0264\u0268\u0265\u0263\u0266\u0267\x07!\u0267\u0269D#\u0268\u0266\u0268\u0269\u0269S\u026A\u026B	\u026BU\u026C\u026D	\u026DW\u026E\u0272\x07\u026F\u0271Z.\u0270\u026F\u0271\u0274\u0272\u0270\u0272\u0273\u0273\u0275\u0274\u0272\u0275\u0276\x07\u0276Y\u0277\u0287^0\u0278\u0287`1\u0279\u0287d3\u027A\u0287j6\u027B\u0287X-\u027C\u0287l7\u027D\u0287p9\u027E\u0287r:\u027F\u0287t;\u0280\u0287v<\u0281\u0287x=\u0282\u0287z>\u0283\u0287f4\u0284\u0287h5\u0285\u0287|?\u0286\u0277\u0286\u0278\u0286\u0279\u0286\u027A\u0286\u027B\u0286\u027C\u0286\u027D\u0286\u027E\u0286\u027F\u0286\u0280\u0286\u0281\u0286\u0282\u0286\u0283\u0286\u0284\u0286\u0285\u0287[\u0288\u0289\x86D\u0289\u028A\x07\u028A]\u028B\u028C\x07-\u028C\u028D\x07\u028D\u028E\x86D\u028E\u028F\x07\u028F\u0292Z.\u0290\u0291\x07.\u0291\u0293Z.\u0292\u0290\u0292\u0293\u0293_\u0294\u0295\x07/\u0295\u0297\x86D\u0296\u02982\u0297\u0296\u0297\u0298\u0298\u0299\u0299\u029BX-\u029A\u029Cb2\u029B\u029A\u029C\u029D\u029D\u029B\u029D\u029E\u029Ea\u029F\u02A4\x070\u02A0\u02A2\xBE`\u02A1\u02A0\u02A1\u02A2\u02A2\u02A3\u02A3\u02A5<\u02A4\u02A1\u02A4\u02A5\u02A5\u02A6\u02A6\u02A7X-\u02A7c\u02A8\u02A9\x071\u02A9\u02AA\x07\u02AA\u02AB\x86D\u02AB\u02AC\x07\u02AC\u02ADZ.\u02ADe\u02AE\u02B1~@\u02AF\u02B1\\/\u02B0\u02AE\u02B0\u02AF\u02B1g\u02B2\u02B3\x072\u02B3\u02B4X-\u02B4i\u02B5\u02B6\x07\u02B6\u02B9\x07\u02B7\u02BAf4\u02B8\u02BA\x07\u02B9\u02B7\u02B9\u02B8\u02BA\u02BD\u02BB\u02BE\\/\u02BC\u02BE\x07\u02BD\u02BB\u02BD\u02BC\u02BE\u02C0\u02BF\u02C1\x86D\u02C0\u02BF\u02C0\u02C1\u02C1\u02C2\u02C2\u02C3\x07\u02C3\u02C4Z.\u02C4k\u02C5\u02C7\x073\u02C6\u02C8\x07\x84\u02C7\u02C6\u02C7\u02C8\u02C8\u02CD\u02C9\u02CA\x07\u02CA\u02CBn8\u02CB\u02CC\x07\u02CC\u02CE\u02CD\u02C9\u02CD\u02CE\u02CE\u02CF\u02CF\u02D0\x94K\u02D0m\u02D1\u02D2\xC4c\u02D2o\u02D3\u02D4\x074\u02D4\u02D5Z.\u02D5\u02D6\x071\u02D6\u02D7\x07\u02D7\u02D8\x86D\u02D8\u02D9\x07\u02D9\u02DA\x07\u02DAq\u02DB\u02DC\x07s\u02DC\u02DD\x07\u02DDs\u02DE\u02DF\x07p\u02DF\u02E0\x07\u02E0u\u02E1\u02E3\x075\u02E2\u02E4\x86D\u02E3\u02E2\u02E3\u02E4\u02E4\u02E5\u02E5\u02E6\x07\u02E6w\u02E7\u02E8\x076\u02E8\u02E9\x07\u02E9y\u02EA\u02EB\x077\u02EB\u02EC\x92J\u02EC\u02ED\x07\u02ED{\u02EE\u02EF\x078\u02EF\u02F0\x92J\u02F0\u02F1\x07\u02F1}\u02F2\u02F3\x079\u02F3\u02FA\x82B\u02F4\u02FAH%\u02F5\u02F6\x07\u02F6\u02F7\x80A\u02F7\u02F8\x07\u02F8\u02FA\u02F9\u02F2\u02F9\u02F4\u02F9\u02F5\u02FA\u02FD\u02FB\u02FC\x07\r\u02FC\u02FE\x86D\u02FD\u02FB\u02FD\u02FE\u02FE\u02FF\u02FF\u0300\x07\u0300\x7F\u0301\u0303H%\u0302\u0301\u0302\u0303\u0303\u030A\u0304\u0306\x07\u0305\u0307H%\u0306\u0305\u0306\u0307\u0307\u0309\u0308\u0304\u0309\u030C\u030A\u0308\u030A\u030B\u030B\x81\u030C\u030A\u030D\u0314\x07\u030E\u0310\xBE`\u030F\u030E\u030F\u0310\u0310\u0311\u0311\u0313\x07\u0312\u030F\u0313\u0316\u0314\u0312\u0314\u0315\u0315\u0318\u0316\u0314\u0317\u0319\xBE`\u0318\u0317\u0318\u0319\u0319\u031A\u031A\u031B\x07\u031B\x83\u031C\u031D	\u031D\x85\u031E\u031F\bD\u031F\u0320\x07?\u0320\u0331J&\u0321\u0322\x07\u0322\u0323\x86D\u0323\u0324\x07\u0324\u0331\u0325\u0326	\x07\u0326\u0331\x86D\u0327\u0328	\b\u0328\u0331\x86D\u0329\u032A		\u032A\u0331\x86D\u032B\u032C\x07E\u032C\u0331\x86D\u032D\u032E\x07\b\u032E\u0331\x86D\u032F\u0331\x88E\u0330\u031E\u0330\u0321\u0330\u0325\u0330\u0327\u0330\u0329\u0330\u032B\u0330\u032D\u0330\u032F\u0331\u037C\u0332\u0333\f\u0333\u0334\x07F\u0334\u037B\x86D\u0335\u0336\f\u0336\u0337	\n\u0337\u037B\x86D\u0338\u0339\f\u0339\u033A	\b\u033A\u037B\x86D\u033B\u033C\f\r\u033C\u033D	\v\u033D\u037B\x86D\u033E\u033F\f\f\u033F\u0340\x07K\u0340\u037B\x86D\r\u0341\u0342\f\v\u0342\u0343\x07\x07\u0343\u037B\x86D\f\u0344\u0345\f\n\u0345\u0346\x07L\u0346\u037B\x86D\v\u0347\u0348\f	\u0348\u0349	\f\u0349\u037B\x86D\n\u034A\u034B\f\b\u034B\u034C	\r\u034C\u037B\x86D	\u034D\u034E\f\x07\u034E\u034F\x07O\u034F\u037B\x86D\b\u0350\u0351\f\u0351\u0352\x07\u0352\u037B\x86D\x07\u0353\u0354\f\u0354\u0355\x07P\u0355\u0356\x86D\u0356\u0357\x07@\u0357\u0358\x86D\u0358\u037B\u0359\u035A\f\u035A\u035B	\u035B\u037B\x86D\u035C\u035D\f\u035D\u037B	\x07\u035E\u035F\f\u035F\u0360\x07$\u0360\u0361\x86D\u0361\u0362\x07%\u0362\u037B\u0363\u0364\f\u0364\u0366\x07$\u0365\u0367\x86D\u0366\u0365\u0366\u0367\u0367\u0368\u0368\u036A\x07@\u0369\u036B\x86D\u036A\u0369\u036A\u036B\u036B\u036C\u036C\u037B\x07%\u036D\u036E\f\u036E\u036F\x07'\u036F\u037B\xBE`\u0370\u0371\f\u0371\u0372\x07\u0372\u0373\x8CG\u0373\u0374\x07\u0374\u037B\u0375\u0376\f\u0376\u0377\x07\u0377\u0378\x90I\u0378\u0379\x07\u0379\u037B\u037A\u0332\u037A\u0335\u037A\u0338\u037A\u033B\u037A\u033E\u037A\u0341\u037A\u0344\u037A\u0347\u037A\u034A\u037A\u034D\u037A\u0350\u037A\u0353\u037A\u0359\u037A\u035C\u037A\u035E\u037A\u0363\u037A\u036D\u037A\u0370\u037A\u0375\u037B\u037E\u037C\u037A\u037C\u037D\u037D\x87\u037E\u037C\u037F\u0389\x07i\u0380\u0389\xBC_\u0381\u0389\xC0a\u0382\u0389\xC4c\u0383\u0389\xBE`\u0384\u0389\x07}\u0385\u0389\x07x\u0386\u0389\xBA^\u0387\u0389J&\u0388\u037F\u0388\u0380\u0388\u0381\u0388\u0382\u0388\u0383\u0388\u0384\u0388\u0385\u0388\u0386\u0388\u0387\u0389\x89\u038A\u038F\x86D\u038B\u038C\x07\u038C\u038E\x86D\u038D\u038B\u038E\u0391\u038F\u038D\u038F\u0390\u0390\x8B\u0391\u038F\u0392\u0397\x8EH\u0393\u0394\x07\u0394\u0396\x8EH\u0395\u0393\u0396\u0399\u0397\u0395\u0397\u0398\u0398\u039B\u0399\u0397\u039A\u039C\x07\u039B\u039A\u039B\u039C\u039C\x8D\u039D\u039E\xBE`\u039E\u039F\x07@\u039F\u03A0\x86D\u03A0\x8F\u03A1\u03A3\x07\u03A2\u03A4\x8CG\u03A3\u03A2\u03A3\u03A4\u03A4\u03A5\u03A5\u03AA\x07\u03A6\u03A8\x8AF\u03A7\u03A6\u03A7\u03A8\u03A8\u03AA\u03A9\u03A1\u03A9\u03A7\u03AA\x91\u03AB\u03AC\x86D\u03AC\u03AD\x07\u03AD\u03AE\x90I\u03AE\u03AF\x07\u03AF\x93\u03B0\u03B4\x07\u03B1\u03B3\x96L\u03B2\u03B1\u03B3\u03B6\u03B4\u03B2\u03B4\u03B5\u03B5\u03B7\u03B6\u03B4\u03B7\u03B8\x07\u03B8\x95\u03B9\u03CC\xBE`\u03BA\u03CC\x94K\u03BB\u03CC\x98M\u03BC\u03CC\x9EP\u03BD\u03CC\xA0Q\u03BE\u03CC\xA6T\u03BF\u03CC\xA8U\u03C0\u03CC\xAAV\u03C1\u03CC\xAEX\u03C2\u03CC\xB2Z\u03C3\u03CC\xB4[\u03C4\u03CC\x07p\u03C5\u03CC\x07s\u03C6\u03CC\x07t\u03C7\u03CC\xB8]\u03C8\u03CC\xBC_\u03C9\u03CC\xC4c\u03CA\u03CC\xC0a\u03CB\u03B9\u03CB\u03BA\u03CB\u03BB\u03CB\u03BC\u03CB\u03BD\u03CB\u03BE\u03CB\u03BF\u03CB\u03C0\u03CB\u03C1\u03CB\u03C2\u03CB\u03C3\u03CB\u03C4\u03CB\u03C5\u03CB\u03C6\u03CB\u03C7\u03CB\u03C8\u03CB\u03C9\u03CB\u03CA\u03CC\x97\u03CD\u03D1\x9CO\u03CE\u03D1\xB6\\\u03CF\u03D1\x9AN\u03D0\u03CD\u03D0\u03CE\u03D0\u03CF\u03D1\x99\u03D2\u03D3\xBE`\u03D3\u03D4\x07'\u03D4\u03D5\xBE`\u03D5\x9B\u03D6\u03DB\x075\u03D7\u03DB\x07&\u03D8\u03DB\x07<\u03D9\u03DB\xBE`\u03DA\u03D6\u03DA\u03D7\u03DA\u03D8\u03DA\u03D9\u03DB\u03E8\u03DC\u03DE\x07\u03DD\u03DF\x98M\u03DE\u03DD\u03DE\u03DF\u03DF\u03E4\u03E0\u03E1\x07\u03E1\u03E3\x98M\u03E2\u03E0\u03E3\u03E6\u03E4\u03E2\u03E4\u03E5\u03E5\u03E7\u03E6\u03E4\u03E7\u03E9\x07\u03E8\u03DC\u03E8\u03E9\u03E9\x9D\u03EA\u03EB\x07[\u03EB\u03EE\xA2R\u03EC\u03ED\x07\\\u03ED\u03EF\x98M\u03EE\u03EC\u03EE\u03EF\u03EF\x9F\u03F0\u03F1\xA2R\u03F1\u03F2\x07\\\u03F2\u03F3\x98M\u03F3\xA1\u03F4\u03FC\xBE`\u03F5\u03FC\x9AN\u03F6\u03FC\xA4S\u03F7\u03F8\x07\u03F8\u03F9\xA4S\u03F9\u03FA\x07\u03FA\u03FC\u03FB\u03F4\u03FB\u03F5\u03FB\u03F6\u03FB\u03F7\u03FC\xA3\u03FD\u0402\xBE`\u03FE\u03FF\x07\u03FF\u0401\xBE`\u0400\u03FE\u0401\u0404\u0402\u0400\u0402\u0403\u0403\xA5\u0404\u0402\u0405\u0406\x98M\u0406\u0407\x07]\u0407\u0408\xBE`\u0408\xA7\u0409\u040A\xBE`\u040A\u040B\x07@\u040B\xA9\u040C\u040D\x07^\u040D\u0411\x98M\u040E\u0410\xACW\u040F\u040E\u0410\u0413\u0411\u040F\u0411\u0412\u0412\xAB\u0413\u0411\u0414\u0415\x07_\u0415\u0416\xB6\\\u0416\u0417\x94K\u0417\u041B\u0418\u0419\x07`\u0419\u041B\x94K\u041A\u0414\u041A\u0418\u041B\xAD\u041C\u041D\x07 \u041D\u041E\xBE`\u041E\u0420\x07\u041F\u0421\xA4S\u0420\u041F\u0420\u0421\u0421\u0422\u0422\u0424\x07\u0423\u0425\xB0Y\u0424\u0423\u0424\u0425\u0425\u0426\u0426\u0427\x94K\u0427\xAF\u0428\u0429\x07a\u0429\u042A\xA4S\u042A\xB1\u042B\u042E\x07\u042C\u042F\x94K\u042D\u042F\x98M\u042E\u042C\u042E\u042D\u042F\u0430\u0430\u0433\x98M\u0431\u0434\x94K\u0432\u0434\x98M\u0433\u0431\u0433\u0432\u0434\u0435\u0435\u0436\x94K\u0436\xB3\u0437\u0438\x07-\u0438\u0439\x98M\u0439\u043A\x94K\u043A\xB5\u043B\u0441\xC4c\u043C\u0441\x07j\u043D\u0441\x07k\u043E\u0441\xC0a\u043F\u0441\x07i\u0440\u043B\u0440\u043C\u0440\u043D\u0440\u043E\u0440\u043F";
SolidityParser._serializedATNSegment2 = "\u0441\xB7\u0442\u0443\x073\u0443\u0444\xBE`\u0444\u0445\x94K\u0445\xB9\u0446\u0448\x07\u0447\u0449\x86D\u0448\u0447\u0448\u0449\u0449\u0450\u044A\u044C\x07\u044B\u044D\x86D\u044C\u044B\u044C\u044D\u044D\u044F\u044E\u044A\u044F\u0452\u0450\u044E\u0450\u0451\u0451\u0453\u0452\u0450\u0453\u0461\x07\u0454\u045D\x07$\u0455\u045A\x86D\u0456\u0457\x07\u0457\u0459\x86D\u0458\u0456\u0459\u045C\u045A\u0458\u045A\u045B\u045B\u045E\u045C\u045A\u045D\u0455\u045D\u045E\u045E\u045F\u045F\u0461\x07%\u0460\u0446\u0460\u0454\u0461\xBB\u0462\u0464	\u0463\u0465\x07l\u0464\u0463\u0464\u0465\u0465\xBD\u0466\u0467	\u0467\xBF\u0468\u046A\x07m\u0469\u0468\u046A\u046B\u046B\u0469\u046B\u046C\u046C\xC1\u046D\u0479\x07c\u046E\u046F\x07\u046F\u0474L'\u0470\u0471\x07\u0471\u0473L'\u0472\u0470\u0473\u0476\u0474\u0472\u0474\u0475\u0475\u0477\u0476\u0474\u0477\u0478\x07\u0478\u047A\u0479\u046E\u0479\u047A\u047A\xC3\u047B\u047D\x07\x84\u047C\u047B\u047D\u047E\u047E\u047C\u047E\u047F\u047F\xC5\x81\xD0\xD2\xE1\xE5\xEA\xF0\xF4\xF7\xFC\u0102\u0109\u010D\u011A\u0122\u0127\u0131\u0134\u013A\u0142\u0145\u0150\u0159\u015B\u0161\u017C\u017F\u018A\u018F\u019B\u019E\u01A5\u01A9\u01AB\u01B0\u01B5\u01B8\u01BE\u01C2\u01C6\u01CB\u01D8\u01DA\u01E1\u01EB\u01F1\u01FC\u01FF\u0205\u0208\u0210\u0213\u0219\u021C\u0224\u0227\u022D\u0231\u023C\u0241\u0246\u024E\u0253\u0261\u0263\u0268\u0272\u0286\u0292\u0297\u029D\u02A1\u02A4\u02B0\u02B9\u02BD\u02C0\u02C7\u02CD\u02E3\u02F9\u02FD\u0302\u0306\u030A\u030F\u0314\u0318\u0330\u0366\u036A\u037A\u037C\u0388\u038F\u0397\u039B\u03A3\u03A7\u03A9\u03B4\u03CB\u03D0\u03DA\u03DE\u03E4\u03E8\u03EE\u03FB\u0402\u0411\u041A\u0420\u0424\u042E\u0433\u0440\u0448\u044C\u0450\u045A\u045D\u0460\u0464\u046B\u0474\u0479\u047E";
SolidityParser._serializedATN = Utils2.join([
  _SolidityParser._serializedATNSegment0,
  _SolidityParser._serializedATNSegment1,
  _SolidityParser._serializedATNSegment2
], "");
var SourceUnitContext = class extends import_ParserRuleContext.ParserRuleContext {
  EOF() {
    return this.getToken(SolidityParser.EOF, 0);
  }
  pragmaDirective(i) {
    if (i === void 0) {
      return this.getRuleContexts(PragmaDirectiveContext);
    } else {
      return this.getRuleContext(i, PragmaDirectiveContext);
    }
  }
  importDirective(i) {
    if (i === void 0) {
      return this.getRuleContexts(ImportDirectiveContext);
    } else {
      return this.getRuleContext(i, ImportDirectiveContext);
    }
  }
  contractDefinition(i) {
    if (i === void 0) {
      return this.getRuleContexts(ContractDefinitionContext);
    } else {
      return this.getRuleContext(i, ContractDefinitionContext);
    }
  }
  enumDefinition(i) {
    if (i === void 0) {
      return this.getRuleContexts(EnumDefinitionContext);
    } else {
      return this.getRuleContext(i, EnumDefinitionContext);
    }
  }
  structDefinition(i) {
    if (i === void 0) {
      return this.getRuleContexts(StructDefinitionContext);
    } else {
      return this.getRuleContext(i, StructDefinitionContext);
    }
  }
  functionDefinition(i) {
    if (i === void 0) {
      return this.getRuleContexts(FunctionDefinitionContext);
    } else {
      return this.getRuleContext(i, FunctionDefinitionContext);
    }
  }
  fileLevelConstant(i) {
    if (i === void 0) {
      return this.getRuleContexts(FileLevelConstantContext);
    } else {
      return this.getRuleContext(i, FileLevelConstantContext);
    }
  }
  customErrorDefinition(i) {
    if (i === void 0) {
      return this.getRuleContexts(CustomErrorDefinitionContext);
    } else {
      return this.getRuleContext(i, CustomErrorDefinitionContext);
    }
  }
  typeDefinition(i) {
    if (i === void 0) {
      return this.getRuleContexts(TypeDefinitionContext);
    } else {
      return this.getRuleContext(i, TypeDefinitionContext);
    }
  }
  usingForDeclaration(i) {
    if (i === void 0) {
      return this.getRuleContexts(UsingForDeclarationContext);
    } else {
      return this.getRuleContext(i, UsingForDeclarationContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_sourceUnit;
  }
  enterRule(listener) {
    if (listener.enterSourceUnit) {
      listener.enterSourceUnit(this);
    }
  }
  exitRule(listener) {
    if (listener.exitSourceUnit) {
      listener.exitSourceUnit(this);
    }
  }
  accept(visitor) {
    if (visitor.visitSourceUnit) {
      return visitor.visitSourceUnit(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var PragmaDirectiveContext = class extends import_ParserRuleContext.ParserRuleContext {
  pragmaName() {
    return this.getRuleContext(0, PragmaNameContext);
  }
  pragmaValue() {
    return this.getRuleContext(0, PragmaValueContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_pragmaDirective;
  }
  enterRule(listener) {
    if (listener.enterPragmaDirective) {
      listener.enterPragmaDirective(this);
    }
  }
  exitRule(listener) {
    if (listener.exitPragmaDirective) {
      listener.exitPragmaDirective(this);
    }
  }
  accept(visitor) {
    if (visitor.visitPragmaDirective) {
      return visitor.visitPragmaDirective(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var PragmaNameContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier() {
    return this.getRuleContext(0, IdentifierContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_pragmaName;
  }
  enterRule(listener) {
    if (listener.enterPragmaName) {
      listener.enterPragmaName(this);
    }
  }
  exitRule(listener) {
    if (listener.exitPragmaName) {
      listener.exitPragmaName(this);
    }
  }
  accept(visitor) {
    if (visitor.visitPragmaName) {
      return visitor.visitPragmaName(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var PragmaValueContext = class extends import_ParserRuleContext.ParserRuleContext {
  version() {
    return this.tryGetRuleContext(0, VersionContext);
  }
  expression() {
    return this.tryGetRuleContext(0, ExpressionContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_pragmaValue;
  }
  enterRule(listener) {
    if (listener.enterPragmaValue) {
      listener.enterPragmaValue(this);
    }
  }
  exitRule(listener) {
    if (listener.exitPragmaValue) {
      listener.exitPragmaValue(this);
    }
  }
  accept(visitor) {
    if (visitor.visitPragmaValue) {
      return visitor.visitPragmaValue(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var VersionContext = class extends import_ParserRuleContext.ParserRuleContext {
  versionConstraint(i) {
    if (i === void 0) {
      return this.getRuleContexts(VersionConstraintContext);
    } else {
      return this.getRuleContext(i, VersionConstraintContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_version;
  }
  enterRule(listener) {
    if (listener.enterVersion) {
      listener.enterVersion(this);
    }
  }
  exitRule(listener) {
    if (listener.exitVersion) {
      listener.exitVersion(this);
    }
  }
  accept(visitor) {
    if (visitor.visitVersion) {
      return visitor.visitVersion(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var VersionOperatorContext = class extends import_ParserRuleContext.ParserRuleContext {
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_versionOperator;
  }
  enterRule(listener) {
    if (listener.enterVersionOperator) {
      listener.enterVersionOperator(this);
    }
  }
  exitRule(listener) {
    if (listener.exitVersionOperator) {
      listener.exitVersionOperator(this);
    }
  }
  accept(visitor) {
    if (visitor.visitVersionOperator) {
      return visitor.visitVersionOperator(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var VersionConstraintContext = class extends import_ParserRuleContext.ParserRuleContext {
  VersionLiteral() {
    return this.tryGetToken(SolidityParser.VersionLiteral, 0);
  }
  versionOperator() {
    return this.tryGetRuleContext(0, VersionOperatorContext);
  }
  DecimalNumber() {
    return this.tryGetToken(SolidityParser.DecimalNumber, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_versionConstraint;
  }
  enterRule(listener) {
    if (listener.enterVersionConstraint) {
      listener.enterVersionConstraint(this);
    }
  }
  exitRule(listener) {
    if (listener.exitVersionConstraint) {
      listener.exitVersionConstraint(this);
    }
  }
  accept(visitor) {
    if (visitor.visitVersionConstraint) {
      return visitor.visitVersionConstraint(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ImportDeclarationContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier(i) {
    if (i === void 0) {
      return this.getRuleContexts(IdentifierContext);
    } else {
      return this.getRuleContext(i, IdentifierContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_importDeclaration;
  }
  enterRule(listener) {
    if (listener.enterImportDeclaration) {
      listener.enterImportDeclaration(this);
    }
  }
  exitRule(listener) {
    if (listener.exitImportDeclaration) {
      listener.exitImportDeclaration(this);
    }
  }
  accept(visitor) {
    if (visitor.visitImportDeclaration) {
      return visitor.visitImportDeclaration(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ImportDirectiveContext = class extends import_ParserRuleContext.ParserRuleContext {
  importPath() {
    return this.getRuleContext(0, ImportPathContext);
  }
  identifier(i) {
    if (i === void 0) {
      return this.getRuleContexts(IdentifierContext);
    } else {
      return this.getRuleContext(i, IdentifierContext);
    }
  }
  importDeclaration(i) {
    if (i === void 0) {
      return this.getRuleContexts(ImportDeclarationContext);
    } else {
      return this.getRuleContext(i, ImportDeclarationContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_importDirective;
  }
  enterRule(listener) {
    if (listener.enterImportDirective) {
      listener.enterImportDirective(this);
    }
  }
  exitRule(listener) {
    if (listener.exitImportDirective) {
      listener.exitImportDirective(this);
    }
  }
  accept(visitor) {
    if (visitor.visitImportDirective) {
      return visitor.visitImportDirective(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ImportPathContext = class extends import_ParserRuleContext.ParserRuleContext {
  StringLiteralFragment() {
    return this.getToken(SolidityParser.StringLiteralFragment, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_importPath;
  }
  enterRule(listener) {
    if (listener.enterImportPath) {
      listener.enterImportPath(this);
    }
  }
  exitRule(listener) {
    if (listener.exitImportPath) {
      listener.exitImportPath(this);
    }
  }
  accept(visitor) {
    if (visitor.visitImportPath) {
      return visitor.visitImportPath(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ContractDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier() {
    return this.getRuleContext(0, IdentifierContext);
  }
  inheritanceSpecifier(i) {
    if (i === void 0) {
      return this.getRuleContexts(InheritanceSpecifierContext);
    } else {
      return this.getRuleContext(i, InheritanceSpecifierContext);
    }
  }
  contractPart(i) {
    if (i === void 0) {
      return this.getRuleContexts(ContractPartContext);
    } else {
      return this.getRuleContext(i, ContractPartContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_contractDefinition;
  }
  enterRule(listener) {
    if (listener.enterContractDefinition) {
      listener.enterContractDefinition(this);
    }
  }
  exitRule(listener) {
    if (listener.exitContractDefinition) {
      listener.exitContractDefinition(this);
    }
  }
  accept(visitor) {
    if (visitor.visitContractDefinition) {
      return visitor.visitContractDefinition(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var InheritanceSpecifierContext = class extends import_ParserRuleContext.ParserRuleContext {
  userDefinedTypeName() {
    return this.getRuleContext(0, UserDefinedTypeNameContext);
  }
  expressionList() {
    return this.tryGetRuleContext(0, ExpressionListContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_inheritanceSpecifier;
  }
  enterRule(listener) {
    if (listener.enterInheritanceSpecifier) {
      listener.enterInheritanceSpecifier(this);
    }
  }
  exitRule(listener) {
    if (listener.exitInheritanceSpecifier) {
      listener.exitInheritanceSpecifier(this);
    }
  }
  accept(visitor) {
    if (visitor.visitInheritanceSpecifier) {
      return visitor.visitInheritanceSpecifier(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ContractPartContext = class extends import_ParserRuleContext.ParserRuleContext {
  stateVariableDeclaration() {
    return this.tryGetRuleContext(0, StateVariableDeclarationContext);
  }
  usingForDeclaration() {
    return this.tryGetRuleContext(0, UsingForDeclarationContext);
  }
  structDefinition() {
    return this.tryGetRuleContext(0, StructDefinitionContext);
  }
  modifierDefinition() {
    return this.tryGetRuleContext(0, ModifierDefinitionContext);
  }
  functionDefinition() {
    return this.tryGetRuleContext(0, FunctionDefinitionContext);
  }
  eventDefinition() {
    return this.tryGetRuleContext(0, EventDefinitionContext);
  }
  enumDefinition() {
    return this.tryGetRuleContext(0, EnumDefinitionContext);
  }
  customErrorDefinition() {
    return this.tryGetRuleContext(0, CustomErrorDefinitionContext);
  }
  typeDefinition() {
    return this.tryGetRuleContext(0, TypeDefinitionContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_contractPart;
  }
  enterRule(listener) {
    if (listener.enterContractPart) {
      listener.enterContractPart(this);
    }
  }
  exitRule(listener) {
    if (listener.exitContractPart) {
      listener.exitContractPart(this);
    }
  }
  accept(visitor) {
    if (visitor.visitContractPart) {
      return visitor.visitContractPart(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var StateVariableDeclarationContext = class extends import_ParserRuleContext.ParserRuleContext {
  typeName() {
    return this.getRuleContext(0, TypeNameContext);
  }
  identifier() {
    return this.getRuleContext(0, IdentifierContext);
  }
  PublicKeyword(i) {
    if (i === void 0) {
      return this.getTokens(SolidityParser.PublicKeyword);
    } else {
      return this.getToken(SolidityParser.PublicKeyword, i);
    }
  }
  InternalKeyword(i) {
    if (i === void 0) {
      return this.getTokens(SolidityParser.InternalKeyword);
    } else {
      return this.getToken(SolidityParser.InternalKeyword, i);
    }
  }
  PrivateKeyword(i) {
    if (i === void 0) {
      return this.getTokens(SolidityParser.PrivateKeyword);
    } else {
      return this.getToken(SolidityParser.PrivateKeyword, i);
    }
  }
  ConstantKeyword(i) {
    if (i === void 0) {
      return this.getTokens(SolidityParser.ConstantKeyword);
    } else {
      return this.getToken(SolidityParser.ConstantKeyword, i);
    }
  }
  ImmutableKeyword(i) {
    if (i === void 0) {
      return this.getTokens(SolidityParser.ImmutableKeyword);
    } else {
      return this.getToken(SolidityParser.ImmutableKeyword, i);
    }
  }
  overrideSpecifier(i) {
    if (i === void 0) {
      return this.getRuleContexts(OverrideSpecifierContext);
    } else {
      return this.getRuleContext(i, OverrideSpecifierContext);
    }
  }
  expression() {
    return this.tryGetRuleContext(0, ExpressionContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_stateVariableDeclaration;
  }
  enterRule(listener) {
    if (listener.enterStateVariableDeclaration) {
      listener.enterStateVariableDeclaration(this);
    }
  }
  exitRule(listener) {
    if (listener.exitStateVariableDeclaration) {
      listener.exitStateVariableDeclaration(this);
    }
  }
  accept(visitor) {
    if (visitor.visitStateVariableDeclaration) {
      return visitor.visitStateVariableDeclaration(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var FileLevelConstantContext = class extends import_ParserRuleContext.ParserRuleContext {
  typeName() {
    return this.getRuleContext(0, TypeNameContext);
  }
  ConstantKeyword() {
    return this.getToken(SolidityParser.ConstantKeyword, 0);
  }
  identifier() {
    return this.getRuleContext(0, IdentifierContext);
  }
  expression() {
    return this.getRuleContext(0, ExpressionContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_fileLevelConstant;
  }
  enterRule(listener) {
    if (listener.enterFileLevelConstant) {
      listener.enterFileLevelConstant(this);
    }
  }
  exitRule(listener) {
    if (listener.exitFileLevelConstant) {
      listener.exitFileLevelConstant(this);
    }
  }
  accept(visitor) {
    if (visitor.visitFileLevelConstant) {
      return visitor.visitFileLevelConstant(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var CustomErrorDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier() {
    return this.getRuleContext(0, IdentifierContext);
  }
  parameterList() {
    return this.getRuleContext(0, ParameterListContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_customErrorDefinition;
  }
  enterRule(listener) {
    if (listener.enterCustomErrorDefinition) {
      listener.enterCustomErrorDefinition(this);
    }
  }
  exitRule(listener) {
    if (listener.exitCustomErrorDefinition) {
      listener.exitCustomErrorDefinition(this);
    }
  }
  accept(visitor) {
    if (visitor.visitCustomErrorDefinition) {
      return visitor.visitCustomErrorDefinition(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var TypeDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {
  TypeKeyword() {
    return this.getToken(SolidityParser.TypeKeyword, 0);
  }
  identifier() {
    return this.getRuleContext(0, IdentifierContext);
  }
  elementaryTypeName() {
    return this.getRuleContext(0, ElementaryTypeNameContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_typeDefinition;
  }
  enterRule(listener) {
    if (listener.enterTypeDefinition) {
      listener.enterTypeDefinition(this);
    }
  }
  exitRule(listener) {
    if (listener.exitTypeDefinition) {
      listener.exitTypeDefinition(this);
    }
  }
  accept(visitor) {
    if (visitor.visitTypeDefinition) {
      return visitor.visitTypeDefinition(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var UsingForDeclarationContext = class extends import_ParserRuleContext.ParserRuleContext {
  usingForObject() {
    return this.getRuleContext(0, UsingForObjectContext);
  }
  typeName() {
    return this.tryGetRuleContext(0, TypeNameContext);
  }
  GlobalKeyword() {
    return this.tryGetToken(SolidityParser.GlobalKeyword, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_usingForDeclaration;
  }
  enterRule(listener) {
    if (listener.enterUsingForDeclaration) {
      listener.enterUsingForDeclaration(this);
    }
  }
  exitRule(listener) {
    if (listener.exitUsingForDeclaration) {
      listener.exitUsingForDeclaration(this);
    }
  }
  accept(visitor) {
    if (visitor.visitUsingForDeclaration) {
      return visitor.visitUsingForDeclaration(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var UsingForObjectContext = class extends import_ParserRuleContext.ParserRuleContext {
  userDefinedTypeName(i) {
    if (i === void 0) {
      return this.getRuleContexts(UserDefinedTypeNameContext);
    } else {
      return this.getRuleContext(i, UserDefinedTypeNameContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_usingForObject;
  }
  enterRule(listener) {
    if (listener.enterUsingForObject) {
      listener.enterUsingForObject(this);
    }
  }
  exitRule(listener) {
    if (listener.exitUsingForObject) {
      listener.exitUsingForObject(this);
    }
  }
  accept(visitor) {
    if (visitor.visitUsingForObject) {
      return visitor.visitUsingForObject(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var StructDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier() {
    return this.getRuleContext(0, IdentifierContext);
  }
  variableDeclaration(i) {
    if (i === void 0) {
      return this.getRuleContexts(VariableDeclarationContext);
    } else {
      return this.getRuleContext(i, VariableDeclarationContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_structDefinition;
  }
  enterRule(listener) {
    if (listener.enterStructDefinition) {
      listener.enterStructDefinition(this);
    }
  }
  exitRule(listener) {
    if (listener.exitStructDefinition) {
      listener.exitStructDefinition(this);
    }
  }
  accept(visitor) {
    if (visitor.visitStructDefinition) {
      return visitor.visitStructDefinition(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ModifierDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier() {
    return this.getRuleContext(0, IdentifierContext);
  }
  block() {
    return this.tryGetRuleContext(0, BlockContext);
  }
  parameterList() {
    return this.tryGetRuleContext(0, ParameterListContext);
  }
  VirtualKeyword(i) {
    if (i === void 0) {
      return this.getTokens(SolidityParser.VirtualKeyword);
    } else {
      return this.getToken(SolidityParser.VirtualKeyword, i);
    }
  }
  overrideSpecifier(i) {
    if (i === void 0) {
      return this.getRuleContexts(OverrideSpecifierContext);
    } else {
      return this.getRuleContext(i, OverrideSpecifierContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_modifierDefinition;
  }
  enterRule(listener) {
    if (listener.enterModifierDefinition) {
      listener.enterModifierDefinition(this);
    }
  }
  exitRule(listener) {
    if (listener.exitModifierDefinition) {
      listener.exitModifierDefinition(this);
    }
  }
  accept(visitor) {
    if (visitor.visitModifierDefinition) {
      return visitor.visitModifierDefinition(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ModifierInvocationContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier() {
    return this.getRuleContext(0, IdentifierContext);
  }
  expressionList() {
    return this.tryGetRuleContext(0, ExpressionListContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_modifierInvocation;
  }
  enterRule(listener) {
    if (listener.enterModifierInvocation) {
      listener.enterModifierInvocation(this);
    }
  }
  exitRule(listener) {
    if (listener.exitModifierInvocation) {
      listener.exitModifierInvocation(this);
    }
  }
  accept(visitor) {
    if (visitor.visitModifierInvocation) {
      return visitor.visitModifierInvocation(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var FunctionDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {
  functionDescriptor() {
    return this.getRuleContext(0, FunctionDescriptorContext);
  }
  parameterList() {
    return this.getRuleContext(0, ParameterListContext);
  }
  modifierList() {
    return this.getRuleContext(0, ModifierListContext);
  }
  block() {
    return this.tryGetRuleContext(0, BlockContext);
  }
  returnParameters() {
    return this.tryGetRuleContext(0, ReturnParametersContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_functionDefinition;
  }
  enterRule(listener) {
    if (listener.enterFunctionDefinition) {
      listener.enterFunctionDefinition(this);
    }
  }
  exitRule(listener) {
    if (listener.exitFunctionDefinition) {
      listener.exitFunctionDefinition(this);
    }
  }
  accept(visitor) {
    if (visitor.visitFunctionDefinition) {
      return visitor.visitFunctionDefinition(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var FunctionDescriptorContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier() {
    return this.tryGetRuleContext(0, IdentifierContext);
  }
  ConstructorKeyword() {
    return this.tryGetToken(SolidityParser.ConstructorKeyword, 0);
  }
  FallbackKeyword() {
    return this.tryGetToken(SolidityParser.FallbackKeyword, 0);
  }
  ReceiveKeyword() {
    return this.tryGetToken(SolidityParser.ReceiveKeyword, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_functionDescriptor;
  }
  enterRule(listener) {
    if (listener.enterFunctionDescriptor) {
      listener.enterFunctionDescriptor(this);
    }
  }
  exitRule(listener) {
    if (listener.exitFunctionDescriptor) {
      listener.exitFunctionDescriptor(this);
    }
  }
  accept(visitor) {
    if (visitor.visitFunctionDescriptor) {
      return visitor.visitFunctionDescriptor(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ReturnParametersContext = class extends import_ParserRuleContext.ParserRuleContext {
  parameterList() {
    return this.getRuleContext(0, ParameterListContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_returnParameters;
  }
  enterRule(listener) {
    if (listener.enterReturnParameters) {
      listener.enterReturnParameters(this);
    }
  }
  exitRule(listener) {
    if (listener.exitReturnParameters) {
      listener.exitReturnParameters(this);
    }
  }
  accept(visitor) {
    if (visitor.visitReturnParameters) {
      return visitor.visitReturnParameters(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ModifierListContext = class extends import_ParserRuleContext.ParserRuleContext {
  ExternalKeyword(i) {
    if (i === void 0) {
      return this.getTokens(SolidityParser.ExternalKeyword);
    } else {
      return this.getToken(SolidityParser.ExternalKeyword, i);
    }
  }
  PublicKeyword(i) {
    if (i === void 0) {
      return this.getTokens(SolidityParser.PublicKeyword);
    } else {
      return this.getToken(SolidityParser.PublicKeyword, i);
    }
  }
  InternalKeyword(i) {
    if (i === void 0) {
      return this.getTokens(SolidityParser.InternalKeyword);
    } else {
      return this.getToken(SolidityParser.InternalKeyword, i);
    }
  }
  PrivateKeyword(i) {
    if (i === void 0) {
      return this.getTokens(SolidityParser.PrivateKeyword);
    } else {
      return this.getToken(SolidityParser.PrivateKeyword, i);
    }
  }
  VirtualKeyword(i) {
    if (i === void 0) {
      return this.getTokens(SolidityParser.VirtualKeyword);
    } else {
      return this.getToken(SolidityParser.VirtualKeyword, i);
    }
  }
  stateMutability(i) {
    if (i === void 0) {
      return this.getRuleContexts(StateMutabilityContext);
    } else {
      return this.getRuleContext(i, StateMutabilityContext);
    }
  }
  modifierInvocation(i) {
    if (i === void 0) {
      return this.getRuleContexts(ModifierInvocationContext);
    } else {
      return this.getRuleContext(i, ModifierInvocationContext);
    }
  }
  overrideSpecifier(i) {
    if (i === void 0) {
      return this.getRuleContexts(OverrideSpecifierContext);
    } else {
      return this.getRuleContext(i, OverrideSpecifierContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_modifierList;
  }
  enterRule(listener) {
    if (listener.enterModifierList) {
      listener.enterModifierList(this);
    }
  }
  exitRule(listener) {
    if (listener.exitModifierList) {
      listener.exitModifierList(this);
    }
  }
  accept(visitor) {
    if (visitor.visitModifierList) {
      return visitor.visitModifierList(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var EventDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier() {
    return this.getRuleContext(0, IdentifierContext);
  }
  eventParameterList() {
    return this.getRuleContext(0, EventParameterListContext);
  }
  AnonymousKeyword() {
    return this.tryGetToken(SolidityParser.AnonymousKeyword, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_eventDefinition;
  }
  enterRule(listener) {
    if (listener.enterEventDefinition) {
      listener.enterEventDefinition(this);
    }
  }
  exitRule(listener) {
    if (listener.exitEventDefinition) {
      listener.exitEventDefinition(this);
    }
  }
  accept(visitor) {
    if (visitor.visitEventDefinition) {
      return visitor.visitEventDefinition(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var EnumValueContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier() {
    return this.getRuleContext(0, IdentifierContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_enumValue;
  }
  enterRule(listener) {
    if (listener.enterEnumValue) {
      listener.enterEnumValue(this);
    }
  }
  exitRule(listener) {
    if (listener.exitEnumValue) {
      listener.exitEnumValue(this);
    }
  }
  accept(visitor) {
    if (visitor.visitEnumValue) {
      return visitor.visitEnumValue(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var EnumDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier() {
    return this.getRuleContext(0, IdentifierContext);
  }
  enumValue(i) {
    if (i === void 0) {
      return this.getRuleContexts(EnumValueContext);
    } else {
      return this.getRuleContext(i, EnumValueContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_enumDefinition;
  }
  enterRule(listener) {
    if (listener.enterEnumDefinition) {
      listener.enterEnumDefinition(this);
    }
  }
  exitRule(listener) {
    if (listener.exitEnumDefinition) {
      listener.exitEnumDefinition(this);
    }
  }
  accept(visitor) {
    if (visitor.visitEnumDefinition) {
      return visitor.visitEnumDefinition(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ParameterListContext = class extends import_ParserRuleContext.ParserRuleContext {
  parameter(i) {
    if (i === void 0) {
      return this.getRuleContexts(ParameterContext);
    } else {
      return this.getRuleContext(i, ParameterContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_parameterList;
  }
  enterRule(listener) {
    if (listener.enterParameterList) {
      listener.enterParameterList(this);
    }
  }
  exitRule(listener) {
    if (listener.exitParameterList) {
      listener.exitParameterList(this);
    }
  }
  accept(visitor) {
    if (visitor.visitParameterList) {
      return visitor.visitParameterList(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ParameterContext = class extends import_ParserRuleContext.ParserRuleContext {
  typeName() {
    return this.getRuleContext(0, TypeNameContext);
  }
  storageLocation() {
    return this.tryGetRuleContext(0, StorageLocationContext);
  }
  identifier() {
    return this.tryGetRuleContext(0, IdentifierContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_parameter;
  }
  enterRule(listener) {
    if (listener.enterParameter) {
      listener.enterParameter(this);
    }
  }
  exitRule(listener) {
    if (listener.exitParameter) {
      listener.exitParameter(this);
    }
  }
  accept(visitor) {
    if (visitor.visitParameter) {
      return visitor.visitParameter(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var EventParameterListContext = class extends import_ParserRuleContext.ParserRuleContext {
  eventParameter(i) {
    if (i === void 0) {
      return this.getRuleContexts(EventParameterContext);
    } else {
      return this.getRuleContext(i, EventParameterContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_eventParameterList;
  }
  enterRule(listener) {
    if (listener.enterEventParameterList) {
      listener.enterEventParameterList(this);
    }
  }
  exitRule(listener) {
    if (listener.exitEventParameterList) {
      listener.exitEventParameterList(this);
    }
  }
  accept(visitor) {
    if (visitor.visitEventParameterList) {
      return visitor.visitEventParameterList(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var EventParameterContext = class extends import_ParserRuleContext.ParserRuleContext {
  typeName() {
    return this.getRuleContext(0, TypeNameContext);
  }
  IndexedKeyword() {
    return this.tryGetToken(SolidityParser.IndexedKeyword, 0);
  }
  identifier() {
    return this.tryGetRuleContext(0, IdentifierContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_eventParameter;
  }
  enterRule(listener) {
    if (listener.enterEventParameter) {
      listener.enterEventParameter(this);
    }
  }
  exitRule(listener) {
    if (listener.exitEventParameter) {
      listener.exitEventParameter(this);
    }
  }
  accept(visitor) {
    if (visitor.visitEventParameter) {
      return visitor.visitEventParameter(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var FunctionTypeParameterListContext = class extends import_ParserRuleContext.ParserRuleContext {
  functionTypeParameter(i) {
    if (i === void 0) {
      return this.getRuleContexts(FunctionTypeParameterContext);
    } else {
      return this.getRuleContext(i, FunctionTypeParameterContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_functionTypeParameterList;
  }
  enterRule(listener) {
    if (listener.enterFunctionTypeParameterList) {
      listener.enterFunctionTypeParameterList(this);
    }
  }
  exitRule(listener) {
    if (listener.exitFunctionTypeParameterList) {
      listener.exitFunctionTypeParameterList(this);
    }
  }
  accept(visitor) {
    if (visitor.visitFunctionTypeParameterList) {
      return visitor.visitFunctionTypeParameterList(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var FunctionTypeParameterContext = class extends import_ParserRuleContext.ParserRuleContext {
  typeName() {
    return this.getRuleContext(0, TypeNameContext);
  }
  storageLocation() {
    return this.tryGetRuleContext(0, StorageLocationContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_functionTypeParameter;
  }
  enterRule(listener) {
    if (listener.enterFunctionTypeParameter) {
      listener.enterFunctionTypeParameter(this);
    }
  }
  exitRule(listener) {
    if (listener.exitFunctionTypeParameter) {
      listener.exitFunctionTypeParameter(this);
    }
  }
  accept(visitor) {
    if (visitor.visitFunctionTypeParameter) {
      return visitor.visitFunctionTypeParameter(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var VariableDeclarationContext = class extends import_ParserRuleContext.ParserRuleContext {
  typeName() {
    return this.getRuleContext(0, TypeNameContext);
  }
  identifier() {
    return this.getRuleContext(0, IdentifierContext);
  }
  storageLocation() {
    return this.tryGetRuleContext(0, StorageLocationContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_variableDeclaration;
  }
  enterRule(listener) {
    if (listener.enterVariableDeclaration) {
      listener.enterVariableDeclaration(this);
    }
  }
  exitRule(listener) {
    if (listener.exitVariableDeclaration) {
      listener.exitVariableDeclaration(this);
    }
  }
  accept(visitor) {
    if (visitor.visitVariableDeclaration) {
      return visitor.visitVariableDeclaration(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var TypeNameContext = class extends import_ParserRuleContext.ParserRuleContext {
  elementaryTypeName() {
    return this.tryGetRuleContext(0, ElementaryTypeNameContext);
  }
  userDefinedTypeName() {
    return this.tryGetRuleContext(0, UserDefinedTypeNameContext);
  }
  mapping() {
    return this.tryGetRuleContext(0, MappingContext);
  }
  typeName() {
    return this.tryGetRuleContext(0, TypeNameContext);
  }
  expression() {
    return this.tryGetRuleContext(0, ExpressionContext);
  }
  functionTypeName() {
    return this.tryGetRuleContext(0, FunctionTypeNameContext);
  }
  PayableKeyword() {
    return this.tryGetToken(SolidityParser.PayableKeyword, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_typeName;
  }
  enterRule(listener) {
    if (listener.enterTypeName) {
      listener.enterTypeName(this);
    }
  }
  exitRule(listener) {
    if (listener.exitTypeName) {
      listener.exitTypeName(this);
    }
  }
  accept(visitor) {
    if (visitor.visitTypeName) {
      return visitor.visitTypeName(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var UserDefinedTypeNameContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier(i) {
    if (i === void 0) {
      return this.getRuleContexts(IdentifierContext);
    } else {
      return this.getRuleContext(i, IdentifierContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_userDefinedTypeName;
  }
  enterRule(listener) {
    if (listener.enterUserDefinedTypeName) {
      listener.enterUserDefinedTypeName(this);
    }
  }
  exitRule(listener) {
    if (listener.exitUserDefinedTypeName) {
      listener.exitUserDefinedTypeName(this);
    }
  }
  accept(visitor) {
    if (visitor.visitUserDefinedTypeName) {
      return visitor.visitUserDefinedTypeName(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var MappingKeyContext = class extends import_ParserRuleContext.ParserRuleContext {
  elementaryTypeName() {
    return this.tryGetRuleContext(0, ElementaryTypeNameContext);
  }
  userDefinedTypeName() {
    return this.tryGetRuleContext(0, UserDefinedTypeNameContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_mappingKey;
  }
  enterRule(listener) {
    if (listener.enterMappingKey) {
      listener.enterMappingKey(this);
    }
  }
  exitRule(listener) {
    if (listener.exitMappingKey) {
      listener.exitMappingKey(this);
    }
  }
  accept(visitor) {
    if (visitor.visitMappingKey) {
      return visitor.visitMappingKey(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var MappingContext = class extends import_ParserRuleContext.ParserRuleContext {
  mappingKey() {
    return this.getRuleContext(0, MappingKeyContext);
  }
  typeName() {
    return this.getRuleContext(0, TypeNameContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_mapping;
  }
  enterRule(listener) {
    if (listener.enterMapping) {
      listener.enterMapping(this);
    }
  }
  exitRule(listener) {
    if (listener.exitMapping) {
      listener.exitMapping(this);
    }
  }
  accept(visitor) {
    if (visitor.visitMapping) {
      return visitor.visitMapping(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var FunctionTypeNameContext = class extends import_ParserRuleContext.ParserRuleContext {
  functionTypeParameterList(i) {
    if (i === void 0) {
      return this.getRuleContexts(FunctionTypeParameterListContext);
    } else {
      return this.getRuleContext(i, FunctionTypeParameterListContext);
    }
  }
  InternalKeyword(i) {
    if (i === void 0) {
      return this.getTokens(SolidityParser.InternalKeyword);
    } else {
      return this.getToken(SolidityParser.InternalKeyword, i);
    }
  }
  ExternalKeyword(i) {
    if (i === void 0) {
      return this.getTokens(SolidityParser.ExternalKeyword);
    } else {
      return this.getToken(SolidityParser.ExternalKeyword, i);
    }
  }
  stateMutability(i) {
    if (i === void 0) {
      return this.getRuleContexts(StateMutabilityContext);
    } else {
      return this.getRuleContext(i, StateMutabilityContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_functionTypeName;
  }
  enterRule(listener) {
    if (listener.enterFunctionTypeName) {
      listener.enterFunctionTypeName(this);
    }
  }
  exitRule(listener) {
    if (listener.exitFunctionTypeName) {
      listener.exitFunctionTypeName(this);
    }
  }
  accept(visitor) {
    if (visitor.visitFunctionTypeName) {
      return visitor.visitFunctionTypeName(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var StorageLocationContext = class extends import_ParserRuleContext.ParserRuleContext {
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_storageLocation;
  }
  enterRule(listener) {
    if (listener.enterStorageLocation) {
      listener.enterStorageLocation(this);
    }
  }
  exitRule(listener) {
    if (listener.exitStorageLocation) {
      listener.exitStorageLocation(this);
    }
  }
  accept(visitor) {
    if (visitor.visitStorageLocation) {
      return visitor.visitStorageLocation(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var StateMutabilityContext = class extends import_ParserRuleContext.ParserRuleContext {
  PureKeyword() {
    return this.tryGetToken(SolidityParser.PureKeyword, 0);
  }
  ConstantKeyword() {
    return this.tryGetToken(SolidityParser.ConstantKeyword, 0);
  }
  ViewKeyword() {
    return this.tryGetToken(SolidityParser.ViewKeyword, 0);
  }
  PayableKeyword() {
    return this.tryGetToken(SolidityParser.PayableKeyword, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_stateMutability;
  }
  enterRule(listener) {
    if (listener.enterStateMutability) {
      listener.enterStateMutability(this);
    }
  }
  exitRule(listener) {
    if (listener.exitStateMutability) {
      listener.exitStateMutability(this);
    }
  }
  accept(visitor) {
    if (visitor.visitStateMutability) {
      return visitor.visitStateMutability(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var BlockContext = class extends import_ParserRuleContext.ParserRuleContext {
  statement(i) {
    if (i === void 0) {
      return this.getRuleContexts(StatementContext);
    } else {
      return this.getRuleContext(i, StatementContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_block;
  }
  enterRule(listener) {
    if (listener.enterBlock) {
      listener.enterBlock(this);
    }
  }
  exitRule(listener) {
    if (listener.exitBlock) {
      listener.exitBlock(this);
    }
  }
  accept(visitor) {
    if (visitor.visitBlock) {
      return visitor.visitBlock(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var StatementContext = class extends import_ParserRuleContext.ParserRuleContext {
  ifStatement() {
    return this.tryGetRuleContext(0, IfStatementContext);
  }
  tryStatement() {
    return this.tryGetRuleContext(0, TryStatementContext);
  }
  whileStatement() {
    return this.tryGetRuleContext(0, WhileStatementContext);
  }
  forStatement() {
    return this.tryGetRuleContext(0, ForStatementContext);
  }
  block() {
    return this.tryGetRuleContext(0, BlockContext);
  }
  inlineAssemblyStatement() {
    return this.tryGetRuleContext(0, InlineAssemblyStatementContext);
  }
  doWhileStatement() {
    return this.tryGetRuleContext(0, DoWhileStatementContext);
  }
  continueStatement() {
    return this.tryGetRuleContext(0, ContinueStatementContext);
  }
  breakStatement() {
    return this.tryGetRuleContext(0, BreakStatementContext);
  }
  returnStatement() {
    return this.tryGetRuleContext(0, ReturnStatementContext);
  }
  throwStatement() {
    return this.tryGetRuleContext(0, ThrowStatementContext);
  }
  emitStatement() {
    return this.tryGetRuleContext(0, EmitStatementContext);
  }
  simpleStatement() {
    return this.tryGetRuleContext(0, SimpleStatementContext);
  }
  uncheckedStatement() {
    return this.tryGetRuleContext(0, UncheckedStatementContext);
  }
  revertStatement() {
    return this.tryGetRuleContext(0, RevertStatementContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_statement;
  }
  enterRule(listener) {
    if (listener.enterStatement) {
      listener.enterStatement(this);
    }
  }
  exitRule(listener) {
    if (listener.exitStatement) {
      listener.exitStatement(this);
    }
  }
  accept(visitor) {
    if (visitor.visitStatement) {
      return visitor.visitStatement(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ExpressionStatementContext = class extends import_ParserRuleContext.ParserRuleContext {
  expression() {
    return this.getRuleContext(0, ExpressionContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_expressionStatement;
  }
  enterRule(listener) {
    if (listener.enterExpressionStatement) {
      listener.enterExpressionStatement(this);
    }
  }
  exitRule(listener) {
    if (listener.exitExpressionStatement) {
      listener.exitExpressionStatement(this);
    }
  }
  accept(visitor) {
    if (visitor.visitExpressionStatement) {
      return visitor.visitExpressionStatement(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var IfStatementContext = class extends import_ParserRuleContext.ParserRuleContext {
  expression() {
    return this.getRuleContext(0, ExpressionContext);
  }
  statement(i) {
    if (i === void 0) {
      return this.getRuleContexts(StatementContext);
    } else {
      return this.getRuleContext(i, StatementContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_ifStatement;
  }
  enterRule(listener) {
    if (listener.enterIfStatement) {
      listener.enterIfStatement(this);
    }
  }
  exitRule(listener) {
    if (listener.exitIfStatement) {
      listener.exitIfStatement(this);
    }
  }
  accept(visitor) {
    if (visitor.visitIfStatement) {
      return visitor.visitIfStatement(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var TryStatementContext = class extends import_ParserRuleContext.ParserRuleContext {
  expression() {
    return this.getRuleContext(0, ExpressionContext);
  }
  block() {
    return this.getRuleContext(0, BlockContext);
  }
  returnParameters() {
    return this.tryGetRuleContext(0, ReturnParametersContext);
  }
  catchClause(i) {
    if (i === void 0) {
      return this.getRuleContexts(CatchClauseContext);
    } else {
      return this.getRuleContext(i, CatchClauseContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_tryStatement;
  }
  enterRule(listener) {
    if (listener.enterTryStatement) {
      listener.enterTryStatement(this);
    }
  }
  exitRule(listener) {
    if (listener.exitTryStatement) {
      listener.exitTryStatement(this);
    }
  }
  accept(visitor) {
    if (visitor.visitTryStatement) {
      return visitor.visitTryStatement(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var CatchClauseContext = class extends import_ParserRuleContext.ParserRuleContext {
  block() {
    return this.getRuleContext(0, BlockContext);
  }
  parameterList() {
    return this.tryGetRuleContext(0, ParameterListContext);
  }
  identifier() {
    return this.tryGetRuleContext(0, IdentifierContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_catchClause;
  }
  enterRule(listener) {
    if (listener.enterCatchClause) {
      listener.enterCatchClause(this);
    }
  }
  exitRule(listener) {
    if (listener.exitCatchClause) {
      listener.exitCatchClause(this);
    }
  }
  accept(visitor) {
    if (visitor.visitCatchClause) {
      return visitor.visitCatchClause(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var WhileStatementContext = class extends import_ParserRuleContext.ParserRuleContext {
  expression() {
    return this.getRuleContext(0, ExpressionContext);
  }
  statement() {
    return this.getRuleContext(0, StatementContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_whileStatement;
  }
  enterRule(listener) {
    if (listener.enterWhileStatement) {
      listener.enterWhileStatement(this);
    }
  }
  exitRule(listener) {
    if (listener.exitWhileStatement) {
      listener.exitWhileStatement(this);
    }
  }
  accept(visitor) {
    if (visitor.visitWhileStatement) {
      return visitor.visitWhileStatement(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var SimpleStatementContext = class extends import_ParserRuleContext.ParserRuleContext {
  variableDeclarationStatement() {
    return this.tryGetRuleContext(0, VariableDeclarationStatementContext);
  }
  expressionStatement() {
    return this.tryGetRuleContext(0, ExpressionStatementContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_simpleStatement;
  }
  enterRule(listener) {
    if (listener.enterSimpleStatement) {
      listener.enterSimpleStatement(this);
    }
  }
  exitRule(listener) {
    if (listener.exitSimpleStatement) {
      listener.exitSimpleStatement(this);
    }
  }
  accept(visitor) {
    if (visitor.visitSimpleStatement) {
      return visitor.visitSimpleStatement(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var UncheckedStatementContext = class extends import_ParserRuleContext.ParserRuleContext {
  block() {
    return this.getRuleContext(0, BlockContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_uncheckedStatement;
  }
  enterRule(listener) {
    if (listener.enterUncheckedStatement) {
      listener.enterUncheckedStatement(this);
    }
  }
  exitRule(listener) {
    if (listener.exitUncheckedStatement) {
      listener.exitUncheckedStatement(this);
    }
  }
  accept(visitor) {
    if (visitor.visitUncheckedStatement) {
      return visitor.visitUncheckedStatement(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ForStatementContext = class extends import_ParserRuleContext.ParserRuleContext {
  statement() {
    return this.getRuleContext(0, StatementContext);
  }
  simpleStatement() {
    return this.tryGetRuleContext(0, SimpleStatementContext);
  }
  expressionStatement() {
    return this.tryGetRuleContext(0, ExpressionStatementContext);
  }
  expression() {
    return this.tryGetRuleContext(0, ExpressionContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_forStatement;
  }
  enterRule(listener) {
    if (listener.enterForStatement) {
      listener.enterForStatement(this);
    }
  }
  exitRule(listener) {
    if (listener.exitForStatement) {
      listener.exitForStatement(this);
    }
  }
  accept(visitor) {
    if (visitor.visitForStatement) {
      return visitor.visitForStatement(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var InlineAssemblyStatementContext = class extends import_ParserRuleContext.ParserRuleContext {
  assemblyBlock() {
    return this.getRuleContext(0, AssemblyBlockContext);
  }
  StringLiteralFragment() {
    return this.tryGetToken(SolidityParser.StringLiteralFragment, 0);
  }
  inlineAssemblyStatementFlag() {
    return this.tryGetRuleContext(0, InlineAssemblyStatementFlagContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_inlineAssemblyStatement;
  }
  enterRule(listener) {
    if (listener.enterInlineAssemblyStatement) {
      listener.enterInlineAssemblyStatement(this);
    }
  }
  exitRule(listener) {
    if (listener.exitInlineAssemblyStatement) {
      listener.exitInlineAssemblyStatement(this);
    }
  }
  accept(visitor) {
    if (visitor.visitInlineAssemblyStatement) {
      return visitor.visitInlineAssemblyStatement(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var InlineAssemblyStatementFlagContext = class extends import_ParserRuleContext.ParserRuleContext {
  stringLiteral() {
    return this.getRuleContext(0, StringLiteralContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_inlineAssemblyStatementFlag;
  }
  enterRule(listener) {
    if (listener.enterInlineAssemblyStatementFlag) {
      listener.enterInlineAssemblyStatementFlag(this);
    }
  }
  exitRule(listener) {
    if (listener.exitInlineAssemblyStatementFlag) {
      listener.exitInlineAssemblyStatementFlag(this);
    }
  }
  accept(visitor) {
    if (visitor.visitInlineAssemblyStatementFlag) {
      return visitor.visitInlineAssemblyStatementFlag(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var DoWhileStatementContext = class extends import_ParserRuleContext.ParserRuleContext {
  statement() {
    return this.getRuleContext(0, StatementContext);
  }
  expression() {
    return this.getRuleContext(0, ExpressionContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_doWhileStatement;
  }
  enterRule(listener) {
    if (listener.enterDoWhileStatement) {
      listener.enterDoWhileStatement(this);
    }
  }
  exitRule(listener) {
    if (listener.exitDoWhileStatement) {
      listener.exitDoWhileStatement(this);
    }
  }
  accept(visitor) {
    if (visitor.visitDoWhileStatement) {
      return visitor.visitDoWhileStatement(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ContinueStatementContext = class extends import_ParserRuleContext.ParserRuleContext {
  ContinueKeyword() {
    return this.getToken(SolidityParser.ContinueKeyword, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_continueStatement;
  }
  enterRule(listener) {
    if (listener.enterContinueStatement) {
      listener.enterContinueStatement(this);
    }
  }
  exitRule(listener) {
    if (listener.exitContinueStatement) {
      listener.exitContinueStatement(this);
    }
  }
  accept(visitor) {
    if (visitor.visitContinueStatement) {
      return visitor.visitContinueStatement(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var BreakStatementContext = class extends import_ParserRuleContext.ParserRuleContext {
  BreakKeyword() {
    return this.getToken(SolidityParser.BreakKeyword, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_breakStatement;
  }
  enterRule(listener) {
    if (listener.enterBreakStatement) {
      listener.enterBreakStatement(this);
    }
  }
  exitRule(listener) {
    if (listener.exitBreakStatement) {
      listener.exitBreakStatement(this);
    }
  }
  accept(visitor) {
    if (visitor.visitBreakStatement) {
      return visitor.visitBreakStatement(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ReturnStatementContext = class extends import_ParserRuleContext.ParserRuleContext {
  expression() {
    return this.tryGetRuleContext(0, ExpressionContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_returnStatement;
  }
  enterRule(listener) {
    if (listener.enterReturnStatement) {
      listener.enterReturnStatement(this);
    }
  }
  exitRule(listener) {
    if (listener.exitReturnStatement) {
      listener.exitReturnStatement(this);
    }
  }
  accept(visitor) {
    if (visitor.visitReturnStatement) {
      return visitor.visitReturnStatement(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ThrowStatementContext = class extends import_ParserRuleContext.ParserRuleContext {
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_throwStatement;
  }
  enterRule(listener) {
    if (listener.enterThrowStatement) {
      listener.enterThrowStatement(this);
    }
  }
  exitRule(listener) {
    if (listener.exitThrowStatement) {
      listener.exitThrowStatement(this);
    }
  }
  accept(visitor) {
    if (visitor.visitThrowStatement) {
      return visitor.visitThrowStatement(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var EmitStatementContext = class extends import_ParserRuleContext.ParserRuleContext {
  functionCall() {
    return this.getRuleContext(0, FunctionCallContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_emitStatement;
  }
  enterRule(listener) {
    if (listener.enterEmitStatement) {
      listener.enterEmitStatement(this);
    }
  }
  exitRule(listener) {
    if (listener.exitEmitStatement) {
      listener.exitEmitStatement(this);
    }
  }
  accept(visitor) {
    if (visitor.visitEmitStatement) {
      return visitor.visitEmitStatement(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var RevertStatementContext = class extends import_ParserRuleContext.ParserRuleContext {
  functionCall() {
    return this.getRuleContext(0, FunctionCallContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_revertStatement;
  }
  enterRule(listener) {
    if (listener.enterRevertStatement) {
      listener.enterRevertStatement(this);
    }
  }
  exitRule(listener) {
    if (listener.exitRevertStatement) {
      listener.exitRevertStatement(this);
    }
  }
  accept(visitor) {
    if (visitor.visitRevertStatement) {
      return visitor.visitRevertStatement(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var VariableDeclarationStatementContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifierList() {
    return this.tryGetRuleContext(0, IdentifierListContext);
  }
  variableDeclaration() {
    return this.tryGetRuleContext(0, VariableDeclarationContext);
  }
  variableDeclarationList() {
    return this.tryGetRuleContext(0, VariableDeclarationListContext);
  }
  expression() {
    return this.tryGetRuleContext(0, ExpressionContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_variableDeclarationStatement;
  }
  enterRule(listener) {
    if (listener.enterVariableDeclarationStatement) {
      listener.enterVariableDeclarationStatement(this);
    }
  }
  exitRule(listener) {
    if (listener.exitVariableDeclarationStatement) {
      listener.exitVariableDeclarationStatement(this);
    }
  }
  accept(visitor) {
    if (visitor.visitVariableDeclarationStatement) {
      return visitor.visitVariableDeclarationStatement(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var VariableDeclarationListContext = class extends import_ParserRuleContext.ParserRuleContext {
  variableDeclaration(i) {
    if (i === void 0) {
      return this.getRuleContexts(VariableDeclarationContext);
    } else {
      return this.getRuleContext(i, VariableDeclarationContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_variableDeclarationList;
  }
  enterRule(listener) {
    if (listener.enterVariableDeclarationList) {
      listener.enterVariableDeclarationList(this);
    }
  }
  exitRule(listener) {
    if (listener.exitVariableDeclarationList) {
      listener.exitVariableDeclarationList(this);
    }
  }
  accept(visitor) {
    if (visitor.visitVariableDeclarationList) {
      return visitor.visitVariableDeclarationList(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var IdentifierListContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier(i) {
    if (i === void 0) {
      return this.getRuleContexts(IdentifierContext);
    } else {
      return this.getRuleContext(i, IdentifierContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_identifierList;
  }
  enterRule(listener) {
    if (listener.enterIdentifierList) {
      listener.enterIdentifierList(this);
    }
  }
  exitRule(listener) {
    if (listener.exitIdentifierList) {
      listener.exitIdentifierList(this);
    }
  }
  accept(visitor) {
    if (visitor.visitIdentifierList) {
      return visitor.visitIdentifierList(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ElementaryTypeNameContext = class extends import_ParserRuleContext.ParserRuleContext {
  Int() {
    return this.tryGetToken(SolidityParser.Int, 0);
  }
  Uint() {
    return this.tryGetToken(SolidityParser.Uint, 0);
  }
  Byte() {
    return this.tryGetToken(SolidityParser.Byte, 0);
  }
  Fixed() {
    return this.tryGetToken(SolidityParser.Fixed, 0);
  }
  Ufixed() {
    return this.tryGetToken(SolidityParser.Ufixed, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_elementaryTypeName;
  }
  enterRule(listener) {
    if (listener.enterElementaryTypeName) {
      listener.enterElementaryTypeName(this);
    }
  }
  exitRule(listener) {
    if (listener.exitElementaryTypeName) {
      listener.exitElementaryTypeName(this);
    }
  }
  accept(visitor) {
    if (visitor.visitElementaryTypeName) {
      return visitor.visitElementaryTypeName(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ExpressionContext = class extends import_ParserRuleContext.ParserRuleContext {
  expression(i) {
    if (i === void 0) {
      return this.getRuleContexts(ExpressionContext);
    } else {
      return this.getRuleContext(i, ExpressionContext);
    }
  }
  typeName() {
    return this.tryGetRuleContext(0, TypeNameContext);
  }
  identifier() {
    return this.tryGetRuleContext(0, IdentifierContext);
  }
  nameValueList() {
    return this.tryGetRuleContext(0, NameValueListContext);
  }
  functionCallArguments() {
    return this.tryGetRuleContext(0, FunctionCallArgumentsContext);
  }
  primaryExpression() {
    return this.tryGetRuleContext(0, PrimaryExpressionContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_expression;
  }
  enterRule(listener) {
    if (listener.enterExpression) {
      listener.enterExpression(this);
    }
  }
  exitRule(listener) {
    if (listener.exitExpression) {
      listener.exitExpression(this);
    }
  }
  accept(visitor) {
    if (visitor.visitExpression) {
      return visitor.visitExpression(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var PrimaryExpressionContext = class extends import_ParserRuleContext.ParserRuleContext {
  BooleanLiteral() {
    return this.tryGetToken(SolidityParser.BooleanLiteral, 0);
  }
  numberLiteral() {
    return this.tryGetRuleContext(0, NumberLiteralContext);
  }
  hexLiteral() {
    return this.tryGetRuleContext(0, HexLiteralContext);
  }
  stringLiteral() {
    return this.tryGetRuleContext(0, StringLiteralContext);
  }
  identifier() {
    return this.tryGetRuleContext(0, IdentifierContext);
  }
  TypeKeyword() {
    return this.tryGetToken(SolidityParser.TypeKeyword, 0);
  }
  PayableKeyword() {
    return this.tryGetToken(SolidityParser.PayableKeyword, 0);
  }
  tupleExpression() {
    return this.tryGetRuleContext(0, TupleExpressionContext);
  }
  typeName() {
    return this.tryGetRuleContext(0, TypeNameContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_primaryExpression;
  }
  enterRule(listener) {
    if (listener.enterPrimaryExpression) {
      listener.enterPrimaryExpression(this);
    }
  }
  exitRule(listener) {
    if (listener.exitPrimaryExpression) {
      listener.exitPrimaryExpression(this);
    }
  }
  accept(visitor) {
    if (visitor.visitPrimaryExpression) {
      return visitor.visitPrimaryExpression(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var ExpressionListContext = class extends import_ParserRuleContext.ParserRuleContext {
  expression(i) {
    if (i === void 0) {
      return this.getRuleContexts(ExpressionContext);
    } else {
      return this.getRuleContext(i, ExpressionContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_expressionList;
  }
  enterRule(listener) {
    if (listener.enterExpressionList) {
      listener.enterExpressionList(this);
    }
  }
  exitRule(listener) {
    if (listener.exitExpressionList) {
      listener.exitExpressionList(this);
    }
  }
  accept(visitor) {
    if (visitor.visitExpressionList) {
      return visitor.visitExpressionList(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var NameValueListContext = class extends import_ParserRuleContext.ParserRuleContext {
  nameValue(i) {
    if (i === void 0) {
      return this.getRuleContexts(NameValueContext);
    } else {
      return this.getRuleContext(i, NameValueContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_nameValueList;
  }
  enterRule(listener) {
    if (listener.enterNameValueList) {
      listener.enterNameValueList(this);
    }
  }
  exitRule(listener) {
    if (listener.exitNameValueList) {
      listener.exitNameValueList(this);
    }
  }
  accept(visitor) {
    if (visitor.visitNameValueList) {
      return visitor.visitNameValueList(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var NameValueContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier() {
    return this.getRuleContext(0, IdentifierContext);
  }
  expression() {
    return this.getRuleContext(0, ExpressionContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_nameValue;
  }
  enterRule(listener) {
    if (listener.enterNameValue) {
      listener.enterNameValue(this);
    }
  }
  exitRule(listener) {
    if (listener.exitNameValue) {
      listener.exitNameValue(this);
    }
  }
  accept(visitor) {
    if (visitor.visitNameValue) {
      return visitor.visitNameValue(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var FunctionCallArgumentsContext = class extends import_ParserRuleContext.ParserRuleContext {
  nameValueList() {
    return this.tryGetRuleContext(0, NameValueListContext);
  }
  expressionList() {
    return this.tryGetRuleContext(0, ExpressionListContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_functionCallArguments;
  }
  enterRule(listener) {
    if (listener.enterFunctionCallArguments) {
      listener.enterFunctionCallArguments(this);
    }
  }
  exitRule(listener) {
    if (listener.exitFunctionCallArguments) {
      listener.exitFunctionCallArguments(this);
    }
  }
  accept(visitor) {
    if (visitor.visitFunctionCallArguments) {
      return visitor.visitFunctionCallArguments(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var FunctionCallContext = class extends import_ParserRuleContext.ParserRuleContext {
  expression() {
    return this.getRuleContext(0, ExpressionContext);
  }
  functionCallArguments() {
    return this.getRuleContext(0, FunctionCallArgumentsContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_functionCall;
  }
  enterRule(listener) {
    if (listener.enterFunctionCall) {
      listener.enterFunctionCall(this);
    }
  }
  exitRule(listener) {
    if (listener.exitFunctionCall) {
      listener.exitFunctionCall(this);
    }
  }
  accept(visitor) {
    if (visitor.visitFunctionCall) {
      return visitor.visitFunctionCall(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var AssemblyBlockContext = class extends import_ParserRuleContext.ParserRuleContext {
  assemblyItem(i) {
    if (i === void 0) {
      return this.getRuleContexts(AssemblyItemContext);
    } else {
      return this.getRuleContext(i, AssemblyItemContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_assemblyBlock;
  }
  enterRule(listener) {
    if (listener.enterAssemblyBlock) {
      listener.enterAssemblyBlock(this);
    }
  }
  exitRule(listener) {
    if (listener.exitAssemblyBlock) {
      listener.exitAssemblyBlock(this);
    }
  }
  accept(visitor) {
    if (visitor.visitAssemblyBlock) {
      return visitor.visitAssemblyBlock(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var AssemblyItemContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier() {
    return this.tryGetRuleContext(0, IdentifierContext);
  }
  assemblyBlock() {
    return this.tryGetRuleContext(0, AssemblyBlockContext);
  }
  assemblyExpression() {
    return this.tryGetRuleContext(0, AssemblyExpressionContext);
  }
  assemblyLocalDefinition() {
    return this.tryGetRuleContext(0, AssemblyLocalDefinitionContext);
  }
  assemblyAssignment() {
    return this.tryGetRuleContext(0, AssemblyAssignmentContext);
  }
  assemblyStackAssignment() {
    return this.tryGetRuleContext(0, AssemblyStackAssignmentContext);
  }
  labelDefinition() {
    return this.tryGetRuleContext(0, LabelDefinitionContext);
  }
  assemblySwitch() {
    return this.tryGetRuleContext(0, AssemblySwitchContext);
  }
  assemblyFunctionDefinition() {
    return this.tryGetRuleContext(0, AssemblyFunctionDefinitionContext);
  }
  assemblyFor() {
    return this.tryGetRuleContext(0, AssemblyForContext);
  }
  assemblyIf() {
    return this.tryGetRuleContext(0, AssemblyIfContext);
  }
  BreakKeyword() {
    return this.tryGetToken(SolidityParser.BreakKeyword, 0);
  }
  ContinueKeyword() {
    return this.tryGetToken(SolidityParser.ContinueKeyword, 0);
  }
  LeaveKeyword() {
    return this.tryGetToken(SolidityParser.LeaveKeyword, 0);
  }
  subAssembly() {
    return this.tryGetRuleContext(0, SubAssemblyContext);
  }
  numberLiteral() {
    return this.tryGetRuleContext(0, NumberLiteralContext);
  }
  stringLiteral() {
    return this.tryGetRuleContext(0, StringLiteralContext);
  }
  hexLiteral() {
    return this.tryGetRuleContext(0, HexLiteralContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_assemblyItem;
  }
  enterRule(listener) {
    if (listener.enterAssemblyItem) {
      listener.enterAssemblyItem(this);
    }
  }
  exitRule(listener) {
    if (listener.exitAssemblyItem) {
      listener.exitAssemblyItem(this);
    }
  }
  accept(visitor) {
    if (visitor.visitAssemblyItem) {
      return visitor.visitAssemblyItem(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var AssemblyExpressionContext = class extends import_ParserRuleContext.ParserRuleContext {
  assemblyCall() {
    return this.tryGetRuleContext(0, AssemblyCallContext);
  }
  assemblyLiteral() {
    return this.tryGetRuleContext(0, AssemblyLiteralContext);
  }
  assemblyMember() {
    return this.tryGetRuleContext(0, AssemblyMemberContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_assemblyExpression;
  }
  enterRule(listener) {
    if (listener.enterAssemblyExpression) {
      listener.enterAssemblyExpression(this);
    }
  }
  exitRule(listener) {
    if (listener.exitAssemblyExpression) {
      listener.exitAssemblyExpression(this);
    }
  }
  accept(visitor) {
    if (visitor.visitAssemblyExpression) {
      return visitor.visitAssemblyExpression(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var AssemblyMemberContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier(i) {
    if (i === void 0) {
      return this.getRuleContexts(IdentifierContext);
    } else {
      return this.getRuleContext(i, IdentifierContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_assemblyMember;
  }
  enterRule(listener) {
    if (listener.enterAssemblyMember) {
      listener.enterAssemblyMember(this);
    }
  }
  exitRule(listener) {
    if (listener.exitAssemblyMember) {
      listener.exitAssemblyMember(this);
    }
  }
  accept(visitor) {
    if (visitor.visitAssemblyMember) {
      return visitor.visitAssemblyMember(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var AssemblyCallContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier() {
    return this.tryGetRuleContext(0, IdentifierContext);
  }
  assemblyExpression(i) {
    if (i === void 0) {
      return this.getRuleContexts(AssemblyExpressionContext);
    } else {
      return this.getRuleContext(i, AssemblyExpressionContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_assemblyCall;
  }
  enterRule(listener) {
    if (listener.enterAssemblyCall) {
      listener.enterAssemblyCall(this);
    }
  }
  exitRule(listener) {
    if (listener.exitAssemblyCall) {
      listener.exitAssemblyCall(this);
    }
  }
  accept(visitor) {
    if (visitor.visitAssemblyCall) {
      return visitor.visitAssemblyCall(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var AssemblyLocalDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {
  assemblyIdentifierOrList() {
    return this.getRuleContext(0, AssemblyIdentifierOrListContext);
  }
  assemblyExpression() {
    return this.tryGetRuleContext(0, AssemblyExpressionContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_assemblyLocalDefinition;
  }
  enterRule(listener) {
    if (listener.enterAssemblyLocalDefinition) {
      listener.enterAssemblyLocalDefinition(this);
    }
  }
  exitRule(listener) {
    if (listener.exitAssemblyLocalDefinition) {
      listener.exitAssemblyLocalDefinition(this);
    }
  }
  accept(visitor) {
    if (visitor.visitAssemblyLocalDefinition) {
      return visitor.visitAssemblyLocalDefinition(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var AssemblyAssignmentContext = class extends import_ParserRuleContext.ParserRuleContext {
  assemblyIdentifierOrList() {
    return this.getRuleContext(0, AssemblyIdentifierOrListContext);
  }
  assemblyExpression() {
    return this.getRuleContext(0, AssemblyExpressionContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_assemblyAssignment;
  }
  enterRule(listener) {
    if (listener.enterAssemblyAssignment) {
      listener.enterAssemblyAssignment(this);
    }
  }
  exitRule(listener) {
    if (listener.exitAssemblyAssignment) {
      listener.exitAssemblyAssignment(this);
    }
  }
  accept(visitor) {
    if (visitor.visitAssemblyAssignment) {
      return visitor.visitAssemblyAssignment(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var AssemblyIdentifierOrListContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier() {
    return this.tryGetRuleContext(0, IdentifierContext);
  }
  assemblyMember() {
    return this.tryGetRuleContext(0, AssemblyMemberContext);
  }
  assemblyIdentifierList() {
    return this.tryGetRuleContext(0, AssemblyIdentifierListContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_assemblyIdentifierOrList;
  }
  enterRule(listener) {
    if (listener.enterAssemblyIdentifierOrList) {
      listener.enterAssemblyIdentifierOrList(this);
    }
  }
  exitRule(listener) {
    if (listener.exitAssemblyIdentifierOrList) {
      listener.exitAssemblyIdentifierOrList(this);
    }
  }
  accept(visitor) {
    if (visitor.visitAssemblyIdentifierOrList) {
      return visitor.visitAssemblyIdentifierOrList(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var AssemblyIdentifierListContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier(i) {
    if (i === void 0) {
      return this.getRuleContexts(IdentifierContext);
    } else {
      return this.getRuleContext(i, IdentifierContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_assemblyIdentifierList;
  }
  enterRule(listener) {
    if (listener.enterAssemblyIdentifierList) {
      listener.enterAssemblyIdentifierList(this);
    }
  }
  exitRule(listener) {
    if (listener.exitAssemblyIdentifierList) {
      listener.exitAssemblyIdentifierList(this);
    }
  }
  accept(visitor) {
    if (visitor.visitAssemblyIdentifierList) {
      return visitor.visitAssemblyIdentifierList(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var AssemblyStackAssignmentContext = class extends import_ParserRuleContext.ParserRuleContext {
  assemblyExpression() {
    return this.getRuleContext(0, AssemblyExpressionContext);
  }
  identifier() {
    return this.getRuleContext(0, IdentifierContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_assemblyStackAssignment;
  }
  enterRule(listener) {
    if (listener.enterAssemblyStackAssignment) {
      listener.enterAssemblyStackAssignment(this);
    }
  }
  exitRule(listener) {
    if (listener.exitAssemblyStackAssignment) {
      listener.exitAssemblyStackAssignment(this);
    }
  }
  accept(visitor) {
    if (visitor.visitAssemblyStackAssignment) {
      return visitor.visitAssemblyStackAssignment(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var LabelDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier() {
    return this.getRuleContext(0, IdentifierContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_labelDefinition;
  }
  enterRule(listener) {
    if (listener.enterLabelDefinition) {
      listener.enterLabelDefinition(this);
    }
  }
  exitRule(listener) {
    if (listener.exitLabelDefinition) {
      listener.exitLabelDefinition(this);
    }
  }
  accept(visitor) {
    if (visitor.visitLabelDefinition) {
      return visitor.visitLabelDefinition(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var AssemblySwitchContext = class extends import_ParserRuleContext.ParserRuleContext {
  assemblyExpression() {
    return this.getRuleContext(0, AssemblyExpressionContext);
  }
  assemblyCase(i) {
    if (i === void 0) {
      return this.getRuleContexts(AssemblyCaseContext);
    } else {
      return this.getRuleContext(i, AssemblyCaseContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_assemblySwitch;
  }
  enterRule(listener) {
    if (listener.enterAssemblySwitch) {
      listener.enterAssemblySwitch(this);
    }
  }
  exitRule(listener) {
    if (listener.exitAssemblySwitch) {
      listener.exitAssemblySwitch(this);
    }
  }
  accept(visitor) {
    if (visitor.visitAssemblySwitch) {
      return visitor.visitAssemblySwitch(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var AssemblyCaseContext = class extends import_ParserRuleContext.ParserRuleContext {
  assemblyLiteral() {
    return this.tryGetRuleContext(0, AssemblyLiteralContext);
  }
  assemblyBlock() {
    return this.getRuleContext(0, AssemblyBlockContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_assemblyCase;
  }
  enterRule(listener) {
    if (listener.enterAssemblyCase) {
      listener.enterAssemblyCase(this);
    }
  }
  exitRule(listener) {
    if (listener.exitAssemblyCase) {
      listener.exitAssemblyCase(this);
    }
  }
  accept(visitor) {
    if (visitor.visitAssemblyCase) {
      return visitor.visitAssemblyCase(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var AssemblyFunctionDefinitionContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier() {
    return this.getRuleContext(0, IdentifierContext);
  }
  assemblyBlock() {
    return this.getRuleContext(0, AssemblyBlockContext);
  }
  assemblyIdentifierList() {
    return this.tryGetRuleContext(0, AssemblyIdentifierListContext);
  }
  assemblyFunctionReturns() {
    return this.tryGetRuleContext(0, AssemblyFunctionReturnsContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_assemblyFunctionDefinition;
  }
  enterRule(listener) {
    if (listener.enterAssemblyFunctionDefinition) {
      listener.enterAssemblyFunctionDefinition(this);
    }
  }
  exitRule(listener) {
    if (listener.exitAssemblyFunctionDefinition) {
      listener.exitAssemblyFunctionDefinition(this);
    }
  }
  accept(visitor) {
    if (visitor.visitAssemblyFunctionDefinition) {
      return visitor.visitAssemblyFunctionDefinition(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var AssemblyFunctionReturnsContext = class extends import_ParserRuleContext.ParserRuleContext {
  assemblyIdentifierList() {
    return this.tryGetRuleContext(0, AssemblyIdentifierListContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_assemblyFunctionReturns;
  }
  enterRule(listener) {
    if (listener.enterAssemblyFunctionReturns) {
      listener.enterAssemblyFunctionReturns(this);
    }
  }
  exitRule(listener) {
    if (listener.exitAssemblyFunctionReturns) {
      listener.exitAssemblyFunctionReturns(this);
    }
  }
  accept(visitor) {
    if (visitor.visitAssemblyFunctionReturns) {
      return visitor.visitAssemblyFunctionReturns(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var AssemblyForContext = class extends import_ParserRuleContext.ParserRuleContext {
  assemblyExpression(i) {
    if (i === void 0) {
      return this.getRuleContexts(AssemblyExpressionContext);
    } else {
      return this.getRuleContext(i, AssemblyExpressionContext);
    }
  }
  assemblyBlock(i) {
    if (i === void 0) {
      return this.getRuleContexts(AssemblyBlockContext);
    } else {
      return this.getRuleContext(i, AssemblyBlockContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_assemblyFor;
  }
  enterRule(listener) {
    if (listener.enterAssemblyFor) {
      listener.enterAssemblyFor(this);
    }
  }
  exitRule(listener) {
    if (listener.exitAssemblyFor) {
      listener.exitAssemblyFor(this);
    }
  }
  accept(visitor) {
    if (visitor.visitAssemblyFor) {
      return visitor.visitAssemblyFor(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var AssemblyIfContext = class extends import_ParserRuleContext.ParserRuleContext {
  assemblyExpression() {
    return this.getRuleContext(0, AssemblyExpressionContext);
  }
  assemblyBlock() {
    return this.getRuleContext(0, AssemblyBlockContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_assemblyIf;
  }
  enterRule(listener) {
    if (listener.enterAssemblyIf) {
      listener.enterAssemblyIf(this);
    }
  }
  exitRule(listener) {
    if (listener.exitAssemblyIf) {
      listener.exitAssemblyIf(this);
    }
  }
  accept(visitor) {
    if (visitor.visitAssemblyIf) {
      return visitor.visitAssemblyIf(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var AssemblyLiteralContext = class extends import_ParserRuleContext.ParserRuleContext {
  stringLiteral() {
    return this.tryGetRuleContext(0, StringLiteralContext);
  }
  DecimalNumber() {
    return this.tryGetToken(SolidityParser.DecimalNumber, 0);
  }
  HexNumber() {
    return this.tryGetToken(SolidityParser.HexNumber, 0);
  }
  hexLiteral() {
    return this.tryGetRuleContext(0, HexLiteralContext);
  }
  BooleanLiteral() {
    return this.tryGetToken(SolidityParser.BooleanLiteral, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_assemblyLiteral;
  }
  enterRule(listener) {
    if (listener.enterAssemblyLiteral) {
      listener.enterAssemblyLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener.exitAssemblyLiteral) {
      listener.exitAssemblyLiteral(this);
    }
  }
  accept(visitor) {
    if (visitor.visitAssemblyLiteral) {
      return visitor.visitAssemblyLiteral(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var SubAssemblyContext = class extends import_ParserRuleContext.ParserRuleContext {
  identifier() {
    return this.getRuleContext(0, IdentifierContext);
  }
  assemblyBlock() {
    return this.getRuleContext(0, AssemblyBlockContext);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_subAssembly;
  }
  enterRule(listener) {
    if (listener.enterSubAssembly) {
      listener.enterSubAssembly(this);
    }
  }
  exitRule(listener) {
    if (listener.exitSubAssembly) {
      listener.exitSubAssembly(this);
    }
  }
  accept(visitor) {
    if (visitor.visitSubAssembly) {
      return visitor.visitSubAssembly(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var TupleExpressionContext = class extends import_ParserRuleContext.ParserRuleContext {
  expression(i) {
    if (i === void 0) {
      return this.getRuleContexts(ExpressionContext);
    } else {
      return this.getRuleContext(i, ExpressionContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_tupleExpression;
  }
  enterRule(listener) {
    if (listener.enterTupleExpression) {
      listener.enterTupleExpression(this);
    }
  }
  exitRule(listener) {
    if (listener.exitTupleExpression) {
      listener.exitTupleExpression(this);
    }
  }
  accept(visitor) {
    if (visitor.visitTupleExpression) {
      return visitor.visitTupleExpression(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var NumberLiteralContext = class extends import_ParserRuleContext.ParserRuleContext {
  DecimalNumber() {
    return this.tryGetToken(SolidityParser.DecimalNumber, 0);
  }
  HexNumber() {
    return this.tryGetToken(SolidityParser.HexNumber, 0);
  }
  NumberUnit() {
    return this.tryGetToken(SolidityParser.NumberUnit, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_numberLiteral;
  }
  enterRule(listener) {
    if (listener.enterNumberLiteral) {
      listener.enterNumberLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener.exitNumberLiteral) {
      listener.exitNumberLiteral(this);
    }
  }
  accept(visitor) {
    if (visitor.visitNumberLiteral) {
      return visitor.visitNumberLiteral(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var IdentifierContext = class extends import_ParserRuleContext.ParserRuleContext {
  ReceiveKeyword() {
    return this.tryGetToken(SolidityParser.ReceiveKeyword, 0);
  }
  ConstructorKeyword() {
    return this.tryGetToken(SolidityParser.ConstructorKeyword, 0);
  }
  PayableKeyword() {
    return this.tryGetToken(SolidityParser.PayableKeyword, 0);
  }
  LeaveKeyword() {
    return this.tryGetToken(SolidityParser.LeaveKeyword, 0);
  }
  Identifier() {
    return this.tryGetToken(SolidityParser.Identifier, 0);
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_identifier;
  }
  enterRule(listener) {
    if (listener.enterIdentifier) {
      listener.enterIdentifier(this);
    }
  }
  exitRule(listener) {
    if (listener.exitIdentifier) {
      listener.exitIdentifier(this);
    }
  }
  accept(visitor) {
    if (visitor.visitIdentifier) {
      return visitor.visitIdentifier(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var HexLiteralContext = class extends import_ParserRuleContext.ParserRuleContext {
  HexLiteralFragment(i) {
    if (i === void 0) {
      return this.getTokens(SolidityParser.HexLiteralFragment);
    } else {
      return this.getToken(SolidityParser.HexLiteralFragment, i);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_hexLiteral;
  }
  enterRule(listener) {
    if (listener.enterHexLiteral) {
      listener.enterHexLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener.exitHexLiteral) {
      listener.exitHexLiteral(this);
    }
  }
  accept(visitor) {
    if (visitor.visitHexLiteral) {
      return visitor.visitHexLiteral(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var OverrideSpecifierContext = class extends import_ParserRuleContext.ParserRuleContext {
  userDefinedTypeName(i) {
    if (i === void 0) {
      return this.getRuleContexts(UserDefinedTypeNameContext);
    } else {
      return this.getRuleContext(i, UserDefinedTypeNameContext);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_overrideSpecifier;
  }
  enterRule(listener) {
    if (listener.enterOverrideSpecifier) {
      listener.enterOverrideSpecifier(this);
    }
  }
  exitRule(listener) {
    if (listener.exitOverrideSpecifier) {
      listener.exitOverrideSpecifier(this);
    }
  }
  accept(visitor) {
    if (visitor.visitOverrideSpecifier) {
      return visitor.visitOverrideSpecifier(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};
var StringLiteralContext = class extends import_ParserRuleContext.ParserRuleContext {
  StringLiteralFragment(i) {
    if (i === void 0) {
      return this.getTokens(SolidityParser.StringLiteralFragment);
    } else {
      return this.getToken(SolidityParser.StringLiteralFragment, i);
    }
  }
  constructor(parent, invokingState) {
    super(parent, invokingState);
  }
  get ruleIndex() {
    return SolidityParser.RULE_stringLiteral;
  }
  enterRule(listener) {
    if (listener.enterStringLiteral) {
      listener.enterStringLiteral(this);
    }
  }
  exitRule(listener) {
    if (listener.exitStringLiteral) {
      listener.exitStringLiteral(this);
    }
  }
  accept(visitor) {
    if (visitor.visitStringLiteral) {
      return visitor.visitStringLiteral(this);
    } else {
      return visitor.visitChildren(this);
    }
  }
};

// src/ast-types.ts
var astNodeTypes = [
  "SourceUnit",
  "PragmaDirective",
  "ImportDirective",
  "ContractDefinition",
  "InheritanceSpecifier",
  "StateVariableDeclaration",
  "UsingForDeclaration",
  "StructDefinition",
  "ModifierDefinition",
  "ModifierInvocation",
  "FunctionDefinition",
  "EventDefinition",
  "CustomErrorDefinition",
  "RevertStatement",
  "EnumValue",
  "EnumDefinition",
  "VariableDeclaration",
  "UserDefinedTypeName",
  "Mapping",
  "ArrayTypeName",
  "FunctionTypeName",
  "Block",
  "ExpressionStatement",
  "IfStatement",
  "WhileStatement",
  "ForStatement",
  "InlineAssemblyStatement",
  "DoWhileStatement",
  "ContinueStatement",
  "Break",
  "Continue",
  "BreakStatement",
  "ReturnStatement",
  "EmitStatement",
  "ThrowStatement",
  "VariableDeclarationStatement",
  "ElementaryTypeName",
  "FunctionCall",
  "AssemblyBlock",
  "AssemblyCall",
  "AssemblyLocalDefinition",
  "AssemblyAssignment",
  "AssemblyStackAssignment",
  "LabelDefinition",
  "AssemblySwitch",
  "AssemblyCase",
  "AssemblyFunctionDefinition",
  "AssemblyFunctionReturns",
  "AssemblyFor",
  "AssemblyIf",
  "SubAssembly",
  "TupleExpression",
  "NameValueExpression",
  "BooleanLiteral",
  "NumberLiteral",
  "Identifier",
  "BinaryOperation",
  "UnaryOperation",
  "NewExpression",
  "Conditional",
  "StringLiteral",
  "HexLiteral",
  "HexNumber",
  "DecimalNumber",
  "MemberAccess",
  "IndexAccess",
  "IndexRangeAccess",
  "NameValueList",
  "UncheckedStatement",
  "TryStatement",
  "CatchClause",
  "FileLevelConstant",
  "AssemblyMemberAccess",
  "TypeDefinition"
];
var binaryOpValues = [
  "+",
  "-",
  "*",
  "/",
  "**",
  "%",
  "<<",
  ">>",
  "&&",
  "||",
  ",,",
  "&",
  ",",
  "^",
  "<",
  ">",
  "<=",
  ">=",
  "==",
  "!=",
  "=",
  ",=",
  "^=",
  "&=",
  "<<=",
  ">>=",
  "+=",
  "-=",
  "*=",
  "/=",
  "%=",
  "|",
  "|="
];
var unaryOpValues = [
  "-",
  "+",
  "++",
  "--",
  "~",
  "after",
  "delete",
  "!"
];

// src/ASTBuilder.ts
var import_AbstractParseTreeVisitor = __toModule(require_AbstractParseTreeVisitor());
var import_ErrorNode = __toModule(require_ErrorNode());
var ASTBuilder = class extends import_AbstractParseTreeVisitor.AbstractParseTreeVisitor {
  constructor(options) {
    super();
    this.options = options;
    this.result = null;
  }
  defaultResult() {
    throw new Error("Unknown node");
  }
  aggregateResult() {
    return {type: ""};
  }
  visitSourceUnit(ctx) {
    var _a;
    const children = ((_a = ctx.children) != null ? _a : []).filter((x) => !(x instanceof import_ErrorNode.ErrorNode));
    const node = {
      type: "SourceUnit",
      children: children.slice(0, -1).map((child) => this.visit(child))
    };
    const result = this._addMeta(node, ctx);
    this.result = result;
    return result;
  }
  visitContractPart(ctx) {
    return this.visit(ctx.getChild(0));
  }
  visitContractDefinition(ctx) {
    const name = this._toText(ctx.identifier());
    const kind = this._toText(ctx.getChild(0));
    this._currentContract = name;
    const node = {
      type: "ContractDefinition",
      name,
      baseContracts: ctx.inheritanceSpecifier().map((x) => this.visitInheritanceSpecifier(x)),
      subNodes: ctx.contractPart().map((x) => this.visit(x)),
      kind
    };
    return this._addMeta(node, ctx);
  }
  visitStateVariableDeclaration(ctx) {
    const type = this.visitTypeName(ctx.typeName());
    const iden = ctx.identifier();
    const name = this._toText(iden);
    let expression = null;
    const ctxExpression = ctx.expression();
    if (ctxExpression) {
      expression = this.visitExpression(ctxExpression);
    }
    let visibility = "default";
    if (ctx.InternalKeyword().length > 0) {
      visibility = "internal";
    } else if (ctx.PublicKeyword().length > 0) {
      visibility = "public";
    } else if (ctx.PrivateKeyword().length > 0) {
      visibility = "private";
    }
    let isDeclaredConst = false;
    if (ctx.ConstantKeyword().length > 0) {
      isDeclaredConst = true;
    }
    let override;
    const overrideSpecifier = ctx.overrideSpecifier();
    if (overrideSpecifier.length === 0) {
      override = null;
    } else {
      override = overrideSpecifier[0].userDefinedTypeName().map((x) => this.visitUserDefinedTypeName(x));
    }
    let isImmutable = false;
    if (ctx.ImmutableKeyword().length > 0) {
      isImmutable = true;
    }
    const decl = {
      type: "VariableDeclaration",
      typeName: type,
      name,
      identifier: this.visitIdentifier(iden),
      expression,
      visibility,
      isStateVar: true,
      isDeclaredConst,
      isIndexed: false,
      isImmutable,
      override,
      storageLocation: null
    };
    const node = {
      type: "StateVariableDeclaration",
      variables: [this._addMeta(decl, ctx)],
      initialValue: expression
    };
    return this._addMeta(node, ctx);
  }
  visitVariableDeclaration(ctx) {
    let storageLocation = null;
    const ctxStorageLocation = ctx.storageLocation();
    if (ctxStorageLocation) {
      storageLocation = this._toText(ctxStorageLocation);
    }
    const identifierCtx = ctx.identifier();
    const node = {
      type: "VariableDeclaration",
      typeName: this.visitTypeName(ctx.typeName()),
      name: this._toText(identifierCtx),
      identifier: this.visitIdentifier(identifierCtx),
      storageLocation,
      isStateVar: false,
      isIndexed: false,
      expression: null
    };
    return this._addMeta(node, ctx);
  }
  visitVariableDeclarationStatement(ctx) {
    let variables = [];
    const ctxVariableDeclaration = ctx.variableDeclaration();
    const ctxIdentifierList = ctx.identifierList();
    const ctxVariableDeclarationList = ctx.variableDeclarationList();
    if (ctxVariableDeclaration !== void 0) {
      variables = [this.visitVariableDeclaration(ctxVariableDeclaration)];
    } else if (ctxIdentifierList !== void 0) {
      variables = this.buildIdentifierList(ctxIdentifierList);
    } else if (ctxVariableDeclarationList) {
      variables = this.buildVariableDeclarationList(ctxVariableDeclarationList);
    }
    let initialValue = null;
    const ctxExpression = ctx.expression();
    if (ctxExpression) {
      initialValue = this.visitExpression(ctxExpression);
    }
    const node = {
      type: "VariableDeclarationStatement",
      variables,
      initialValue
    };
    return this._addMeta(node, ctx);
  }
  visitStatement(ctx) {
    return this.visit(ctx.getChild(0));
  }
  visitSimpleStatement(ctx) {
    return this.visit(ctx.getChild(0));
  }
  visitEventDefinition(ctx) {
    const parameters = ctx.eventParameterList().eventParameter().map((paramCtx) => {
      const type = this.visitTypeName(paramCtx.typeName());
      let name = null;
      const paramCtxIdentifier = paramCtx.identifier();
      if (paramCtxIdentifier) {
        name = this._toText(paramCtxIdentifier);
      }
      const node2 = {
        type: "VariableDeclaration",
        typeName: type,
        name,
        identifier: paramCtxIdentifier !== void 0 ? this.visitIdentifier(paramCtxIdentifier) : null,
        isStateVar: false,
        isIndexed: paramCtx.IndexedKeyword() !== void 0,
        storageLocation: null,
        expression: null
      };
      return this._addMeta(node2, paramCtx);
    });
    const node = {
      type: "EventDefinition",
      name: this._toText(ctx.identifier()),
      parameters,
      isAnonymous: ctx.AnonymousKeyword() !== void 0
    };
    return this._addMeta(node, ctx);
  }
  visitBlock(ctx) {
    const node = {
      type: "Block",
      statements: ctx.statement().map((x) => this.visitStatement(x))
    };
    return this._addMeta(node, ctx);
  }
  visitParameter(ctx) {
    let storageLocation = null;
    const ctxStorageLocation = ctx.storageLocation();
    if (ctxStorageLocation !== void 0) {
      storageLocation = this._toText(ctxStorageLocation);
    }
    let name = null;
    const ctxIdentifier = ctx.identifier();
    if (ctxIdentifier !== void 0) {
      name = this._toText(ctxIdentifier);
    }
    const node = {
      type: "VariableDeclaration",
      typeName: this.visitTypeName(ctx.typeName()),
      name,
      identifier: ctxIdentifier !== void 0 ? this.visitIdentifier(ctxIdentifier) : null,
      storageLocation,
      isStateVar: false,
      isIndexed: false,
      expression: null
    };
    return this._addMeta(node, ctx);
  }
  visitFunctionDefinition(ctx) {
    let isConstructor = false;
    let isFallback = false;
    let isReceiveEther = false;
    let isVirtual = false;
    let name = null;
    let parameters = [];
    let returnParameters = null;
    let visibility = "default";
    let block = null;
    const ctxBlock = ctx.block();
    if (ctxBlock !== void 0) {
      block = this.visitBlock(ctxBlock);
    }
    const modifiers = ctx.modifierList().modifierInvocation().map((mod) => this.visitModifierInvocation(mod));
    let stateMutability = null;
    if (ctx.modifierList().stateMutability().length > 0) {
      stateMutability = this._stateMutabilityToText(ctx.modifierList().stateMutability(0));
    }
    const ctxReturnParameters = ctx.returnParameters();
    switch (this._toText(ctx.functionDescriptor().getChild(0))) {
      case "constructor":
        parameters = ctx.parameterList().parameter().map((x) => this.visit(x));
        if (ctx.modifierList().InternalKeyword().length > 0) {
          visibility = "internal";
        } else if (ctx.modifierList().PublicKeyword().length > 0) {
          visibility = "public";
        } else {
          visibility = "default";
        }
        isConstructor = true;
        break;
      case "fallback":
        parameters = ctx.parameterList().parameter().map((x) => this.visit(x));
        returnParameters = ctxReturnParameters !== void 0 ? this.visitReturnParameters(ctxReturnParameters) : null;
        visibility = "external";
        isFallback = true;
        break;
      case "receive":
        visibility = "external";
        isReceiveEther = true;
        break;
      case "function": {
        const identifier = ctx.functionDescriptor().identifier();
        name = identifier !== void 0 ? this._toText(identifier) : "";
        parameters = ctx.parameterList().parameter().map((x) => this.visit(x));
        returnParameters = ctxReturnParameters !== void 0 ? this.visitReturnParameters(ctxReturnParameters) : null;
        if (ctx.modifierList().ExternalKeyword().length > 0) {
          visibility = "external";
        } else if (ctx.modifierList().InternalKeyword().length > 0) {
          visibility = "internal";
        } else if (ctx.modifierList().PublicKeyword().length > 0) {
          visibility = "public";
        } else if (ctx.modifierList().PrivateKeyword().length > 0) {
          visibility = "private";
        }
        isConstructor = name === this._currentContract;
        isFallback = name === "";
        break;
      }
    }
    if (ctx.modifierList().VirtualKeyword().length > 0) {
      isVirtual = true;
    }
    let override;
    const overrideSpecifier = ctx.modifierList().overrideSpecifier();
    if (overrideSpecifier.length === 0) {
      override = null;
    } else {
      override = overrideSpecifier[0].userDefinedTypeName().map((x) => this.visitUserDefinedTypeName(x));
    }
    const node = {
      type: "FunctionDefinition",
      name,
      parameters,
      returnParameters,
      body: block,
      visibility,
      modifiers,
      override,
      isConstructor,
      isReceiveEther,
      isFallback,
      isVirtual,
      stateMutability
    };
    return this._addMeta(node, ctx);
  }
  visitEnumDefinition(ctx) {
    const node = {
      type: "EnumDefinition",
      name: this._toText(ctx.identifier()),
      members: ctx.enumValue().map((x) => this.visitEnumValue(x))
    };
    return this._addMeta(node, ctx);
  }
  visitEnumValue(ctx) {
    const node = {
      type: "EnumValue",
      name: this._toText(ctx.identifier())
    };
    return this._addMeta(node, ctx);
  }
  visitElementaryTypeName(ctx) {
    const node = {
      type: "ElementaryTypeName",
      name: this._toText(ctx),
      stateMutability: null
    };
    return this._addMeta(node, ctx);
  }
  visitIdentifier(ctx) {
    const node = {
      type: "Identifier",
      name: this._toText(ctx)
    };
    return this._addMeta(node, ctx);
  }
  visitTypeName(ctx) {
    var _a;
    if (ctx.children !== void 0 && ctx.children.length > 2) {
      let length = null;
      if (ctx.children.length === 4) {
        const expression = ctx.expression();
        if (expression === void 0) {
          throw new Error("Assertion error: a typeName with 4 children should have an expression");
        }
        length = this.visitExpression(expression);
      }
      const ctxTypeName = ctx.typeName();
      const node = {
        type: "ArrayTypeName",
        baseTypeName: this.visitTypeName(ctxTypeName),
        length
      };
      return this._addMeta(node, ctx);
    }
    if (((_a = ctx.children) == null ? void 0 : _a.length) === 2) {
      const node = {
        type: "ElementaryTypeName",
        name: this._toText(ctx.getChild(0)),
        stateMutability: this._toText(ctx.getChild(1))
      };
      return this._addMeta(node, ctx);
    }
    if (ctx.elementaryTypeName() !== void 0) {
      return this.visitElementaryTypeName(ctx.elementaryTypeName());
    }
    if (ctx.userDefinedTypeName() !== void 0) {
      return this.visitUserDefinedTypeName(ctx.userDefinedTypeName());
    }
    if (ctx.mapping() !== void 0) {
      return this.visitMapping(ctx.mapping());
    }
    if (ctx.functionTypeName() !== void 0) {
      return this.visitFunctionTypeName(ctx.functionTypeName());
    }
    throw new Error("Assertion error: unhandled type name case");
  }
  visitUserDefinedTypeName(ctx) {
    const node = {
      type: "UserDefinedTypeName",
      namePath: this._toText(ctx)
    };
    return this._addMeta(node, ctx);
  }
  visitUsingForDeclaration(ctx) {
    let typeName = null;
    const ctxTypeName = ctx.typeName();
    if (ctxTypeName !== void 0) {
      typeName = this.visitTypeName(ctxTypeName);
    }
    const isGlobal = ctx.GlobalKeyword() !== void 0;
    let node;
    const usingForObject = ctx.usingForObject();
    const firstChild = this._toText(usingForObject.getChild(0));
    if (firstChild === "{") {
      node = {
        type: "UsingForDeclaration",
        isGlobal,
        typeName,
        libraryName: null,
        functions: usingForObject.userDefinedTypeName().map((x) => this._toText(x))
      };
    } else {
      node = {
        type: "UsingForDeclaration",
        isGlobal,
        typeName,
        libraryName: this._toText(usingForObject.userDefinedTypeName(0)),
        functions: []
      };
    }
    return this._addMeta(node, ctx);
  }
  visitPragmaDirective(ctx) {
    const versionContext = ctx.pragmaValue().version();
    let value = this._toText(ctx.pragmaValue());
    if ((versionContext == null ? void 0 : versionContext.children) !== void 0) {
      value = versionContext.children.map((x) => this._toText(x)).join(" ");
    }
    const node = {
      type: "PragmaDirective",
      name: this._toText(ctx.pragmaName()),
      value
    };
    return this._addMeta(node, ctx);
  }
  visitInheritanceSpecifier(ctx) {
    const exprList = ctx.expressionList();
    const args = exprList !== void 0 ? exprList.expression().map((x) => this.visitExpression(x)) : [];
    const node = {
      type: "InheritanceSpecifier",
      baseName: this.visitUserDefinedTypeName(ctx.userDefinedTypeName()),
      arguments: args
    };
    return this._addMeta(node, ctx);
  }
  visitModifierInvocation(ctx) {
    const exprList = ctx.expressionList();
    let args;
    if (exprList != null) {
      args = exprList.expression().map((x) => this.visit(x));
    } else if (ctx.children !== void 0 && ctx.children.length > 1) {
      args = [];
    } else {
      args = null;
    }
    const node = {
      type: "ModifierInvocation",
      name: this._toText(ctx.identifier()),
      arguments: args
    };
    return this._addMeta(node, ctx);
  }
  visitFunctionTypeName(ctx) {
    const parameterTypes = ctx.functionTypeParameterList(0).functionTypeParameter().map((typeCtx) => this.visitFunctionTypeParameter(typeCtx));
    let returnTypes = [];
    if (ctx.functionTypeParameterList().length > 1) {
      returnTypes = ctx.functionTypeParameterList(1).functionTypeParameter().map((typeCtx) => this.visitFunctionTypeParameter(typeCtx));
    }
    let visibility = "default";
    if (ctx.InternalKeyword().length > 0) {
      visibility = "internal";
    } else if (ctx.ExternalKeyword().length > 0) {
      visibility = "external";
    }
    let stateMutability = null;
    if (ctx.stateMutability().length > 0) {
      stateMutability = this._toText(ctx.stateMutability(0));
    }
    const node = {
      type: "FunctionTypeName",
      parameterTypes,
      returnTypes,
      visibility,
      stateMutability
    };
    return this._addMeta(node, ctx);
  }
  visitFunctionTypeParameter(ctx) {
    let storageLocation = null;
    if (ctx.storageLocation()) {
      storageLocation = this._toText(ctx.storageLocation());
    }
    const node = {
      type: "VariableDeclaration",
      typeName: this.visitTypeName(ctx.typeName()),
      name: null,
      identifier: null,
      storageLocation,
      isStateVar: false,
      isIndexed: false,
      expression: null
    };
    return this._addMeta(node, ctx);
  }
  visitThrowStatement(ctx) {
    const node = {
      type: "ThrowStatement"
    };
    return this._addMeta(node, ctx);
  }
  visitReturnStatement(ctx) {
    let expression = null;
    const ctxExpression = ctx.expression();
    if (ctxExpression) {
      expression = this.visitExpression(ctxExpression);
    }
    const node = {
      type: "ReturnStatement",
      expression
    };
    return this._addMeta(node, ctx);
  }
  visitEmitStatement(ctx) {
    const node = {
      type: "EmitStatement",
      eventCall: this.visitFunctionCall(ctx.functionCall())
    };
    return this._addMeta(node, ctx);
  }
  visitCustomErrorDefinition(ctx) {
    const node = {
      type: "CustomErrorDefinition",
      name: this._toText(ctx.identifier()),
      parameters: this.visitParameterList(ctx.parameterList())
    };
    return this._addMeta(node, ctx);
  }
  visitTypeDefinition(ctx) {
    const node = {
      type: "TypeDefinition",
      name: this._toText(ctx.identifier()),
      definition: this.visitElementaryTypeName(ctx.elementaryTypeName())
    };
    return this._addMeta(node, ctx);
  }
  visitRevertStatement(ctx) {
    const node = {
      type: "RevertStatement",
      revertCall: this.visitFunctionCall(ctx.functionCall())
    };
    return this._addMeta(node, ctx);
  }
  visitFunctionCall(ctx) {
    let args = [];
    const names = [];
    const identifiers = [];
    const ctxArgs = ctx.functionCallArguments();
    const ctxArgsExpressionList = ctxArgs.expressionList();
    const ctxArgsNameValueList = ctxArgs.nameValueList();
    if (ctxArgsExpressionList) {
      args = ctxArgsExpressionList.expression().map((exprCtx) => this.visitExpression(exprCtx));
    } else if (ctxArgsNameValueList) {
      for (const nameValue of ctxArgsNameValueList.nameValue()) {
        args.push(this.visitExpression(nameValue.expression()));
        names.push(this._toText(nameValue.identifier()));
        identifiers.push(this.visitIdentifier(nameValue.identifier()));
      }
    }
    const node = {
      type: "FunctionCall",
      expression: this.visitExpression(ctx.expression()),
      arguments: args,
      names,
      identifiers
    };
    return this._addMeta(node, ctx);
  }
  visitStructDefinition(ctx) {
    const node = {
      type: "StructDefinition",
      name: this._toText(ctx.identifier()),
      members: ctx.variableDeclaration().map((x) => this.visitVariableDeclaration(x))
    };
    return this._addMeta(node, ctx);
  }
  visitWhileStatement(ctx) {
    const node = {
      type: "WhileStatement",
      condition: this.visitExpression(ctx.expression()),
      body: this.visitStatement(ctx.statement())
    };
    return this._addMeta(node, ctx);
  }
  visitDoWhileStatement(ctx) {
    const node = {
      type: "DoWhileStatement",
      condition: this.visitExpression(ctx.expression()),
      body: this.visitStatement(ctx.statement())
    };
    return this._addMeta(node, ctx);
  }
  visitIfStatement(ctx) {
    const trueBody = this.visitStatement(ctx.statement(0));
    let falseBody = null;
    if (ctx.statement().length > 1) {
      falseBody = this.visitStatement(ctx.statement(1));
    }
    const node = {
      type: "IfStatement",
      condition: this.visitExpression(ctx.expression()),
      trueBody,
      falseBody
    };
    return this._addMeta(node, ctx);
  }
  visitTryStatement(ctx) {
    let returnParameters = null;
    const ctxReturnParameters = ctx.returnParameters();
    if (ctxReturnParameters !== void 0) {
      returnParameters = this.visitReturnParameters(ctxReturnParameters);
    }
    const catchClauses = ctx.catchClause().map((exprCtx) => this.visitCatchClause(exprCtx));
    const node = {
      type: "TryStatement",
      expression: this.visitExpression(ctx.expression()),
      returnParameters,
      body: this.visitBlock(ctx.block()),
      catchClauses
    };
    return this._addMeta(node, ctx);
  }
  visitCatchClause(ctx) {
    let parameters = null;
    if (ctx.parameterList()) {
      parameters = this.visitParameterList(ctx.parameterList());
    }
    if (ctx.identifier() && this._toText(ctx.identifier()) !== "Error" && this._toText(ctx.identifier()) !== "Panic") {
      throw new Error('Expected "Error" or "Panic" identifier in catch clause');
    }
    let kind = null;
    const ctxIdentifier = ctx.identifier();
    if (ctxIdentifier !== void 0) {
      kind = this._toText(ctxIdentifier);
    }
    const node = {
      type: "CatchClause",
      isReasonStringType: kind === "Error",
      kind,
      parameters,
      body: this.visitBlock(ctx.block())
    };
    return this._addMeta(node, ctx);
  }
  visitExpressionStatement(ctx) {
    if (!ctx) {
      return null;
    }
    const node = {
      type: "ExpressionStatement",
      expression: this.visitExpression(ctx.expression())
    };
    return this._addMeta(node, ctx);
  }
  visitNumberLiteral(ctx) {
    var _a;
    const number = this._toText(ctx.getChild(0));
    let subdenomination = null;
    if (((_a = ctx.children) == null ? void 0 : _a.length) === 2) {
      subdenomination = this._toText(ctx.getChild(1));
    }
    const node = {
      type: "NumberLiteral",
      number,
      subdenomination
    };
    return this._addMeta(node, ctx);
  }
  visitMappingKey(ctx) {
    if (ctx.elementaryTypeName()) {
      return this.visitElementaryTypeName(ctx.elementaryTypeName());
    } else if (ctx.userDefinedTypeName()) {
      return this.visitUserDefinedTypeName(ctx.userDefinedTypeName());
    } else {
      throw new Error("Expected MappingKey to have either elementaryTypeName or userDefinedTypeName");
    }
  }
  visitMapping(ctx) {
    const node = {
      type: "Mapping",
      keyType: this.visitMappingKey(ctx.mappingKey()),
      valueType: this.visitTypeName(ctx.typeName())
    };
    return this._addMeta(node, ctx);
  }
  visitModifierDefinition(ctx) {
    let parameters = null;
    if (ctx.parameterList()) {
      parameters = this.visitParameterList(ctx.parameterList());
    }
    let isVirtual = false;
    if (ctx.VirtualKeyword().length > 0) {
      isVirtual = true;
    }
    let override;
    const overrideSpecifier = ctx.overrideSpecifier();
    if (overrideSpecifier.length === 0) {
      override = null;
    } else {
      override = overrideSpecifier[0].userDefinedTypeName().map((x) => this.visitUserDefinedTypeName(x));
    }
    let body = null;
    const blockCtx = ctx.block();
    if (blockCtx !== void 0) {
      body = this.visitBlock(blockCtx);
    }
    const node = {
      type: "ModifierDefinition",
      name: this._toText(ctx.identifier()),
      parameters,
      body,
      isVirtual,
      override
    };
    return this._addMeta(node, ctx);
  }
  visitUncheckedStatement(ctx) {
    const node = {
      type: "UncheckedStatement",
      block: this.visitBlock(ctx.block())
    };
    return this._addMeta(node, ctx);
  }
  visitExpression(ctx) {
    let op;
    switch (ctx.children.length) {
      case 1: {
        const primaryExpressionCtx = ctx.tryGetRuleContext(0, PrimaryExpressionContext);
        if (primaryExpressionCtx === void 0) {
          throw new Error("Assertion error: primary expression should exist when children length is 1");
        }
        return this.visitPrimaryExpression(primaryExpressionCtx);
      }
      case 2:
        op = this._toText(ctx.getChild(0));
        if (op === "new") {
          const node = {
            type: "NewExpression",
            typeName: this.visitTypeName(ctx.typeName())
          };
          return this._addMeta(node, ctx);
        }
        if (unaryOpValues.includes(op)) {
          const node = {
            type: "UnaryOperation",
            operator: op,
            subExpression: this.visitExpression(ctx.getRuleContext(0, ExpressionContext)),
            isPrefix: true
          };
          return this._addMeta(node, ctx);
        }
        op = this._toText(ctx.getChild(1));
        if (["++", "--"].includes(op)) {
          const node = {
            type: "UnaryOperation",
            operator: op,
            subExpression: this.visitExpression(ctx.getRuleContext(0, ExpressionContext)),
            isPrefix: false
          };
          return this._addMeta(node, ctx);
        }
        break;
      case 3:
        if (this._toText(ctx.getChild(0)) === "(" && this._toText(ctx.getChild(2)) === ")") {
          const node = {
            type: "TupleExpression",
            components: [
              this.visitExpression(ctx.getRuleContext(0, ExpressionContext))
            ],
            isArray: false
          };
          return this._addMeta(node, ctx);
        }
        op = this._toText(ctx.getChild(1));
        if (op === ".") {
          const node = {
            type: "MemberAccess",
            expression: this.visitExpression(ctx.expression(0)),
            memberName: this._toText(ctx.identifier())
          };
          return this._addMeta(node, ctx);
        }
        if (isBinOp(op)) {
          const node = {
            type: "BinaryOperation",
            operator: op,
            left: this.visitExpression(ctx.expression(0)),
            right: this.visitExpression(ctx.expression(1))
          };
          return this._addMeta(node, ctx);
        }
        break;
      case 4:
        if (this._toText(ctx.getChild(1)) === "(" && this._toText(ctx.getChild(3)) === ")") {
          let args = [];
          const names = [];
          const identifiers = [];
          const ctxArgs = ctx.functionCallArguments();
          if (ctxArgs.expressionList()) {
            args = ctxArgs.expressionList().expression().map((exprCtx) => this.visitExpression(exprCtx));
          } else if (ctxArgs.nameValueList()) {
            for (const nameValue of ctxArgs.nameValueList().nameValue()) {
              args.push(this.visitExpression(nameValue.expression()));
              names.push(this._toText(nameValue.identifier()));
              identifiers.push(this.visitIdentifier(nameValue.identifier()));
            }
          }
          const node = {
            type: "FunctionCall",
            expression: this.visitExpression(ctx.expression(0)),
            arguments: args,
            names,
            identifiers
          };
          return this._addMeta(node, ctx);
        }
        if (this._toText(ctx.getChild(1)) === "[" && this._toText(ctx.getChild(3)) === "]") {
          if (ctx.getChild(2).text === ":") {
            const node2 = {
              type: "IndexRangeAccess",
              base: this.visitExpression(ctx.expression(0))
            };
            return this._addMeta(node2, ctx);
          }
          const node = {
            type: "IndexAccess",
            base: this.visitExpression(ctx.expression(0)),
            index: this.visitExpression(ctx.expression(1))
          };
          return this._addMeta(node, ctx);
        }
        if (this._toText(ctx.getChild(1)) === "{" && this._toText(ctx.getChild(3)) === "}") {
          const node = {
            type: "NameValueExpression",
            expression: this.visitExpression(ctx.expression(0)),
            arguments: this.visitNameValueList(ctx.nameValueList())
          };
          return this._addMeta(node, ctx);
        }
        break;
      case 5:
        if (this._toText(ctx.getChild(1)) === "?" && this._toText(ctx.getChild(3)) === ":") {
          const node = {
            type: "Conditional",
            condition: this.visitExpression(ctx.expression(0)),
            trueExpression: this.visitExpression(ctx.expression(1)),
            falseExpression: this.visitExpression(ctx.expression(2))
          };
          return this._addMeta(node, ctx);
        }
        if (this._toText(ctx.getChild(1)) === "[" && this._toText(ctx.getChild(2)) === ":" && this._toText(ctx.getChild(4)) === "]") {
          const node = {
            type: "IndexRangeAccess",
            base: this.visitExpression(ctx.expression(0)),
            indexEnd: this.visitExpression(ctx.expression(1))
          };
          return this._addMeta(node, ctx);
        } else if (this._toText(ctx.getChild(1)) === "[" && this._toText(ctx.getChild(3)) === ":" && this._toText(ctx.getChild(4)) === "]") {
          const node = {
            type: "IndexRangeAccess",
            base: this.visitExpression(ctx.expression(0)),
            indexStart: this.visitExpression(ctx.expression(1))
          };
          return this._addMeta(node, ctx);
        }
        break;
      case 6:
        if (this._toText(ctx.getChild(1)) === "[" && this._toText(ctx.getChild(3)) === ":" && this._toText(ctx.getChild(5)) === "]") {
          const node = {
            type: "IndexRangeAccess",
            base: this.visitExpression(ctx.expression(0)),
            indexStart: this.visitExpression(ctx.expression(1)),
            indexEnd: this.visitExpression(ctx.expression(2))
          };
          return this._addMeta(node, ctx);
        }
        break;
    }
    throw new Error("Unrecognized expression");
  }
  visitNameValueList(ctx) {
    const names = [];
    const identifiers = [];
    const args = [];
    for (const nameValue of ctx.nameValue()) {
      names.push(this._toText(nameValue.identifier()));
      identifiers.push(this.visitIdentifier(nameValue.identifier()));
      args.push(this.visitExpression(nameValue.expression()));
    }
    const node = {
      type: "NameValueList",
      names,
      identifiers,
      arguments: args
    };
    return this._addMeta(node, ctx);
  }
  visitFileLevelConstant(ctx) {
    const type = this.visitTypeName(ctx.typeName());
    const iden = ctx.identifier();
    const name = this._toText(iden);
    const expression = this.visitExpression(ctx.expression());
    const node = {
      type: "FileLevelConstant",
      typeName: type,
      name,
      initialValue: expression,
      isDeclaredConst: true,
      isImmutable: false
    };
    return this._addMeta(node, ctx);
  }
  visitForStatement(ctx) {
    let conditionExpression = this.visitExpressionStatement(ctx.expressionStatement());
    if (conditionExpression) {
      conditionExpression = conditionExpression.expression;
    }
    const node = {
      type: "ForStatement",
      initExpression: ctx.simpleStatement() ? this.visitSimpleStatement(ctx.simpleStatement()) : null,
      conditionExpression,
      loopExpression: {
        type: "ExpressionStatement",
        expression: ctx.expression() !== void 0 ? this.visitExpression(ctx.expression()) : null
      },
      body: this.visitStatement(ctx.statement())
    };
    return this._addMeta(node, ctx);
  }
  visitHexLiteral(ctx) {
    const parts = ctx.HexLiteralFragment().map((x) => this._toText(x)).map((x) => x.substring(4, x.length - 1));
    const node = {
      type: "HexLiteral",
      value: parts.join(""),
      parts
    };
    return this._addMeta(node, ctx);
  }
  visitPrimaryExpression(ctx) {
    if (ctx.BooleanLiteral()) {
      const node = {
        type: "BooleanLiteral",
        value: this._toText(ctx.BooleanLiteral()) === "true"
      };
      return this._addMeta(node, ctx);
    }
    if (ctx.hexLiteral()) {
      return this.visitHexLiteral(ctx.hexLiteral());
    }
    if (ctx.stringLiteral()) {
      const fragments = ctx.stringLiteral().StringLiteralFragment().map((stringLiteralFragmentCtx) => {
        let text = this._toText(stringLiteralFragmentCtx);
        const isUnicode = text.slice(0, 7) === "unicode";
        if (isUnicode) {
          text = text.slice(7);
        }
        const singleQuotes = text[0] === "'";
        const textWithoutQuotes = text.substring(1, text.length - 1);
        const value = singleQuotes ? textWithoutQuotes.replace(new RegExp("\\\\'", "g"), "'") : textWithoutQuotes.replace(new RegExp('\\\\"', "g"), '"');
        return {value, isUnicode};
      });
      const parts = fragments.map((x) => x.value);
      const node = {
        type: "StringLiteral",
        value: parts.join(""),
        parts,
        isUnicode: fragments.map((x) => x.isUnicode)
      };
      return this._addMeta(node, ctx);
    }
    if (ctx.numberLiteral()) {
      return this.visitNumberLiteral(ctx.numberLiteral());
    }
    if (ctx.TypeKeyword()) {
      const node = {
        type: "Identifier",
        name: "type"
      };
      return this._addMeta(node, ctx);
    }
    if (ctx.typeName()) {
      return this.visitTypeName(ctx.typeName());
    }
    return this.visit(ctx.getChild(0));
  }
  visitTupleExpression(ctx) {
    const children = ctx.children.slice(1, -1);
    const components = this._mapCommasToNulls(children).map((expr) => {
      if (expr === null) {
        return null;
      }
      return this.visit(expr);
    });
    const node = {
      type: "TupleExpression",
      components,
      isArray: this._toText(ctx.getChild(0)) === "["
    };
    return this._addMeta(node, ctx);
  }
  buildIdentifierList(ctx) {
    const children = ctx.children.slice(1, -1);
    const identifiers = ctx.identifier();
    let i = 0;
    return this._mapCommasToNulls(children).map((idenOrNull) => {
      if (!idenOrNull) {
        return null;
      }
      const iden = identifiers[i];
      i++;
      const node = {
        type: "VariableDeclaration",
        name: this._toText(iden),
        identifier: this.visitIdentifier(iden),
        isStateVar: false,
        isIndexed: false,
        typeName: null,
        storageLocation: null,
        expression: null
      };
      return this._addMeta(node, iden);
    });
  }
  buildVariableDeclarationList(ctx) {
    var _a;
    const variableDeclarations = ctx.variableDeclaration();
    let i = 0;
    return this._mapCommasToNulls((_a = ctx.children) != null ? _a : []).map((declOrNull) => {
      if (!declOrNull) {
        return null;
      }
      const decl = variableDeclarations[i];
      i++;
      let storageLocation = null;
      if (decl.storageLocation()) {
        storageLocation = this._toText(decl.storageLocation());
      }
      const identifierCtx = decl.identifier();
      const result = {
        type: "VariableDeclaration",
        name: this._toText(identifierCtx),
        identifier: this.visitIdentifier(identifierCtx),
        typeName: this.visitTypeName(decl.typeName()),
        storageLocation,
        isStateVar: false,
        isIndexed: false,
        expression: null
      };
      return this._addMeta(result, decl);
    });
  }
  visitImportDirective(ctx) {
    const pathString = this._toText(ctx.importPath());
    let unitAlias = null;
    let unitAliasIdentifier = null;
    let symbolAliases = null;
    let symbolAliasesIdentifiers = null;
    if (ctx.importDeclaration().length > 0) {
      symbolAliases = ctx.importDeclaration().map((decl) => {
        const symbol = this._toText(decl.identifier(0));
        let alias = null;
        if (decl.identifier().length > 1) {
          alias = this._toText(decl.identifier(1));
        }
        return [symbol, alias];
      });
      symbolAliasesIdentifiers = ctx.importDeclaration().map((decl) => {
        const symbolIdentifier = this.visitIdentifier(decl.identifier(0));
        let aliasIdentifier = null;
        if (decl.identifier().length > 1) {
          aliasIdentifier = this.visitIdentifier(decl.identifier(1));
        }
        return [symbolIdentifier, aliasIdentifier];
      });
    } else {
      const identifierCtxList = ctx.identifier();
      if (identifierCtxList.length === 0) {
      } else if (identifierCtxList.length === 1) {
        const aliasIdentifierCtx = ctx.identifier(0);
        unitAlias = this._toText(aliasIdentifierCtx);
        unitAliasIdentifier = this.visitIdentifier(aliasIdentifierCtx);
      } else if (identifierCtxList.length === 2) {
        const aliasIdentifierCtx = ctx.identifier(1);
        unitAlias = this._toText(aliasIdentifierCtx);
        unitAliasIdentifier = this.visitIdentifier(aliasIdentifierCtx);
      } else {
        throw new Error("Assertion error: an import should have one or two identifiers");
      }
    }
    const path = pathString.substring(1, pathString.length - 1);
    const pathLiteral = {
      type: "StringLiteral",
      value: path,
      parts: [path],
      isUnicode: [false]
    };
    const node = {
      type: "ImportDirective",
      path,
      pathLiteral: this._addMeta(pathLiteral, ctx.importPath()),
      unitAlias,
      unitAliasIdentifier,
      symbolAliases,
      symbolAliasesIdentifiers
    };
    return this._addMeta(node, ctx);
  }
  buildEventParameterList(ctx) {
    return ctx.eventParameter().map((paramCtx) => {
      const type = this.visit(paramCtx.typeName());
      let name = null;
      if (paramCtx.identifier()) {
        name = this._toText(paramCtx.identifier());
      }
      return {
        type: "VariableDeclaration",
        typeName: type,
        name,
        isStateVar: false,
        isIndexed: !!paramCtx.IndexedKeyword(0)
      };
    });
  }
  visitReturnParameters(ctx) {
    return this.visitParameterList(ctx.parameterList());
  }
  visitParameterList(ctx) {
    return ctx.parameter().map((paramCtx) => this.visitParameter(paramCtx));
  }
  visitInlineAssemblyStatement(ctx) {
    let language = null;
    if (ctx.StringLiteralFragment()) {
      language = this._toText(ctx.StringLiteralFragment());
      language = language.substring(1, language.length - 1);
    }
    const flags = [];
    const flag = ctx.inlineAssemblyStatementFlag();
    if (flag !== void 0) {
      const flagString = this._toText(flag.stringLiteral());
      flags.push(flagString.slice(1, flagString.length - 1));
    }
    const node = {
      type: "InlineAssemblyStatement",
      language,
      flags,
      body: this.visitAssemblyBlock(ctx.assemblyBlock())
    };
    return this._addMeta(node, ctx);
  }
  visitAssemblyBlock(ctx) {
    const operations = ctx.assemblyItem().map((item) => this.visitAssemblyItem(item));
    const node = {
      type: "AssemblyBlock",
      operations
    };
    return this._addMeta(node, ctx);
  }
  visitAssemblyItem(ctx) {
    let text;
    if (ctx.hexLiteral()) {
      return this.visitHexLiteral(ctx.hexLiteral());
    }
    if (ctx.stringLiteral()) {
      text = this._toText(ctx.stringLiteral());
      const value = text.substring(1, text.length - 1);
      const node = {
        type: "StringLiteral",
        value,
        parts: [value],
        isUnicode: [false]
      };
      return this._addMeta(node, ctx);
    }
    if (ctx.BreakKeyword()) {
      const node = {
        type: "Break"
      };
      return this._addMeta(node, ctx);
    }
    if (ctx.ContinueKeyword()) {
      const node = {
        type: "Continue"
      };
      return this._addMeta(node, ctx);
    }
    return this.visit(ctx.getChild(0));
  }
  visitAssemblyExpression(ctx) {
    return this.visit(ctx.getChild(0));
  }
  visitAssemblyCall(ctx) {
    const functionName = this._toText(ctx.getChild(0));
    const args = ctx.assemblyExpression().map((assemblyExpr) => this.visitAssemblyExpression(assemblyExpr));
    const node = {
      type: "AssemblyCall",
      functionName,
      arguments: args
    };
    return this._addMeta(node, ctx);
  }
  visitAssemblyLiteral(ctx) {
    let text;
    if (ctx.stringLiteral()) {
      text = this._toText(ctx);
      const value = text.substring(1, text.length - 1);
      const node = {
        type: "StringLiteral",
        value,
        parts: [value],
        isUnicode: [false]
      };
      return this._addMeta(node, ctx);
    }
    if (ctx.BooleanLiteral()) {
      const node = {
        type: "BooleanLiteral",
        value: this._toText(ctx.BooleanLiteral()) === "true"
      };
      return this._addMeta(node, ctx);
    }
    if (ctx.DecimalNumber()) {
      const node = {
        type: "DecimalNumber",
        value: this._toText(ctx)
      };
      return this._addMeta(node, ctx);
    }
    if (ctx.HexNumber()) {
      const node = {
        type: "HexNumber",
        value: this._toText(ctx)
      };
      return this._addMeta(node, ctx);
    }
    if (ctx.hexLiteral()) {
      return this.visitHexLiteral(ctx.hexLiteral());
    }
    throw new Error("Should never reach here");
  }
  visitAssemblySwitch(ctx) {
    const node = {
      type: "AssemblySwitch",
      expression: this.visitAssemblyExpression(ctx.assemblyExpression()),
      cases: ctx.assemblyCase().map((c) => this.visitAssemblyCase(c))
    };
    return this._addMeta(node, ctx);
  }
  visitAssemblyCase(ctx) {
    let value = null;
    if (this._toText(ctx.getChild(0)) === "case") {
      value = this.visitAssemblyLiteral(ctx.assemblyLiteral());
    }
    const node = {
      type: "AssemblyCase",
      block: this.visitAssemblyBlock(ctx.assemblyBlock()),
      value,
      default: value === null
    };
    return this._addMeta(node, ctx);
  }
  visitAssemblyLocalDefinition(ctx) {
    const ctxAssemblyIdentifierOrList = ctx.assemblyIdentifierOrList();
    let names;
    if (ctxAssemblyIdentifierOrList.identifier()) {
      names = [this.visitIdentifier(ctxAssemblyIdentifierOrList.identifier())];
    } else if (ctxAssemblyIdentifierOrList.assemblyMember()) {
      names = [
        this.visitAssemblyMember(ctxAssemblyIdentifierOrList.assemblyMember())
      ];
    } else {
      names = ctxAssemblyIdentifierOrList.assemblyIdentifierList().identifier().map((x) => this.visitIdentifier(x));
    }
    let expression = null;
    if (ctx.assemblyExpression() !== void 0) {
      expression = this.visitAssemblyExpression(ctx.assemblyExpression());
    }
    const node = {
      type: "AssemblyLocalDefinition",
      names,
      expression
    };
    return this._addMeta(node, ctx);
  }
  visitAssemblyFunctionDefinition(ctx) {
    const ctxAssemblyIdentifierList = ctx.assemblyIdentifierList();
    const args = ctxAssemblyIdentifierList !== void 0 ? ctxAssemblyIdentifierList.identifier().map((x) => this.visitIdentifier(x)) : [];
    const ctxAssemblyFunctionReturns = ctx.assemblyFunctionReturns();
    const returnArgs = ctxAssemblyFunctionReturns ? ctxAssemblyFunctionReturns.assemblyIdentifierList().identifier().map((x) => this.visitIdentifier(x)) : [];
    const node = {
      type: "AssemblyFunctionDefinition",
      name: this._toText(ctx.identifier()),
      arguments: args,
      returnArguments: returnArgs,
      body: this.visitAssemblyBlock(ctx.assemblyBlock())
    };
    return this._addMeta(node, ctx);
  }
  visitAssemblyAssignment(ctx) {
    const ctxAssemblyIdentifierOrList = ctx.assemblyIdentifierOrList();
    let names;
    if (ctxAssemblyIdentifierOrList.identifier()) {
      names = [this.visitIdentifier(ctxAssemblyIdentifierOrList.identifier())];
    } else if (ctxAssemblyIdentifierOrList.assemblyMember()) {
      names = [
        this.visitAssemblyMember(ctxAssemblyIdentifierOrList.assemblyMember())
      ];
    } else {
      names = ctxAssemblyIdentifierOrList.assemblyIdentifierList().identifier().map((x) => this.visitIdentifier(x));
    }
    const node = {
      type: "AssemblyAssignment",
      names,
      expression: this.visitAssemblyExpression(ctx.assemblyExpression())
    };
    return this._addMeta(node, ctx);
  }
  visitAssemblyMember(ctx) {
    const [accessed, member] = ctx.identifier();
    const node = {
      type: "AssemblyMemberAccess",
      expression: this.visitIdentifier(accessed),
      memberName: this.visitIdentifier(member)
    };
    return this._addMeta(node, ctx);
  }
  visitLabelDefinition(ctx) {
    const node = {
      type: "LabelDefinition",
      name: this._toText(ctx.identifier())
    };
    return this._addMeta(node, ctx);
  }
  visitAssemblyStackAssignment(ctx) {
    const node = {
      type: "AssemblyStackAssignment",
      name: this._toText(ctx.identifier()),
      expression: this.visitAssemblyExpression(ctx.assemblyExpression())
    };
    return this._addMeta(node, ctx);
  }
  visitAssemblyFor(ctx) {
    const node = {
      type: "AssemblyFor",
      pre: this.visit(ctx.getChild(1)),
      condition: this.visit(ctx.getChild(2)),
      post: this.visit(ctx.getChild(3)),
      body: this.visit(ctx.getChild(4))
    };
    return this._addMeta(node, ctx);
  }
  visitAssemblyIf(ctx) {
    const node = {
      type: "AssemblyIf",
      condition: this.visitAssemblyExpression(ctx.assemblyExpression()),
      body: this.visitAssemblyBlock(ctx.assemblyBlock())
    };
    return this._addMeta(node, ctx);
  }
  visitContinueStatement(ctx) {
    const node = {
      type: "ContinueStatement"
    };
    return this._addMeta(node, ctx);
  }
  visitBreakStatement(ctx) {
    const node = {
      type: "BreakStatement"
    };
    return this._addMeta(node, ctx);
  }
  _toText(ctx) {
    const text = ctx.text;
    if (text === void 0) {
      throw new Error("Assertion error: text should never be undefiend");
    }
    return text;
  }
  _stateMutabilityToText(ctx) {
    if (ctx.PureKeyword() !== void 0) {
      return "pure";
    }
    if (ctx.ConstantKeyword() !== void 0) {
      return "constant";
    }
    if (ctx.PayableKeyword() !== void 0) {
      return "payable";
    }
    if (ctx.ViewKeyword() !== void 0) {
      return "view";
    }
    throw new Error("Assertion error: non-exhaustive stateMutability check");
  }
  _loc(ctx) {
    const sourceLocation = {
      start: {
        line: ctx.start.line,
        column: ctx.start.charPositionInLine
      },
      end: {
        line: ctx.stop ? ctx.stop.line : ctx.start.line,
        column: ctx.stop ? ctx.stop.charPositionInLine : ctx.start.charPositionInLine
      }
    };
    return sourceLocation;
  }
  _range(ctx) {
    var _a, _b;
    return [ctx.start.startIndex, (_b = (_a = ctx.stop) == null ? void 0 : _a.stopIndex) != null ? _b : ctx.start.startIndex];
  }
  _addMeta(node, ctx) {
    const nodeWithMeta = {
      type: node.type
    };
    if (this.options.loc === true) {
      node.loc = this._loc(ctx);
    }
    if (this.options.range === true) {
      node.range = this._range(ctx);
    }
    return __objSpread(__objSpread({}, nodeWithMeta), node);
  }
  _mapCommasToNulls(children) {
    if (children.length === 0) {
      return [];
    }
    const values = [];
    let comma = true;
    for (const el of children) {
      if (comma) {
        if (this._toText(el) === ",") {
          values.push(null);
        } else {
          values.push(el);
          comma = false;
        }
      } else {
        if (this._toText(el) !== ",") {
          throw new Error("expected comma");
        }
        comma = true;
      }
    }
    if (comma) {
      values.push(null);
    }
    return values;
  }
};
function isBinOp(op) {
  return binaryOpValues.includes(op);
}

// src/ErrorListener.ts
var import_antlr4 = __toModule(require_antlr4());
var ErrorListener = class extends import_antlr4.default.error.ErrorListener {
  constructor() {
    super();
    this._errors = [];
  }
  syntaxError(recognizer, offendingSymbol, line, column, message) {
    this._errors.push({message, line, column});
  }
  getErrors() {
    return this._errors;
  }
  hasErrors() {
    return this._errors.length > 0;
  }
};
var ErrorListener_default = ErrorListener;

// src/tokens.ts
var import_tokens_string = __toModule(require_tokens_string());
var tokens = import_tokens_string.default;
var TYPE_TOKENS = [
  "var",
  "bool",
  "address",
  "string",
  "Int",
  "Uint",
  "Byte",
  "Fixed",
  "UFixed"
];
function rsplit(str, value) {
  const index = str.lastIndexOf(value);
  return [str.substring(0, index), str.substring(index + 1, str.length)];
}
function normalizeTokenType(value) {
  if (value.endsWith("'")) {
    value = value.substring(0, value.length - 1);
  }
  if (value.startsWith("'")) {
    value = value.substring(1, value.length);
  }
  return value;
}
function getTokenType(value) {
  if (value === "Identifier" || value === "from") {
    return "Identifier";
  } else if (value === "TrueLiteral" || value === "FalseLiteral") {
    return "Boolean";
  } else if (value === "VersionLiteral") {
    return "Version";
  } else if (value === "StringLiteral") {
    return "String";
  } else if (TYPE_TOKENS.includes(value)) {
    return "Type";
  } else if (value === "NumberUnit") {
    return "Subdenomination";
  } else if (value === "DecimalNumber") {
    return "Numeric";
  } else if (value === "HexLiteral") {
    return "Hex";
  } else if (value === "ReservedKeyword") {
    return "Reserved";
  } else if (/^\W+$/.test(value)) {
    return "Punctuator";
  } else {
    return "Keyword";
  }
}
function getTokenTypeMap() {
  return tokens.split("\n").map((line) => rsplit(line, "=")).reduce((acum, [value, key]) => {
    acum[parseInt(key, 10)] = normalizeTokenType(value);
    return acum;
  }, {});
}
function buildTokenList(tokensArg, options) {
  const tokenTypes = getTokenTypeMap();
  const result = tokensArg.map((token) => {
    var _a, _b;
    const type = getTokenType(tokenTypes[token.type]);
    const node = {type, value: token.text};
    if (options.range === true) {
      node.range = [token.startIndex, token.stopIndex + 1];
    }
    if (options.loc === true) {
      node.loc = {
        start: {line: token.line, column: token.charPositionInLine},
        end: {line: token.line, column: token.charPositionInLine + ((_b = (_a = token.text) == null ? void 0 : _a.length) != null ? _b : 0)}
      };
    }
    return node;
  });
  return result;
}

// src/parser.ts
var ParserError = class extends Error {
  constructor(args) {
    super();
    const {message, line, column} = args.errors[0];
    this.message = `${message} (${line}:${column})`;
    this.errors = args.errors;
    if (Error.captureStackTrace !== void 0) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
  }
};
function tokenize(input, options = {}) {
  const inputStream = new import_antlr4ts.ANTLRInputStream(input);
  const lexer = new SolidityLexer(inputStream);
  return buildTokenList(lexer.getAllTokens(), options);
}
function parse(input, options = {}) {
  const inputStream = new import_antlr4ts.ANTLRInputStream(input);
  const lexer = new SolidityLexer(inputStream);
  const tokenStream = new import_antlr4ts.CommonTokenStream(lexer);
  const parser = new SolidityParser(tokenStream);
  const listener = new ErrorListener_default();
  lexer.removeErrorListeners();
  lexer.addErrorListener(listener);
  parser.removeErrorListeners();
  parser.addErrorListener(listener);
  parser.buildParseTree = true;
  const sourceUnit = parser.sourceUnit();
  const astBuilder = new ASTBuilder(options);
  astBuilder.visit(sourceUnit);
  const ast = astBuilder.result;
  if (ast === null) {
    throw new Error("ast should never be null");
  }
  let tokenList = [];
  if (options.tokens === true) {
    tokenList = buildTokenList(tokenStream.getTokens(), options);
  }
  if (options.tolerant !== true && listener.hasErrors()) {
    throw new ParserError({errors: listener.getErrors()});
  }
  if (options.tolerant === true && listener.hasErrors()) {
    ast.errors = listener.getErrors();
  }
  if (options.tokens === true) {
    ast.tokens = tokenList;
  }
  return ast;
}
function _isASTNode(node) {
  if (typeof node !== "object" || node === null) {
    return false;
  }
  const nodeAsAny = node;
  if (Object.prototype.hasOwnProperty.call(nodeAsAny, "type") && typeof nodeAsAny.type === "string") {
    return astNodeTypes.includes(nodeAsAny.type);
  }
  return false;
}
function visit(node, visitor, nodeParent) {
  if (Array.isArray(node)) {
    node.forEach((child) => visit(child, visitor, nodeParent));
  }
  if (!_isASTNode(node))
    return;
  let cont = true;
  if (visitor[node.type] !== void 0) {
    cont = visitor[node.type](node, nodeParent);
  }
  if (cont === false)
    return;
  for (const prop in node) {
    if (Object.prototype.hasOwnProperty.call(node, prop)) {
      visit(node[prop], visitor, node);
    }
  }
  const selector = node.type + ":exit";
  if (visitor[selector] !== void 0) {
    visitor[selector](node, nodeParent);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (0);
/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
/*! https://mths.be/codepointat v0.2.0 by @mathias */
/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */
//# sourceMappingURL=index.cjs.js.map


/***/ }),

/***/ 6761:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const Utils = __nccwpck_require__(5182);
const pth = __nccwpck_require__(1017);
const ZipEntry = __nccwpck_require__(4057);
const ZipFile = __nccwpck_require__(7744);

const get_Bool = (val, def) => (typeof val === "boolean" ? val : def);
const get_Str = (val, def) => (typeof val === "string" ? val : def);

const defaultOptions = {
    // option "noSort" : if true it disables files sorting
    noSort: false,
    // read entries during load (initial loading may be slower)
    readEntries: false,
    // default method is none
    method: Utils.Constants.NONE,
    // file system
    fs: null
};

module.exports = function (/**String*/ input, /** object */ options) {
    let inBuffer = null;

    // create object based default options, allowing them to be overwritten
    const opts = Object.assign(Object.create(null), defaultOptions);

    // test input variable
    if (input && "object" === typeof input) {
        // if value is not buffer we accept it to be object with options
        if (!(input instanceof Uint8Array)) {
            Object.assign(opts, input);
            input = opts.input ? opts.input : undefined;
            if (opts.input) delete opts.input;
        }

        // if input is buffer
        if (Buffer.isBuffer(input)) {
            inBuffer = input;
            opts.method = Utils.Constants.BUFFER;
            input = undefined;
        }
    }

    // assign options
    Object.assign(opts, options);

    // instanciate utils filesystem
    const filetools = new Utils(opts);

    // if input is file name we retrieve its content
    if (input && "string" === typeof input) {
        // load zip file
        if (filetools.fs.existsSync(input)) {
            opts.method = Utils.Constants.FILE;
            opts.filename = input;
            inBuffer = filetools.fs.readFileSync(input);
        } else {
            throw new Error(Utils.Errors.INVALID_FILENAME);
        }
    }

    // create variable
    const _zip = new ZipFile(inBuffer, opts);

    const { canonical, sanitize } = Utils;

    function getEntry(/**Object*/ entry) {
        if (entry && _zip) {
            var item;
            // If entry was given as a file name
            if (typeof entry === "string") item = _zip.getEntry(entry);
            // if entry was given as a ZipEntry object
            if (typeof entry === "object" && typeof entry.entryName !== "undefined" && typeof entry.header !== "undefined") item = _zip.getEntry(entry.entryName);

            if (item) {
                return item;
            }
        }
        return null;
    }

    function fixPath(zipPath) {
        const { join, normalize, sep } = pth.posix;
        // convert windows file separators and normalize
        return join(".", normalize(sep + zipPath.split("\\").join(sep) + sep));
    }

    return {
        /**
         * Extracts the given entry from the archive and returns the content as a Buffer object
         * @param entry ZipEntry object or String with the full path of the entry
         *
         * @return Buffer or Null in case of error
         */
        readFile: function (/**Object*/ entry, /*String, Buffer*/ pass) {
            var item = getEntry(entry);
            return (item && item.getData(pass)) || null;
        },

        /**
         * Asynchronous readFile
         * @param entry ZipEntry object or String with the full path of the entry
         * @param callback
         *
         * @return Buffer or Null in case of error
         */
        readFileAsync: function (/**Object*/ entry, /**Function*/ callback) {
            var item = getEntry(entry);
            if (item) {
                item.getDataAsync(callback);
            } else {
                callback(null, "getEntry failed for:" + entry);
            }
        },

        /**
         * Extracts the given entry from the archive and returns the content as plain text in the given encoding
         * @param entry ZipEntry object or String with the full path of the entry
         * @param encoding Optional. If no encoding is specified utf8 is used
         *
         * @return String
         */
        readAsText: function (/**Object*/ entry, /**String=*/ encoding) {
            var item = getEntry(entry);
            if (item) {
                var data = item.getData();
                if (data && data.length) {
                    return data.toString(encoding || "utf8");
                }
            }
            return "";
        },

        /**
         * Asynchronous readAsText
         * @param entry ZipEntry object or String with the full path of the entry
         * @param callback
         * @param encoding Optional. If no encoding is specified utf8 is used
         *
         * @return String
         */
        readAsTextAsync: function (/**Object*/ entry, /**Function*/ callback, /**String=*/ encoding) {
            var item = getEntry(entry);
            if (item) {
                item.getDataAsync(function (data, err) {
                    if (err) {
                        callback(data, err);
                        return;
                    }

                    if (data && data.length) {
                        callback(data.toString(encoding || "utf8"));
                    } else {
                        callback("");
                    }
                });
            } else {
                callback("");
            }
        },

        /**
         * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory
         *
         * @param entry
         */
        deleteFile: function (/**Object*/ entry) {
            // @TODO: test deleteFile
            var item = getEntry(entry);
            if (item) {
                _zip.deleteEntry(item.entryName);
            }
        },

        /**
         * Adds a comment to the zip. The zip must be rewritten after adding the comment.
         *
         * @param comment
         */
        addZipComment: function (/**String*/ comment) {
            // @TODO: test addZipComment
            _zip.comment = comment;
        },

        /**
         * Returns the zip comment
         *
         * @return String
         */
        getZipComment: function () {
            return _zip.comment || "";
        },

        /**
         * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment
         * The comment cannot exceed 65535 characters in length
         *
         * @param entry
         * @param comment
         */
        addZipEntryComment: function (/**Object*/ entry, /**String*/ comment) {
            var item = getEntry(entry);
            if (item) {
                item.comment = comment;
            }
        },

        /**
         * Returns the comment of the specified entry
         *
         * @param entry
         * @return String
         */
        getZipEntryComment: function (/**Object*/ entry) {
            var item = getEntry(entry);
            if (item) {
                return item.comment || "";
            }
            return "";
        },

        /**
         * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content
         *
         * @param entry
         * @param content
         */
        updateFile: function (/**Object*/ entry, /**Buffer*/ content) {
            var item = getEntry(entry);
            if (item) {
                item.setData(content);
            }
        },

        /**
         * Adds a file from the disk to the archive
         *
         * @param localPath File to add to zip
         * @param zipPath Optional path inside the zip
         * @param zipName Optional name for the file
         */
        addLocalFile: function (/**String*/ localPath, /**String=*/ zipPath, /**String=*/ zipName, /**String*/ comment) {
            if (filetools.fs.existsSync(localPath)) {
                // fix ZipPath
                zipPath = zipPath ? fixPath(zipPath) : "";

                // p - local file name
                var p = localPath.split("\\").join("/").split("/").pop();

                // add file name into zippath
                zipPath += zipName ? zipName : p;

                // read file attributes
                const _attr = filetools.fs.statSync(localPath);

                // add file into zip file
                this.addFile(zipPath, filetools.fs.readFileSync(localPath), comment, _attr);
            } else {
                throw new Error(Utils.Errors.FILE_NOT_FOUND.replace("%s", localPath));
            }
        },

        /**
         * Adds a local directory and all its nested files and directories to the archive
         *
         * @param localPath
         * @param zipPath optional path inside zip
         * @param filter optional RegExp or Function if files match will
         *               be included.
         * @param {number | object} attr - number as unix file permissions, object as filesystem Stats object
         */
        addLocalFolder: function (/**String*/ localPath, /**String=*/ zipPath, /**=RegExp|Function*/ filter, /**=number|object*/ attr) {
            // Prepare filter
            if (filter instanceof RegExp) {
                // if filter is RegExp wrap it
                filter = (function (rx) {
                    return function (filename) {
                        return rx.test(filename);
                    };
                })(filter);
            } else if ("function" !== typeof filter) {
                // if filter is not function we will replace it
                filter = function () {
                    return true;
                };
            }

            // fix ZipPath
            zipPath = zipPath ? fixPath(zipPath) : "";

            // normalize the path first
            localPath = pth.normalize(localPath);

            if (filetools.fs.existsSync(localPath)) {
                const items = filetools.findFiles(localPath);
                const self = this;

                if (items.length) {
                    items.forEach(function (filepath) {
                        var p = pth.relative(localPath, filepath).split("\\").join("/"); //windows fix
                        if (filter(p)) {
                            var stats = filetools.fs.statSync(filepath);
                            if (stats.isFile()) {
                                self.addFile(zipPath + p, filetools.fs.readFileSync(filepath), "", attr ? attr : stats);
                            } else {
                                self.addFile(zipPath + p + "/", Buffer.alloc(0), "", attr ? attr : stats);
                            }
                        }
                    });
                }
            } else {
                throw new Error(Utils.Errors.FILE_NOT_FOUND.replace("%s", localPath));
            }
        },

        /**
         * Asynchronous addLocalFile
         * @param localPath
         * @param callback
         * @param zipPath optional path inside zip
         * @param filter optional RegExp or Function if files match will
         *               be included.
         */
        addLocalFolderAsync: function (/*String*/ localPath, /*Function*/ callback, /*String*/ zipPath, /*RegExp|Function*/ filter) {
            if (filter instanceof RegExp) {
                filter = (function (rx) {
                    return function (filename) {
                        return rx.test(filename);
                    };
                })(filter);
            } else if ("function" !== typeof filter) {
                filter = function () {
                    return true;
                };
            }

            // fix ZipPath
            zipPath = zipPath ? fixPath(zipPath) : "";

            // normalize the path first
            localPath = pth.normalize(localPath);

            var self = this;
            filetools.fs.open(localPath, "r", function (err) {
                if (err && err.code === "ENOENT") {
                    callback(undefined, Utils.Errors.FILE_NOT_FOUND.replace("%s", localPath));
                } else if (err) {
                    callback(undefined, err);
                } else {
                    var items = filetools.findFiles(localPath);
                    var i = -1;

                    var next = function () {
                        i += 1;
                        if (i < items.length) {
                            var filepath = items[i];
                            var p = pth.relative(localPath, filepath).split("\\").join("/"); //windows fix
                            p = p
                                .normalize("NFD")
                                .replace(/[\u0300-\u036f]/g, "")
                                .replace(/[^\x20-\x7E]/g, ""); // accent fix
                            if (filter(p)) {
                                filetools.fs.stat(filepath, function (er0, stats) {
                                    if (er0) callback(undefined, er0);
                                    if (stats.isFile()) {
                                        filetools.fs.readFile(filepath, function (er1, data) {
                                            if (er1) {
                                                callback(undefined, er1);
                                            } else {
                                                self.addFile(zipPath + p, data, "", stats);
                                                next();
                                            }
                                        });
                                    } else {
                                        self.addFile(zipPath + p + "/", Buffer.alloc(0), "", stats);
                                        next();
                                    }
                                });
                            } else {
                                process.nextTick(() => {
                                    next();
                                });
                            }
                        } else {
                            callback(true, undefined);
                        }
                    };

                    next();
                }
            });
        },

        /**
         *
         * @param {string} localPath - path where files will be extracted
         * @param {object} props - optional properties
         * @param {string} props.zipPath - optional path inside zip
         * @param {regexp, function} props.filter - RegExp or Function if files match will be included.
         */
        addLocalFolderPromise: function (/*String*/ localPath, /* object */ props) {
            return new Promise((resolve, reject) => {
                const { filter, zipPath } = Object.assign({}, props);
                this.addLocalFolderAsync(
                    localPath,
                    (done, err) => {
                        if (err) reject(err);
                        if (done) resolve(this);
                    },
                    zipPath,
                    filter
                );
            });
        },

        /**
         * Allows you to create a entry (file or directory) in the zip file.
         * If you want to create a directory the entryName must end in / and a null buffer should be provided.
         * Comment and attributes are optional
         *
         * @param {string} entryName
         * @param {Buffer | string} content - file content as buffer or utf8 coded string
         * @param {string} comment - file comment
         * @param {number | object} attr - number as unix file permissions, object as filesystem Stats object
         */
        addFile: function (/**String*/ entryName, /**Buffer*/ content, /**String*/ comment, /**Number*/ attr) {
            let entry = getEntry(entryName);
            const update = entry != null;

            // prepare new entry
            if (!update) {
                entry = new ZipEntry();
                entry.entryName = entryName;
            }
            entry.comment = comment || "";

            const isStat = "object" === typeof attr && attr instanceof filetools.fs.Stats;

            // last modification time from file stats
            if (isStat) {
                entry.header.time = attr.mtime;
            }

            // Set file attribute
            var fileattr = entry.isDirectory ? 0x10 : 0; // (MS-DOS directory flag)

            // extended attributes field for Unix
            // set file type either S_IFDIR / S_IFREG
            let unix = entry.isDirectory ? 0x4000 : 0x8000;

            if (isStat) {
                // File attributes from file stats
                unix |= 0xfff & attr.mode;
            } else if ("number" === typeof attr) {
                // attr from given attr values
                unix |= 0xfff & attr;
            } else {
                // Default values:
                unix |= entry.isDirectory ? 0o755 : 0o644; // permissions (drwxr-xr-x) or (-r-wr--r--)
            }

            fileattr = (fileattr | (unix << 16)) >>> 0; // add attributes

            entry.attr = fileattr;

            entry.setData(content);
            if (!update) _zip.setEntry(entry);
        },

        /**
         * Returns an array of ZipEntry objects representing the files and folders inside the archive
         *
         * @return Array
         */
        getEntries: function () {
            return _zip ? _zip.entries : [];
        },

        /**
         * Returns a ZipEntry object representing the file or folder specified by ``name``.
         *
         * @param name
         * @return ZipEntry
         */
        getEntry: function (/**String*/ name) {
            return getEntry(name);
        },

        getEntryCount: function () {
            return _zip.getEntryCount();
        },

        forEach: function (callback) {
            return _zip.forEach(callback);
        },

        /**
         * Extracts the given entry to the given targetPath
         * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted
         *
         * @param entry ZipEntry object or String with the full path of the entry
         * @param targetPath Target folder where to write the file
         * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder
         *                          will be created in targetPath as well. Default is TRUE
         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
         *                  Default is FALSE
         * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.
         *                  Default is FALSE
         * @param outFileName String If set will override the filename of the extracted file (Only works if the entry is a file)
         *
         * @return Boolean
         */
        extractEntryTo: function (
            /**Object*/ entry,
            /**String*/ targetPath,
            /**Boolean*/ maintainEntryPath,
            /**Boolean*/ overwrite,
            /**Boolean*/ keepOriginalPermission,
            /**String**/ outFileName
        ) {
            overwrite = get_Bool(overwrite, false);
            keepOriginalPermission = get_Bool(keepOriginalPermission, false);
            maintainEntryPath = get_Bool(maintainEntryPath, true);
            outFileName = get_Str(outFileName, get_Str(keepOriginalPermission, undefined));

            var item = getEntry(entry);
            if (!item) {
                throw new Error(Utils.Errors.NO_ENTRY);
            }

            var entryName = canonical(item.entryName);

            var target = sanitize(targetPath, outFileName && !item.isDirectory ? outFileName : maintainEntryPath ? entryName : pth.basename(entryName));

            if (item.isDirectory) {
                var children = _zip.getEntryChildren(item);
                children.forEach(function (child) {
                    if (child.isDirectory) return;
                    var content = child.getData();
                    if (!content) {
                        throw new Error(Utils.Errors.CANT_EXTRACT_FILE);
                    }
                    var name = canonical(child.entryName);
                    var childName = sanitize(targetPath, maintainEntryPath ? name : pth.basename(name));
                    // The reverse operation for attr depend on method addFile()
                    const fileAttr = keepOriginalPermission ? child.header.fileAttr : undefined;
                    filetools.writeFileTo(childName, content, overwrite, fileAttr);
                });
                return true;
            }

            var content = item.getData();
            if (!content) throw new Error(Utils.Errors.CANT_EXTRACT_FILE);

            if (filetools.fs.existsSync(target) && !overwrite) {
                throw new Error(Utils.Errors.CANT_OVERRIDE);
            }
            // The reverse operation for attr depend on method addFile()
            const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;
            filetools.writeFileTo(target, content, overwrite, fileAttr);

            return true;
        },

        /**
         * Test the archive
         *
         */
        test: function (pass) {
            if (!_zip) {
                return false;
            }

            for (var entry in _zip.entries) {
                try {
                    if (entry.isDirectory) {
                        continue;
                    }
                    var content = _zip.entries[entry].getData(pass);
                    if (!content) {
                        return false;
                    }
                } catch (err) {
                    return false;
                }
            }
            return true;
        },

        /**
         * Extracts the entire archive to the given location
         *
         * @param targetPath Target location
         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
         *                  Default is FALSE
         * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.
         *                  Default is FALSE
         */
        extractAllTo: function (/**String*/ targetPath, /**Boolean*/ overwrite, /**Boolean*/ keepOriginalPermission, /*String, Buffer*/ pass) {
            overwrite = get_Bool(overwrite, false);
            pass = get_Str(keepOriginalPermission, pass);
            keepOriginalPermission = get_Bool(keepOriginalPermission, false);
            if (!_zip) {
                throw new Error(Utils.Errors.NO_ZIP);
            }
            _zip.entries.forEach(function (entry) {
                var entryName = sanitize(targetPath, canonical(entry.entryName.toString()));
                if (entry.isDirectory) {
                    filetools.makeDir(entryName);
                    return;
                }
                var content = entry.getData(pass);
                if (!content) {
                    throw new Error(Utils.Errors.CANT_EXTRACT_FILE);
                }
                // The reverse operation for attr depend on method addFile()
                const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;
                filetools.writeFileTo(entryName, content, overwrite, fileAttr);
                try {
                    filetools.fs.utimesSync(entryName, entry.header.time, entry.header.time);
                } catch (err) {
                    throw new Error(Utils.Errors.CANT_EXTRACT_FILE);
                }
            });
        },

        /**
         * Asynchronous extractAllTo
         *
         * @param targetPath Target location
         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
         *                  Default is FALSE
         * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.
         *                  Default is FALSE
         * @param callback The callback will be executed when all entries are extracted successfully or any error is thrown.
         */
        extractAllToAsync: function (/**String*/ targetPath, /**Boolean*/ overwrite, /**Boolean*/ keepOriginalPermission, /**Function*/ callback) {
            overwrite = get_Bool(overwrite, false);
            if (typeof keepOriginalPermission === "function" && !callback) callback = keepOriginalPermission;
            keepOriginalPermission = get_Bool(keepOriginalPermission, false);
            if (!callback) {
                callback = function (err) {
                    throw new Error(err);
                };
            }
            if (!_zip) {
                callback(new Error(Utils.Errors.NO_ZIP));
                return;
            }

            targetPath = pth.resolve(targetPath);
            // convert entryName to
            const getPath = (entry) => sanitize(targetPath, pth.normalize(canonical(entry.entryName.toString())));
            const getError = (msg, file) => new Error(msg + ': "' + file + '"');

            // separate directories from files
            const dirEntries = [];
            const fileEntries = new Set();
            _zip.entries.forEach((e) => {
                if (e.isDirectory) {
                    dirEntries.push(e);
                } else {
                    fileEntries.add(e);
                }
            });

            // Create directory entries first synchronously
            // this prevents race condition and assures folders are there before writing files
            for (const entry of dirEntries) {
                const dirPath = getPath(entry);
                // The reverse operation for attr depend on method addFile()
                const dirAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;
                try {
                    filetools.makeDir(dirPath);
                    if (dirAttr) filetools.fs.chmodSync(dirPath, dirAttr);
                    // in unix timestamp will change if files are later added to folder, but still
                    filetools.fs.utimesSync(dirPath, entry.header.time, entry.header.time);
                } catch (er) {
                    callback(getError("Unable to create folder", dirPath));
                }
            }

            // callback wrapper, for some house keeping
            const done = () => {
                if (fileEntries.size === 0) {
                    callback();
                }
            };

            // Extract file entries asynchronously
            for (const entry of fileEntries.values()) {
                const entryName = pth.normalize(canonical(entry.entryName.toString()));
                const filePath = sanitize(targetPath, entryName);
                entry.getDataAsync(function (content, err_1) {
                    if (err_1) {
                        callback(new Error(err_1));
                        return;
                    }
                    if (!content) {
                        callback(new Error(Utils.Errors.CANT_EXTRACT_FILE));
                    } else {
                        // The reverse operation for attr depend on method addFile()
                        const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;
                        filetools.writeFileToAsync(filePath, content, overwrite, fileAttr, function (succ) {
                            if (!succ) {
                                callback(getError("Unable to write file", filePath));
                                return;
                            }
                            filetools.fs.utimes(filePath, entry.header.time, entry.header.time, function (err_2) {
                                if (err_2) {
                                    callback(getError("Unable to set times", filePath));
                                    return;
                                }
                                fileEntries.delete(entry);
                                // call the callback if it was last entry
                                done();
                            });
                        });
                    }
                });
            }
            // call the callback if fileEntries was empty
            done();
        },

        /**
         * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip
         *
         * @param targetFileName
         * @param callback
         */
        writeZip: function (/**String*/ targetFileName, /**Function*/ callback) {
            if (arguments.length === 1) {
                if (typeof targetFileName === "function") {
                    callback = targetFileName;
                    targetFileName = "";
                }
            }

            if (!targetFileName && opts.filename) {
                targetFileName = opts.filename;
            }
            if (!targetFileName) return;

            var zipData = _zip.compressToBuffer();
            if (zipData) {
                var ok = filetools.writeFileTo(targetFileName, zipData, true);
                if (typeof callback === "function") callback(!ok ? new Error("failed") : null, "");
            }
        },

        writeZipPromise: function (/**String*/ targetFileName, /* object */ props) {
            const { overwrite, perm } = Object.assign({ overwrite: true }, props);

            return new Promise((resolve, reject) => {
                // find file name
                if (!targetFileName && opts.filename) targetFileName = opts.filename;
                if (!targetFileName) reject("ADM-ZIP: ZIP File Name Missing");

                this.toBufferPromise().then((zipData) => {
                    const ret = (done) => (done ? resolve(done) : reject("ADM-ZIP: Wasn't able to write zip file"));
                    filetools.writeFileToAsync(targetFileName, zipData, overwrite, perm, ret);
                }, reject);
            });
        },

        toBufferPromise: function () {
            return new Promise((resolve, reject) => {
                _zip.toAsyncBuffer(resolve, reject);
            });
        },

        /**
         * Returns the content of the entire zip file as a Buffer object
         *
         * @return Buffer
         */
        toBuffer: function (/**Function=*/ onSuccess, /**Function=*/ onFail, /**Function=*/ onItemStart, /**Function=*/ onItemEnd) {
            this.valueOf = 2;
            if (typeof onSuccess === "function") {
                _zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);
                return null;
            }
            return _zip.compressToBuffer();
        }
    };
};


/***/ }),

/***/ 9032:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Utils = __nccwpck_require__(5182),
    Constants = Utils.Constants;

/* The central directory file header */
module.exports = function () {
    var _verMade = 20, // v2.0
        _version = 10, // v1.0
        _flags = 0,
        _method = 0,
        _time = 0,
        _crc = 0,
        _compressedSize = 0,
        _size = 0,
        _fnameLen = 0,
        _extraLen = 0,
        _comLen = 0,
        _diskStart = 0,
        _inattr = 0,
        _attr = 0,
        _offset = 0;

    _verMade |= Utils.isWin ? 0x0a00 : 0x0300;

    // Set EFS flag since filename and comment fields are all by default encoded using UTF-8.
    // Without it file names may be corrupted for other apps when file names use unicode chars
    _flags |= Constants.FLG_EFS;

    var _dataHeader = {};

    function setTime(val) {
        val = new Date(val);
        _time =
            (((val.getFullYear() - 1980) & 0x7f) << 25) | // b09-16 years from 1980
            ((val.getMonth() + 1) << 21) | // b05-08 month
            (val.getDate() << 16) | // b00-04 hour
            // 2 bytes time
            (val.getHours() << 11) | // b11-15 hour
            (val.getMinutes() << 5) | // b05-10 minute
            (val.getSeconds() >> 1); // b00-04 seconds divided by 2
    }

    setTime(+new Date());

    return {
        get made() {
            return _verMade;
        },
        set made(val) {
            _verMade = val;
        },

        get version() {
            return _version;
        },
        set version(val) {
            _version = val;
        },

        get flags() {
            return _flags;
        },
        set flags(val) {
            _flags = val;
        },

        get method() {
            return _method;
        },
        set method(val) {
            switch (val) {
                case Constants.STORED:
                    this.version = 10;
                case Constants.DEFLATED:
                default:
                    this.version = 20;
            }
            _method = val;
        },

        get time() {
            return new Date(((_time >> 25) & 0x7f) + 1980, ((_time >> 21) & 0x0f) - 1, (_time >> 16) & 0x1f, (_time >> 11) & 0x1f, (_time >> 5) & 0x3f, (_time & 0x1f) << 1);
        },
        set time(val) {
            setTime(val);
        },

        get crc() {
            return _crc;
        },
        set crc(val) {
            _crc = Math.max(0, val) >>> 0;
        },

        get compressedSize() {
            return _compressedSize;
        },
        set compressedSize(val) {
            _compressedSize = Math.max(0, val) >>> 0;
        },

        get size() {
            return _size;
        },
        set size(val) {
            _size = Math.max(0, val) >>> 0;
        },

        get fileNameLength() {
            return _fnameLen;
        },
        set fileNameLength(val) {
            _fnameLen = val;
        },

        get extraLength() {
            return _extraLen;
        },
        set extraLength(val) {
            _extraLen = val;
        },

        get commentLength() {
            return _comLen;
        },
        set commentLength(val) {
            _comLen = val;
        },

        get diskNumStart() {
            return _diskStart;
        },
        set diskNumStart(val) {
            _diskStart = Math.max(0, val) >>> 0;
        },

        get inAttr() {
            return _inattr;
        },
        set inAttr(val) {
            _inattr = Math.max(0, val) >>> 0;
        },

        get attr() {
            return _attr;
        },
        set attr(val) {
            _attr = Math.max(0, val) >>> 0;
        },

        // get Unix file permissions
        get fileAttr() {
            return _attr ? (((_attr >>> 0) | 0) >> 16) & 0xfff : 0;
        },

        get offset() {
            return _offset;
        },
        set offset(val) {
            _offset = Math.max(0, val) >>> 0;
        },

        get encripted() {
            return (_flags & 1) === 1;
        },

        get entryHeaderSize() {
            return Constants.CENHDR + _fnameLen + _extraLen + _comLen;
        },

        get realDataOffset() {
            return _offset + Constants.LOCHDR + _dataHeader.fnameLen + _dataHeader.extraLen;
        },

        get dataHeader() {
            return _dataHeader;
        },

        loadDataHeaderFromBinary: function (/*Buffer*/ input) {
            var data = input.slice(_offset, _offset + Constants.LOCHDR);
            // 30 bytes and should start with "PK\003\004"
            if (data.readUInt32LE(0) !== Constants.LOCSIG) {
                throw new Error(Utils.Errors.INVALID_LOC);
            }
            _dataHeader = {
                // version needed to extract
                version: data.readUInt16LE(Constants.LOCVER),
                // general purpose bit flag
                flags: data.readUInt16LE(Constants.LOCFLG),
                // compression method
                method: data.readUInt16LE(Constants.LOCHOW),
                // modification time (2 bytes time, 2 bytes date)
                time: data.readUInt32LE(Constants.LOCTIM),
                // uncompressed file crc-32 value
                crc: data.readUInt32LE(Constants.LOCCRC),
                // compressed size
                compressedSize: data.readUInt32LE(Constants.LOCSIZ),
                // uncompressed size
                size: data.readUInt32LE(Constants.LOCLEN),
                // filename length
                fnameLen: data.readUInt16LE(Constants.LOCNAM),
                // extra field length
                extraLen: data.readUInt16LE(Constants.LOCEXT)
            };
        },

        loadFromBinary: function (/*Buffer*/ data) {
            // data should be 46 bytes and start with "PK 01 02"
            if (data.length !== Constants.CENHDR || data.readUInt32LE(0) !== Constants.CENSIG) {
                throw new Error(Utils.Errors.INVALID_CEN);
            }
            // version made by
            _verMade = data.readUInt16LE(Constants.CENVEM);
            // version needed to extract
            _version = data.readUInt16LE(Constants.CENVER);
            // encrypt, decrypt flags
            _flags = data.readUInt16LE(Constants.CENFLG);
            // compression method
            _method = data.readUInt16LE(Constants.CENHOW);
            // modification time (2 bytes time, 2 bytes date)
            _time = data.readUInt32LE(Constants.CENTIM);
            // uncompressed file crc-32 value
            _crc = data.readUInt32LE(Constants.CENCRC);
            // compressed size
            _compressedSize = data.readUInt32LE(Constants.CENSIZ);
            // uncompressed size
            _size = data.readUInt32LE(Constants.CENLEN);
            // filename length
            _fnameLen = data.readUInt16LE(Constants.CENNAM);
            // extra field length
            _extraLen = data.readUInt16LE(Constants.CENEXT);
            // file comment length
            _comLen = data.readUInt16LE(Constants.CENCOM);
            // volume number start
            _diskStart = data.readUInt16LE(Constants.CENDSK);
            // internal file attributes
            _inattr = data.readUInt16LE(Constants.CENATT);
            // external file attributes
            _attr = data.readUInt32LE(Constants.CENATX);
            // LOC header offset
            _offset = data.readUInt32LE(Constants.CENOFF);
        },

        dataHeaderToBinary: function () {
            // LOC header size (30 bytes)
            var data = Buffer.alloc(Constants.LOCHDR);
            // "PK\003\004"
            data.writeUInt32LE(Constants.LOCSIG, 0);
            // version needed to extract
            data.writeUInt16LE(_version, Constants.LOCVER);
            // general purpose bit flag
            data.writeUInt16LE(_flags, Constants.LOCFLG);
            // compression method
            data.writeUInt16LE(_method, Constants.LOCHOW);
            // modification time (2 bytes time, 2 bytes date)
            data.writeUInt32LE(_time, Constants.LOCTIM);
            // uncompressed file crc-32 value
            data.writeUInt32LE(_crc, Constants.LOCCRC);
            // compressed size
            data.writeUInt32LE(_compressedSize, Constants.LOCSIZ);
            // uncompressed size
            data.writeUInt32LE(_size, Constants.LOCLEN);
            // filename length
            data.writeUInt16LE(_fnameLen, Constants.LOCNAM);
            // extra field length
            data.writeUInt16LE(_extraLen, Constants.LOCEXT);
            return data;
        },

        entryHeaderToBinary: function () {
            // CEN header size (46 bytes)
            var data = Buffer.alloc(Constants.CENHDR + _fnameLen + _extraLen + _comLen);
            // "PK\001\002"
            data.writeUInt32LE(Constants.CENSIG, 0);
            // version made by
            data.writeUInt16LE(_verMade, Constants.CENVEM);
            // version needed to extract
            data.writeUInt16LE(_version, Constants.CENVER);
            // encrypt, decrypt flags
            data.writeUInt16LE(_flags, Constants.CENFLG);
            // compression method
            data.writeUInt16LE(_method, Constants.CENHOW);
            // modification time (2 bytes time, 2 bytes date)
            data.writeUInt32LE(_time, Constants.CENTIM);
            // uncompressed file crc-32 value
            data.writeUInt32LE(_crc, Constants.CENCRC);
            // compressed size
            data.writeUInt32LE(_compressedSize, Constants.CENSIZ);
            // uncompressed size
            data.writeUInt32LE(_size, Constants.CENLEN);
            // filename length
            data.writeUInt16LE(_fnameLen, Constants.CENNAM);
            // extra field length
            data.writeUInt16LE(_extraLen, Constants.CENEXT);
            // file comment length
            data.writeUInt16LE(_comLen, Constants.CENCOM);
            // volume number start
            data.writeUInt16LE(_diskStart, Constants.CENDSK);
            // internal file attributes
            data.writeUInt16LE(_inattr, Constants.CENATT);
            // external file attributes
            data.writeUInt32LE(_attr, Constants.CENATX);
            // LOC header offset
            data.writeUInt32LE(_offset, Constants.CENOFF);
            // fill all with
            data.fill(0x00, Constants.CENHDR);
            return data;
        },

        toJSON: function () {
            const bytes = function (nr) {
                return nr + " bytes";
            };

            return {
                made: _verMade,
                version: _version,
                flags: _flags,
                method: Utils.methodToString(_method),
                time: this.time,
                crc: "0x" + _crc.toString(16).toUpperCase(),
                compressedSize: bytes(_compressedSize),
                size: bytes(_size),
                fileNameLength: bytes(_fnameLen),
                extraLength: bytes(_extraLen),
                commentLength: bytes(_comLen),
                diskNumStart: _diskStart,
                inAttr: _inattr,
                attr: _attr,
                offset: _offset,
                entryHeaderSize: bytes(Constants.CENHDR + _fnameLen + _extraLen + _comLen)
            };
        },

        toString: function () {
            return JSON.stringify(this.toJSON(), null, "\t");
        }
    };
};


/***/ }),

/***/ 4958:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

exports.EntryHeader = __nccwpck_require__(9032);
exports.MainHeader = __nccwpck_require__(4408);


/***/ }),

/***/ 4408:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Utils = __nccwpck_require__(5182),
    Constants = Utils.Constants;

/* The entries in the end of central directory */
module.exports = function () {
    var _volumeEntries = 0,
        _totalEntries = 0,
        _size = 0,
        _offset = 0,
        _commentLength = 0;

    return {
        get diskEntries() {
            return _volumeEntries;
        },
        set diskEntries(/*Number*/ val) {
            _volumeEntries = _totalEntries = val;
        },

        get totalEntries() {
            return _totalEntries;
        },
        set totalEntries(/*Number*/ val) {
            _totalEntries = _volumeEntries = val;
        },

        get size() {
            return _size;
        },
        set size(/*Number*/ val) {
            _size = val;
        },

        get offset() {
            return _offset;
        },
        set offset(/*Number*/ val) {
            _offset = val;
        },

        get commentLength() {
            return _commentLength;
        },
        set commentLength(/*Number*/ val) {
            _commentLength = val;
        },

        get mainHeaderSize() {
            return Constants.ENDHDR + _commentLength;
        },

        loadFromBinary: function (/*Buffer*/ data) {
            // data should be 22 bytes and start with "PK 05 06"
            // or be 56+ bytes and start with "PK 06 06" for Zip64
            if (
                (data.length !== Constants.ENDHDR || data.readUInt32LE(0) !== Constants.ENDSIG) &&
                (data.length < Constants.ZIP64HDR || data.readUInt32LE(0) !== Constants.ZIP64SIG)
            ) {
                throw new Error(Utils.Errors.INVALID_END);
            }

            if (data.readUInt32LE(0) === Constants.ENDSIG) {
                // number of entries on this volume
                _volumeEntries = data.readUInt16LE(Constants.ENDSUB);
                // total number of entries
                _totalEntries = data.readUInt16LE(Constants.ENDTOT);
                // central directory size in bytes
                _size = data.readUInt32LE(Constants.ENDSIZ);
                // offset of first CEN header
                _offset = data.readUInt32LE(Constants.ENDOFF);
                // zip file comment length
                _commentLength = data.readUInt16LE(Constants.ENDCOM);
            } else {
                // number of entries on this volume
                _volumeEntries = Utils.readBigUInt64LE(data, Constants.ZIP64SUB);
                // total number of entries
                _totalEntries = Utils.readBigUInt64LE(data, Constants.ZIP64TOT);
                // central directory size in bytes
                _size = Utils.readBigUInt64LE(data, Constants.ZIP64SIZE);
                // offset of first CEN header
                _offset = Utils.readBigUInt64LE(data, Constants.ZIP64OFF);

                _commentLength = 0;
            }
        },

        toBinary: function () {
            var b = Buffer.alloc(Constants.ENDHDR + _commentLength);
            // "PK 05 06" signature
            b.writeUInt32LE(Constants.ENDSIG, 0);
            b.writeUInt32LE(0, 4);
            // number of entries on this volume
            b.writeUInt16LE(_volumeEntries, Constants.ENDSUB);
            // total number of entries
            b.writeUInt16LE(_totalEntries, Constants.ENDTOT);
            // central directory size in bytes
            b.writeUInt32LE(_size, Constants.ENDSIZ);
            // offset of first CEN header
            b.writeUInt32LE(_offset, Constants.ENDOFF);
            // zip file comment length
            b.writeUInt16LE(_commentLength, Constants.ENDCOM);
            // fill comment memory with spaces so no garbage is left there
            b.fill(" ", Constants.ENDHDR);

            return b;
        },

        toJSON: function () {
            // creates 0x0000 style output
            const offset = function (nr, len) {
                let offs = nr.toString(16).toUpperCase();
                while (offs.length < len) offs = "0" + offs;
                return "0x" + offs;
            };

            return {
                diskEntries: _volumeEntries,
                totalEntries: _totalEntries,
                size: _size + " bytes",
                offset: offset(_offset, 4),
                commentLength: _commentLength
            };
        },

        toString: function () {
            return JSON.stringify(this.toJSON(), null, "\t");
        }
    };
};
 // Misspelled 

/***/ }),

/***/ 7686:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = function (/*Buffer*/ inbuf) {
    var zlib = __nccwpck_require__(9796);

    var opts = { chunkSize: (parseInt(inbuf.length / 1024) + 1) * 1024 };

    return {
        deflate: function () {
            return zlib.deflateRawSync(inbuf, opts);
        },

        deflateAsync: function (/*Function*/ callback) {
            var tmp = zlib.createDeflateRaw(opts),
                parts = [],
                total = 0;
            tmp.on("data", function (data) {
                parts.push(data);
                total += data.length;
            });
            tmp.on("end", function () {
                var buf = Buffer.alloc(total),
                    written = 0;
                buf.fill(0);
                for (var i = 0; i < parts.length; i++) {
                    var part = parts[i];
                    part.copy(buf, written);
                    written += part.length;
                }
                callback && callback(buf);
            });
            tmp.end(inbuf);
        }
    };
};


/***/ }),

/***/ 3928:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

exports.Deflater = __nccwpck_require__(7686);
exports.Inflater = __nccwpck_require__(2153);
exports.ZipCrypto = __nccwpck_require__(3228);


/***/ }),

/***/ 2153:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = function (/*Buffer*/ inbuf) {
    var zlib = __nccwpck_require__(9796);

    return {
        inflate: function () {
            return zlib.inflateRawSync(inbuf);
        },

        inflateAsync: function (/*Function*/ callback) {
            var tmp = zlib.createInflateRaw(),
                parts = [],
                total = 0;
            tmp.on("data", function (data) {
                parts.push(data);
                total += data.length;
            });
            tmp.on("end", function () {
                var buf = Buffer.alloc(total),
                    written = 0;
                buf.fill(0);
                for (var i = 0; i < parts.length; i++) {
                    var part = parts[i];
                    part.copy(buf, written);
                    written += part.length;
                }
                callback && callback(buf);
            });
            tmp.end(inbuf);
        }
    };
};


/***/ }),

/***/ 3228:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


// node crypt, we use it for generate salt
// eslint-disable-next-line node/no-unsupported-features/node-builtins
const { randomFillSync } = __nccwpck_require__(6113);

// generate CRC32 lookup table
const crctable = new Uint32Array(256).map((t, crc) => {
    for (let j = 0; j < 8; j++) {
        if (0 !== (crc & 1)) {
            crc = (crc >>> 1) ^ 0xedb88320;
        } else {
            crc >>>= 1;
        }
    }
    return crc >>> 0;
});

// C-style uInt32 Multiply (discards higher bits, when JS multiply discards lower bits)
const uMul = (a, b) => Math.imul(a, b) >>> 0;

// crc32 byte single update (actually same function is part of utils.crc32 function :) )
const crc32update = (pCrc32, bval) => {
    return crctable[(pCrc32 ^ bval) & 0xff] ^ (pCrc32 >>> 8);
};

// function for generating salt for encrytion header
const genSalt = () => {
    if ("function" === typeof randomFillSync) {
        return randomFillSync(Buffer.alloc(12));
    } else {
        // fallback if function is not defined
        return genSalt.node();
    }
};

// salt generation with node random function (mainly as fallback)
genSalt.node = () => {
    const salt = Buffer.alloc(12);
    const len = salt.length;
    for (let i = 0; i < len; i++) salt[i] = (Math.random() * 256) & 0xff;
    return salt;
};

// general config
const config = {
    genSalt
};

// Class Initkeys handles same basic ops with keys
function Initkeys(pw) {
    const pass = Buffer.isBuffer(pw) ? pw : Buffer.from(pw);
    this.keys = new Uint32Array([0x12345678, 0x23456789, 0x34567890]);
    for (let i = 0; i < pass.length; i++) {
        this.updateKeys(pass[i]);
    }
}

Initkeys.prototype.updateKeys = function (byteValue) {
    const keys = this.keys;
    keys[0] = crc32update(keys[0], byteValue);
    keys[1] += keys[0] & 0xff;
    keys[1] = uMul(keys[1], 134775813) + 1;
    keys[2] = crc32update(keys[2], keys[1] >>> 24);
    return byteValue;
};

Initkeys.prototype.next = function () {
    const k = (this.keys[2] | 2) >>> 0; // key
    return (uMul(k, k ^ 1) >> 8) & 0xff; // decode
};

function make_decrypter(/*Buffer*/ pwd) {
    // 1. Stage initialize key
    const keys = new Initkeys(pwd);

    // return decrypter function
    return function (/*Buffer*/ data) {
        // result - we create new Buffer for results
        const result = Buffer.alloc(data.length);
        let pos = 0;
        // process input data
        for (let c of data) {
            //c ^= keys.next();
            //result[pos++] = c; // decode & Save Value
            result[pos++] = keys.updateKeys(c ^ keys.next()); // update keys with decoded byte
        }
        return result;
    };
}

function make_encrypter(/*Buffer*/ pwd) {
    // 1. Stage initialize key
    const keys = new Initkeys(pwd);

    // return encrypting function, result and pos is here so we dont have to merge buffers later
    return function (/*Buffer*/ data, /*Buffer*/ result, /* Number */ pos = 0) {
        // result - we create new Buffer for results
        if (!result) result = Buffer.alloc(data.length);
        // process input data
        for (let c of data) {
            const k = keys.next(); // save key byte
            result[pos++] = c ^ k; // save val
            keys.updateKeys(c); // update keys with decoded byte
        }
        return result;
    };
}

function decrypt(/*Buffer*/ data, /*Object*/ header, /*String, Buffer*/ pwd) {
    if (!data || !Buffer.isBuffer(data) || data.length < 12) {
        return Buffer.alloc(0);
    }

    // 1. We Initialize and generate decrypting function
    const decrypter = make_decrypter(pwd);

    // 2. decrypt salt what is always 12 bytes and is a part of file content
    const salt = decrypter(data.slice(0, 12));

    // 3. does password meet expectations
    if (salt[11] !== header.crc >>> 24) {
        throw "ADM-ZIP: Wrong Password";
    }

    // 4. decode content
    return decrypter(data.slice(12));
}

// lets add way to populate salt, NOT RECOMMENDED for production but maybe useful for testing general functionality
function _salter(data) {
    if (Buffer.isBuffer(data) && data.length >= 12) {
        // be aware - currently salting buffer data is modified
        config.genSalt = function () {
            return data.slice(0, 12);
        };
    } else if (data === "node") {
        // test salt generation with node random function
        config.genSalt = genSalt.node;
    } else {
        // if value is not acceptable config gets reset.
        config.genSalt = genSalt;
    }
}

function encrypt(/*Buffer*/ data, /*Object*/ header, /*String, Buffer*/ pwd, /*Boolean*/ oldlike = false) {
    // 1. test data if data is not Buffer we make buffer from it
    if (data == null) data = Buffer.alloc(0);
    // if data is not buffer be make buffer from it
    if (!Buffer.isBuffer(data)) data = Buffer.from(data.toString());

    // 2. We Initialize and generate encrypting function
    const encrypter = make_encrypter(pwd);

    // 3. generate salt (12-bytes of random data)
    const salt = config.genSalt();
    salt[11] = (header.crc >>> 24) & 0xff;

    // old implementations (before PKZip 2.04g) used two byte check
    if (oldlike) salt[10] = (header.crc >>> 16) & 0xff;

    // 4. create output
    const result = Buffer.alloc(data.length + 12);
    encrypter(salt, result);

    // finally encode content
    return encrypter(data, result, 12);
}

module.exports = { decrypt, encrypt, _salter };


/***/ }),

/***/ 4522:
/***/ ((module) => {

module.exports = {
    /* The local file header */
    LOCHDR           : 30, // LOC header size
    LOCSIG           : 0x04034b50, // "PK\003\004"
    LOCVER           : 4,	// version needed to extract
    LOCFLG           : 6, // general purpose bit flag
    LOCHOW           : 8, // compression method
    LOCTIM           : 10, // modification time (2 bytes time, 2 bytes date)
    LOCCRC           : 14, // uncompressed file crc-32 value
    LOCSIZ           : 18, // compressed size
    LOCLEN           : 22, // uncompressed size
    LOCNAM           : 26, // filename length
    LOCEXT           : 28, // extra field length

    /* The Data descriptor */
    EXTSIG           : 0x08074b50, // "PK\007\008"
    EXTHDR           : 16, // EXT header size
    EXTCRC           : 4, // uncompressed file crc-32 value
    EXTSIZ           : 8, // compressed size
    EXTLEN           : 12, // uncompressed size

    /* The central directory file header */
    CENHDR           : 46, // CEN header size
    CENSIG           : 0x02014b50, // "PK\001\002"
    CENVEM           : 4, // version made by
    CENVER           : 6, // version needed to extract
    CENFLG           : 8, // encrypt, decrypt flags
    CENHOW           : 10, // compression method
    CENTIM           : 12, // modification time (2 bytes time, 2 bytes date)
    CENCRC           : 16, // uncompressed file crc-32 value
    CENSIZ           : 20, // compressed size
    CENLEN           : 24, // uncompressed size
    CENNAM           : 28, // filename length
    CENEXT           : 30, // extra field length
    CENCOM           : 32, // file comment length
    CENDSK           : 34, // volume number start
    CENATT           : 36, // internal file attributes
    CENATX           : 38, // external file attributes (host system dependent)
    CENOFF           : 42, // LOC header offset

    /* The entries in the end of central directory */
    ENDHDR           : 22, // END header size
    ENDSIG           : 0x06054b50, // "PK\005\006"
    ENDSUB           : 8, // number of entries on this disk
    ENDTOT           : 10, // total number of entries
    ENDSIZ           : 12, // central directory size in bytes
    ENDOFF           : 16, // offset of first CEN header
    ENDCOM           : 20, // zip file comment length

    END64HDR         : 20, // zip64 END header size
    END64SIG         : 0x07064b50, // zip64 Locator signature, "PK\006\007"
    END64START       : 4, // number of the disk with the start of the zip64
    END64OFF         : 8, // relative offset of the zip64 end of central directory
    END64NUMDISKS    : 16, // total number of disks

    ZIP64SIG         : 0x06064b50, // zip64 signature, "PK\006\006"
    ZIP64HDR         : 56, // zip64 record minimum size
    ZIP64LEAD        : 12, // leading bytes at the start of the record, not counted by the value stored in ZIP64SIZE
    ZIP64SIZE        : 4, // zip64 size of the central directory record
    ZIP64VEM         : 12, // zip64 version made by
    ZIP64VER         : 14, // zip64 version needed to extract
    ZIP64DSK         : 16, // zip64 number of this disk
    ZIP64DSKDIR      : 20, // number of the disk with the start of the record directory
    ZIP64SUB         : 24, // number of entries on this disk
    ZIP64TOT         : 32, // total number of entries
    ZIP64SIZB        : 40, // zip64 central directory size in bytes
    ZIP64OFF         : 48, // offset of start of central directory with respect to the starting disk number
    ZIP64EXTRA       : 56, // extensible data sector

    /* Compression methods */
    STORED           : 0, // no compression
    SHRUNK           : 1, // shrunk
    REDUCED1         : 2, // reduced with compression factor 1
    REDUCED2         : 3, // reduced with compression factor 2
    REDUCED3         : 4, // reduced with compression factor 3
    REDUCED4         : 5, // reduced with compression factor 4
    IMPLODED         : 6, // imploded
    // 7 reserved for Tokenizing compression algorithm
    DEFLATED         : 8, // deflated
    ENHANCED_DEFLATED: 9, // enhanced deflated
    PKWARE           : 10,// PKWare DCL imploded
    // 11 reserved by PKWARE
    BZIP2            : 12, //  compressed using BZIP2
    // 13 reserved by PKWARE
    LZMA             : 14, // LZMA
    // 15-17 reserved by PKWARE
    IBM_TERSE        : 18, // compressed using IBM TERSE
    IBM_LZ77         : 19, // IBM LZ77 z
    AES_ENCRYPT      : 99, // WinZIP AES encryption method

    /* General purpose bit flag */
    // values can obtained with expression 2**bitnr
    FLG_ENC          : 1,    // Bit 0: encrypted file
    FLG_COMP1        : 2,    // Bit 1, compression option
    FLG_COMP2        : 4,    // Bit 2, compression option
    FLG_DESC         : 8,    // Bit 3, data descriptor
    FLG_ENH          : 16,   // Bit 4, enhanced deflating
    FLG_PATCH        : 32,   // Bit 5, indicates that the file is compressed patched data.
    FLG_STR          : 64,   // Bit 6, strong encryption (patented)
                             // Bits 7-10: Currently unused.
    FLG_EFS          : 2048, // Bit 11: Language encoding flag (EFS)
                             // Bit 12: Reserved by PKWARE for enhanced compression.
                             // Bit 13: encrypted the Central Directory (patented).
                             // Bits 14-15: Reserved by PKWARE.
    FLG_MSK          : 4096, // mask header values

    /* Load type */
    FILE             : 2,
    BUFFER           : 1,
    NONE             : 0,

    /* 4.5 Extensible data fields */
    EF_ID            : 0,
    EF_SIZE          : 2,

    /* Header IDs */
    ID_ZIP64         : 0x0001,
    ID_AVINFO        : 0x0007,
    ID_PFS           : 0x0008,
    ID_OS2           : 0x0009,
    ID_NTFS          : 0x000a,
    ID_OPENVMS       : 0x000c,
    ID_UNIX          : 0x000d,
    ID_FORK          : 0x000e,
    ID_PATCH         : 0x000f,
    ID_X509_PKCS7    : 0x0014,
    ID_X509_CERTID_F : 0x0015,
    ID_X509_CERTID_C : 0x0016,
    ID_STRONGENC     : 0x0017,
    ID_RECORD_MGT    : 0x0018,
    ID_X509_PKCS7_RL : 0x0019,
    ID_IBM1          : 0x0065,
    ID_IBM2          : 0x0066,
    ID_POSZIP        : 0x4690,

    EF_ZIP64_OR_32   : 0xffffffff,
    EF_ZIP64_OR_16   : 0xffff,
    EF_ZIP64_SUNCOMP : 0,
    EF_ZIP64_SCOMP   : 8,
    EF_ZIP64_RHO     : 16,
    EF_ZIP64_DSN     : 24
};


/***/ }),

/***/ 1255:
/***/ ((module) => {

module.exports = {
    /* Header error messages */
    INVALID_LOC: "Invalid LOC header (bad signature)",
    INVALID_CEN: "Invalid CEN header (bad signature)",
    INVALID_END: "Invalid END header (bad signature)",

    /* ZipEntry error messages*/
    NO_DATA: "Nothing to decompress",
    BAD_CRC: "CRC32 checksum failed",
    FILE_IN_THE_WAY: "There is a file in the way: %s",
    UNKNOWN_METHOD: "Invalid/unsupported compression method",

    /* Inflater error messages */
    AVAIL_DATA: "inflate::Available inflate data did not terminate",
    INVALID_DISTANCE: "inflate::Invalid literal/length or distance code in fixed or dynamic block",
    TO_MANY_CODES: "inflate::Dynamic block code description: too many length or distance codes",
    INVALID_REPEAT_LEN: "inflate::Dynamic block code description: repeat more than specified lengths",
    INVALID_REPEAT_FIRST: "inflate::Dynamic block code description: repeat lengths with no first length",
    INCOMPLETE_CODES: "inflate::Dynamic block code description: code lengths codes incomplete",
    INVALID_DYN_DISTANCE: "inflate::Dynamic block code description: invalid distance code lengths",
    INVALID_CODES_LEN: "inflate::Dynamic block code description: invalid literal/length code lengths",
    INVALID_STORE_BLOCK: "inflate::Stored block length did not match one's complement",
    INVALID_BLOCK_TYPE: "inflate::Invalid block type (type == 3)",

    /* ADM-ZIP error messages */
    CANT_EXTRACT_FILE: "Could not extract the file",
    CANT_OVERRIDE: "Target file already exists",
    NO_ZIP: "No zip file was loaded",
    NO_ENTRY: "Entry doesn't exist",
    DIRECTORY_CONTENT_ERROR: "A directory cannot have content",
    FILE_NOT_FOUND: "File not found: %s",
    NOT_IMPLEMENTED: "Not implemented",
    INVALID_FILENAME: "Invalid filename",
    INVALID_FORMAT: "Invalid or unsupported zip format. No END header found"
};


/***/ }),

/***/ 8321:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const fs = (__nccwpck_require__(2895).require)();
const pth = __nccwpck_require__(1017);

fs.existsSync = fs.existsSync || pth.existsSync;

module.exports = function (/*String*/ path) {
    var _path = path || "",
        _obj = newAttr(),
        _stat = null;

    function newAttr() {
        return {
            directory: false,
            readonly: false,
            hidden: false,
            executable: false,
            mtime: 0,
            atime: 0
        };
    }

    if (_path && fs.existsSync(_path)) {
        _stat = fs.statSync(_path);
        _obj.directory = _stat.isDirectory();
        _obj.mtime = _stat.mtime;
        _obj.atime = _stat.atime;
        _obj.executable = (0o111 & _stat.mode) !== 0; // file is executable who ever har right not just owner
        _obj.readonly = (0o200 & _stat.mode) === 0; // readonly if owner has no write right
        _obj.hidden = pth.basename(_path)[0] === ".";
    } else {
        console.warn("Invalid path: " + _path);
    }

    return {
        get directory() {
            return _obj.directory;
        },

        get readOnly() {
            return _obj.readonly;
        },

        get hidden() {
            return _obj.hidden;
        },

        get mtime() {
            return _obj.mtime;
        },

        get atime() {
            return _obj.atime;
        },

        get executable() {
            return _obj.executable;
        },

        decodeAttributes: function () {},

        encodeAttributes: function () {},

        toJSON: function () {
            return {
                path: _path,
                isDirectory: _obj.directory,
                isReadOnly: _obj.readonly,
                isHidden: _obj.hidden,
                isExecutable: _obj.executable,
                mTime: _obj.mtime,
                aTime: _obj.atime
            };
        },

        toString: function () {
            return JSON.stringify(this.toJSON(), null, "\t");
        }
    };
};


/***/ }),

/***/ 2895:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

exports.require = function () {
    if (typeof process === "object" && process.versions && process.versions["electron"]) {
        try {
            const originalFs = __nccwpck_require__(2941);
            if (Object.keys(originalFs).length > 0) {
                return originalFs;
            }
        } catch (e) {}
    }
    return __nccwpck_require__(7147);
};


/***/ }),

/***/ 5182:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(1291);
module.exports.Constants = __nccwpck_require__(4522);
module.exports.Errors = __nccwpck_require__(1255);
module.exports.FileAttr = __nccwpck_require__(8321);


/***/ }),

/***/ 1291:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const fsystem = (__nccwpck_require__(2895).require)();
const pth = __nccwpck_require__(1017);
const Constants = __nccwpck_require__(4522);
const Errors = __nccwpck_require__(1255);
const isWin = typeof process === "object" && "win32" === process.platform;

const is_Obj = (obj) => obj && typeof obj === "object";

// generate CRC32 lookup table
const crcTable = new Uint32Array(256).map((t, c) => {
    for (let k = 0; k < 8; k++) {
        if ((c & 1) !== 0) {
            c = 0xedb88320 ^ (c >>> 1);
        } else {
            c >>>= 1;
        }
    }
    return c >>> 0;
});

// UTILS functions

function Utils(opts) {
    this.sep = pth.sep;
    this.fs = fsystem;

    if (is_Obj(opts)) {
        // custom filesystem
        if (is_Obj(opts.fs) && typeof opts.fs.statSync === "function") {
            this.fs = opts.fs;
        }
    }
}

module.exports = Utils;

// INSTANCED functions

Utils.prototype.makeDir = function (/*String*/ folder) {
    const self = this;

    // Sync - make directories tree
    function mkdirSync(/*String*/ fpath) {
        let resolvedPath = fpath.split(self.sep)[0];
        fpath.split(self.sep).forEach(function (name) {
            if (!name || name.substr(-1, 1) === ":") return;
            resolvedPath += self.sep + name;
            var stat;
            try {
                stat = self.fs.statSync(resolvedPath);
            } catch (e) {
                self.fs.mkdirSync(resolvedPath);
            }
            if (stat && stat.isFile()) throw Errors.FILE_IN_THE_WAY.replace("%s", resolvedPath);
        });
    }

    mkdirSync(folder);
};

Utils.prototype.writeFileTo = function (/*String*/ path, /*Buffer*/ content, /*Boolean*/ overwrite, /*Number*/ attr) {
    const self = this;
    if (self.fs.existsSync(path)) {
        if (!overwrite) return false; // cannot overwrite

        var stat = self.fs.statSync(path);
        if (stat.isDirectory()) {
            return false;
        }
    }
    var folder = pth.dirname(path);
    if (!self.fs.existsSync(folder)) {
        self.makeDir(folder);
    }

    var fd;
    try {
        fd = self.fs.openSync(path, "w", 438); // 0666
    } catch (e) {
        self.fs.chmodSync(path, 438);
        fd = self.fs.openSync(path, "w", 438);
    }
    if (fd) {
        try {
            self.fs.writeSync(fd, content, 0, content.length, 0);
        } finally {
            self.fs.closeSync(fd);
        }
    }
    self.fs.chmodSync(path, attr || 438);
    return true;
};

Utils.prototype.writeFileToAsync = function (/*String*/ path, /*Buffer*/ content, /*Boolean*/ overwrite, /*Number*/ attr, /*Function*/ callback) {
    if (typeof attr === "function") {
        callback = attr;
        attr = undefined;
    }

    const self = this;

    self.fs.exists(path, function (exist) {
        if (exist && !overwrite) return callback(false);

        self.fs.stat(path, function (err, stat) {
            if (exist && stat.isDirectory()) {
                return callback(false);
            }

            var folder = pth.dirname(path);
            self.fs.exists(folder, function (exists) {
                if (!exists) self.makeDir(folder);

                self.fs.open(path, "w", 438, function (err, fd) {
                    if (err) {
                        self.fs.chmod(path, 438, function () {
                            self.fs.open(path, "w", 438, function (err, fd) {
                                self.fs.write(fd, content, 0, content.length, 0, function () {
                                    self.fs.close(fd, function () {
                                        self.fs.chmod(path, attr || 438, function () {
                                            callback(true);
                                        });
                                    });
                                });
                            });
                        });
                    } else if (fd) {
                        self.fs.write(fd, content, 0, content.length, 0, function () {
                            self.fs.close(fd, function () {
                                self.fs.chmod(path, attr || 438, function () {
                                    callback(true);
                                });
                            });
                        });
                    } else {
                        self.fs.chmod(path, attr || 438, function () {
                            callback(true);
                        });
                    }
                });
            });
        });
    });
};

Utils.prototype.findFiles = function (/*String*/ path) {
    const self = this;

    function findSync(/*String*/ dir, /*RegExp*/ pattern, /*Boolean*/ recursive) {
        if (typeof pattern === "boolean") {
            recursive = pattern;
            pattern = undefined;
        }
        let files = [];
        self.fs.readdirSync(dir).forEach(function (file) {
            var path = pth.join(dir, file);

            if (self.fs.statSync(path).isDirectory() && recursive) files = files.concat(findSync(path, pattern, recursive));

            if (!pattern || pattern.test(path)) {
                files.push(pth.normalize(path) + (self.fs.statSync(path).isDirectory() ? self.sep : ""));
            }
        });
        return files;
    }

    return findSync(path, undefined, true);
};

Utils.prototype.getAttributes = function () {};

Utils.prototype.setAttributes = function () {};

// STATIC functions

// crc32 single update (it is part of crc32)
Utils.crc32update = function (crc, byte) {
    return crcTable[(crc ^ byte) & 0xff] ^ (crc >>> 8);
};

Utils.crc32 = function (buf) {
    if (typeof buf === "string") {
        buf = Buffer.from(buf, "utf8");
    }
    // Generate crcTable
    if (!crcTable.length) genCRCTable();

    let len = buf.length;
    let crc = ~0;
    for (let off = 0; off < len; ) crc = Utils.crc32update(crc, buf[off++]);
    // xor and cast as uint32 number
    return ~crc >>> 0;
};

Utils.methodToString = function (/*Number*/ method) {
    switch (method) {
        case Constants.STORED:
            return "STORED (" + method + ")";
        case Constants.DEFLATED:
            return "DEFLATED (" + method + ")";
        default:
            return "UNSUPPORTED (" + method + ")";
    }
};

// removes ".." style path elements
Utils.canonical = function (/*string*/ path) {
    if (!path) return "";
    // trick normalize think path is absolute
    var safeSuffix = pth.posix.normalize("/" + path.split("\\").join("/"));
    return pth.join(".", safeSuffix);
};

// make abolute paths taking prefix as root folder
Utils.sanitize = function (/*string*/ prefix, /*string*/ name) {
    prefix = pth.resolve(pth.normalize(prefix));
    var parts = name.split("/");
    for (var i = 0, l = parts.length; i < l; i++) {
        var path = pth.normalize(pth.join(prefix, parts.slice(i, l).join(pth.sep)));
        if (path.indexOf(prefix) === 0) {
            return path;
        }
    }
    return pth.normalize(pth.join(prefix, pth.basename(name)));
};

// converts buffer, Uint8Array, string types to buffer
Utils.toBuffer = function toBuffer(/*buffer, Uint8Array, string*/ input) {
    if (Buffer.isBuffer(input)) {
        return input;
    } else if (input instanceof Uint8Array) {
        return Buffer.from(input);
    } else {
        // expect string all other values are invalid and return empty buffer
        return typeof input === "string" ? Buffer.from(input, "utf8") : Buffer.alloc(0);
    }
};

Utils.readBigUInt64LE = function (/*Buffer*/ buffer, /*int*/ index) {
    var slice = Buffer.from(buffer.slice(index, index + 8));
    slice.swap64();

    return parseInt(`0x${slice.toString("hex")}`);
};

Utils.isWin = isWin; // Do we have windows system
Utils.crcTable = crcTable;


/***/ }),

/***/ 4057:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Utils = __nccwpck_require__(5182),
    Headers = __nccwpck_require__(4958),
    Constants = Utils.Constants,
    Methods = __nccwpck_require__(3928);

module.exports = function (/*Buffer*/ input) {
    var _entryHeader = new Headers.EntryHeader(),
        _entryName = Buffer.alloc(0),
        _comment = Buffer.alloc(0),
        _isDirectory = false,
        uncompressedData = null,
        _extra = Buffer.alloc(0);

    function getCompressedDataFromZip() {
        if (!input || !Buffer.isBuffer(input)) {
            return Buffer.alloc(0);
        }
        _entryHeader.loadDataHeaderFromBinary(input);
        return input.slice(_entryHeader.realDataOffset, _entryHeader.realDataOffset + _entryHeader.compressedSize);
    }

    function crc32OK(data) {
        // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written
        if ((_entryHeader.flags & 0x8) !== 0x8) {
            if (Utils.crc32(data) !== _entryHeader.dataHeader.crc) {
                return false;
            }
        } else {
            // @TODO: load and check data descriptor header
            // The fields in the local header are filled with zero, and the CRC-32 and size are appended in a 12-byte structure
            // (optionally preceded by a 4-byte signature) immediately after the compressed data:
        }
        return true;
    }

    function decompress(/*Boolean*/ async, /*Function*/ callback, /*String, Buffer*/ pass) {
        if (typeof callback === "undefined" && typeof async === "string") {
            pass = async;
            async = void 0;
        }
        if (_isDirectory) {
            if (async && callback) {
                callback(Buffer.alloc(0), Utils.Errors.DIRECTORY_CONTENT_ERROR); //si added error.
            }
            return Buffer.alloc(0);
        }

        var compressedData = getCompressedDataFromZip();

        if (compressedData.length === 0) {
            // File is empty, nothing to decompress.
            if (async && callback) callback(compressedData);
            return compressedData;
        }

        if (_entryHeader.encripted) {
            if ("string" !== typeof pass && !Buffer.isBuffer(pass)) {
                throw new Error("ADM-ZIP: Incompatible password parameter");
            }
            compressedData = Methods.ZipCrypto.decrypt(compressedData, _entryHeader, pass);
        }

        var data = Buffer.alloc(_entryHeader.size);

        switch (_entryHeader.method) {
            case Utils.Constants.STORED:
                compressedData.copy(data);
                if (!crc32OK(data)) {
                    if (async && callback) callback(data, Utils.Errors.BAD_CRC); //si added error
                    throw new Error(Utils.Errors.BAD_CRC);
                } else {
                    //si added otherwise did not seem to return data.
                    if (async && callback) callback(data);
                    return data;
                }
            case Utils.Constants.DEFLATED:
                var inflater = new Methods.Inflater(compressedData);
                if (!async) {
                    const result = inflater.inflate(data);
                    result.copy(data, 0);
                    if (!crc32OK(data)) {
                        throw new Error(Utils.Errors.BAD_CRC + " " + _entryName.toString());
                    }
                    return data;
                } else {
                    inflater.inflateAsync(function (result) {
                        result.copy(result, 0);
                        if (callback) {
                            if (!crc32OK(result)) {
                                callback(result, Utils.Errors.BAD_CRC); //si added error
                            } else {
                                callback(result);
                            }
                        }
                    });
                }
                break;
            default:
                if (async && callback) callback(Buffer.alloc(0), Utils.Errors.UNKNOWN_METHOD);
                throw new Error(Utils.Errors.UNKNOWN_METHOD);
        }
    }

    function compress(/*Boolean*/ async, /*Function*/ callback) {
        if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {
            // no data set or the data wasn't changed to require recompression
            if (async && callback) callback(getCompressedDataFromZip());
            return getCompressedDataFromZip();
        }

        if (uncompressedData.length && !_isDirectory) {
            var compressedData;
            // Local file header
            switch (_entryHeader.method) {
                case Utils.Constants.STORED:
                    _entryHeader.compressedSize = _entryHeader.size;

                    compressedData = Buffer.alloc(uncompressedData.length);
                    uncompressedData.copy(compressedData);

                    if (async && callback) callback(compressedData);
                    return compressedData;
                default:
                case Utils.Constants.DEFLATED:
                    var deflater = new Methods.Deflater(uncompressedData);
                    if (!async) {
                        var deflated = deflater.deflate();
                        _entryHeader.compressedSize = deflated.length;
                        return deflated;
                    } else {
                        deflater.deflateAsync(function (data) {
                            compressedData = Buffer.alloc(data.length);
                            _entryHeader.compressedSize = data.length;
                            data.copy(compressedData);
                            callback && callback(compressedData);
                        });
                    }
                    deflater = null;
                    break;
            }
        } else if (async && callback) {
            callback(Buffer.alloc(0));
        } else {
            return Buffer.alloc(0);
        }
    }

    function readUInt64LE(buffer, offset) {
        return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);
    }

    function parseExtra(data) {
        var offset = 0;
        var signature, size, part;
        while (offset < data.length) {
            signature = data.readUInt16LE(offset);
            offset += 2;
            size = data.readUInt16LE(offset);
            offset += 2;
            part = data.slice(offset, offset + size);
            offset += size;
            if (Constants.ID_ZIP64 === signature) {
                parseZip64ExtendedInformation(part);
            }
        }
    }

    //Override header field values with values from the ZIP64 extra field
    function parseZip64ExtendedInformation(data) {
        var size, compressedSize, offset, diskNumStart;

        if (data.length >= Constants.EF_ZIP64_SCOMP) {
            size = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);
            if (_entryHeader.size === Constants.EF_ZIP64_OR_32) {
                _entryHeader.size = size;
            }
        }
        if (data.length >= Constants.EF_ZIP64_RHO) {
            compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);
            if (_entryHeader.compressedSize === Constants.EF_ZIP64_OR_32) {
                _entryHeader.compressedSize = compressedSize;
            }
        }
        if (data.length >= Constants.EF_ZIP64_DSN) {
            offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);
            if (_entryHeader.offset === Constants.EF_ZIP64_OR_32) {
                _entryHeader.offset = offset;
            }
        }
        if (data.length >= Constants.EF_ZIP64_DSN + 4) {
            diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);
            if (_entryHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {
                _entryHeader.diskNumStart = diskNumStart;
            }
        }
    }

    return {
        get entryName() {
            return _entryName.toString();
        },
        get rawEntryName() {
            return _entryName;
        },
        set entryName(val) {
            _entryName = Utils.toBuffer(val);
            var lastChar = _entryName[_entryName.length - 1];
            _isDirectory = lastChar === 47 || lastChar === 92;
            _entryHeader.fileNameLength = _entryName.length;
        },

        get extra() {
            return _extra;
        },
        set extra(val) {
            _extra = val;
            _entryHeader.extraLength = val.length;
            parseExtra(val);
        },

        get comment() {
            return _comment.toString();
        },
        set comment(val) {
            _comment = Utils.toBuffer(val);
            _entryHeader.commentLength = _comment.length;
        },

        get name() {
            var n = _entryName.toString();
            return _isDirectory
                ? n
                      .substr(n.length - 1)
                      .split("/")
                      .pop()
                : n.split("/").pop();
        },
        get isDirectory() {
            return _isDirectory;
        },

        getCompressedData: function () {
            return compress(false, null);
        },

        getCompressedDataAsync: function (/*Function*/ callback) {
            compress(true, callback);
        },

        setData: function (value) {
            uncompressedData = Utils.toBuffer(value);
            if (!_isDirectory && uncompressedData.length) {
                _entryHeader.size = uncompressedData.length;
                _entryHeader.method = Utils.Constants.DEFLATED;
                _entryHeader.crc = Utils.crc32(value);
                _entryHeader.changed = true;
            } else {
                // folders and blank files should be stored
                _entryHeader.method = Utils.Constants.STORED;
            }
        },

        getData: function (pass) {
            if (_entryHeader.changed) {
                return uncompressedData;
            } else {
                return decompress(false, null, pass);
            }
        },

        getDataAsync: function (/*Function*/ callback, pass) {
            if (_entryHeader.changed) {
                callback(uncompressedData);
            } else {
                decompress(true, callback, pass);
            }
        },

        set attr(attr) {
            _entryHeader.attr = attr;
        },
        get attr() {
            return _entryHeader.attr;
        },

        set header(/*Buffer*/ data) {
            _entryHeader.loadFromBinary(data);
        },

        get header() {
            return _entryHeader;
        },

        packHeader: function () {
            // 1. create header (buffer)
            var header = _entryHeader.entryHeaderToBinary();
            var addpos = Utils.Constants.CENHDR;
            // 2. add file name
            _entryName.copy(header, addpos);
            addpos += _entryName.length;
            // 3. add extra data
            if (_entryHeader.extraLength) {
                _extra.copy(header, addpos);
                addpos += _entryHeader.extraLength;
            }
            // 4. add file comment
            if (_entryHeader.commentLength) {
                _comment.copy(header, addpos);
            }
            return header;
        },

        toJSON: function () {
            const bytes = function (nr) {
                return "<" + ((nr && nr.length + " bytes buffer") || "null") + ">";
            };

            return {
                entryName: this.entryName,
                name: this.name,
                comment: this.comment,
                isDirectory: this.isDirectory,
                header: _entryHeader.toJSON(),
                compressedData: bytes(input),
                data: bytes(uncompressedData)
            };
        },

        toString: function () {
            return JSON.stringify(this.toJSON(), null, "\t");
        }
    };
};


/***/ }),

/***/ 7744:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const ZipEntry = __nccwpck_require__(4057);
const Headers = __nccwpck_require__(4958);
const Utils = __nccwpck_require__(5182);

module.exports = function (/*Buffer|null*/ inBuffer, /** object */ options) {
    var entryList = [],
        entryTable = {},
        _comment = Buffer.alloc(0),
        mainHeader = new Headers.MainHeader(),
        loadedEntries = false;

    // assign options
    const opts = Object.assign(Object.create(null), options);

    const { noSort } = opts;

    if (inBuffer) {
        // is a memory buffer
        readMainHeader(opts.readEntries);
    } else {
        // none. is a new file
        loadedEntries = true;
    }

    function iterateEntries(callback) {
        const totalEntries = mainHeader.diskEntries; // total number of entries
        let index = mainHeader.offset; // offset of first CEN header

        for (let i = 0; i < totalEntries; i++) {
            let tmp = index;
            const entry = new ZipEntry(inBuffer);

            entry.header = inBuffer.slice(tmp, (tmp += Utils.Constants.CENHDR));
            entry.entryName = inBuffer.slice(tmp, (tmp += entry.header.fileNameLength));

            index += entry.header.entryHeaderSize;

            callback(entry);
        }
    }

    function readEntries() {
        loadedEntries = true;
        entryTable = {};
        entryList = new Array(mainHeader.diskEntries); // total number of entries
        var index = mainHeader.offset; // offset of first CEN header
        for (var i = 0; i < entryList.length; i++) {
            var tmp = index,
                entry = new ZipEntry(inBuffer);
            entry.header = inBuffer.slice(tmp, (tmp += Utils.Constants.CENHDR));

            entry.entryName = inBuffer.slice(tmp, (tmp += entry.header.fileNameLength));

            if (entry.header.extraLength) {
                entry.extra = inBuffer.slice(tmp, (tmp += entry.header.extraLength));
            }

            if (entry.header.commentLength) entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);

            index += entry.header.entryHeaderSize;

            entryList[i] = entry;
            entryTable[entry.entryName] = entry;
        }
    }

    function readMainHeader(/*Boolean*/ readNow) {
        var i = inBuffer.length - Utils.Constants.ENDHDR, // END header size
            max = Math.max(0, i - 0xffff), // 0xFFFF is the max zip file comment length
            n = max,
            endStart = inBuffer.length,
            endOffset = -1, // Start offset of the END header
            commentEnd = 0;

        for (i; i >= n; i--) {
            if (inBuffer[i] !== 0x50) continue; // quick check that the byte is 'P'
            if (inBuffer.readUInt32LE(i) === Utils.Constants.ENDSIG) {
                // "PK\005\006"
                endOffset = i;
                commentEnd = i;
                endStart = i + Utils.Constants.ENDHDR;
                // We already found a regular signature, let's look just a bit further to check if there's any zip64 signature
                n = i - Utils.Constants.END64HDR;
                continue;
            }

            if (inBuffer.readUInt32LE(i) === Utils.Constants.END64SIG) {
                // Found a zip64 signature, let's continue reading the whole zip64 record
                n = max;
                continue;
            }

            if (inBuffer.readUInt32LE(i) === Utils.Constants.ZIP64SIG) {
                // Found the zip64 record, let's determine it's size
                endOffset = i;
                endStart = i + Utils.readBigUInt64LE(inBuffer, i + Utils.Constants.ZIP64SIZE) + Utils.Constants.ZIP64LEAD;
                break;
            }
        }

        if (!~endOffset) throw new Error(Utils.Errors.INVALID_FORMAT);

        mainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));
        if (mainHeader.commentLength) {
            _comment = inBuffer.slice(commentEnd + Utils.Constants.ENDHDR);
        }
        if (readNow) readEntries();
    }

    function sortEntries() {
        if (entryList.length > 1 && !noSort) {
            entryList.sort((a, b) => a.entryName.toLowerCase().localeCompare(b.entryName.toLowerCase()));
        }
    }

    return {
        /**
         * Returns an array of ZipEntry objects existent in the current opened archive
         * @return Array
         */
        get entries() {
            if (!loadedEntries) {
                readEntries();
            }
            return entryList;
        },

        /**
         * Archive comment
         * @return {String}
         */
        get comment() {
            return _comment.toString();
        },
        set comment(val) {
            _comment = Utils.toBuffer(val);
            mainHeader.commentLength = _comment.length;
        },

        getEntryCount: function () {
            if (!loadedEntries) {
                return mainHeader.diskEntries;
            }

            return entryList.length;
        },

        forEach: function (callback) {
            if (!loadedEntries) {
                iterateEntries(callback);
                return;
            }

            entryList.forEach(callback);
        },

        /**
         * Returns a reference to the entry with the given name or null if entry is inexistent
         *
         * @param entryName
         * @return ZipEntry
         */
        getEntry: function (/*String*/ entryName) {
            if (!loadedEntries) {
                readEntries();
            }
            return entryTable[entryName] || null;
        },

        /**
         * Adds the given entry to the entry list
         *
         * @param entry
         */
        setEntry: function (/*ZipEntry*/ entry) {
            if (!loadedEntries) {
                readEntries();
            }
            entryList.push(entry);
            entryTable[entry.entryName] = entry;
            mainHeader.totalEntries = entryList.length;
        },

        /**
         * Removes the entry with the given name from the entry list.
         *
         * If the entry is a directory, then all nested files and directories will be removed
         * @param entryName
         */
        deleteEntry: function (/*String*/ entryName) {
            if (!loadedEntries) {
                readEntries();
            }
            var entry = entryTable[entryName];
            if (entry && entry.isDirectory) {
                var _self = this;
                this.getEntryChildren(entry).forEach(function (child) {
                    if (child.entryName !== entryName) {
                        _self.deleteEntry(child.entryName);
                    }
                });
            }
            entryList.splice(entryList.indexOf(entry), 1);
            delete entryTable[entryName];
            mainHeader.totalEntries = entryList.length;
        },

        /**
         *  Iterates and returns all nested files and directories of the given entry
         *
         * @param entry
         * @return Array
         */
        getEntryChildren: function (/*ZipEntry*/ entry) {
            if (!loadedEntries) {
                readEntries();
            }
            if (entry && entry.isDirectory) {
                const list = [];
                const name = entry.entryName;
                const len = name.length;

                entryList.forEach(function (zipEntry) {
                    if (zipEntry.entryName.substr(0, len) === name) {
                        list.push(zipEntry);
                    }
                });
                return list;
            }
            return [];
        },

        /**
         * Returns the zip file
         *
         * @return Buffer
         */
        compressToBuffer: function () {
            if (!loadedEntries) {
                readEntries();
            }
            sortEntries();

            const dataBlock = [];
            const entryHeaders = [];
            let totalSize = 0;
            let dindex = 0;

            mainHeader.size = 0;
            mainHeader.offset = 0;

            for (const entry of entryList) {
                // compress data and set local and entry header accordingly. Reason why is called first
                const compressedData = entry.getCompressedData();
                // 1. construct data header
                entry.header.offset = dindex;
                const dataHeader = entry.header.dataHeaderToBinary();
                const entryNameLen = entry.rawEntryName.length;
                // 1.2. postheader - data after data header
                const postHeader = Buffer.alloc(entryNameLen + entry.extra.length);
                entry.rawEntryName.copy(postHeader, 0);
                postHeader.copy(entry.extra, entryNameLen);

                // 2. offsets
                const dataLength = dataHeader.length + postHeader.length + compressedData.length;
                dindex += dataLength;

                // 3. store values in sequence
                dataBlock.push(dataHeader);
                dataBlock.push(postHeader);
                dataBlock.push(compressedData);

                // 4. construct entry header
                const entryHeader = entry.packHeader();
                entryHeaders.push(entryHeader);
                // 5. update main header
                mainHeader.size += entryHeader.length;
                totalSize += dataLength + entryHeader.length;
            }

            totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length
            // point to end of data and beginning of central directory first record
            mainHeader.offset = dindex;

            dindex = 0;
            const outBuffer = Buffer.alloc(totalSize);
            // write data blocks
            for (const content of dataBlock) {
                content.copy(outBuffer, dindex);
                dindex += content.length;
            }

            // write central directory entries
            for (const content of entryHeaders) {
                content.copy(outBuffer, dindex);
                dindex += content.length;
            }

            // write main header
            const mh = mainHeader.toBinary();
            if (_comment) {
                _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment
            }
            mh.copy(outBuffer, dindex);

            return outBuffer;
        },

        toAsyncBuffer: function (/*Function*/ onSuccess, /*Function*/ onFail, /*Function*/ onItemStart, /*Function*/ onItemEnd) {
            try {
                if (!loadedEntries) {
                    readEntries();
                }
                sortEntries();

                const dataBlock = [];
                const entryHeaders = [];
                let totalSize = 0;
                let dindex = 0;

                mainHeader.size = 0;
                mainHeader.offset = 0;

                const compress2Buffer = function (entryLists) {
                    if (entryLists.length) {
                        const entry = entryLists.pop();
                        const name = entry.entryName + entry.extra.toString();
                        if (onItemStart) onItemStart(name);
                        entry.getCompressedDataAsync(function (compressedData) {
                            if (onItemEnd) onItemEnd(name);

                            entry.header.offset = dindex;
                            // data header
                            const dataHeader = entry.header.dataHeaderToBinary();
                            const postHeader = Buffer.alloc(name.length, name);
                            const dataLength = dataHeader.length + postHeader.length + compressedData.length;

                            dindex += dataLength;

                            dataBlock.push(dataHeader);
                            dataBlock.push(postHeader);
                            dataBlock.push(compressedData);

                            const entryHeader = entry.packHeader();
                            entryHeaders.push(entryHeader);
                            mainHeader.size += entryHeader.length;
                            totalSize += dataLength + entryHeader.length;

                            compress2Buffer(entryLists);
                        });
                    } else {
                        totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length
                        // point to end of data and beginning of central directory first record
                        mainHeader.offset = dindex;

                        dindex = 0;
                        const outBuffer = Buffer.alloc(totalSize);
                        dataBlock.forEach(function (content) {
                            content.copy(outBuffer, dindex); // write data blocks
                            dindex += content.length;
                        });
                        entryHeaders.forEach(function (content) {
                            content.copy(outBuffer, dindex); // write central directory entries
                            dindex += content.length;
                        });

                        const mh = mainHeader.toBinary();
                        if (_comment) {
                            _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment
                        }

                        mh.copy(outBuffer, dindex); // write main header

                        onSuccess(outBuffer);
                    }
                };

                compress2Buffer(entryList);
            } catch (e) {
                onFail(e);
            }
        }
    };
};


/***/ }),

/***/ 9417:
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    if(a===b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),

/***/ 8464:
/***/ ((module) => {

"use strict";

var ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'

// pre-compute lookup table
var ALPHABET_MAP = {}
for (var z = 0; z < ALPHABET.length; z++) {
  var x = ALPHABET.charAt(z)

  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')
  ALPHABET_MAP[x] = z
}

function polymodStep (pre) {
  var b = pre >> 25
  return ((pre & 0x1FFFFFF) << 5) ^
    (-((b >> 0) & 1) & 0x3b6a57b2) ^
    (-((b >> 1) & 1) & 0x26508e6d) ^
    (-((b >> 2) & 1) & 0x1ea119fa) ^
    (-((b >> 3) & 1) & 0x3d4233dd) ^
    (-((b >> 4) & 1) & 0x2a1462b3)
}

function prefixChk (prefix) {
  var chk = 1
  for (var i = 0; i < prefix.length; ++i) {
    var c = prefix.charCodeAt(i)
    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'

    chk = polymodStep(chk) ^ (c >> 5)
  }
  chk = polymodStep(chk)

  for (i = 0; i < prefix.length; ++i) {
    var v = prefix.charCodeAt(i)
    chk = polymodStep(chk) ^ (v & 0x1f)
  }
  return chk
}

function encode (prefix, words, LIMIT) {
  LIMIT = LIMIT || 90
  if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')

  prefix = prefix.toLowerCase()

  // determine chk mod
  var chk = prefixChk(prefix)
  if (typeof chk === 'string') throw new Error(chk)

  var result = prefix + '1'
  for (var i = 0; i < words.length; ++i) {
    var x = words[i]
    if ((x >> 5) !== 0) throw new Error('Non 5-bit word')

    chk = polymodStep(chk) ^ x
    result += ALPHABET.charAt(x)
  }

  for (i = 0; i < 6; ++i) {
    chk = polymodStep(chk)
  }
  chk ^= 1

  for (i = 0; i < 6; ++i) {
    var v = (chk >> ((5 - i) * 5)) & 0x1f
    result += ALPHABET.charAt(v)
  }

  return result
}

function __decode (str, LIMIT) {
  LIMIT = LIMIT || 90
  if (str.length < 8) return str + ' too short'
  if (str.length > LIMIT) return 'Exceeds length limit'

  // don't allow mixed case
  var lowered = str.toLowerCase()
  var uppered = str.toUpperCase()
  if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str
  str = lowered

  var split = str.lastIndexOf('1')
  if (split === -1) return 'No separator character for ' + str
  if (split === 0) return 'Missing prefix for ' + str

  var prefix = str.slice(0, split)
  var wordChars = str.slice(split + 1)
  if (wordChars.length < 6) return 'Data too short'

  var chk = prefixChk(prefix)
  if (typeof chk === 'string') return chk

  var words = []
  for (var i = 0; i < wordChars.length; ++i) {
    var c = wordChars.charAt(i)
    var v = ALPHABET_MAP[c]
    if (v === undefined) return 'Unknown character ' + c
    chk = polymodStep(chk) ^ v

    // not in the checksum?
    if (i + 6 >= wordChars.length) continue
    words.push(v)
  }

  if (chk !== 1) return 'Invalid checksum for ' + str
  return { prefix: prefix, words: words }
}

function decodeUnsafe () {
  var res = __decode.apply(null, arguments)
  if (typeof res === 'object') return res
}

function decode (str) {
  var res = __decode.apply(null, arguments)
  if (typeof res === 'object') return res

  throw new Error(res)
}

function convert (data, inBits, outBits, pad) {
  var value = 0
  var bits = 0
  var maxV = (1 << outBits) - 1

  var result = []
  for (var i = 0; i < data.length; ++i) {
    value = (value << inBits) | data[i]
    bits += inBits

    while (bits >= outBits) {
      bits -= outBits
      result.push((value >> bits) & maxV)
    }
  }

  if (pad) {
    if (bits > 0) {
      result.push((value << (outBits - bits)) & maxV)
    }
  } else {
    if (bits >= inBits) return 'Excess padding'
    if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'
  }

  return result
}

function toWordsUnsafe (bytes) {
  var res = convert(bytes, 8, 5, true)
  if (Array.isArray(res)) return res
}

function toWords (bytes) {
  var res = convert(bytes, 8, 5, true)
  if (Array.isArray(res)) return res

  throw new Error(res)
}

function fromWordsUnsafe (words) {
  var res = convert(words, 5, 8, false)
  if (Array.isArray(res)) return res
}

function fromWords (words) {
  var res = convert(words, 5, 8, false)
  if (Array.isArray(res)) return res

  throw new Error(res)
}

module.exports = {
  decodeUnsafe: decodeUnsafe,
  decode: decode,
  encode: encode,
  toWordsUnsafe: toWordsUnsafe,
  toWords: toWords,
  fromWordsUnsafe: fromWordsUnsafe,
  fromWords: fromWords
}


/***/ }),

/***/ 3682:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var register = __nccwpck_require__(4670)
var addHook = __nccwpck_require__(5549)
var removeHook = __nccwpck_require__(6819)

// bind with array of arguments: https://stackoverflow.com/a/21792913
var bind = Function.bind
var bindable = bind.bind(bind)

function bindApi (hook, state, name) {
  var removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state])
  hook.api = { remove: removeHookRef }
  hook.remove = removeHookRef

  ;['before', 'error', 'after', 'wrap'].forEach(function (kind) {
    var args = name ? [state, kind, name] : [state, kind]
    hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args)
  })
}

function HookSingular () {
  var singularHookName = 'h'
  var singularHookState = {
    registry: {}
  }
  var singularHook = register.bind(null, singularHookState, singularHookName)
  bindApi(singularHook, singularHookState, singularHookName)
  return singularHook
}

function HookCollection () {
  var state = {
    registry: {}
  }

  var hook = register.bind(null, state)
  bindApi(hook, state)

  return hook
}

var collectionHookDeprecationMessageDisplayed = false
function Hook () {
  if (!collectionHookDeprecationMessageDisplayed) {
    console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4')
    collectionHookDeprecationMessageDisplayed = true
  }
  return HookCollection()
}

Hook.Singular = HookSingular.bind()
Hook.Collection = HookCollection.bind()

module.exports = Hook
// expose constructors as a named property for TypeScript
module.exports.Hook = Hook
module.exports.Singular = Hook.Singular
module.exports.Collection = Hook.Collection


/***/ }),

/***/ 5549:
/***/ ((module) => {

module.exports = addHook;

function addHook(state, kind, name, hook) {
  var orig = hook;
  if (!state.registry[name]) {
    state.registry[name] = [];
  }

  if (kind === "before") {
    hook = function (method, options) {
      return Promise.resolve()
        .then(orig.bind(null, options))
        .then(method.bind(null, options));
    };
  }

  if (kind === "after") {
    hook = function (method, options) {
      var result;
      return Promise.resolve()
        .then(method.bind(null, options))
        .then(function (result_) {
          result = result_;
          return orig(result, options);
        })
        .then(function () {
          return result;
        });
    };
  }

  if (kind === "error") {
    hook = function (method, options) {
      return Promise.resolve()
        .then(method.bind(null, options))
        .catch(function (error) {
          return orig(error, options);
        });
    };
  }

  state.registry[name].push({
    hook: hook,
    orig: orig,
  });
}


/***/ }),

/***/ 4670:
/***/ ((module) => {

module.exports = register;

function register(state, name, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }

  if (!options) {
    options = {};
  }

  if (Array.isArray(name)) {
    return name.reverse().reduce(function (callback, name) {
      return register.bind(null, state, name, callback, options);
    }, method)();
  }

  return Promise.resolve().then(function () {
    if (!state.registry[name]) {
      return method(options);
    }

    return state.registry[name].reduce(function (method, registered) {
      return registered.hook.bind(null, method, options);
    }, method)();
  });
}


/***/ }),

/***/ 6819:
/***/ ((module) => {

module.exports = removeHook;

function removeHook(state, name, method) {
  if (!state.registry[name]) {
    return;
  }

  var index = state.registry[name]
    .map(function (registered) {
      return registered.orig;
    })
    .indexOf(method);

  if (index === -1) {
    return;
  }

  state.registry[name].splice(index, 1);
}


/***/ }),

/***/ 6641:
/***/ (function(module, __unused_webpack_exports, __nccwpck_require__) {

/* module decorator */ module = __nccwpck_require__.nmd(module);
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = (__nccwpck_require__(4300).Buffer);
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this._strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // '0' - '9'
    if (c >= 48 && c <= 57) {
      return c - 48;
    // 'A' - 'F'
    } else if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      assert(false, 'Invalid character in ' + string);
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this._strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        b = c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa;

      // '0' - '9'
      } else {
        b = c;
      }
      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this._strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  function move (dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }

  BN.prototype._move = function _move (dest) {
    move(dest, this);
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype._strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    try {
      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }

  function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16, 2);
  };

  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this._strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] >>> wbit) & 0x01;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this._strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this._strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this._strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this._strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this._strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this._strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out._strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out._strip();
  }

  function jumboMulTo (self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this._strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this._strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this._strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this._strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this._strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this._strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q._strip();
    }
    a._strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modrn = function modrn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return isNegNum ? -acc : acc;
  };

  // WARNING: DEPRECATED
  BN.prototype.modn = function modn (num) {
    return this.modrn(num);
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    this._strip();
    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this._strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);


/***/ }),

/***/ 3717:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var concatMap = __nccwpck_require__(6891);
var balanced = __nccwpck_require__(9417);

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}



/***/ }),

/***/ 9266:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = __nccwpck_require__(6113);
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}


/***/ }),

/***/ 6891:
/***/ ((module) => {

module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ 8932:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

class Deprecation extends Error {
  constructor(message) {
    super(message); // Maintains proper stack trace (only available on V8)

    /* istanbul ignore next */

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    this.name = 'Deprecation';
  }

}

exports.Deprecation = Deprecation;


/***/ }),

/***/ 9485:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var elliptic = exports;

elliptic.version = (__nccwpck_require__(8597)/* .version */ .i8);
elliptic.utils = __nccwpck_require__(9274);
elliptic.rand = __nccwpck_require__(9266);
elliptic.curve = __nccwpck_require__(9356);
elliptic.curves = __nccwpck_require__(8315);

// Protocols
elliptic.ec = __nccwpck_require__(8505);
elliptic.eddsa = __nccwpck_require__(2612);


/***/ }),

/***/ 9331:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var BN = __nccwpck_require__(2729);
var utils = __nccwpck_require__(9274);
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
  points,
  coeffs,
  len,
  jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b], /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3,  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null,
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles,
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res,
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};


/***/ }),

/***/ 9837:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(9274);
var BN = __nccwpck_require__(2729);
var inherits = __nccwpck_require__(4124);
var Base = __nccwpck_require__(9331);

var assert = utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;
  if (this.curve.twisted) {
    // E = a * C
    e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      h = this.z.redSqr();
      // J = F - 2 * H
      j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    e = c.redAdd(d);
    // H = (c * Z1)^2
    h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;


/***/ }),

/***/ 9356:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var curve = exports;

curve.base = __nccwpck_require__(9331);
curve.short = __nccwpck_require__(9345);
curve.mont = __nccwpck_require__(6820);
curve.edwards = __nccwpck_require__(9837);


/***/ }),

/***/ 6820:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var BN = __nccwpck_require__(2729);
var inherits = __nccwpck_require__(4124);
var Base = __nccwpck_require__(9331);

var utils = __nccwpck_require__(9274);

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};


/***/ }),

/***/ 9345:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(9274);
var BN = __nccwpck_require__(2729);
var inherits = __nccwpck_require__(4124);
var Base = __nccwpck_require__(9331);

var assert = utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis,
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 },
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();

        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }

        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

      // Clean-up references to points and coefficients
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul),
      },
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1),
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1),
    },
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point)),
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point)),
    },
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate),
      },
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};


/***/ }),

/***/ 8315:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var curves = exports;

var hash = __nccwpck_require__(5591);
var curve = __nccwpck_require__(9356);
var utils = __nccwpck_require__(9274);

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve.edwards(options);
  else
    this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve,
      });
      return curve;
    },
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
  ],
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
  ],
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
  ],
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
  ],
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
  ],
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9',
  ],
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658',
  ],
});

var pre;
try {
  pre = __nccwpck_require__(806);
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3',
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15',
    },
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre,
  ],
});


/***/ }),

/***/ 8505:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var BN = __nccwpck_require__(2729);
var HmacDRBG = __nccwpck_require__(4909);
var utils = __nccwpck_require__(9274);
var curves = __nccwpck_require__(8315);
var rand = __nccwpck_require__(9266);
var assert = utils.assert;

var KeyPair = __nccwpck_require__(1663);
var Signature = __nccwpck_require__(173);

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(Object.prototype.hasOwnProperty.call(curves, options),
      'Unknown curve ' + options);

    options = curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray(),
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  for (;;) {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; ; iter++) {
    var k = options.k ?
      options.k(iter) :
      new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};


/***/ }),

/***/ 1663:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var BN = __nccwpck_require__(2729);
var utils = __nccwpck_require__(9274);
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc,
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc,
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  if(!pub.validate()) {
    assert(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};


/***/ }),

/***/ 173:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var BN = __nccwpck_require__(2729);

var utils = __nccwpck_require__(9274);
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};


/***/ }),

/***/ 2612:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var hash = __nccwpck_require__(5591);
var curves = __nccwpck_require__(8315);
var utils = __nccwpck_require__(9274);
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = __nccwpck_require__(7247);
var Signature = __nccwpck_require__(1087);

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
    .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};


/***/ }),

/***/ 7247:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(9274);
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;


/***/ }),

/***/ 1087:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var BN = __nccwpck_require__(2729);
var utils = __nccwpck_require__(9274);
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength),
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;


/***/ }),

/***/ 806:
/***/ ((module) => {

module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
      ],
    ],
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
      ],
    ],
  },
};


/***/ }),

/***/ 9274:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var utils = exports;
var BN = __nccwpck_require__(2729);
var minAssert = __nccwpck_require__(910);
var minUtils = __nccwpck_require__(8165);

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  naf.fill(0);

  var ws = 1 << (w + 1);
  var k = num.clone();

  for (var i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    [],
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
      this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
    bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;



/***/ }),

/***/ 2729:
/***/ (function(module, __unused_webpack_exports, __nccwpck_require__) {

/* module decorator */ module = __nccwpck_require__.nmd(module);
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = (__nccwpck_require__(4300).Buffer);
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);


/***/ }),

/***/ 6863:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = realpath
realpath.realpath = realpath
realpath.sync = realpathSync
realpath.realpathSync = realpathSync
realpath.monkeypatch = monkeypatch
realpath.unmonkeypatch = unmonkeypatch

var fs = __nccwpck_require__(7147)
var origRealpath = fs.realpath
var origRealpathSync = fs.realpathSync

var version = process.version
var ok = /^v[0-5]\./.test(version)
var old = __nccwpck_require__(1734)

function newError (er) {
  return er && er.syscall === 'realpath' && (
    er.code === 'ELOOP' ||
    er.code === 'ENOMEM' ||
    er.code === 'ENAMETOOLONG'
  )
}

function realpath (p, cache, cb) {
  if (ok) {
    return origRealpath(p, cache, cb)
  }

  if (typeof cache === 'function') {
    cb = cache
    cache = null
  }
  origRealpath(p, cache, function (er, result) {
    if (newError(er)) {
      old.realpath(p, cache, cb)
    } else {
      cb(er, result)
    }
  })
}

function realpathSync (p, cache) {
  if (ok) {
    return origRealpathSync(p, cache)
  }

  try {
    return origRealpathSync(p, cache)
  } catch (er) {
    if (newError(er)) {
      return old.realpathSync(p, cache)
    } else {
      throw er
    }
  }
}

function monkeypatch () {
  fs.realpath = realpath
  fs.realpathSync = realpathSync
}

function unmonkeypatch () {
  fs.realpath = origRealpath
  fs.realpathSync = origRealpathSync
}


/***/ }),

/***/ 1734:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var pathModule = __nccwpck_require__(1017);
var isWindows = process.platform === 'win32';
var fs = __nccwpck_require__(7147);

// JavaScript implementation of realpath, ported from node pre-v6

var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

function rethrow() {
  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
  // is fairly slow to generate.
  var callback;
  if (DEBUG) {
    var backtrace = new Error;
    callback = debugCallback;
  } else
    callback = missingCallback;

  return callback;

  function debugCallback(err) {
    if (err) {
      backtrace.message = err.message;
      err = backtrace;
      missingCallback(err);
    }
  }

  function missingCallback(err) {
    if (err) {
      if (process.throwDeprecation)
        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs
      else if (!process.noDeprecation) {
        var msg = 'fs: missing callback ' + (err.stack || err.message);
        if (process.traceDeprecation)
          console.trace(msg);
        else
          console.error(msg);
      }
    }
  }
}

function maybeCallback(cb) {
  return typeof cb === 'function' ? cb : rethrow();
}

var normalize = pathModule.normalize;

// Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
if (isWindows) {
  var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
  var nextPartRe = /(.*?)(?:[\/]+|$)/g;
}

// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
if (isWindows) {
  var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
  var splitRootRe = /^[\/]*/;
}

exports.realpathSync = function realpathSync(p, cache) {
  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstatSync(base);
      knownHard[base] = true;
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.
  while (pos < p.length) {
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      continue;
    }

    var resolvedLink;
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // some known symbolic link.  no need to stat again.
      resolvedLink = cache[base];
    } else {
      var stat = fs.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      }

      // read the link if it wasn't read before
      // dev/ino always return 0 on windows, so skip the check.
      var linkTarget = null;
      if (!isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs.statSync(base);
        linkTarget = fs.readlinkSync(base);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);
      // track this, if given a cache.
      if (cache) cache[base] = resolvedLink;
      if (!isWindows) seenLinks[id] = linkTarget;
    }

    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache[original] = p;

  return p;
};


exports.realpath = function realpath(p, cache, cb) {
  if (typeof cb !== 'function') {
    cb = maybeCallback(cache);
    cache = null;
  }

  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process.nextTick(cb.bind(null, null, cache[p]));
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstat(base, function(err) {
        if (err) return cb(err);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  function LOOP() {
    // stop if scanned past end of path
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    }

    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      return process.nextTick(LOOP);
    }

    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // known symbolic link.  no need to stat again.
      return gotResolvedLink(cache[base]);
    }

    return fs.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return cb(err);

    // if not a symlink, skip to the next path part
    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process.nextTick(LOOP);
    }

    // stat & read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.
    if (!isWindows) {
      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    fs.stat(base, function(err) {
      if (err) return cb(err);

      fs.readlink(base, function(err, target) {
        if (!isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return cb(err);

    var resolvedLink = pathModule.resolve(previous, target);
    if (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
};


/***/ }),

/***/ 7625:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

exports.setopts = setopts
exports.ownProp = ownProp
exports.makeAbs = makeAbs
exports.finish = finish
exports.mark = mark
exports.isIgnored = isIgnored
exports.childrenIgnored = childrenIgnored

function ownProp (obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field)
}

var fs = __nccwpck_require__(7147)
var path = __nccwpck_require__(1017)
var minimatch = __nccwpck_require__(3973)
var isAbsolute = __nccwpck_require__(8714)
var Minimatch = minimatch.Minimatch

function alphasort (a, b) {
  return a.localeCompare(b, 'en')
}

function setupIgnores (self, options) {
  self.ignore = options.ignore || []

  if (!Array.isArray(self.ignore))
    self.ignore = [self.ignore]

  if (self.ignore.length) {
    self.ignore = self.ignore.map(ignoreMap)
  }
}

// ignore patterns are always in dot:true mode.
function ignoreMap (pattern) {
  var gmatcher = null
  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
    gmatcher = new Minimatch(gpattern, { dot: true })
  }

  return {
    matcher: new Minimatch(pattern, { dot: true }),
    gmatcher: gmatcher
  }
}

function setopts (self, pattern, options) {
  if (!options)
    options = {}

  // base-matching: just use globstar for that.
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar")
    }
    pattern = "**/" + pattern
  }

  self.silent = !!options.silent
  self.pattern = pattern
  self.strict = options.strict !== false
  self.realpath = !!options.realpath
  self.realpathCache = options.realpathCache || Object.create(null)
  self.follow = !!options.follow
  self.dot = !!options.dot
  self.mark = !!options.mark
  self.nodir = !!options.nodir
  if (self.nodir)
    self.mark = true
  self.sync = !!options.sync
  self.nounique = !!options.nounique
  self.nonull = !!options.nonull
  self.nosort = !!options.nosort
  self.nocase = !!options.nocase
  self.stat = !!options.stat
  self.noprocess = !!options.noprocess
  self.absolute = !!options.absolute
  self.fs = options.fs || fs

  self.maxLength = options.maxLength || Infinity
  self.cache = options.cache || Object.create(null)
  self.statCache = options.statCache || Object.create(null)
  self.symlinks = options.symlinks || Object.create(null)

  setupIgnores(self, options)

  self.changedCwd = false
  var cwd = process.cwd()
  if (!ownProp(options, "cwd"))
    self.cwd = cwd
  else {
    self.cwd = path.resolve(options.cwd)
    self.changedCwd = self.cwd !== cwd
  }

  self.root = options.root || path.resolve(self.cwd, "/")
  self.root = path.resolve(self.root)
  if (process.platform === "win32")
    self.root = self.root.replace(/\\/g, "/")

  // TODO: is an absolute `cwd` supposed to be resolved against `root`?
  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')
  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)
  if (process.platform === "win32")
    self.cwdAbs = self.cwdAbs.replace(/\\/g, "/")
  self.nomount = !!options.nomount

  // disable comments and negation in Minimatch.
  // Note that they are not supported in Glob itself anyway.
  options.nonegate = true
  options.nocomment = true
  // always treat \ in patterns as escapes, not path separators
  options.allowWindowsEscape = false

  self.minimatch = new Minimatch(pattern, options)
  self.options = self.minimatch.options
}

function finish (self) {
  var nou = self.nounique
  var all = nou ? [] : Object.create(null)

  for (var i = 0, l = self.matches.length; i < l; i ++) {
    var matches = self.matches[i]
    if (!matches || Object.keys(matches).length === 0) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i]
        if (nou)
          all.push(literal)
        else
          all[literal] = true
      }
    } else {
      // had matches
      var m = Object.keys(matches)
      if (nou)
        all.push.apply(all, m)
      else
        m.forEach(function (m) {
          all[m] = true
        })
    }
  }

  if (!nou)
    all = Object.keys(all)

  if (!self.nosort)
    all = all.sort(alphasort)

  // at *some* point we statted all of these
  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i])
    }
    if (self.nodir) {
      all = all.filter(function (e) {
        var notDir = !(/\/$/.test(e))
        var c = self.cache[e] || self.cache[makeAbs(self, e)]
        if (notDir && c)
          notDir = c !== 'DIR' && !Array.isArray(c)
        return notDir
      })
    }
  }

  if (self.ignore.length)
    all = all.filter(function(m) {
      return !isIgnored(self, m)
    })

  self.found = all
}

function mark (self, p) {
  var abs = makeAbs(self, p)
  var c = self.cache[abs]
  var m = p
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c)
    var slash = p.slice(-1) === '/'

    if (isDir && !slash)
      m += '/'
    else if (!isDir && slash)
      m = m.slice(0, -1)

    if (m !== p) {
      var mabs = makeAbs(self, m)
      self.statCache[mabs] = self.statCache[abs]
      self.cache[mabs] = self.cache[abs]
    }
  }

  return m
}

// lotta situps...
function makeAbs (self, f) {
  var abs = f
  if (f.charAt(0) === '/') {
    abs = path.join(self.root, f)
  } else if (isAbsolute(f) || f === '') {
    abs = f
  } else if (self.changedCwd) {
    abs = path.resolve(self.cwd, f)
  } else {
    abs = path.resolve(f)
  }

  if (process.platform === 'win32')
    abs = abs.replace(/\\/g, '/')

  return abs
}


// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function isIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
  })
}

function childrenIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path))
  })
}


/***/ }),

/***/ 1957:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

module.exports = glob

var rp = __nccwpck_require__(6863)
var minimatch = __nccwpck_require__(3973)
var Minimatch = minimatch.Minimatch
var inherits = __nccwpck_require__(4124)
var EE = (__nccwpck_require__(2361).EventEmitter)
var path = __nccwpck_require__(1017)
var assert = __nccwpck_require__(9491)
var isAbsolute = __nccwpck_require__(8714)
var globSync = __nccwpck_require__(9010)
var common = __nccwpck_require__(7625)
var setopts = common.setopts
var ownProp = common.ownProp
var inflight = __nccwpck_require__(2492)
var util = __nccwpck_require__(3837)
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

var once = __nccwpck_require__(1223)

function glob (pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {}
  if (!options) options = {}

  if (options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return globSync(pattern, options)
  }

  return new Glob(pattern, options, cb)
}

glob.sync = globSync
var GlobSync = glob.GlobSync = globSync.GlobSync

// old api surface
glob.glob = glob

function extend (origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin
  }

  var keys = Object.keys(add)
  var i = keys.length
  while (i--) {
    origin[keys[i]] = add[keys[i]]
  }
  return origin
}

glob.hasMagic = function (pattern, options_) {
  var options = extend({}, options_)
  options.noprocess = true

  var g = new Glob(pattern, options)
  var set = g.minimatch.set

  if (!pattern)
    return false

  if (set.length > 1)
    return true

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string')
      return true
  }

  return false
}

glob.Glob = Glob
inherits(Glob, EE)
function Glob (pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = null
  }

  if (options && options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return new GlobSync(pattern, options)
  }

  if (!(this instanceof Glob))
    return new Glob(pattern, options, cb)

  setopts(this, pattern, options)
  this._didRealPath = false

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n)

  if (typeof cb === 'function') {
    cb = once(cb)
    this.on('error', cb)
    this.on('end', function (matches) {
      cb(null, matches)
    })
  }

  var self = this
  this._processing = 0

  this._emitQueue = []
  this._processQueue = []
  this.paused = false

  if (this.noprocess)
    return this

  if (n === 0)
    return done()

  var sync = true
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false, done)
  }
  sync = false

  function done () {
    --self._processing
    if (self._processing <= 0) {
      if (sync) {
        process.nextTick(function () {
          self._finish()
        })
      } else {
        self._finish()
      }
    }
  }
}

Glob.prototype._finish = function () {
  assert(this instanceof Glob)
  if (this.aborted)
    return

  if (this.realpath && !this._didRealpath)
    return this._realpath()

  common.finish(this)
  this.emit('end', this.found)
}

Glob.prototype._realpath = function () {
  if (this._didRealpath)
    return

  this._didRealpath = true

  var n = this.matches.length
  if (n === 0)
    return this._finish()

  var self = this
  for (var i = 0; i < this.matches.length; i++)
    this._realpathSet(i, next)

  function next () {
    if (--n === 0)
      self._finish()
  }
}

Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index]
  if (!matchset)
    return cb()

  var found = Object.keys(matchset)
  var self = this
  var n = found.length

  if (n === 0)
    return cb()

  var set = this.matches[index] = Object.create(null)
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p)
    rp.realpath(p, self.realpathCache, function (er, real) {
      if (!er)
        set[real] = true
      else if (er.syscall === 'stat')
        set[p] = true
      else
        self.emit('error', er) // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set
        cb()
      }
    })
  })
}

Glob.prototype._mark = function (p) {
  return common.mark(this, p)
}

Glob.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

Glob.prototype.abort = function () {
  this.aborted = true
  this.emit('abort')
}

Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true
    this.emit('pause')
  }
}

Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume')
    this.paused = false
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0)
      this._emitQueue.length = 0
      for (var i = 0; i < eq.length; i ++) {
        var e = eq[i]
        this._emitMatch(e[0], e[1])
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0)
      this._processQueue.length = 0
      for (var i = 0; i < pq.length; i ++) {
        var p = pq[i]
        this._processing--
        this._process(p[0], p[1], p[2], p[3])
      }
    }
  }
}

Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob)
  assert(typeof cb === 'function')

  if (this.aborted)
    return

  this._processing++
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb])
    return
  }

  //console.error('PROCESS %d', this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) ||
      isAbsolute(pattern.map(function (p) {
        return typeof p === 'string' ? p : '[*]'
      }).join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip _processing
  if (childrenIgnored(this, read))
    return cb()

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
}

Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}

Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return cb()

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return cb()

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return cb()
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix) {
      if (prefix !== '/')
        e = prefix + '/' + e
      else
        e = prefix + e
    }
    this._process([e].concat(remain), index, inGlobStar, cb)
  }
  cb()
}

Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted)
    return

  if (isIgnored(this, e))
    return

  if (this.paused) {
    this._emitQueue.push([index, e])
    return
  }

  var abs = isAbsolute(e) ? e : this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute)
    e = abs

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  var st = this.statCache[abs]
  if (st)
    this.emit('stat', e, st)

  this.emit('match', e)
}

Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted)
    return

  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false, cb)

  var lstatkey = 'lstat\0' + abs
  var self = this
  var lstatcb = inflight(lstatkey, lstatcb_)

  if (lstatcb)
    self.fs.lstat(abs, lstatcb)

  function lstatcb_ (er, lstat) {
    if (er && er.code === 'ENOENT')
      return cb()

    var isSym = lstat && lstat.isSymbolicLink()
    self.symlinks[abs] = isSym

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && lstat && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE'
      cb()
    } else
      self._readdir(abs, false, cb)
  }
}

Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted)
    return

  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
  if (!cb)
    return

  //console.error('RD %j %j', +inGlobStar, abs)
  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs, cb)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return cb()

    if (Array.isArray(c))
      return cb(null, c)
  }

  var self = this
  self.fs.readdir(abs, readdirCb(this, abs, cb))
}

function readdirCb (self, abs, cb) {
  return function (er, entries) {
    if (er)
      self._readdirError(abs, er, cb)
    else
      self._readdirEntries(abs, entries, cb)
  }
}

Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted)
    return

  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries
  return cb(null, entries)
}

Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted)
    return

  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        this.emit('error', error)
        this.abort()
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict) {
        this.emit('error', er)
        // If the error is handled, then we abort
        // if not, we threw out of here
        this.abort()
      }
      if (!this.silent)
        console.error('glob error', er)
      break
  }

  return cb()
}

Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}


Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return cb()

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false, cb)

  var isSym = this.symlinks[abs]
  var len = entries.length

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return cb()

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true, cb)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true, cb)
  }

  cb()
}

Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this
  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb)
  })
}
Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

  //console.error('ps2', prefix, exists)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return cb()

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
  cb()
}

// Returns either 'DIR', 'FILE', or false
Glob.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return cb()

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return cb(null, c)

    if (needDir && c === 'FILE')
      return cb()

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (stat !== undefined) {
    if (stat === false)
      return cb(null, stat)
    else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE'
      if (needDir && type === 'FILE')
        return cb()
      else
        return cb(null, type, stat)
    }
  }

  var self = this
  var statcb = inflight('stat\0' + abs, lstatcb_)
  if (statcb)
    self.fs.lstat(abs, statcb)

  function lstatcb_ (er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return self.fs.stat(abs, function (er, stat) {
        if (er)
          self._stat2(f, abs, null, lstat, cb)
        else
          self._stat2(f, abs, er, stat, cb)
      })
    } else {
      self._stat2(f, abs, er, lstat, cb)
    }
  }
}

Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
    this.statCache[abs] = false
    return cb()
  }

  var needDir = f.slice(-1) === '/'
  this.statCache[abs] = stat

  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())
    return cb(null, false, stat)

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'
  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return cb()

  return cb(null, c, stat)
}


/***/ }),

/***/ 9010:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = globSync
globSync.GlobSync = GlobSync

var rp = __nccwpck_require__(6863)
var minimatch = __nccwpck_require__(3973)
var Minimatch = minimatch.Minimatch
var Glob = (__nccwpck_require__(1957).Glob)
var util = __nccwpck_require__(3837)
var path = __nccwpck_require__(1017)
var assert = __nccwpck_require__(9491)
var isAbsolute = __nccwpck_require__(8714)
var common = __nccwpck_require__(7625)
var setopts = common.setopts
var ownProp = common.ownProp
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

function globSync (pattern, options) {
  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  return new GlobSync(pattern, options).found
}

function GlobSync (pattern, options) {
  if (!pattern)
    throw new Error('must provide pattern')

  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  if (!(this instanceof GlobSync))
    return new GlobSync(pattern, options)

  setopts(this, pattern, options)

  if (this.noprocess)
    return this

  var n = this.minimatch.set.length
  this.matches = new Array(n)
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false)
  }
  this._finish()
}

GlobSync.prototype._finish = function () {
  assert.ok(this instanceof GlobSync)
  if (this.realpath) {
    var self = this
    this.matches.forEach(function (matchset, index) {
      var set = self.matches[index] = Object.create(null)
      for (var p in matchset) {
        try {
          p = self._makeAbs(p)
          var real = rp.realpathSync(p, self.realpathCache)
          set[real] = true
        } catch (er) {
          if (er.syscall === 'stat')
            set[self._makeAbs(p)] = true
          else
            throw er
        }
      }
    })
  }
  common.finish(this)
}


GlobSync.prototype._process = function (pattern, index, inGlobStar) {
  assert.ok(this instanceof GlobSync)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // See if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) ||
      isAbsolute(pattern.map(function (p) {
        return typeof p === 'string' ? p : '[*]'
      }).join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip processing
  if (childrenIgnored(this, read))
    return

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
}


GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar)

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix.slice(-1) !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix)
      newPattern = [prefix, e]
    else
      newPattern = [e]
    this._process(newPattern.concat(remain), index, inGlobStar)
  }
}


GlobSync.prototype._emitMatch = function (index, e) {
  if (isIgnored(this, e))
    return

  var abs = this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute) {
    e = abs
  }

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  if (this.stat)
    this._stat(e)
}


GlobSync.prototype._readdirInGlobStar = function (abs) {
  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false)

  var entries
  var lstat
  var stat
  try {
    lstat = this.fs.lstatSync(abs)
  } catch (er) {
    if (er.code === 'ENOENT') {
      // lstat failed, doesn't exist
      return null
    }
  }

  var isSym = lstat && lstat.isSymbolicLink()
  this.symlinks[abs] = isSym

  // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.
  if (!isSym && lstat && !lstat.isDirectory())
    this.cache[abs] = 'FILE'
  else
    entries = this._readdir(abs, false)

  return entries
}

GlobSync.prototype._readdir = function (abs, inGlobStar) {
  var entries

  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return null

    if (Array.isArray(c))
      return c
  }

  try {
    return this._readdirEntries(abs, this.fs.readdirSync(abs))
  } catch (er) {
    this._readdirError(abs, er)
    return null
  }
}

GlobSync.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries

  // mark and cache dir-ness
  return entries
}

GlobSync.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        throw error
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict)
        throw er
      if (!this.silent)
        console.error('glob error', er)
      break
  }
}

GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

  var entries = this._readdir(abs, inGlobStar)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false)

  var len = entries.length
  var isSym = this.symlinks[abs]

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true)
  }
}

GlobSync.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
}

// Returns either 'DIR', 'FILE', or false
GlobSync.prototype._stat = function (f) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return false

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return c

    if (needDir && c === 'FILE')
      return false

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (!stat) {
    var lstat
    try {
      lstat = this.fs.lstatSync(abs)
    } catch (er) {
      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
        this.statCache[abs] = false
        return false
      }
    }

    if (lstat && lstat.isSymbolicLink()) {
      try {
        stat = this.fs.statSync(abs)
      } catch (er) {
        stat = lstat
      }
    } else {
      stat = lstat
    }
  }

  this.statCache[abs] = stat

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'

  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return false

  return c
}

GlobSync.prototype._mark = function (p) {
  return common.mark(this, p)
}

GlobSync.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}


/***/ }),

/***/ 5591:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

var hash = exports;

hash.utils = __nccwpck_require__(4844);
hash.common = __nccwpck_require__(7511);
hash.sha = __nccwpck_require__(1183);
hash.ripemd = __nccwpck_require__(4502);
hash.hmac = __nccwpck_require__(1084);

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;


/***/ }),

/***/ 7511:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(4844);
var assert = __nccwpck_require__(910);

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};


/***/ }),

/***/ 1084:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(4844);
var assert = __nccwpck_require__(910);

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};


/***/ }),

/***/ 4502:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(4844);
var common = __nccwpck_require__(7511);

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];


/***/ }),

/***/ 1183:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


exports.sha1 = __nccwpck_require__(9918);
exports.sha224 = __nccwpck_require__(2847);
exports.sha256 = __nccwpck_require__(6996);
exports.sha384 = __nccwpck_require__(4752);
exports.sha512 = __nccwpck_require__(3433);


/***/ }),

/***/ 9918:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(4844);
var common = __nccwpck_require__(7511);
var shaCommon = __nccwpck_require__(950);

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ 2847:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(4844);
var SHA256 = __nccwpck_require__(6996);

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};



/***/ }),

/***/ 6996:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(4844);
var common = __nccwpck_require__(7511);
var shaCommon = __nccwpck_require__(950);
var assert = __nccwpck_require__(910);

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ 4752:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(4844);

var SHA512 = __nccwpck_require__(3433);

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};


/***/ }),

/***/ 3433:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(4844);
var common = __nccwpck_require__(7511);
var assert = __nccwpck_require__(910);

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}


/***/ }),

/***/ 950:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var utils = __nccwpck_require__(4844);
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;


/***/ }),

/***/ 4844:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var assert = __nccwpck_require__(910);
var inherits = __nccwpck_require__(4124);

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;


/***/ }),

/***/ 4909:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var hash = __nccwpck_require__(5591);
var utils = __nccwpck_require__(8165);
var assert = __nccwpck_require__(910);

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};


/***/ }),

/***/ 2492:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var wrappy = __nccwpck_require__(2940)
var reqs = Object.create(null)
var once = __nccwpck_require__(1223)

module.exports = wrappy(inflight)

function inflight (key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb)
    return null
  } else {
    reqs[key] = [cb]
    return makeres(key)
  }
}

function makeres (key) {
  return once(function RES () {
    var cbs = reqs[key]
    var len = cbs.length
    var args = slice(arguments)

    // XXX It's somewhat ambiguous whether a new callback added in this
    // pass should be queued for later execution if something in the
    // list of callbacks throws, or if it should just be discarded.
    // However, it's such an edge case that it hardly matters, and either
    // choice is likely as surprising as the other.
    // As it happens, we do go ahead and schedule it for later execution.
    try {
      for (var i = 0; i < len; i++) {
        cbs[i].apply(null, args)
      }
    } finally {
      if (cbs.length > len) {
        // added more in the interim.
        // de-zalgo, just in case, but don't call again.
        cbs.splice(0, len)
        process.nextTick(function () {
          RES.apply(null, args)
        })
      } else {
        delete reqs[key]
      }
    }
  })
}

function slice (args) {
  var length = args.length
  var array = []

  for (var i = 0; i < length; i++) array[i] = args[i]
  return array
}


/***/ }),

/***/ 4124:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

try {
  var util = __nccwpck_require__(3837);
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __nccwpck_require__(8544);
}


/***/ }),

/***/ 8544:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ 3287:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

function isObject(o) {
  return Object.prototype.toString.call(o) === '[object Object]';
}

function isPlainObject(o) {
  var ctor,prot;

  if (isObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (ctor === undefined) return true;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
}

exports.isPlainObject = isPlainObject;


/***/ }),

/***/ 1434:
/***/ ((module) => {

/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var INPUT_ERROR = 'input is invalid type';
  var FINALIZE_ERROR = 'finalize already called';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_SHA3_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && "object" === 'object' && module.exports;
  var AMD = typeof define === 'function' && define.amd;
  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
  var KECCAK_PADDING = [1, 256, 65536, 16777216];
  var PADDING = [6, 1536, 393216, 100663296];
  var SHIFT = [0, 8, 16, 24];
  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  var BITS = [224, 256, 384, 512];
  var SHAKE_BITS = [128, 256];
  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
  var CSHAKE_BYTEPAD = {
    '128': 168,
    '256': 136
  };

  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (bits, padding, outputType) {
    return function (message) {
      return new Keccak(bits, padding, bits).update(message)[outputType]();
    };
  };

  var createShakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits) {
      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
    };
  };

  var createCshakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits, n, s) {
      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
    };
  };

  var createKmacOutputMethod = function (bits, padding, outputType) {
    return function (key, message, outputBits, s) {
      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
    };
  };

  var createOutputMethods = function (method, createMethod, bits, padding) {
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createMethod(bits, padding, type);
    }
    return method;
  };

  var createMethod = function (bits, padding) {
    var method = createOutputMethod(bits, padding, 'hex');
    method.create = function () {
      return new Keccak(bits, padding, bits);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    return createOutputMethods(method, createOutputMethod, bits, padding);
  };

  var createShakeMethod = function (bits, padding) {
    var method = createShakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits) {
      return new Keccak(bits, padding, outputBits);
    };
    method.update = function (message, outputBits) {
      return method.create(outputBits).update(message);
    };
    return createOutputMethods(method, createShakeOutputMethod, bits, padding);
  };

  var createCshakeMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createCshakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits, n, s) {
      if (!n && !s) {
        return methods['shake' + bits].create(outputBits);
      } else {
        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
      }
    };
    method.update = function (message, outputBits, n, s) {
      return method.create(outputBits, n, s).update(message);
    };
    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
  };

  var createKmacMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createKmacOutputMethod(bits, padding, 'hex');
    method.create = function (key, outputBits, s) {
      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
    };
    method.update = function (key, message, outputBits, s) {
      return method.create(key, outputBits, s).update(message);
    };
    return createOutputMethods(method, createKmacOutputMethod, bits, padding);
  };

  var algorithms = [
    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },
    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },
    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
  ];

  var methods = {}, methodNames = [];

  for (var i = 0; i < algorithms.length; ++i) {
    var algorithm = algorithms[i];
    var bits = algorithm.bits;
    for (var j = 0; j < bits.length; ++j) {
      var methodName = algorithm.name + '_' + bits[j];
      methodNames.push(methodName);
      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
      if (algorithm.name !== 'sha3') {
        var newMethodName = algorithm.name + bits[j];
        methodNames.push(newMethodName);
        methods[newMethodName] = methods[methodName];
      }
    }
  }

  function Keccak(bits, padding, outputBits) {
    this.blocks = [];
    this.s = [];
    this.padding = padding;
    this.outputBits = outputBits;
    this.reset = true;
    this.finalized = false;
    this.block = 0;
    this.start = 0;
    this.blockCount = (1600 - (bits << 1)) >> 5;
    this.byteCount = this.blockCount << 2;
    this.outputBlocks = outputBits >> 5;
    this.extraBytes = (outputBits & 31) >> 3;

    for (var i = 0; i < 50; ++i) {
      this.s[i] = 0;
    }
  }

  Keccak.prototype.update = function (message) {
    if (this.finalized) {
      throw new Error(FINALIZE_ERROR);
    }
    var notString, type = typeof message;
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,
      blockCount = this.blockCount, index = 0, s = this.s, i, code;

    while (index < length) {
      if (this.reset) {
        this.reset = false;
        blocks[0] = this.block;
        for (i = 1; i < blockCount + 1; ++i) {
          blocks[i] = 0;
        }
      }
      if (notString) {
        for (i = this.start; index < length && i < byteCount; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < byteCount; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }
      this.lastByteIndex = i;
      if (i >= byteCount) {
        this.start = i - byteCount;
        this.block = blocks[blockCount];
        for (i = 0; i < blockCount; ++i) {
          s[i] ^= blocks[i];
        }
        f(s);
        this.reset = true;
      } else {
        this.start = i;
      }
    }
    return this;
  };

  Keccak.prototype.encode = function (x, right) {
    var o = x & 255, n = 1;
    var bytes = [o];
    x = x >> 8;
    o = x & 255;
    while (o > 0) {
      bytes.unshift(o);
      x = x >> 8;
      o = x & 255;
      ++n;
    }
    if (right) {
      bytes.push(n);
    } else {
      bytes.unshift(n);
    }
    this.update(bytes);
    return bytes.length;
  };

  Keccak.prototype.encodeString = function (str) {
    var notString, type = typeof str;
    if (type !== 'string') {
      if (type === 'object') {
        if (str === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
          str = new Uint8Array(str);
        } else if (!Array.isArray(str)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var bytes = 0, length = str.length;
    if (notString) {
      bytes = length;
    } else {
      for (var i = 0; i < str.length; ++i) {
        var code = str.charCodeAt(i);
        if (code < 0x80) {
          bytes += 1;
        } else if (code < 0x800) {
          bytes += 2;
        } else if (code < 0xd800 || code >= 0xe000) {
          bytes += 3;
        } else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));
          bytes += 4;
        }
      }
    }
    bytes += this.encode(bytes * 8);
    this.update(str);
    return bytes;
  };

  Keccak.prototype.bytepad = function (strs, w) {
    var bytes = this.encode(w);
    for (var i = 0; i < strs.length; ++i) {
      bytes += this.encodeString(strs[i]);
    }
    var paddingBytes = w - bytes % w;
    var zeros = [];
    zeros.length = paddingBytes;
    this.update(zeros);
    return this;
  };

  Keccak.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
    blocks[i >> 2] |= this.padding[i & 3];
    if (this.lastByteIndex === this.byteCount) {
      blocks[0] = blocks[blockCount];
      for (i = 1; i < blockCount + 1; ++i) {
        blocks[i] = 0;
      }
    }
    blocks[blockCount - 1] |= 0x80000000;
    for (i = 0; i < blockCount; ++i) {
      s[i] ^= blocks[i];
    }
    f(s);
  };

  Keccak.prototype.toString = Keccak.prototype.hex = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var hex = '', block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        block = s[i];
        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
      }
      if (j % blockCount === 0) {
        f(s);
        i = 0;
      }
    }
    if (extraBytes) {
      block = s[i];
      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
      if (extraBytes > 1) {
        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
      }
      if (extraBytes > 2) {
        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
      }
    }
    return hex;
  };

  Keccak.prototype.arrayBuffer = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var bytes = this.outputBits >> 3;
    var buffer;
    if (extraBytes) {
      buffer = new ArrayBuffer((outputBlocks + 1) << 2);
    } else {
      buffer = new ArrayBuffer(bytes);
    }
    var array = new Uint32Array(buffer);
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        array[j] = s[i];
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      array[i] = s[i];
      buffer = buffer.slice(0, bytes);
    }
    return buffer;
  };

  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

  Keccak.prototype.digest = Keccak.prototype.array = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var array = [], offset, block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        offset = j << 2;
        block = s[i];
        array[offset] = block & 0xFF;
        array[offset + 1] = (block >> 8) & 0xFF;
        array[offset + 2] = (block >> 16) & 0xFF;
        array[offset + 3] = (block >> 24) & 0xFF;
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      offset = j << 2;
      block = s[i];
      array[offset] = block & 0xFF;
      if (extraBytes > 1) {
        array[offset + 1] = (block >> 8) & 0xFF;
      }
      if (extraBytes > 2) {
        array[offset + 2] = (block >> 16) & 0xFF;
      }
    }
    return array;
  };

  function Kmac(bits, padding, outputBits) {
    Keccak.call(this, bits, padding, outputBits);
  }

  Kmac.prototype = new Keccak();

  Kmac.prototype.finalize = function () {
    this.encode(this.outputBits, true);
    return Keccak.prototype.finalize.call(this);
  };

  var f = function (s) {
    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,
      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,
      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,
      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
    for (n = 0; n < 48; n += 2) {
      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

      h = c8 ^ ((c2 << 1) | (c3 >>> 31));
      l = c9 ^ ((c3 << 1) | (c2 >>> 31));
      s[0] ^= h;
      s[1] ^= l;
      s[10] ^= h;
      s[11] ^= l;
      s[20] ^= h;
      s[21] ^= l;
      s[30] ^= h;
      s[31] ^= l;
      s[40] ^= h;
      s[41] ^= l;
      h = c0 ^ ((c4 << 1) | (c5 >>> 31));
      l = c1 ^ ((c5 << 1) | (c4 >>> 31));
      s[2] ^= h;
      s[3] ^= l;
      s[12] ^= h;
      s[13] ^= l;
      s[22] ^= h;
      s[23] ^= l;
      s[32] ^= h;
      s[33] ^= l;
      s[42] ^= h;
      s[43] ^= l;
      h = c2 ^ ((c6 << 1) | (c7 >>> 31));
      l = c3 ^ ((c7 << 1) | (c6 >>> 31));
      s[4] ^= h;
      s[5] ^= l;
      s[14] ^= h;
      s[15] ^= l;
      s[24] ^= h;
      s[25] ^= l;
      s[34] ^= h;
      s[35] ^= l;
      s[44] ^= h;
      s[45] ^= l;
      h = c4 ^ ((c8 << 1) | (c9 >>> 31));
      l = c5 ^ ((c9 << 1) | (c8 >>> 31));
      s[6] ^= h;
      s[7] ^= l;
      s[16] ^= h;
      s[17] ^= l;
      s[26] ^= h;
      s[27] ^= l;
      s[36] ^= h;
      s[37] ^= l;
      s[46] ^= h;
      s[47] ^= l;
      h = c6 ^ ((c0 << 1) | (c1 >>> 31));
      l = c7 ^ ((c1 << 1) | (c0 >>> 31));
      s[8] ^= h;
      s[9] ^= l;
      s[18] ^= h;
      s[19] ^= l;
      s[28] ^= h;
      s[29] ^= l;
      s[38] ^= h;
      s[39] ^= l;
      s[48] ^= h;
      s[49] ^= l;

      b0 = s[0];
      b1 = s[1];
      b32 = (s[11] << 4) | (s[10] >>> 28);
      b33 = (s[10] << 4) | (s[11] >>> 28);
      b14 = (s[20] << 3) | (s[21] >>> 29);
      b15 = (s[21] << 3) | (s[20] >>> 29);
      b46 = (s[31] << 9) | (s[30] >>> 23);
      b47 = (s[30] << 9) | (s[31] >>> 23);
      b28 = (s[40] << 18) | (s[41] >>> 14);
      b29 = (s[41] << 18) | (s[40] >>> 14);
      b20 = (s[2] << 1) | (s[3] >>> 31);
      b21 = (s[3] << 1) | (s[2] >>> 31);
      b2 = (s[13] << 12) | (s[12] >>> 20);
      b3 = (s[12] << 12) | (s[13] >>> 20);
      b34 = (s[22] << 10) | (s[23] >>> 22);
      b35 = (s[23] << 10) | (s[22] >>> 22);
      b16 = (s[33] << 13) | (s[32] >>> 19);
      b17 = (s[32] << 13) | (s[33] >>> 19);
      b48 = (s[42] << 2) | (s[43] >>> 30);
      b49 = (s[43] << 2) | (s[42] >>> 30);
      b40 = (s[5] << 30) | (s[4] >>> 2);
      b41 = (s[4] << 30) | (s[5] >>> 2);
      b22 = (s[14] << 6) | (s[15] >>> 26);
      b23 = (s[15] << 6) | (s[14] >>> 26);
      b4 = (s[25] << 11) | (s[24] >>> 21);
      b5 = (s[24] << 11) | (s[25] >>> 21);
      b36 = (s[34] << 15) | (s[35] >>> 17);
      b37 = (s[35] << 15) | (s[34] >>> 17);
      b18 = (s[45] << 29) | (s[44] >>> 3);
      b19 = (s[44] << 29) | (s[45] >>> 3);
      b10 = (s[6] << 28) | (s[7] >>> 4);
      b11 = (s[7] << 28) | (s[6] >>> 4);
      b42 = (s[17] << 23) | (s[16] >>> 9);
      b43 = (s[16] << 23) | (s[17] >>> 9);
      b24 = (s[26] << 25) | (s[27] >>> 7);
      b25 = (s[27] << 25) | (s[26] >>> 7);
      b6 = (s[36] << 21) | (s[37] >>> 11);
      b7 = (s[37] << 21) | (s[36] >>> 11);
      b38 = (s[47] << 24) | (s[46] >>> 8);
      b39 = (s[46] << 24) | (s[47] >>> 8);
      b30 = (s[8] << 27) | (s[9] >>> 5);
      b31 = (s[9] << 27) | (s[8] >>> 5);
      b12 = (s[18] << 20) | (s[19] >>> 12);
      b13 = (s[19] << 20) | (s[18] >>> 12);
      b44 = (s[29] << 7) | (s[28] >>> 25);
      b45 = (s[28] << 7) | (s[29] >>> 25);
      b26 = (s[38] << 8) | (s[39] >>> 24);
      b27 = (s[39] << 8) | (s[38] >>> 24);
      b8 = (s[48] << 14) | (s[49] >>> 18);
      b9 = (s[49] << 14) | (s[48] >>> 18);

      s[0] = b0 ^ (~b2 & b4);
      s[1] = b1 ^ (~b3 & b5);
      s[10] = b10 ^ (~b12 & b14);
      s[11] = b11 ^ (~b13 & b15);
      s[20] = b20 ^ (~b22 & b24);
      s[21] = b21 ^ (~b23 & b25);
      s[30] = b30 ^ (~b32 & b34);
      s[31] = b31 ^ (~b33 & b35);
      s[40] = b40 ^ (~b42 & b44);
      s[41] = b41 ^ (~b43 & b45);
      s[2] = b2 ^ (~b4 & b6);
      s[3] = b3 ^ (~b5 & b7);
      s[12] = b12 ^ (~b14 & b16);
      s[13] = b13 ^ (~b15 & b17);
      s[22] = b22 ^ (~b24 & b26);
      s[23] = b23 ^ (~b25 & b27);
      s[32] = b32 ^ (~b34 & b36);
      s[33] = b33 ^ (~b35 & b37);
      s[42] = b42 ^ (~b44 & b46);
      s[43] = b43 ^ (~b45 & b47);
      s[4] = b4 ^ (~b6 & b8);
      s[5] = b5 ^ (~b7 & b9);
      s[14] = b14 ^ (~b16 & b18);
      s[15] = b15 ^ (~b17 & b19);
      s[24] = b24 ^ (~b26 & b28);
      s[25] = b25 ^ (~b27 & b29);
      s[34] = b34 ^ (~b36 & b38);
      s[35] = b35 ^ (~b37 & b39);
      s[44] = b44 ^ (~b46 & b48);
      s[45] = b45 ^ (~b47 & b49);
      s[6] = b6 ^ (~b8 & b0);
      s[7] = b7 ^ (~b9 & b1);
      s[16] = b16 ^ (~b18 & b10);
      s[17] = b17 ^ (~b19 & b11);
      s[26] = b26 ^ (~b28 & b20);
      s[27] = b27 ^ (~b29 & b21);
      s[36] = b36 ^ (~b38 & b30);
      s[37] = b37 ^ (~b39 & b31);
      s[46] = b46 ^ (~b48 & b40);
      s[47] = b47 ^ (~b49 & b41);
      s[8] = b8 ^ (~b0 & b2);
      s[9] = b9 ^ (~b1 & b3);
      s[18] = b18 ^ (~b10 & b12);
      s[19] = b19 ^ (~b11 & b13);
      s[28] = b28 ^ (~b20 & b22);
      s[29] = b29 ^ (~b21 & b23);
      s[38] = b38 ^ (~b30 & b32);
      s[39] = b39 ^ (~b31 & b33);
      s[48] = b48 ^ (~b40 & b42);
      s[49] = b49 ^ (~b41 & b43);

      s[0] ^= RC[n];
      s[1] ^= RC[n + 1];
    }
  };

  if (COMMON_JS) {
    module.exports = methods;
  } else {
    for (i = 0; i < methodNames.length; ++i) {
      root[methodNames[i]] = methods[methodNames[i]];
    }
    if (AMD) {
      define(function () {
        return methods;
      });
    }
  }
})();


/***/ }),

/***/ 1857:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getNative = __nccwpck_require__(4479),
    root = __nccwpck_require__(9882);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ 5902:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var hashClear = __nccwpck_require__(1789),
    hashDelete = __nccwpck_require__(712),
    hashGet = __nccwpck_require__(5395),
    hashHas = __nccwpck_require__(5232),
    hashSet = __nccwpck_require__(7320);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ 6608:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var listCacheClear = __nccwpck_require__(9792),
    listCacheDelete = __nccwpck_require__(7716),
    listCacheGet = __nccwpck_require__(5789),
    listCacheHas = __nccwpck_require__(9386),
    listCacheSet = __nccwpck_require__(7399);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ 881:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getNative = __nccwpck_require__(4479),
    root = __nccwpck_require__(9882);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ 938:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var mapCacheClear = __nccwpck_require__(1610),
    mapCacheDelete = __nccwpck_require__(6657),
    mapCacheGet = __nccwpck_require__(1372),
    mapCacheHas = __nccwpck_require__(609),
    mapCacheSet = __nccwpck_require__(5582);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ 4671:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getNative = __nccwpck_require__(4479),
    root = __nccwpck_require__(9882);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ 5793:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getNative = __nccwpck_require__(4479),
    root = __nccwpck_require__(9882);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ 558:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var MapCache = __nccwpck_require__(938),
    setCacheAdd = __nccwpck_require__(6895),
    setCacheHas = __nccwpck_require__(804);

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),

/***/ 5323:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var ListCache = __nccwpck_require__(6608),
    stackClear = __nccwpck_require__(2843),
    stackDelete = __nccwpck_require__(4717),
    stackGet = __nccwpck_require__(21),
    stackHas = __nccwpck_require__(3910),
    stackSet = __nccwpck_require__(9955);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ 9213:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var root = __nccwpck_require__(9882);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ 3261:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var root = __nccwpck_require__(9882);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ 3915:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getNative = __nccwpck_require__(4479),
    root = __nccwpck_require__(9882);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ 9647:
/***/ ((module) => {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),

/***/ 8388:
/***/ ((module) => {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ 7183:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseIndexOf = __nccwpck_require__(5425);

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;


/***/ }),

/***/ 6732:
/***/ ((module) => {

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;


/***/ }),

/***/ 2237:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseTimes = __nccwpck_require__(7765),
    isArguments = __nccwpck_require__(8495),
    isArray = __nccwpck_require__(4869),
    isBuffer = __nccwpck_require__(4190),
    isIndex = __nccwpck_require__(2936),
    isTypedArray = __nccwpck_require__(2496);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ 4356:
/***/ ((module) => {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),

/***/ 82:
/***/ ((module) => {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ 9410:
/***/ ((module) => {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),

/***/ 6752:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var eq = __nccwpck_require__(1901);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ 3236:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseForOwn = __nccwpck_require__(5712),
    createBaseEach = __nccwpck_require__(9327);

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;


/***/ }),

/***/ 7265:
/***/ ((module) => {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;


/***/ }),

/***/ 9588:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var arrayPush = __nccwpck_require__(82),
    isFlattenable = __nccwpck_require__(9299);

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),

/***/ 6588:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var createBaseFor = __nccwpck_require__(5709);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),

/***/ 5712:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseFor = __nccwpck_require__(6588),
    keys = __nccwpck_require__(7645);

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;


/***/ }),

/***/ 5758:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var castPath = __nccwpck_require__(2688),
    toKey = __nccwpck_require__(9071);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),

/***/ 5951:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var arrayPush = __nccwpck_require__(82),
    isArray = __nccwpck_require__(4869);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ 7497:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Symbol = __nccwpck_require__(9213),
    getRawTag = __nccwpck_require__(923),
    objectToString = __nccwpck_require__(4200);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ 4129:
/***/ ((module) => {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),

/***/ 5425:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseFindIndex = __nccwpck_require__(7265),
    baseIsNaN = __nccwpck_require__(8048),
    strictIndexOf = __nccwpck_require__(8868);

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;


/***/ }),

/***/ 2177:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseGetTag = __nccwpck_require__(7497),
    isObjectLike = __nccwpck_require__(5926);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ 8494:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseIsEqualDeep = __nccwpck_require__(3987),
    isObjectLike = __nccwpck_require__(5926);

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),

/***/ 3987:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Stack = __nccwpck_require__(5323),
    equalArrays = __nccwpck_require__(6305),
    equalByTag = __nccwpck_require__(9106),
    equalObjects = __nccwpck_require__(101),
    getTag = __nccwpck_require__(941),
    isArray = __nccwpck_require__(4869),
    isBuffer = __nccwpck_require__(4190),
    isTypedArray = __nccwpck_require__(2496);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),

/***/ 9124:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Stack = __nccwpck_require__(5323),
    baseIsEqual = __nccwpck_require__(8494);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),

/***/ 8048:
/***/ ((module) => {

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;


/***/ }),

/***/ 411:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isFunction = __nccwpck_require__(7799),
    isMasked = __nccwpck_require__(9058),
    isObject = __nccwpck_require__(3334),
    toSource = __nccwpck_require__(6928);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ 1528:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseGetTag = __nccwpck_require__(7497),
    isLength = __nccwpck_require__(4530),
    isObjectLike = __nccwpck_require__(5926);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ 427:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseMatches = __nccwpck_require__(599),
    baseMatchesProperty = __nccwpck_require__(7591),
    identity = __nccwpck_require__(7822),
    isArray = __nccwpck_require__(4869),
    property = __nccwpck_require__(7261);

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),

/***/ 7164:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isPrototype = __nccwpck_require__(10),
    nativeKeys = __nccwpck_require__(5778);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ 6192:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseEach = __nccwpck_require__(3236),
    isArrayLike = __nccwpck_require__(8017);

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;


/***/ }),

/***/ 599:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseIsMatch = __nccwpck_require__(9124),
    getMatchData = __nccwpck_require__(2458),
    matchesStrictComparable = __nccwpck_require__(3509);

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),

/***/ 7591:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseIsEqual = __nccwpck_require__(8494),
    get = __nccwpck_require__(6908),
    hasIn = __nccwpck_require__(9409),
    isKey = __nccwpck_require__(9084),
    isStrictComparable = __nccwpck_require__(9789),
    matchesStrictComparable = __nccwpck_require__(3509),
    toKey = __nccwpck_require__(9071);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),

/***/ 2850:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var arrayMap = __nccwpck_require__(4356),
    baseGet = __nccwpck_require__(5758),
    baseIteratee = __nccwpck_require__(427),
    baseMap = __nccwpck_require__(6192),
    baseSortBy = __nccwpck_require__(9241),
    baseUnary = __nccwpck_require__(9258),
    compareMultiple = __nccwpck_require__(8386),
    identity = __nccwpck_require__(7822),
    isArray = __nccwpck_require__(4869);

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap(iteratees, function(iteratee) {
      if (isArray(iteratee)) {
        return function(value) {
          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        }
      }
      return iteratee;
    });
  } else {
    iteratees = [identity];
  }

  var index = -1;
  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));

  var result = baseMap(collection, function(value, key, collection) {
    var criteria = arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}

module.exports = baseOrderBy;


/***/ }),

/***/ 6829:
/***/ ((module) => {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),

/***/ 974:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseGet = __nccwpck_require__(5758);

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),

/***/ 6578:
/***/ ((module) => {

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}

module.exports = baseRange;


/***/ }),

/***/ 5979:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var identity = __nccwpck_require__(7822),
    overRest = __nccwpck_require__(2417),
    setToString = __nccwpck_require__(8416);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),

/***/ 979:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var constant = __nccwpck_require__(5946),
    defineProperty = __nccwpck_require__(416),
    identity = __nccwpck_require__(7822);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),

/***/ 9241:
/***/ ((module) => {

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

module.exports = baseSortBy;


/***/ }),

/***/ 7765:
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ 6792:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Symbol = __nccwpck_require__(9213),
    arrayMap = __nccwpck_require__(4356),
    isArray = __nccwpck_require__(4869),
    isSymbol = __nccwpck_require__(264);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),

/***/ 9528:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var trimmedEndIndex = __nccwpck_require__(7010);

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

module.exports = baseTrim;


/***/ }),

/***/ 9258:
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ 9036:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var SetCache = __nccwpck_require__(558),
    arrayIncludes = __nccwpck_require__(7183),
    arrayIncludesWith = __nccwpck_require__(6732),
    cacheHas = __nccwpck_require__(2675),
    createSet = __nccwpck_require__(6505),
    setToArray = __nccwpck_require__(4955);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;


/***/ }),

/***/ 2675:
/***/ ((module) => {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),

/***/ 2688:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isArray = __nccwpck_require__(4869),
    isKey = __nccwpck_require__(9084),
    stringToPath = __nccwpck_require__(1853),
    toString = __nccwpck_require__(2931);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),

/***/ 3201:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isSymbol = __nccwpck_require__(264);

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

module.exports = compareAscending;


/***/ }),

/***/ 8386:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var compareAscending = __nccwpck_require__(3201);

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

module.exports = compareMultiple;


/***/ }),

/***/ 8380:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var root = __nccwpck_require__(9882);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ 9327:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isArrayLike = __nccwpck_require__(8017);

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;


/***/ }),

/***/ 5709:
/***/ ((module) => {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),

/***/ 3382:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseRange = __nccwpck_require__(6578),
    isIterateeCall = __nccwpck_require__(2482),
    toFinite = __nccwpck_require__(9323);

/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
      end = step = undefined;
    }
    // Ensure the sign of `-0` is preserved.
    start = toFinite(start);
    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }
    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
    return baseRange(start, end, step, fromRight);
  };
}

module.exports = createRange;


/***/ }),

/***/ 6505:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Set = __nccwpck_require__(5793),
    noop = __nccwpck_require__(6022),
    setToArray = __nccwpck_require__(4955);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

module.exports = createSet;


/***/ }),

/***/ 416:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getNative = __nccwpck_require__(4479);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),

/***/ 6305:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var SetCache = __nccwpck_require__(558),
    arraySome = __nccwpck_require__(9410),
    cacheHas = __nccwpck_require__(2675);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),

/***/ 9106:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Symbol = __nccwpck_require__(9213),
    Uint8Array = __nccwpck_require__(3261),
    eq = __nccwpck_require__(1901),
    equalArrays = __nccwpck_require__(6305),
    mapToArray = __nccwpck_require__(5853),
    setToArray = __nccwpck_require__(4955);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),

/***/ 101:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getAllKeys = __nccwpck_require__(8009);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),

/***/ 2085:
/***/ ((module) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;


/***/ }),

/***/ 8009:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseGetAllKeys = __nccwpck_require__(5951),
    getSymbols = __nccwpck_require__(6802),
    keys = __nccwpck_require__(7645);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ 9980:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isKeyable = __nccwpck_require__(3308);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ 2458:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isStrictComparable = __nccwpck_require__(9789),
    keys = __nccwpck_require__(7645);

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),

/***/ 4479:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseIsNative = __nccwpck_require__(411),
    getValue = __nccwpck_require__(3542);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ 923:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Symbol = __nccwpck_require__(9213);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ 6802:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var arrayFilter = __nccwpck_require__(8388),
    stubArray = __nccwpck_require__(8634);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ 941:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var DataView = __nccwpck_require__(1857),
    Map = __nccwpck_require__(881),
    Promise = __nccwpck_require__(4671),
    Set = __nccwpck_require__(5793),
    WeakMap = __nccwpck_require__(3915),
    baseGetTag = __nccwpck_require__(7497),
    toSource = __nccwpck_require__(6928);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ 3542:
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ 7658:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var castPath = __nccwpck_require__(2688),
    isArguments = __nccwpck_require__(8495),
    isArray = __nccwpck_require__(4869),
    isIndex = __nccwpck_require__(2936),
    isLength = __nccwpck_require__(4530),
    toKey = __nccwpck_require__(9071);

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),

/***/ 1789:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var nativeCreate = __nccwpck_require__(3041);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ 712:
/***/ ((module) => {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ 5395:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var nativeCreate = __nccwpck_require__(3041);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ 5232:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var nativeCreate = __nccwpck_require__(3041);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ 7320:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var nativeCreate = __nccwpck_require__(3041);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ 9299:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Symbol = __nccwpck_require__(9213),
    isArguments = __nccwpck_require__(8495),
    isArray = __nccwpck_require__(4869);

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),

/***/ 2936:
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ 2482:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var eq = __nccwpck_require__(1901),
    isArrayLike = __nccwpck_require__(8017),
    isIndex = __nccwpck_require__(2936),
    isObject = __nccwpck_require__(3334);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),

/***/ 9084:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isArray = __nccwpck_require__(4869),
    isSymbol = __nccwpck_require__(264);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),

/***/ 3308:
/***/ ((module) => {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ 9058:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var coreJsData = __nccwpck_require__(8380);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ 10:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ 9789:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isObject = __nccwpck_require__(3334);

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),

/***/ 9792:
/***/ ((module) => {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ 7716:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var assocIndexOf = __nccwpck_require__(6752);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ 5789:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var assocIndexOf = __nccwpck_require__(6752);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ 9386:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var assocIndexOf = __nccwpck_require__(6752);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ 7399:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var assocIndexOf = __nccwpck_require__(6752);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ 1610:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Hash = __nccwpck_require__(5902),
    ListCache = __nccwpck_require__(6608),
    Map = __nccwpck_require__(881);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ 6657:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getMapData = __nccwpck_require__(9980);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ 1372:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getMapData = __nccwpck_require__(9980);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ 609:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getMapData = __nccwpck_require__(9980);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ 5582:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getMapData = __nccwpck_require__(9980);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ 5853:
/***/ ((module) => {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),

/***/ 3509:
/***/ ((module) => {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),

/***/ 9422:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var memoize = __nccwpck_require__(9885);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),

/***/ 3041:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var getNative = __nccwpck_require__(4479);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ 5778:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var overArg = __nccwpck_require__(6320);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ 4643:
/***/ ((module, exports, __nccwpck_require__) => {

/* module decorator */ module = __nccwpck_require__.nmd(module);
var freeGlobal = __nccwpck_require__(2085);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;


/***/ }),

/***/ 4200:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ 6320:
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ 2417:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var apply = __nccwpck_require__(9647);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),

/***/ 9882:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var freeGlobal = __nccwpck_require__(2085);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ 6895:
/***/ ((module) => {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),

/***/ 804:
/***/ ((module) => {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),

/***/ 4955:
/***/ ((module) => {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),

/***/ 8416:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseSetToString = __nccwpck_require__(979),
    shortOut = __nccwpck_require__(7882);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),

/***/ 7882:
/***/ ((module) => {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),

/***/ 2843:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var ListCache = __nccwpck_require__(6608);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ 4717:
/***/ ((module) => {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ 21:
/***/ ((module) => {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ 3910:
/***/ ((module) => {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ 9955:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var ListCache = __nccwpck_require__(6608),
    Map = __nccwpck_require__(881),
    MapCache = __nccwpck_require__(938);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ 8868:
/***/ ((module) => {

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;


/***/ }),

/***/ 1853:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var memoizeCapped = __nccwpck_require__(9422);

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),

/***/ 9071:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isSymbol = __nccwpck_require__(264);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),

/***/ 6928:
/***/ ((module) => {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ 7010:
/***/ ((module) => {

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

module.exports = trimmedEndIndex;


/***/ }),

/***/ 5946:
/***/ ((module) => {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),

/***/ 1901:
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ 6908:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseGet = __nccwpck_require__(5758);

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),

/***/ 9409:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseHasIn = __nccwpck_require__(4129),
    hasPath = __nccwpck_require__(7658);

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),

/***/ 7822:
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ 8495:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseIsArguments = __nccwpck_require__(2177),
    isObjectLike = __nccwpck_require__(5926);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ 4869:
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ 8017:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isFunction = __nccwpck_require__(7799),
    isLength = __nccwpck_require__(4530);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ 4190:
/***/ ((module, exports, __nccwpck_require__) => {

/* module decorator */ module = __nccwpck_require__.nmd(module);
var root = __nccwpck_require__(9882),
    stubFalse = __nccwpck_require__(1389);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;


/***/ }),

/***/ 52:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseIsEqual = __nccwpck_require__(8494);

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;


/***/ }),

/***/ 7799:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseGetTag = __nccwpck_require__(7497),
    isObject = __nccwpck_require__(3334);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ 4530:
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ 3334:
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ 5926:
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ 264:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseGetTag = __nccwpck_require__(7497),
    isObjectLike = __nccwpck_require__(5926);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ 2496:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseIsTypedArray = __nccwpck_require__(1528),
    baseUnary = __nccwpck_require__(9258),
    nodeUtil = __nccwpck_require__(4643);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ 7645:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var arrayLikeKeys = __nccwpck_require__(2237),
    baseKeys = __nccwpck_require__(7164),
    isArrayLike = __nccwpck_require__(8017);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ 9885:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var MapCache = __nccwpck_require__(938);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),

/***/ 6022:
/***/ ((module) => {

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;


/***/ }),

/***/ 7261:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseProperty = __nccwpck_require__(6829),
    basePropertyDeep = __nccwpck_require__(974),
    isKey = __nccwpck_require__(9084),
    toKey = __nccwpck_require__(9071);

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),

/***/ 9826:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var createRange = __nccwpck_require__(3382);

/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */
var range = createRange();

module.exports = range;


/***/ }),

/***/ 9774:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseFlatten = __nccwpck_require__(9588),
    baseOrderBy = __nccwpck_require__(2850),
    baseRest = __nccwpck_require__(5979),
    isIterateeCall = __nccwpck_require__(2482);

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 30 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
 */
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});

module.exports = sortBy;


/***/ }),

/***/ 8634:
/***/ ((module) => {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ 1389:
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ 9323:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var toNumber = __nccwpck_require__(1235);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;


/***/ }),

/***/ 1235:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseTrim = __nccwpck_require__(9528),
    isObject = __nccwpck_require__(3334),
    isSymbol = __nccwpck_require__(264);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),

/***/ 2931:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseToString = __nccwpck_require__(6792);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),

/***/ 2854:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var baseUniq = __nccwpck_require__(9036);

/**
 * This method is like `_.uniq` except that it accepts `comparator` which
 * is invoked to compare elements of `array`. The order of result values is
 * determined by the order they occur in the array.The comparator is invoked
 * with two arguments: (arrVal, othVal).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
 *
 * _.uniqWith(objects, _.isEqual);
 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
 */
function uniqWith(array, comparator) {
  comparator = typeof comparator == 'function' ? comparator : undefined;
  return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
}

module.exports = uniqWith;


/***/ }),

/***/ 910:
/***/ ((module) => {

module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};


/***/ }),

/***/ 8165:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};


/***/ }),

/***/ 3973:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = (function () { try { return __nccwpck_require__(1017) } catch (e) {}}()) || {
  sep: '/'
}
minimatch.sep = path.sep

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = __nccwpck_require__(3717)

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  b = b || {}
  var t = {}
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || typeof def !== 'object' || !Object.keys(def).length) {
    return minimatch
  }

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }
  m.Minimatch.defaults = function defaults (options) {
    return orig.defaults(ext(def, options)).Minimatch
  }

  m.filter = function filter (pattern, options) {
    return orig.filter(pattern, ext(def, options))
  }

  m.defaults = function defaults (options) {
    return orig.defaults(ext(def, options))
  }

  m.makeRe = function makeRe (pattern, options) {
    return orig.makeRe(pattern, ext(def, options))
  }

  m.braceExpand = function braceExpand (pattern, options) {
    return orig.braceExpand(pattern, ext(def, options))
  }

  m.match = function (list, pattern, options) {
    return orig.match(list, pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  assertValidPattern(pattern)

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  assertValidPattern(pattern)

  if (!options) options = {}

  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (!options.allowWindowsEscape && path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false
  this.partial = !!options.partial

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = function debug() { console.error.apply(console, arguments) }

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  assertValidPattern(pattern)

  // Thanks to Yeting Li <https://github.com/yetingli> for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

var MAX_PATTERN_LENGTH = 1024 * 64
var assertValidPattern = function (pattern) {
  if (typeof pattern !== 'string') {
    throw new TypeError('invalid pattern')
  }

  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError('pattern is too long')
  }
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  assertValidPattern(pattern)

  var options = this.options

  // shortcuts
  if (pattern === '**') {
    if (!options.noglobstar)
      return GLOBSTAR
    else
      pattern = '*'
  }
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      /* istanbul ignore next */
      case '/': {
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false
      }

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        // split where the last [ was, make sure we don't have
        // an invalid re. if so, re-walk the contents of the
        // would-be class to re-translate any characters that
        // were passed through as-is
        // TODO: It would probably be faster to determine this
        // without a try/catch and a new RegExp, but it's tricky
        // to do safely.  For now, this is safe and works.
        var cs = pattern.substring(classStart + 1, i)
        try {
          RegExp('[' + cs + ']')
        } catch (er) {
          // not a valid class!
          var sp = this.parse(cs, SUBPARSE)
          re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
          hasMagic = hasMagic || sp[1]
          inClass = false
          continue
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '[': case '.': case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) /* istanbul ignore next - should be impossible */ {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) /* istanbul ignore next - should be impossible */ {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = function match (f, partial) {
  if (typeof partial === 'undefined') partial = this.partial
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    /* istanbul ignore if */
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      /* istanbul ignore if */
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      hit = f === p
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else /* istanbul ignore else */ if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    return (fi === fl - 1) && (file[fi] === '')
  }

  // should be unreachable.
  /* istanbul ignore next */
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}


/***/ }),

/***/ 467:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Stream = _interopDefault(__nccwpck_require__(2781));
var http = _interopDefault(__nccwpck_require__(3685));
var Url = _interopDefault(__nccwpck_require__(7310));
var whatwgUrl = _interopDefault(__nccwpck_require__(8665));
var https = _interopDefault(__nccwpck_require__(5687));
var zlib = _interopDefault(__nccwpck_require__(9796));

// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js

// fix for "Readable" isn't a named export issue
const Readable = Stream.Readable;

const BUFFER = Symbol('buffer');
const TYPE = Symbol('type');

class Blob {
	constructor() {
		this[TYPE] = '';

		const blobParts = arguments[0];
		const options = arguments[1];

		const buffers = [];
		let size = 0;

		if (blobParts) {
			const a = blobParts;
			const length = Number(a.length);
			for (let i = 0; i < length; i++) {
				const element = a[i];
				let buffer;
				if (element instanceof Buffer) {
					buffer = element;
				} else if (ArrayBuffer.isView(element)) {
					buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
				} else if (element instanceof ArrayBuffer) {
					buffer = Buffer.from(element);
				} else if (element instanceof Blob) {
					buffer = element[BUFFER];
				} else {
					buffer = Buffer.from(typeof element === 'string' ? element : String(element));
				}
				size += buffer.length;
				buffers.push(buffer);
			}
		}

		this[BUFFER] = Buffer.concat(buffers);

		let type = options && options.type !== undefined && String(options.type).toLowerCase();
		if (type && !/[^\u0020-\u007E]/.test(type)) {
			this[TYPE] = type;
		}
	}
	get size() {
		return this[BUFFER].length;
	}
	get type() {
		return this[TYPE];
	}
	text() {
		return Promise.resolve(this[BUFFER].toString());
	}
	arrayBuffer() {
		const buf = this[BUFFER];
		const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		return Promise.resolve(ab);
	}
	stream() {
		const readable = new Readable();
		readable._read = function () {};
		readable.push(this[BUFFER]);
		readable.push(null);
		return readable;
	}
	toString() {
		return '[object Blob]';
	}
	slice() {
		const size = this.size;

		const start = arguments[0];
		const end = arguments[1];
		let relativeStart, relativeEnd;
		if (start === undefined) {
			relativeStart = 0;
		} else if (start < 0) {
			relativeStart = Math.max(size + start, 0);
		} else {
			relativeStart = Math.min(start, size);
		}
		if (end === undefined) {
			relativeEnd = size;
		} else if (end < 0) {
			relativeEnd = Math.max(size + end, 0);
		} else {
			relativeEnd = Math.min(end, size);
		}
		const span = Math.max(relativeEnd - relativeStart, 0);

		const buffer = this[BUFFER];
		const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
		const blob = new Blob([], { type: arguments[2] });
		blob[BUFFER] = slicedBuffer;
		return blob;
	}
}

Object.defineProperties(Blob.prototype, {
	size: { enumerable: true },
	type: { enumerable: true },
	slice: { enumerable: true }
});

Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
	value: 'Blob',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * fetch-error.js
 *
 * FetchError interface for operational errors
 */

/**
 * Create FetchError instance
 *
 * @param   String      message      Error message for human
 * @param   String      type         Error type for machine
 * @param   String      systemError  For Node.js system error
 * @return  FetchError
 */
function FetchError(message, type, systemError) {
  Error.call(this, message);

  this.message = message;
  this.type = type;

  // when err.type is `system`, err.code contains system error code
  if (systemError) {
    this.code = this.errno = systemError.code;
  }

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = 'FetchError';

let convert;
try {
	convert = (__nccwpck_require__(2877).convert);
} catch (e) {}

const INTERNALS = Symbol('Body internals');

// fix an issue where "PassThrough" isn't a named export for node <10
const PassThrough = Stream.PassThrough;

/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
function Body(body) {
	var _this = this;

	var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	    _ref$size = _ref.size;

	let size = _ref$size === undefined ? 0 : _ref$size;
	var _ref$timeout = _ref.timeout;
	let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;

	if (body == null) {
		// body is undefined or null
		body = null;
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		body = Buffer.from(body.toString());
	} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		body = Buffer.from(body);
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
	} else if (body instanceof Stream) ; else {
		// none of the above
		// coerce to string then buffer
		body = Buffer.from(String(body));
	}
	this[INTERNALS] = {
		body,
		disturbed: false,
		error: null
	};
	this.size = size;
	this.timeout = timeout;

	if (body instanceof Stream) {
		body.on('error', function (err) {
			const error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
			_this[INTERNALS].error = error;
		});
	}
}

Body.prototype = {
	get body() {
		return this[INTERNALS].body;
	},

	get bodyUsed() {
		return this[INTERNALS].disturbed;
	},

	/**
  * Decode response as ArrayBuffer
  *
  * @return  Promise
  */
	arrayBuffer() {
		return consumeBody.call(this).then(function (buf) {
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		});
	},

	/**
  * Return raw response as Blob
  *
  * @return Promise
  */
	blob() {
		let ct = this.headers && this.headers.get('content-type') || '';
		return consumeBody.call(this).then(function (buf) {
			return Object.assign(
			// Prevent copying
			new Blob([], {
				type: ct.toLowerCase()
			}), {
				[BUFFER]: buf
			});
		});
	},

	/**
  * Decode response as json
  *
  * @return  Promise
  */
	json() {
		var _this2 = this;

		return consumeBody.call(this).then(function (buffer) {
			try {
				return JSON.parse(buffer.toString());
			} catch (err) {
				return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
			}
		});
	},

	/**
  * Decode response as text
  *
  * @return  Promise
  */
	text() {
		return consumeBody.call(this).then(function (buffer) {
			return buffer.toString();
		});
	},

	/**
  * Decode response as buffer (non-spec api)
  *
  * @return  Promise
  */
	buffer() {
		return consumeBody.call(this);
	},

	/**
  * Decode response as text, while automatically detecting the encoding and
  * trying to decode to UTF-8 (non-spec api)
  *
  * @return  Promise
  */
	textConverted() {
		var _this3 = this;

		return consumeBody.call(this).then(function (buffer) {
			return convertBody(buffer, _this3.headers);
		});
	}
};

// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
	body: { enumerable: true },
	bodyUsed: { enumerable: true },
	arrayBuffer: { enumerable: true },
	blob: { enumerable: true },
	json: { enumerable: true },
	text: { enumerable: true }
});

Body.mixIn = function (proto) {
	for (const name of Object.getOwnPropertyNames(Body.prototype)) {
		// istanbul ignore else: future proof
		if (!(name in proto)) {
			const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
			Object.defineProperty(proto, name, desc);
		}
	}
};

/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return  Promise
 */
function consumeBody() {
	var _this4 = this;

	if (this[INTERNALS].disturbed) {
		return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
	}

	this[INTERNALS].disturbed = true;

	if (this[INTERNALS].error) {
		return Body.Promise.reject(this[INTERNALS].error);
	}

	let body = this.body;

	// body is null
	if (body === null) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is blob
	if (isBlob(body)) {
		body = body.stream();
	}

	// body is buffer
	if (Buffer.isBuffer(body)) {
		return Body.Promise.resolve(body);
	}

	// istanbul ignore if: should never happen
	if (!(body instanceof Stream)) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is stream
	// get ready to actually consume the body
	let accum = [];
	let accumBytes = 0;
	let abort = false;

	return new Body.Promise(function (resolve, reject) {
		let resTimeout;

		// allow timeout on slow response body
		if (_this4.timeout) {
			resTimeout = setTimeout(function () {
				abort = true;
				reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
			}, _this4.timeout);
		}

		// handle stream errors
		body.on('error', function (err) {
			if (err.name === 'AbortError') {
				// if the request was aborted, reject with this Error
				abort = true;
				reject(err);
			} else {
				// other errors, such as incorrect content-encoding
				reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
			}
		});

		body.on('data', function (chunk) {
			if (abort || chunk === null) {
				return;
			}

			if (_this4.size && accumBytes + chunk.length > _this4.size) {
				abort = true;
				reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
				return;
			}

			accumBytes += chunk.length;
			accum.push(chunk);
		});

		body.on('end', function () {
			if (abort) {
				return;
			}

			clearTimeout(resTimeout);

			try {
				resolve(Buffer.concat(accum, accumBytes));
			} catch (err) {
				// handle streams that have accumulated too much data (issue #414)
				reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
			}
		});
	});
}

/**
 * Detect buffer encoding and convert to target encoding
 * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
 *
 * @param   Buffer  buffer    Incoming buffer
 * @param   String  encoding  Target encoding
 * @return  String
 */
function convertBody(buffer, headers) {
	if (typeof convert !== 'function') {
		throw new Error('The package `encoding` must be installed to use the textConverted() function');
	}

	const ct = headers.get('content-type');
	let charset = 'utf-8';
	let res, str;

	// header
	if (ct) {
		res = /charset=([^;]*)/i.exec(ct);
	}

	// no charset in content type, peek at response body for at most 1024 bytes
	str = buffer.slice(0, 1024).toString();

	// html5
	if (!res && str) {
		res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
	}

	// html4
	if (!res && str) {
		res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
		if (!res) {
			res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
			if (res) {
				res.pop(); // drop last quote
			}
		}

		if (res) {
			res = /charset=(.*)/i.exec(res.pop());
		}
	}

	// xml
	if (!res && str) {
		res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
	}

	// found charset
	if (res) {
		charset = res.pop();

		// prevent decode issues when sites use incorrect encoding
		// ref: https://hsivonen.fi/encoding-menu/
		if (charset === 'gb2312' || charset === 'gbk') {
			charset = 'gb18030';
		}
	}

	// turn raw buffers into a single utf-8 buffer
	return convert(buffer, 'UTF-8', charset).toString();
}

/**
 * Detect a URLSearchParams object
 * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
 *
 * @param   Object  obj     Object to detect by type or brand
 * @return  String
 */
function isURLSearchParams(obj) {
	// Duck-typing as a necessary condition.
	if (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {
		return false;
	}

	// Brand-checking and more duck-typing as optional condition.
	return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';
}

/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */
function isBlob(obj) {
	return typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}

/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed  instance  Response or Request instance
 * @return  Mixed
 */
function clone(instance) {
	let p1, p2;
	let body = instance.body;

	// don't allow cloning a used body
	if (instance.bodyUsed) {
		throw new Error('cannot clone body after it is used');
	}

	// check that body is a stream and not form-data object
	// note: we can't clone the form-data object without having it as a dependency
	if (body instanceof Stream && typeof body.getBoundary !== 'function') {
		// tee instance body
		p1 = new PassThrough();
		p2 = new PassThrough();
		body.pipe(p1);
		body.pipe(p2);
		// set instance body to teed body and return the other teed body
		instance[INTERNALS].body = p1;
		body = p2;
	}

	return body;
}

/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param   Mixed  instance  Any options.body input
 */
function extractContentType(body) {
	if (body === null) {
		// body is null
		return null;
	} else if (typeof body === 'string') {
		// body is string
		return 'text/plain;charset=UTF-8';
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		return 'application/x-www-form-urlencoded;charset=UTF-8';
	} else if (isBlob(body)) {
		// body is blob
		return body.type || null;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return null;
	} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		return null;
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		return null;
	} else if (typeof body.getBoundary === 'function') {
		// detect form data input from form-data module
		return `multipart/form-data;boundary=${body.getBoundary()}`;
	} else if (body instanceof Stream) {
		// body is stream
		// can't really do much about this
		return null;
	} else {
		// Body constructor defaults other things to string
		return 'text/plain;charset=UTF-8';
	}
}

/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param   Body    instance   Instance of Body
 * @return  Number?            Number of bytes, or null if not possible
 */
function getTotalBytes(instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		return 0;
	} else if (isBlob(body)) {
		return body.size;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return body.length;
	} else if (body && typeof body.getLengthSync === 'function') {
		// detect form data input from form-data module
		if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
		body.hasKnownLength && body.hasKnownLength()) {
			// 2.x
			return body.getLengthSync();
		}
		return null;
	} else {
		// body is stream
		return null;
	}
}

/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param   Body    instance   Instance of Body
 * @return  Void
 */
function writeToStream(dest, instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		dest.end();
	} else if (isBlob(body)) {
		body.stream().pipe(dest);
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		dest.write(body);
		dest.end();
	} else {
		// body is stream
		body.pipe(dest);
	}
}

// expose Promise
Body.Promise = global.Promise;

/**
 * headers.js
 *
 * Headers class offers convenient helpers
 */

const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

function validateName(name) {
	name = `${name}`;
	if (invalidTokenRegex.test(name) || name === '') {
		throw new TypeError(`${name} is not a legal HTTP header name`);
	}
}

function validateValue(value) {
	value = `${value}`;
	if (invalidHeaderCharRegex.test(value)) {
		throw new TypeError(`${value} is not a legal HTTP header value`);
	}
}

/**
 * Find the key in the map object given a header name.
 *
 * Returns undefined if not found.
 *
 * @param   String  name  Header name
 * @return  String|Undefined
 */
function find(map, name) {
	name = name.toLowerCase();
	for (const key in map) {
		if (key.toLowerCase() === name) {
			return key;
		}
	}
	return undefined;
}

const MAP = Symbol('map');
class Headers {
	/**
  * Headers class
  *
  * @param   Object  headers  Response headers
  * @return  Void
  */
	constructor() {
		let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

		this[MAP] = Object.create(null);

		if (init instanceof Headers) {
			const rawHeaders = init.raw();
			const headerNames = Object.keys(rawHeaders);

			for (const headerName of headerNames) {
				for (const value of rawHeaders[headerName]) {
					this.append(headerName, value);
				}
			}

			return;
		}

		// We don't worry about converting prop to ByteString here as append()
		// will handle it.
		if (init == null) ; else if (typeof init === 'object') {
			const method = init[Symbol.iterator];
			if (method != null) {
				if (typeof method !== 'function') {
					throw new TypeError('Header pairs must be iterable');
				}

				// sequence<sequence<ByteString>>
				// Note: per spec we have to first exhaust the lists then process them
				const pairs = [];
				for (const pair of init) {
					if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
						throw new TypeError('Each header pair must be iterable');
					}
					pairs.push(Array.from(pair));
				}

				for (const pair of pairs) {
					if (pair.length !== 2) {
						throw new TypeError('Each header pair must be a name/value tuple');
					}
					this.append(pair[0], pair[1]);
				}
			} else {
				// record<ByteString, ByteString>
				for (const key of Object.keys(init)) {
					const value = init[key];
					this.append(key, value);
				}
			}
		} else {
			throw new TypeError('Provided initializer must be an object');
		}
	}

	/**
  * Return combined header value given name
  *
  * @param   String  name  Header name
  * @return  Mixed
  */
	get(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key === undefined) {
			return null;
		}

		return this[MAP][key].join(', ');
	}

	/**
  * Iterate over all headers
  *
  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
  * @param   Boolean   thisArg   `this` context for callback function
  * @return  Void
  */
	forEach(callback) {
		let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

		let pairs = getHeaders(this);
		let i = 0;
		while (i < pairs.length) {
			var _pairs$i = pairs[i];
			const name = _pairs$i[0],
			      value = _pairs$i[1];

			callback.call(thisArg, value, name, this);
			pairs = getHeaders(this);
			i++;
		}
	}

	/**
  * Overwrite header values given name
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	set(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		this[MAP][key !== undefined ? key : name] = [value];
	}

	/**
  * Append a value onto existing header
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	append(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			this[MAP][key].push(value);
		} else {
			this[MAP][name] = [value];
		}
	}

	/**
  * Check for header name existence
  *
  * @param   String   name  Header name
  * @return  Boolean
  */
	has(name) {
		name = `${name}`;
		validateName(name);
		return find(this[MAP], name) !== undefined;
	}

	/**
  * Delete all header values given name
  *
  * @param   String  name  Header name
  * @return  Void
  */
	delete(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			delete this[MAP][key];
		}
	}

	/**
  * Return raw headers (non-spec api)
  *
  * @return  Object
  */
	raw() {
		return this[MAP];
	}

	/**
  * Get an iterator on keys.
  *
  * @return  Iterator
  */
	keys() {
		return createHeadersIterator(this, 'key');
	}

	/**
  * Get an iterator on values.
  *
  * @return  Iterator
  */
	values() {
		return createHeadersIterator(this, 'value');
	}

	/**
  * Get an iterator on entries.
  *
  * This is the default iterator of the Headers object.
  *
  * @return  Iterator
  */
	[Symbol.iterator]() {
		return createHeadersIterator(this, 'key+value');
	}
}
Headers.prototype.entries = Headers.prototype[Symbol.iterator];

Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
	value: 'Headers',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Headers.prototype, {
	get: { enumerable: true },
	forEach: { enumerable: true },
	set: { enumerable: true },
	append: { enumerable: true },
	has: { enumerable: true },
	delete: { enumerable: true },
	keys: { enumerable: true },
	values: { enumerable: true },
	entries: { enumerable: true }
});

function getHeaders(headers) {
	let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';

	const keys = Object.keys(headers[MAP]).sort();
	return keys.map(kind === 'key' ? function (k) {
		return k.toLowerCase();
	} : kind === 'value' ? function (k) {
		return headers[MAP][k].join(', ');
	} : function (k) {
		return [k.toLowerCase(), headers[MAP][k].join(', ')];
	});
}

const INTERNAL = Symbol('internal');

function createHeadersIterator(target, kind) {
	const iterator = Object.create(HeadersIteratorPrototype);
	iterator[INTERNAL] = {
		target,
		kind,
		index: 0
	};
	return iterator;
}

const HeadersIteratorPrototype = Object.setPrototypeOf({
	next() {
		// istanbul ignore if
		if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
			throw new TypeError('Value of `this` is not a HeadersIterator');
		}

		var _INTERNAL = this[INTERNAL];
		const target = _INTERNAL.target,
		      kind = _INTERNAL.kind,
		      index = _INTERNAL.index;

		const values = getHeaders(target, kind);
		const len = values.length;
		if (index >= len) {
			return {
				value: undefined,
				done: true
			};
		}

		this[INTERNAL].index = index + 1;

		return {
			value: values[index],
			done: false
		};
	}
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));

Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
	value: 'HeadersIterator',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * Export the Headers object in a form that Node.js can consume.
 *
 * @param   Headers  headers
 * @return  Object
 */
function exportNodeCompatibleHeaders(headers) {
	const obj = Object.assign({ __proto__: null }, headers[MAP]);

	// http.request() only supports string as Host header. This hack makes
	// specifying custom Host header possible.
	const hostHeaderKey = find(headers[MAP], 'Host');
	if (hostHeaderKey !== undefined) {
		obj[hostHeaderKey] = obj[hostHeaderKey][0];
	}

	return obj;
}

/**
 * Create a Headers object from an object of headers, ignoring those that do
 * not conform to HTTP grammar productions.
 *
 * @param   Object  obj  Object of headers
 * @return  Headers
 */
function createHeadersLenient(obj) {
	const headers = new Headers();
	for (const name of Object.keys(obj)) {
		if (invalidTokenRegex.test(name)) {
			continue;
		}
		if (Array.isArray(obj[name])) {
			for (const val of obj[name]) {
				if (invalidHeaderCharRegex.test(val)) {
					continue;
				}
				if (headers[MAP][name] === undefined) {
					headers[MAP][name] = [val];
				} else {
					headers[MAP][name].push(val);
				}
			}
		} else if (!invalidHeaderCharRegex.test(obj[name])) {
			headers[MAP][name] = [obj[name]];
		}
	}
	return headers;
}

const INTERNALS$1 = Symbol('Response internals');

// fix an issue where "STATUS_CODES" aren't a named export for node <10
const STATUS_CODES = http.STATUS_CODES;

/**
 * Response class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
class Response {
	constructor() {
		let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
		let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		Body.call(this, body, opts);

		const status = opts.status || 200;
		const headers = new Headers(opts.headers);

		if (body != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(body);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		this[INTERNALS$1] = {
			url: opts.url,
			status,
			statusText: opts.statusText || STATUS_CODES[status],
			headers,
			counter: opts.counter
		};
	}

	get url() {
		return this[INTERNALS$1].url || '';
	}

	get status() {
		return this[INTERNALS$1].status;
	}

	/**
  * Convenience property representing if the request ended normally
  */
	get ok() {
		return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
	}

	get redirected() {
		return this[INTERNALS$1].counter > 0;
	}

	get statusText() {
		return this[INTERNALS$1].statusText;
	}

	get headers() {
		return this[INTERNALS$1].headers;
	}

	/**
  * Clone this response
  *
  * @return  Response
  */
	clone() {
		return new Response(clone(this), {
			url: this.url,
			status: this.status,
			statusText: this.statusText,
			headers: this.headers,
			ok: this.ok,
			redirected: this.redirected
		});
	}
}

Body.mixIn(Response.prototype);

Object.defineProperties(Response.prototype, {
	url: { enumerable: true },
	status: { enumerable: true },
	ok: { enumerable: true },
	redirected: { enumerable: true },
	statusText: { enumerable: true },
	headers: { enumerable: true },
	clone: { enumerable: true }
});

Object.defineProperty(Response.prototype, Symbol.toStringTag, {
	value: 'Response',
	writable: false,
	enumerable: false,
	configurable: true
});

const INTERNALS$2 = Symbol('Request internals');
const URL = Url.URL || whatwgUrl.URL;

// fix an issue where "format", "parse" aren't a named export for node <10
const parse_url = Url.parse;
const format_url = Url.format;

/**
 * Wrapper around `new URL` to handle arbitrary URLs
 *
 * @param  {string} urlStr
 * @return {void}
 */
function parseURL(urlStr) {
	/*
 	Check whether the URL is absolute or not
 		Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
 	Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
 */
	if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
		urlStr = new URL(urlStr).toString();
	}

	// Fallback to old implementation for arbitrary URLs
	return parse_url(urlStr);
}

const streamDestructionSupported = 'destroy' in Stream.Readable.prototype;

/**
 * Check if a value is an instance of Request.
 *
 * @param   Mixed   input
 * @return  Boolean
 */
function isRequest(input) {
	return typeof input === 'object' && typeof input[INTERNALS$2] === 'object';
}

function isAbortSignal(signal) {
	const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);
	return !!(proto && proto.constructor.name === 'AbortSignal');
}

/**
 * Request class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */
class Request {
	constructor(input) {
		let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		let parsedURL;

		// normalize input
		if (!isRequest(input)) {
			if (input && input.href) {
				// in order to support Node.js' Url objects; though WHATWG's URL objects
				// will fall into this branch also (since their `toString()` will return
				// `href` property anyway)
				parsedURL = parseURL(input.href);
			} else {
				// coerce input to a string before attempting to parse
				parsedURL = parseURL(`${input}`);
			}
			input = {};
		} else {
			parsedURL = parseURL(input.url);
		}

		let method = init.method || input.method || 'GET';
		method = method.toUpperCase();

		if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
			throw new TypeError('Request with GET/HEAD method cannot have body');
		}

		let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;

		Body.call(this, inputBody, {
			timeout: init.timeout || input.timeout || 0,
			size: init.size || input.size || 0
		});

		const headers = new Headers(init.headers || input.headers || {});

		if (inputBody != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(inputBody);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		let signal = isRequest(input) ? input.signal : null;
		if ('signal' in init) signal = init.signal;

		if (signal != null && !isAbortSignal(signal)) {
			throw new TypeError('Expected signal to be an instanceof AbortSignal');
		}

		this[INTERNALS$2] = {
			method,
			redirect: init.redirect || input.redirect || 'follow',
			headers,
			parsedURL,
			signal
		};

		// node-fetch-only options
		this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
		this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
		this.counter = init.counter || input.counter || 0;
		this.agent = init.agent || input.agent;
	}

	get method() {
		return this[INTERNALS$2].method;
	}

	get url() {
		return format_url(this[INTERNALS$2].parsedURL);
	}

	get headers() {
		return this[INTERNALS$2].headers;
	}

	get redirect() {
		return this[INTERNALS$2].redirect;
	}

	get signal() {
		return this[INTERNALS$2].signal;
	}

	/**
  * Clone this request
  *
  * @return  Request
  */
	clone() {
		return new Request(this);
	}
}

Body.mixIn(Request.prototype);

Object.defineProperty(Request.prototype, Symbol.toStringTag, {
	value: 'Request',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Request.prototype, {
	method: { enumerable: true },
	url: { enumerable: true },
	headers: { enumerable: true },
	redirect: { enumerable: true },
	clone: { enumerable: true },
	signal: { enumerable: true }
});

/**
 * Convert a Request to Node.js http request options.
 *
 * @param   Request  A Request instance
 * @return  Object   The options object to be passed to http.request
 */
function getNodeRequestOptions(request) {
	const parsedURL = request[INTERNALS$2].parsedURL;
	const headers = new Headers(request[INTERNALS$2].headers);

	// fetch step 1.3
	if (!headers.has('Accept')) {
		headers.set('Accept', '*/*');
	}

	// Basic fetch
	if (!parsedURL.protocol || !parsedURL.hostname) {
		throw new TypeError('Only absolute URLs are supported');
	}

	if (!/^https?:$/.test(parsedURL.protocol)) {
		throw new TypeError('Only HTTP(S) protocols are supported');
	}

	if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
		throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
	}

	// HTTP-network-or-cache fetch steps 2.4-2.7
	let contentLengthValue = null;
	if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
		contentLengthValue = '0';
	}
	if (request.body != null) {
		const totalBytes = getTotalBytes(request);
		if (typeof totalBytes === 'number') {
			contentLengthValue = String(totalBytes);
		}
	}
	if (contentLengthValue) {
		headers.set('Content-Length', contentLengthValue);
	}

	// HTTP-network-or-cache fetch step 2.11
	if (!headers.has('User-Agent')) {
		headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
	}

	// HTTP-network-or-cache fetch step 2.15
	if (request.compress && !headers.has('Accept-Encoding')) {
		headers.set('Accept-Encoding', 'gzip,deflate');
	}

	let agent = request.agent;
	if (typeof agent === 'function') {
		agent = agent(parsedURL);
	}

	if (!headers.has('Connection') && !agent) {
		headers.set('Connection', 'close');
	}

	// HTTP-network fetch step 4.2
	// chunked encoding is handled by Node.js

	return Object.assign({}, parsedURL, {
		method: request.method,
		headers: exportNodeCompatibleHeaders(headers),
		agent
	});
}

/**
 * abort-error.js
 *
 * AbortError interface for cancelled requests
 */

/**
 * Create AbortError instance
 *
 * @param   String      message      Error message for human
 * @return  AbortError
 */
function AbortError(message) {
  Error.call(this, message);

  this.type = 'aborted';
  this.message = message;

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

AbortError.prototype = Object.create(Error.prototype);
AbortError.prototype.constructor = AbortError;
AbortError.prototype.name = 'AbortError';

const URL$1 = Url.URL || whatwgUrl.URL;

// fix an issue where "PassThrough", "resolve" aren't a named export for node <10
const PassThrough$1 = Stream.PassThrough;

const isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {
	const orig = new URL$1(original).hostname;
	const dest = new URL$1(destination).hostname;

	return orig === dest || orig[orig.length - dest.length - 1] === '.' && orig.endsWith(dest);
};

/**
 * Fetch function
 *
 * @param   Mixed    url   Absolute url or Request instance
 * @param   Object   opts  Fetch options
 * @return  Promise
 */
function fetch(url, opts) {

	// allow custom promise
	if (!fetch.Promise) {
		throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
	}

	Body.Promise = fetch.Promise;

	// wrap http.request into fetch
	return new fetch.Promise(function (resolve, reject) {
		// build request object
		const request = new Request(url, opts);
		const options = getNodeRequestOptions(request);

		const send = (options.protocol === 'https:' ? https : http).request;
		const signal = request.signal;

		let response = null;

		const abort = function abort() {
			let error = new AbortError('The user aborted a request.');
			reject(error);
			if (request.body && request.body instanceof Stream.Readable) {
				request.body.destroy(error);
			}
			if (!response || !response.body) return;
			response.body.emit('error', error);
		};

		if (signal && signal.aborted) {
			abort();
			return;
		}

		const abortAndFinalize = function abortAndFinalize() {
			abort();
			finalize();
		};

		// send request
		const req = send(options);
		let reqTimeout;

		if (signal) {
			signal.addEventListener('abort', abortAndFinalize);
		}

		function finalize() {
			req.abort();
			if (signal) signal.removeEventListener('abort', abortAndFinalize);
			clearTimeout(reqTimeout);
		}

		if (request.timeout) {
			req.once('socket', function (socket) {
				reqTimeout = setTimeout(function () {
					reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
					finalize();
				}, request.timeout);
			});
		}

		req.on('error', function (err) {
			reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
			finalize();
		});

		req.on('response', function (res) {
			clearTimeout(reqTimeout);

			const headers = createHeadersLenient(res.headers);

			// HTTP fetch step 5
			if (fetch.isRedirect(res.statusCode)) {
				// HTTP fetch step 5.2
				const location = headers.get('Location');

				// HTTP fetch step 5.3
				let locationURL = null;
				try {
					locationURL = location === null ? null : new URL$1(location, request.url).toString();
				} catch (err) {
					// error here can only be invalid URL in Location: header
					// do not throw when options.redirect == manual
					// let the user extract the errorneous redirect URL
					if (request.redirect !== 'manual') {
						reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));
						finalize();
						return;
					}
				}

				// HTTP fetch step 5.5
				switch (request.redirect) {
					case 'error':
						reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
						finalize();
						return;
					case 'manual':
						// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
						if (locationURL !== null) {
							// handle corrupted header
							try {
								headers.set('Location', locationURL);
							} catch (err) {
								// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
								reject(err);
							}
						}
						break;
					case 'follow':
						// HTTP-redirect fetch step 2
						if (locationURL === null) {
							break;
						}

						// HTTP-redirect fetch step 5
						if (request.counter >= request.follow) {
							reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 6 (counter increment)
						// Create a new Request object.
						const requestOpts = {
							headers: new Headers(request.headers),
							follow: request.follow,
							counter: request.counter + 1,
							agent: request.agent,
							compress: request.compress,
							method: request.method,
							body: request.body,
							signal: request.signal,
							timeout: request.timeout,
							size: request.size
						};

						if (!isDomainOrSubdomain(request.url, locationURL)) {
							for (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {
								requestOpts.headers.delete(name);
							}
						}

						// HTTP-redirect fetch step 9
						if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
							reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 11
						if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
							requestOpts.method = 'GET';
							requestOpts.body = undefined;
							requestOpts.headers.delete('content-length');
						}

						// HTTP-redirect fetch step 15
						resolve(fetch(new Request(locationURL, requestOpts)));
						finalize();
						return;
				}
			}

			// prepare response
			res.once('end', function () {
				if (signal) signal.removeEventListener('abort', abortAndFinalize);
			});
			let body = res.pipe(new PassThrough$1());

			const response_options = {
				url: request.url,
				status: res.statusCode,
				statusText: res.statusMessage,
				headers: headers,
				size: request.size,
				timeout: request.timeout,
				counter: request.counter
			};

			// HTTP-network fetch step 12.1.1.3
			const codings = headers.get('Content-Encoding');

			// HTTP-network fetch step 12.1.1.4: handle content codings

			// in following scenarios we ignore compression support
			// 1. compression support is disabled
			// 2. HEAD request
			// 3. no Content-Encoding header
			// 4. no content response (204)
			// 5. content not modified response (304)
			if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// For Node v6+
			// Be less strict when decoding compressed responses, since sometimes
			// servers send slightly invalid responses that are still accepted
			// by common browsers.
			// Always using Z_SYNC_FLUSH is what cURL does.
			const zlibOptions = {
				flush: zlib.Z_SYNC_FLUSH,
				finishFlush: zlib.Z_SYNC_FLUSH
			};

			// for gzip
			if (codings == 'gzip' || codings == 'x-gzip') {
				body = body.pipe(zlib.createGunzip(zlibOptions));
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// for deflate
			if (codings == 'deflate' || codings == 'x-deflate') {
				// handle the infamous raw deflate response from old servers
				// a hack for old IIS and Apache servers
				const raw = res.pipe(new PassThrough$1());
				raw.once('data', function (chunk) {
					// see http://stackoverflow.com/questions/37519828
					if ((chunk[0] & 0x0F) === 0x08) {
						body = body.pipe(zlib.createInflate());
					} else {
						body = body.pipe(zlib.createInflateRaw());
					}
					response = new Response(body, response_options);
					resolve(response);
				});
				return;
			}

			// for br
			if (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {
				body = body.pipe(zlib.createBrotliDecompress());
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// otherwise, use response as-is
			response = new Response(body, response_options);
			resolve(response);
		});

		writeToStream(req, request);
	});
}
/**
 * Redirect code matching
 *
 * @param   Number   code  Status code
 * @return  Boolean
 */
fetch.isRedirect = function (code) {
	return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
};

// expose Promise
fetch.Promise = global.Promise;

module.exports = exports = fetch;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = exports;
exports.Headers = Headers;
exports.Request = Request;
exports.Response = Response;
exports.FetchError = FetchError;


/***/ }),

/***/ 1223:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var wrappy = __nccwpck_require__(2940)
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),

/***/ 8714:
/***/ ((module) => {

"use strict";


function posix(path) {
	return path.charAt(0) === '/';
}

function win32(path) {
	// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	var result = splitDeviceRe.exec(path);
	var device = result[1] || '';
	var isUnc = Boolean(device && device.charAt(1) !== ':');

	// UNC paths are always absolute
	return Boolean(result[2] || isUnc);
}

module.exports = process.platform === 'win32' ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;


/***/ }),

/***/ 4959:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const assert = __nccwpck_require__(9491)
const path = __nccwpck_require__(1017)
const fs = __nccwpck_require__(7147)
let glob = undefined
try {
  glob = __nccwpck_require__(1957)
} catch (_err) {
  // treat glob as optional.
}

const defaultGlobOpts = {
  nosort: true,
  silent: true
}

// for EMFILE handling
let timeout = 0

const isWindows = (process.platform === "win32")

const defaults = options => {
  const methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ]
  methods.forEach(m => {
    options[m] = options[m] || fs[m]
    m = m + 'Sync'
    options[m] = options[m] || fs[m]
  })

  options.maxBusyTries = options.maxBusyTries || 3
  options.emfileWait = options.emfileWait || 1000
  if (options.glob === false) {
    options.disableGlob = true
  }
  if (options.disableGlob !== true && glob === undefined) {
    throw Error('glob dependency not found, set `options.disableGlob = true` if intentional')
  }
  options.disableGlob = options.disableGlob || false
  options.glob = options.glob || defaultGlobOpts
}

const rimraf = (p, options, cb) => {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert.equal(typeof cb, 'function', 'rimraf: callback function required')
  assert(options, 'rimraf: invalid options argument provided')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  defaults(options)

  let busyTries = 0
  let errState = null
  let n = 0

  const next = (er) => {
    errState = errState || er
    if (--n === 0)
      cb(errState)
  }

  const afterGlob = (er, results) => {
    if (er)
      return cb(er)

    n = results.length
    if (n === 0)
      return cb()

    results.forEach(p => {
      const CB = (er) => {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") &&
              busyTries < options.maxBusyTries) {
            busyTries ++
            // try again, with the same exact callback as this one.
            return setTimeout(() => rimraf_(p, options, CB), busyTries * 100)
          }

          // this one won't happen if graceful-fs is used.
          if (er.code === "EMFILE" && timeout < options.emfileWait) {
            return setTimeout(() => rimraf_(p, options, CB), timeout ++)
          }

          // already gone
          if (er.code === "ENOENT") er = null
        }

        timeout = 0
        next(er)
      }
      rimraf_(p, options, CB)
    })
  }

  if (options.disableGlob || !glob.hasMagic(p))
    return afterGlob(null, [p])

  options.lstat(p, (er, stat) => {
    if (!er)
      return afterGlob(null, [p])

    glob(p, options.glob, afterGlob)
  })

}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
const rimraf_ = (p, options, cb) => {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, (er, st) => {
    if (er && er.code === "ENOENT")
      return cb(null)

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === "EPERM" && isWindows)
      fixWinEPERM(p, options, er, cb)

    if (st && st.isDirectory())
      return rmdir(p, options, er, cb)

    options.unlink(p, er => {
      if (er) {
        if (er.code === "ENOENT")
          return cb(null)
        if (er.code === "EPERM")
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        if (er.code === "EISDIR")
          return rmdir(p, options, er, cb)
      }
      return cb(er)
    })
  })
}

const fixWinEPERM = (p, options, er, cb) => {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.chmod(p, 0o666, er2 => {
    if (er2)
      cb(er2.code === "ENOENT" ? null : er)
    else
      options.stat(p, (er3, stats) => {
        if (er3)
          cb(er3.code === "ENOENT" ? null : er)
        else if (stats.isDirectory())
          rmdir(p, options, er, cb)
        else
          options.unlink(p, cb)
      })
  })
}

const fixWinEPERMSync = (p, options, er) => {
  assert(p)
  assert(options)

  try {
    options.chmodSync(p, 0o666)
  } catch (er2) {
    if (er2.code === "ENOENT")
      return
    else
      throw er
  }

  let stats
  try {
    stats = options.statSync(p)
  } catch (er3) {
    if (er3.code === "ENOENT")
      return
    else
      throw er
  }

  if (stats.isDirectory())
    rmdirSync(p, options, er)
  else
    options.unlinkSync(p)
}

const rmdir = (p, options, originalEr, cb) => {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, er => {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
      rmkids(p, options, cb)
    else if (er && er.code === "ENOTDIR")
      cb(originalEr)
    else
      cb(er)
  })
}

const rmkids = (p, options, cb) => {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.readdir(p, (er, files) => {
    if (er)
      return cb(er)
    let n = files.length
    if (n === 0)
      return options.rmdir(p, cb)
    let errState
    files.forEach(f => {
      rimraf(path.join(p, f), options, er => {
        if (errState)
          return
        if (er)
          return cb(errState = er)
        if (--n === 0)
          options.rmdir(p, cb)
      })
    })
  })
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
const rimrafSync = (p, options) => {
  options = options || {}
  defaults(options)

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert(options, 'rimraf: missing options')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  let results

  if (options.disableGlob || !glob.hasMagic(p)) {
    results = [p]
  } else {
    try {
      options.lstatSync(p)
      results = [p]
    } catch (er) {
      results = glob.sync(p, options.glob)
    }
  }

  if (!results.length)
    return

  for (let i = 0; i < results.length; i++) {
    const p = results[i]

    let st
    try {
      st = options.lstatSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return

      // Windows can EPERM on stat.  Life is suffering.
      if (er.code === "EPERM" && isWindows)
        fixWinEPERMSync(p, options, er)
    }

    try {
      // sunos lets the root user unlink directories, which is... weird.
      if (st && st.isDirectory())
        rmdirSync(p, options, null)
      else
        options.unlinkSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return
      if (er.code === "EPERM")
        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
      if (er.code !== "EISDIR")
        throw er

      rmdirSync(p, options, er)
    }
  }
}

const rmdirSync = (p, options, originalEr) => {
  assert(p)
  assert(options)

  try {
    options.rmdirSync(p)
  } catch (er) {
    if (er.code === "ENOENT")
      return
    if (er.code === "ENOTDIR")
      throw originalEr
    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
      rmkidsSync(p, options)
  }
}

const rmkidsSync = (p, options) => {
  assert(p)
  assert(options)
  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))

  // We only end up here once we got ENOTEMPTY at least once, and
  // at this point, we are guaranteed to have removed all the kids.
  // So, we know that it won't be ENOENT or ENOTDIR or anything else.
  // try really hard to delete stuff on windows, because it has a
  // PROFOUNDLY annoying habit of not closing handles promptly when
  // files are deleted, resulting in spurious ENOTEMPTY errors.
  const retries = isWindows ? 100 : 1
  let i = 0
  do {
    let threw = true
    try {
      const ret = options.rmdirSync(p, options)
      threw = false
      return ret
    } finally {
      if (++i < retries && threw)
        continue
    }
  } while (true)
}

module.exports = rimraf
rimraf.sync = rimrafSync


/***/ }),

/***/ 8065:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { promisify } = __nccwpck_require__(3837);
const tmp = __nccwpck_require__(8517);

// file
module.exports.fileSync = tmp.fileSync;
const fileWithOptions = promisify((options, cb) =>
  tmp.file(options, (err, path, fd, cleanup) =>
    err ? cb(err) : cb(undefined, { path, fd, cleanup: promisify(cleanup) })
  )
);
module.exports.file = async (options) => fileWithOptions(options);

module.exports.withFile = async function withFile(fn, options) {
  const { path, fd, cleanup } = await module.exports.file(options);
  try {
    return await fn({ path, fd });
  } finally {
    await cleanup();
  }
};


// directory
module.exports.dirSync = tmp.dirSync;
const dirWithOptions = promisify((options, cb) =>
  tmp.dir(options, (err, path, cleanup) =>
    err ? cb(err) : cb(undefined, { path, cleanup: promisify(cleanup) })
  )
);
module.exports.dir = async (options) => dirWithOptions(options);

module.exports.withDir = async function withDir(fn, options) {
  const { path, cleanup } = await module.exports.dir(options);
  try {
    return await fn({ path });
  } finally {
    await cleanup();
  }
};


// name generation
module.exports.tmpNameSync = tmp.tmpNameSync;
module.exports.tmpName = promisify(tmp.tmpName);

module.exports.tmpdir = tmp.tmpdir;

module.exports.setGracefulCleanup = tmp.setGracefulCleanup;


/***/ }),

/***/ 8517:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*!
 * Tmp
 *
 * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
 *
 * MIT Licensed
 */

/*
 * Module dependencies.
 */
const fs = __nccwpck_require__(7147);
const os = __nccwpck_require__(2037);
const path = __nccwpck_require__(1017);
const crypto = __nccwpck_require__(6113);
const _c = { fs: fs.constants, os: os.constants };
const rimraf = __nccwpck_require__(4959);

/*
 * The working inner variables.
 */
const
  // the random characters to choose from
  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',

  TEMPLATE_PATTERN = /XXXXXX/,

  DEFAULT_TRIES = 3,

  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),

  // constants are off on the windows platform and will not match the actual errno codes
  IS_WIN32 = os.platform() === 'win32',
  EBADF = _c.EBADF || _c.os.errno.EBADF,
  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,

  DIR_MODE = 0o700 /* 448 */,
  FILE_MODE = 0o600 /* 384 */,

  EXIT = 'exit',

  // this will hold the objects need to be removed on exit
  _removeObjects = [],

  // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback
  FN_RMDIR_SYNC = fs.rmdirSync.bind(fs),
  FN_RIMRAF_SYNC = rimraf.sync;

let
  _gracefulCleanup = false;

/**
 * Gets a temporary file name.
 *
 * @param {(Options|tmpNameCallback)} options options or callback
 * @param {?tmpNameCallback} callback the callback function
 */
function tmpName(options, callback) {
  const
    args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1];

  try {
    _assertAndSanitizeOptions(opts);
  } catch (err) {
    return cb(err);
  }

  let tries = opts.tries;
  (function _getUniqueName() {
    try {
      const name = _generateTmpName(opts);

      // check whether the path exists then retry if needed
      fs.stat(name, function (err) {
        /* istanbul ignore else */
        if (!err) {
          /* istanbul ignore else */
          if (tries-- > 0) return _getUniqueName();

          return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));
        }

        cb(null, name);
      });
    } catch (err) {
      cb(err);
    }
  }());
}

/**
 * Synchronous version of tmpName.
 *
 * @param {Object} options
 * @returns {string} the generated random name
 * @throws {Error} if the options are invalid or could not generate a filename
 */
function tmpNameSync(options) {
  const
    args = _parseArguments(options),
    opts = args[0];

  _assertAndSanitizeOptions(opts);

  let tries = opts.tries;
  do {
    const name = _generateTmpName(opts);
    try {
      fs.statSync(name);
    } catch (e) {
      return name;
    }
  } while (tries-- > 0);

  throw new Error('Could not get a unique tmp filename, max tries reached');
}

/**
 * Creates and opens a temporary file.
 *
 * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined
 * @param {?fileCallback} callback
 */
function file(options, callback) {
  const
    args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1];

  // gets a temporary filename
  tmpName(opts, function _tmpNameCreated(err, name) {
    /* istanbul ignore else */
    if (err) return cb(err);

    // create and open the file
    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {
      /* istanbu ignore else */
      if (err) return cb(err);

      if (opts.discardDescriptor) {
        return fs.close(fd, function _discardCallback(possibleErr) {
          // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only
          return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));
        });
      } else {
        // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care
        // about the descriptor
        const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));
      }
    });
  });
}

/**
 * Synchronous version of file.
 *
 * @param {Options} options
 * @returns {FileSyncObject} object consists of name, fd and removeCallback
 * @throws {Error} if cannot create a file
 */
function fileSync(options) {
  const
    args = _parseArguments(options),
    opts = args[0];

  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
  const name = tmpNameSync(opts);
  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
  /* istanbul ignore else */
  if (opts.discardDescriptor) {
    fs.closeSync(fd);
    fd = undefined;
  }

  return {
    name: name,
    fd: fd,
    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)
  };
}

/**
 * Creates a temporary directory.
 *
 * @param {(Options|dirCallback)} options the options or the callback function
 * @param {?dirCallback} callback
 */
function dir(options, callback) {
  const
    args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1];

  // gets a temporary filename
  tmpName(opts, function _tmpNameCreated(err, name) {
    /* istanbul ignore else */
    if (err) return cb(err);

    // create the directory
    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {
      /* istanbul ignore else */
      if (err) return cb(err);

      cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));
    });
  });
}

/**
 * Synchronous version of dir.
 *
 * @param {Options} options
 * @returns {DirSyncObject} object consists of name and removeCallback
 * @throws {Error} if it cannot create a directory
 */
function dirSync(options) {
  const
    args = _parseArguments(options),
    opts = args[0];

  const name = tmpNameSync(opts);
  fs.mkdirSync(name, opts.mode || DIR_MODE);

  return {
    name: name,
    removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)
  };
}

/**
 * Removes files asynchronously.
 *
 * @param {Object} fdPath
 * @param {Function} next
 * @private
 */
function _removeFileAsync(fdPath, next) {
  const _handler = function (err) {
    if (err && !_isENOENT(err)) {
      // reraise any unanticipated error
      return next(err);
    }
    next();
  };

  if (0 <= fdPath[0])
    fs.close(fdPath[0], function () {
      fs.unlink(fdPath[1], _handler);
    });
  else fs.unlink(fdPath[1], _handler);
}

/**
 * Removes files synchronously.
 *
 * @param {Object} fdPath
 * @private
 */
function _removeFileSync(fdPath) {
  let rethrownException = null;
  try {
    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);
  } catch (e) {
    // reraise any unanticipated error
    if (!_isEBADF(e) && !_isENOENT(e)) throw e;
  } finally {
    try {
      fs.unlinkSync(fdPath[1]);
    }
    catch (e) {
      // reraise any unanticipated error
      if (!_isENOENT(e)) rethrownException = e;
    }
  }
  if (rethrownException !== null) {
    throw rethrownException;
  }
}

/**
 * Prepares the callback for removal of the temporary file.
 *
 * Returns either a sync callback or a async callback depending on whether
 * fileSync or file was called, which is expressed by the sync parameter.
 *
 * @param {string} name the path of the file
 * @param {number} fd file descriptor
 * @param {Object} opts
 * @param {boolean} sync
 * @returns {fileCallback | fileCallbackSync}
 * @private
 */
function _prepareTmpFileRemoveCallback(name, fd, opts, sync) {
  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);
  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);

  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);

  return sync ? removeCallbackSync : removeCallback;
}

/**
 * Prepares the callback for removal of the temporary directory.
 *
 * Returns either a sync callback or a async callback depending on whether
 * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.
 *
 * @param {string} name
 * @param {Object} opts
 * @param {boolean} sync
 * @returns {Function} the callback
 * @private
 */
function _prepareTmpDirRemoveCallback(name, opts, sync) {
  const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);
  const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;
  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);
  const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);
  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);

  return sync ? removeCallbackSync : removeCallback;
}

/**
 * Creates a guarded function wrapping the removeFunction call.
 *
 * The cleanup callback is save to be called multiple times.
 * Subsequent invocations will be ignored.
 *
 * @param {Function} removeFunction
 * @param {string} fileOrDirName
 * @param {boolean} sync
 * @param {cleanupCallbackSync?} cleanupCallbackSync
 * @returns {cleanupCallback | cleanupCallbackSync}
 * @private
 */
function _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {
  let called = false;

  // if sync is true, the next parameter will be ignored
  return function _cleanupCallback(next) {

    /* istanbul ignore else */
    if (!called) {
      // remove cleanupCallback from cache
      const toRemove = cleanupCallbackSync || _cleanupCallback;
      const index = _removeObjects.indexOf(toRemove);
      /* istanbul ignore else */
      if (index >= 0) _removeObjects.splice(index, 1);

      called = true;
      if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {
        return removeFunction(fileOrDirName);
      } else {
        return removeFunction(fileOrDirName, next || function() {});
      }
    }
  };
}

/**
 * The garbage collector.
 *
 * @private
 */
function _garbageCollector() {
  /* istanbul ignore else */
  if (!_gracefulCleanup) return;

  // the function being called removes itself from _removeObjects,
  // loop until _removeObjects is empty
  while (_removeObjects.length) {
    try {
      _removeObjects[0]();
    } catch (e) {
      // already removed?
    }
  }
}

/**
 * Random name generator based on crypto.
 * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript
 *
 * @param {number} howMany
 * @returns {string} the generated random name
 * @private
 */
function _randomChars(howMany) {
  let
    value = [],
    rnd = null;

  // make sure that we do not fail because we ran out of entropy
  try {
    rnd = crypto.randomBytes(howMany);
  } catch (e) {
    rnd = crypto.pseudoRandomBytes(howMany);
  }

  for (var i = 0; i < howMany; i++) {
    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
  }

  return value.join('');
}

/**
 * Helper which determines whether a string s is blank, that is undefined, or empty or null.
 *
 * @private
 * @param {string} s
 * @returns {Boolean} true whether the string s is blank, false otherwise
 */
function _isBlank(s) {
  return s === null || _isUndefined(s) || !s.trim();
}

/**
 * Checks whether the `obj` parameter is defined or not.
 *
 * @param {Object} obj
 * @returns {boolean} true if the object is undefined
 * @private
 */
function _isUndefined(obj) {
  return typeof obj === 'undefined';
}

/**
 * Parses the function arguments.
 *
 * This function helps to have optional arguments.
 *
 * @param {(Options|null|undefined|Function)} options
 * @param {?Function} callback
 * @returns {Array} parsed arguments
 * @private
 */
function _parseArguments(options, callback) {
  /* istanbul ignore else */
  if (typeof options === 'function') {
    return [{}, options];
  }

  /* istanbul ignore else */
  if (_isUndefined(options)) {
    return [{}, callback];
  }

  // copy options so we do not leak the changes we make internally
  const actualOptions = {};
  for (const key of Object.getOwnPropertyNames(options)) {
    actualOptions[key] = options[key];
  }

  return [actualOptions, callback];
}

/**
 * Generates a new temporary name.
 *
 * @param {Object} opts
 * @returns {string} the new random name according to opts
 * @private
 */
function _generateTmpName(opts) {

  const tmpDir = opts.tmpdir;

  /* istanbul ignore else */
  if (!_isUndefined(opts.name))
    return path.join(tmpDir, opts.dir, opts.name);

  /* istanbul ignore else */
  if (!_isUndefined(opts.template))
    return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));

  // prefix and postfix
  const name = [
    opts.prefix ? opts.prefix : 'tmp',
    '-',
    process.pid,
    '-',
    _randomChars(12),
    opts.postfix ? '-' + opts.postfix : ''
  ].join('');

  return path.join(tmpDir, opts.dir, name);
}

/**
 * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing
 * options.
 *
 * @param {Options} options
 * @private
 */
function _assertAndSanitizeOptions(options) {

  options.tmpdir = _getTmpDir(options);

  const tmpDir = options.tmpdir;

  /* istanbul ignore else */
  if (!_isUndefined(options.name))
    _assertIsRelative(options.name, 'name', tmpDir);
  /* istanbul ignore else */
  if (!_isUndefined(options.dir))
    _assertIsRelative(options.dir, 'dir', tmpDir);
  /* istanbul ignore else */
  if (!_isUndefined(options.template)) {
    _assertIsRelative(options.template, 'template', tmpDir);
    if (!options.template.match(TEMPLATE_PATTERN))
      throw new Error(`Invalid template, found "${options.template}".`);
  }
  /* istanbul ignore else */
  if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0)
    throw new Error(`Invalid tries, found "${options.tries}".`);

  // if a name was specified we will try once
  options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;
  options.keep = !!options.keep;
  options.detachDescriptor = !!options.detachDescriptor;
  options.discardDescriptor = !!options.discardDescriptor;
  options.unsafeCleanup = !!options.unsafeCleanup;

  // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to
  options.dir = _isUndefined(options.dir) ? '' : path.relative(tmpDir, _resolvePath(options.dir, tmpDir));
  options.template = _isUndefined(options.template) ? undefined : path.relative(tmpDir, _resolvePath(options.template, tmpDir));
  // sanitize further if template is relative to options.dir
  options.template = _isBlank(options.template) ? undefined : path.relative(options.dir, options.template);

  // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to
  options.name = _isUndefined(options.name) ? undefined : _sanitizeName(options.name);
  options.prefix = _isUndefined(options.prefix) ? '' : options.prefix;
  options.postfix = _isUndefined(options.postfix) ? '' : options.postfix;
}

/**
 * Resolve the specified path name in respect to tmpDir.
 *
 * The specified name might include relative path components, e.g. ../
 * so we need to resolve in order to be sure that is is located inside tmpDir
 *
 * @param name
 * @param tmpDir
 * @returns {string}
 * @private
 */
function _resolvePath(name, tmpDir) {
  const sanitizedName = _sanitizeName(name);
  if (sanitizedName.startsWith(tmpDir)) {
    return path.resolve(sanitizedName);
  } else {
    return path.resolve(path.join(tmpDir, sanitizedName));
  }
}

/**
 * Sanitize the specified path name by removing all quote characters.
 *
 * @param name
 * @returns {string}
 * @private
 */
function _sanitizeName(name) {
  if (_isBlank(name)) {
    return name;
  }
  return name.replace(/["']/g, '');
}

/**
 * Asserts whether specified name is relative to the specified tmpDir.
 *
 * @param {string} name
 * @param {string} option
 * @param {string} tmpDir
 * @throws {Error}
 * @private
 */
function _assertIsRelative(name, option, tmpDir) {
  if (option === 'name') {
    // assert that name is not absolute and does not contain a path
    if (path.isAbsolute(name))
      throw new Error(`${option} option must not contain an absolute path, found "${name}".`);
    // must not fail on valid .<name> or ..<name> or similar such constructs
    let basename = path.basename(name);
    if (basename === '..' || basename === '.' || basename !== name)
      throw new Error(`${option} option must not contain a path, found "${name}".`);
  }
  else { // if (option === 'dir' || option === 'template') {
    // assert that dir or template are relative to tmpDir
    if (path.isAbsolute(name) && !name.startsWith(tmpDir)) {
      throw new Error(`${option} option must be relative to "${tmpDir}", found "${name}".`);
    }
    let resolvedPath = _resolvePath(name, tmpDir);
    if (!resolvedPath.startsWith(tmpDir))
      throw new Error(`${option} option must be relative to "${tmpDir}", found "${resolvedPath}".`);
  }
}

/**
 * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.
 *
 * @private
 */
function _isEBADF(error) {
  return _isExpectedError(error, -EBADF, 'EBADF');
}

/**
 * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.
 *
 * @private
 */
function _isENOENT(error) {
  return _isExpectedError(error, -ENOENT, 'ENOENT');
}

/**
 * Helper to determine whether the expected error code matches the actual code and errno,
 * which will differ between the supported node versions.
 *
 * - Node >= 7.0:
 *   error.code {string}
 *   error.errno {number} any numerical value will be negated
 *
 * CAVEAT
 *
 * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT
 * is no different here.
 *
 * @param {SystemError} error
 * @param {number} errno
 * @param {string} code
 * @private
 */
function _isExpectedError(error, errno, code) {
  return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;
}

/**
 * Sets the graceful cleanup.
 *
 * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the
 * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary
 * object removals.
 */
function setGracefulCleanup() {
  _gracefulCleanup = true;
}

/**
 * Returns the currently configured tmp dir from os.tmpdir().
 *
 * @private
 * @param {?Options} options
 * @returns {string} the currently configured tmp dir
 */
function _getTmpDir(options) {
  return path.resolve(_sanitizeName(options && options.tmpdir || os.tmpdir()));
}

// Install process exit listener
process.addListener(EXIT, _garbageCollector);

/**
 * Configuration options.
 *
 * @typedef {Object} Options
 * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected
 * @property {?number} tries the number of tries before give up the name generation
 * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files
 * @property {?string} template the "mkstemp" like filename template
 * @property {?string} name fixed name relative to tmpdir or the specified dir option
 * @property {?string} dir tmp directory relative to the root tmp directory in use
 * @property {?string} prefix prefix for the generated name
 * @property {?string} postfix postfix for the generated name
 * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir
 * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty
 * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection
 * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection
 */

/**
 * @typedef {Object} FileSyncObject
 * @property {string} name the name of the file
 * @property {string} fd the file descriptor or -1 if the fd has been discarded
 * @property {fileCallback} removeCallback the callback function to remove the file
 */

/**
 * @typedef {Object} DirSyncObject
 * @property {string} name the name of the directory
 * @property {fileCallback} removeCallback the callback function to remove the directory
 */

/**
 * @callback tmpNameCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 */

/**
 * @callback fileCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {number} fd the file descriptor or -1 if the fd had been discarded
 * @param {cleanupCallback} fn the cleanup callback function
 */

/**
 * @callback fileCallbackSync
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {number} fd the file descriptor or -1 if the fd had been discarded
 * @param {cleanupCallbackSync} fn the cleanup callback function
 */

/**
 * @callback dirCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {cleanupCallback} fn the cleanup callback function
 */

/**
 * @callback dirCallbackSync
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {cleanupCallbackSync} fn the cleanup callback function
 */

/**
 * Removes the temporary created file or directory.
 *
 * @callback cleanupCallback
 * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed
 */

/**
 * Removes the temporary created file or directory.
 *
 * @callback cleanupCallbackSync
 */

/**
 * Callback function for function composition.
 * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}
 *
 * @callback simpleCallback
 */

// exporting all the needed methods

// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will
// allow users to reconfigure the temporary directory
Object.defineProperty(module.exports, "tmpdir", ({
  enumerable: true,
  configurable: false,
  get: function () {
    return _getTmpDir();
  }
}));

module.exports.dir = dir;
module.exports.dirSync = dirSync;

module.exports.file = file;
module.exports.fileSync = fileSync;

module.exports.tmpName = tmpName;
module.exports.tmpNameSync = tmpNameSync;

module.exports.setGracefulCleanup = setGracefulCleanup;


/***/ }),

/***/ 4256:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var punycode = __nccwpck_require__(5477);
var mappingTable = __nccwpck_require__(2020);

var PROCESSING_OPTIONS = {
  TRANSITIONAL: 0,
  NONTRANSITIONAL: 1
};

function normalize(str) { // fix bug in v8
  return str.split('\u0000').map(function (s) { return s.normalize('NFC'); }).join('\u0000');
}

function findStatus(val) {
  var start = 0;
  var end = mappingTable.length - 1;

  while (start <= end) {
    var mid = Math.floor((start + end) / 2);

    var target = mappingTable[mid];
    if (target[0][0] <= val && target[0][1] >= val) {
      return target;
    } else if (target[0][0] > val) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }

  return null;
}

var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;

function countSymbols(string) {
  return string
    // replace every surrogate pair with a BMP symbol
    .replace(regexAstralSymbols, '_')
    // then get the length
    .length;
}

function mapChars(domain_name, useSTD3, processing_option) {
  var hasError = false;
  var processed = "";

  var len = countSymbols(domain_name);
  for (var i = 0; i < len; ++i) {
    var codePoint = domain_name.codePointAt(i);
    var status = findStatus(codePoint);

    switch (status[1]) {
      case "disallowed":
        hasError = true;
        processed += String.fromCodePoint(codePoint);
        break;
      case "ignored":
        break;
      case "mapped":
        processed += String.fromCodePoint.apply(String, status[2]);
        break;
      case "deviation":
        if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
          processed += String.fromCodePoint.apply(String, status[2]);
        } else {
          processed += String.fromCodePoint(codePoint);
        }
        break;
      case "valid":
        processed += String.fromCodePoint(codePoint);
        break;
      case "disallowed_STD3_mapped":
        if (useSTD3) {
          hasError = true;
          processed += String.fromCodePoint(codePoint);
        } else {
          processed += String.fromCodePoint.apply(String, status[2]);
        }
        break;
      case "disallowed_STD3_valid":
        if (useSTD3) {
          hasError = true;
        }

        processed += String.fromCodePoint(codePoint);
        break;
    }
  }

  return {
    string: processed,
    error: hasError
  };
}

var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;

function validateLabel(label, processing_option) {
  if (label.substr(0, 4) === "xn--") {
    label = punycode.toUnicode(label);
    processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
  }

  var error = false;

  if (normalize(label) !== label ||
      (label[3] === "-" && label[4] === "-") ||
      label[0] === "-" || label[label.length - 1] === "-" ||
      label.indexOf(".") !== -1 ||
      label.search(combiningMarksRegex) === 0) {
    error = true;
  }

  var len = countSymbols(label);
  for (var i = 0; i < len; ++i) {
    var status = findStatus(label.codePointAt(i));
    if ((processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid") ||
        (processing === PROCESSING_OPTIONS.NONTRANSITIONAL &&
         status[1] !== "valid" && status[1] !== "deviation")) {
      error = true;
      break;
    }
  }

  return {
    label: label,
    error: error
  };
}

function processing(domain_name, useSTD3, processing_option) {
  var result = mapChars(domain_name, useSTD3, processing_option);
  result.string = normalize(result.string);

  var labels = result.string.split(".");
  for (var i = 0; i < labels.length; ++i) {
    try {
      var validation = validateLabel(labels[i]);
      labels[i] = validation.label;
      result.error = result.error || validation.error;
    } catch(e) {
      result.error = true;
    }
  }

  return {
    string: labels.join("."),
    error: result.error
  };
}

module.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
  var result = processing(domain_name, useSTD3, processing_option);
  var labels = result.string.split(".");
  labels = labels.map(function(l) {
    try {
      return punycode.toASCII(l);
    } catch(e) {
      result.error = true;
      return l;
    }
  });

  if (verifyDnsLength) {
    var total = labels.slice(0, labels.length - 1).join(".").length;
    if (total.length > 253 || total.length === 0) {
      result.error = true;
    }

    for (var i=0; i < labels.length; ++i) {
      if (labels.length > 63 || labels.length === 0) {
        result.error = true;
        break;
      }
    }
  }

  if (result.error) return null;
  return labels.join(".");
};

module.exports.toUnicode = function(domain_name, useSTD3) {
  var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);

  return {
    domain: result.string,
    error: result.error
  };
};

module.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;


/***/ }),

/***/ 4294:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(4219);


/***/ }),

/***/ 4219:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var net = __nccwpck_require__(1808);
var tls = __nccwpck_require__(4404);
var http = __nccwpck_require__(3685);
var https = __nccwpck_require__(5687);
var events = __nccwpck_require__(2361);
var assert = __nccwpck_require__(9491);
var util = __nccwpck_require__(3837);


exports.httpOverHttp = httpOverHttp;
exports.httpsOverHttp = httpsOverHttp;
exports.httpOverHttps = httpOverHttps;
exports.httpsOverHttps = httpsOverHttps;


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  return agent;
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  return agent;
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}


function TunnelingAgent(options) {
  var self = this;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];

  self.on('free', function onFree(socket, host, port, localAddress) {
    var options = toOptions(host, port, localAddress);
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i];
      if (pending.host === options.host && pending.port === options.port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return;
      }
    }
    socket.destroy();
    self.removeSocket(socket);
  });
}
util.inherits(TunnelingAgent, events.EventEmitter);

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
  var self = this;
  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push(options);
    return;
  }

  // If we are under maxSockets create a new one.
  self.createSocket(options, function(socket) {
    socket.on('free', onFree);
    socket.on('close', onCloseOrRemove);
    socket.on('agentRemove', onCloseOrRemove);
    req.onSocket(socket);

    function onFree() {
      self.emit('free', socket, options);
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket);
      socket.removeListener('free', onFree);
      socket.removeListener('close', onCloseOrRemove);
      socket.removeListener('agentRemove', onCloseOrRemove);
    }
  });
};

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this;
  var placeholder = {};
  self.sockets.push(placeholder);

  var connectOptions = mergeOptions({}, self.proxyOptions, {
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false,
    headers: {
      host: options.host + ':' + options.port
    }
  });
  if (options.localAddress) {
    connectOptions.localAddress = options.localAddress;
  }
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64');
  }

  debug('making CONNECT request');
  var connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false; // for v0.6
  connectReq.once('response', onResponse); // for v0.6
  connectReq.once('upgrade', onUpgrade);   // for v0.6
  connectReq.once('connect', onConnect);   // for v0.7 or later
  connectReq.once('error', onError);
  connectReq.end();

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true;
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head);
    });
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    if (res.statusCode !== 200) {
      debug('tunneling socket could not be established, statusCode=%d',
        res.statusCode);
      socket.destroy();
      var error = new Error('tunneling socket could not be established, ' +
        'statusCode=' + res.statusCode);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    if (head.length > 0) {
      debug('got illegal response body from proxy');
      socket.destroy();
      var error = new Error('got illegal response body from proxy');
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    debug('tunneling connection has established');
    self.sockets[self.sockets.indexOf(placeholder)] = socket;
    return cb(socket);
  }

  function onError(cause) {
    connectReq.removeAllListeners();

    debug('tunneling socket could not be established, cause=%s\n',
          cause.message, cause.stack);
    var error = new Error('tunneling socket could not be established, ' +
                          'cause=' + cause.message);
    error.code = 'ECONNRESET';
    options.request.emit('error', error);
    self.removeSocket(placeholder);
  }
};

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) {
    return;
  }
  this.sockets.splice(pos, 1);

  var pending = this.requests.shift();
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket);
    });
  }
};

function createSecureSocket(options, cb) {
  var self = this;
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    var hostHeader = options.request.getHeader('host');
    var tlsOptions = mergeOptions({}, self.options, {
      socket: socket,
      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
    });

    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, tlsOptions);
    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}


function toOptions(host, port, localAddress) {
  if (typeof host === 'string') { // since v0.10
    return {
      host: host,
      port: port,
      localAddress: localAddress
    };
  }
  return host; // for v0.11 or later
}

function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides);
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j];
        if (overrides[k] !== undefined) {
          target[k] = overrides[k];
        }
      }
    }
  }
  return target;
}


var debug;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0];
    } else {
      args.unshift('TUNNEL:');
    }
    console.error.apply(console, args);
  }
} else {
  debug = function() {};
}
exports.debug = debug; // for test


/***/ }),

/***/ 5030:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }

  if (typeof process === "object" && "version" in process) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }

  return "<environment undetectable>";
}

exports.getUserAgent = getUserAgent;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 5840:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "v1", ({
  enumerable: true,
  get: function () {
    return _v.default;
  }
}));
Object.defineProperty(exports, "v3", ({
  enumerable: true,
  get: function () {
    return _v2.default;
  }
}));
Object.defineProperty(exports, "v4", ({
  enumerable: true,
  get: function () {
    return _v3.default;
  }
}));
Object.defineProperty(exports, "v5", ({
  enumerable: true,
  get: function () {
    return _v4.default;
  }
}));
Object.defineProperty(exports, "NIL", ({
  enumerable: true,
  get: function () {
    return _nil.default;
  }
}));
Object.defineProperty(exports, "version", ({
  enumerable: true,
  get: function () {
    return _version.default;
  }
}));
Object.defineProperty(exports, "validate", ({
  enumerable: true,
  get: function () {
    return _validate.default;
  }
}));
Object.defineProperty(exports, "stringify", ({
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
}));
Object.defineProperty(exports, "parse", ({
  enumerable: true,
  get: function () {
    return _parse.default;
  }
}));

var _v = _interopRequireDefault(__nccwpck_require__(8628));

var _v2 = _interopRequireDefault(__nccwpck_require__(6409));

var _v3 = _interopRequireDefault(__nccwpck_require__(5122));

var _v4 = _interopRequireDefault(__nccwpck_require__(9120));

var _nil = _interopRequireDefault(__nccwpck_require__(5332));

var _version = _interopRequireDefault(__nccwpck_require__(1595));

var _validate = _interopRequireDefault(__nccwpck_require__(6900));

var _stringify = _interopRequireDefault(__nccwpck_require__(8950));

var _parse = _interopRequireDefault(__nccwpck_require__(2746));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ 4569:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('md5').update(bytes).digest();
}

var _default = md5;
exports["default"] = _default;

/***/ }),

/***/ 5332:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports["default"] = _default;

/***/ }),

/***/ 2746:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(6900));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports["default"] = _default;

/***/ }),

/***/ 814:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports["default"] = _default;

/***/ }),

/***/ 807:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = rng;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

let poolPtr = rnds8Pool.length;

function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    _crypto.default.randomFillSync(rnds8Pool);

    poolPtr = 0;
  }

  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

/***/ }),

/***/ 5274:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('sha1').update(bytes).digest();
}

var _default = sha1;
exports["default"] = _default;

/***/ }),

/***/ 8950:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(6900));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports["default"] = _default;

/***/ }),

/***/ 8628:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__nccwpck_require__(807));

var _stringify = _interopRequireDefault(__nccwpck_require__(8950));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports["default"] = _default;

/***/ }),

/***/ 6409:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__nccwpck_require__(5998));

var _md = _interopRequireDefault(__nccwpck_require__(4569));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports["default"] = _default;

/***/ }),

/***/ 5998:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(__nccwpck_require__(8950));

var _parse = _interopRequireDefault(__nccwpck_require__(2746));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ 5122:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__nccwpck_require__(807));

var _stringify = _interopRequireDefault(__nccwpck_require__(8950));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports["default"] = _default;

/***/ }),

/***/ 9120:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__nccwpck_require__(5998));

var _sha = _interopRequireDefault(__nccwpck_require__(5274));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports["default"] = _default;

/***/ }),

/***/ 6900:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _regex = _interopRequireDefault(__nccwpck_require__(814));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports["default"] = _default;

/***/ }),

/***/ 1595:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(6900));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports["default"] = _default;

/***/ }),

/***/ 4886:
/***/ ((module) => {

"use strict";


var conversions = {};
module.exports = conversions;

function sign(x) {
    return x < 0 ? -1 : 1;
}

function evenRound(x) {
    // Round x to the nearest integer, choosing the even integer if it lies halfway between two.
    if ((x % 1) === 0.5 && (x & 1) === 0) { // [even number].5; round down (i.e. floor)
        return Math.floor(x);
    } else {
        return Math.round(x);
    }
}

function createNumberConversion(bitLength, typeOpts) {
    if (!typeOpts.unsigned) {
        --bitLength;
    }
    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
    const upperBound = Math.pow(2, bitLength) - 1;

    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);

    return function(V, opts) {
        if (!opts) opts = {};

        let x = +V;

        if (opts.enforceRange) {
            if (!Number.isFinite(x)) {
                throw new TypeError("Argument is not a finite number");
            }

            x = sign(x) * Math.floor(Math.abs(x));
            if (x < lowerBound || x > upperBound) {
                throw new TypeError("Argument is not in byte range");
            }

            return x;
        }

        if (!isNaN(x) && opts.clamp) {
            x = evenRound(x);

            if (x < lowerBound) x = lowerBound;
            if (x > upperBound) x = upperBound;
            return x;
        }

        if (!Number.isFinite(x) || x === 0) {
            return 0;
        }

        x = sign(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;

        if (!typeOpts.unsigned && x >= moduloBound) {
            return x - moduloVal;
        } else if (typeOpts.unsigned) {
            if (x < 0) {
              x += moduloVal;
            } else if (x === -0) { // don't return negative zero
              return 0;
            }
        }

        return x;
    }
}

conversions["void"] = function () {
    return undefined;
};

conversions["boolean"] = function (val) {
    return !!val;
};

conversions["byte"] = createNumberConversion(8, { unsigned: false });
conversions["octet"] = createNumberConversion(8, { unsigned: true });

conversions["short"] = createNumberConversion(16, { unsigned: false });
conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });

conversions["long"] = createNumberConversion(32, { unsigned: false });
conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });

conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });

conversions["double"] = function (V) {
    const x = +V;

    if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value");
    }

    return x;
};

conversions["unrestricted double"] = function (V) {
    const x = +V;

    if (isNaN(x)) {
        throw new TypeError("Argument is NaN");
    }

    return x;
};

// not quite valid, but good enough for JS
conversions["float"] = conversions["double"];
conversions["unrestricted float"] = conversions["unrestricted double"];

conversions["DOMString"] = function (V, opts) {
    if (!opts) opts = {};

    if (opts.treatNullAsEmptyString && V === null) {
        return "";
    }

    return String(V);
};

conversions["ByteString"] = function (V, opts) {
    const x = String(V);
    let c = undefined;
    for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {
        if (c > 255) {
            throw new TypeError("Argument is not a valid bytestring");
        }
    }

    return x;
};

conversions["USVString"] = function (V) {
    const S = String(V);
    const n = S.length;
    const U = [];
    for (let i = 0; i < n; ++i) {
        const c = S.charCodeAt(i);
        if (c < 0xD800 || c > 0xDFFF) {
            U.push(String.fromCodePoint(c));
        } else if (0xDC00 <= c && c <= 0xDFFF) {
            U.push(String.fromCodePoint(0xFFFD));
        } else {
            if (i === n - 1) {
                U.push(String.fromCodePoint(0xFFFD));
            } else {
                const d = S.charCodeAt(i + 1);
                if (0xDC00 <= d && d <= 0xDFFF) {
                    const a = c & 0x3FF;
                    const b = d & 0x3FF;
                    U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
                    ++i;
                } else {
                    U.push(String.fromCodePoint(0xFFFD));
                }
            }
        }
    }

    return U.join('');
};

conversions["Date"] = function (V, opts) {
    if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
    }
    if (isNaN(V)) {
        return undefined;
    }

    return V;
};

conversions["RegExp"] = function (V, opts) {
    if (!(V instanceof RegExp)) {
        V = new RegExp(V);
    }

    return V;
};


/***/ }),

/***/ 7537:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

const usm = __nccwpck_require__(2158);

exports.implementation = class URLImpl {
  constructor(constructorArgs) {
    const url = constructorArgs[0];
    const base = constructorArgs[1];

    let parsedBase = null;
    if (base !== undefined) {
      parsedBase = usm.basicURLParse(base);
      if (parsedBase === "failure") {
        throw new TypeError("Invalid base URL");
      }
    }

    const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
    if (parsedURL === "failure") {
      throw new TypeError("Invalid URL");
    }

    this._url = parsedURL;

    // TODO: query stuff
  }

  get href() {
    return usm.serializeURL(this._url);
  }

  set href(v) {
    const parsedURL = usm.basicURLParse(v);
    if (parsedURL === "failure") {
      throw new TypeError("Invalid URL");
    }

    this._url = parsedURL;
  }

  get origin() {
    return usm.serializeURLOrigin(this._url);
  }

  get protocol() {
    return this._url.scheme + ":";
  }

  set protocol(v) {
    usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
  }

  get username() {
    return this._url.username;
  }

  set username(v) {
    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
      return;
    }

    usm.setTheUsername(this._url, v);
  }

  get password() {
    return this._url.password;
  }

  set password(v) {
    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
      return;
    }

    usm.setThePassword(this._url, v);
  }

  get host() {
    const url = this._url;

    if (url.host === null) {
      return "";
    }

    if (url.port === null) {
      return usm.serializeHost(url.host);
    }

    return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
  }

  set host(v) {
    if (this._url.cannotBeABaseURL) {
      return;
    }

    usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
  }

  get hostname() {
    if (this._url.host === null) {
      return "";
    }

    return usm.serializeHost(this._url.host);
  }

  set hostname(v) {
    if (this._url.cannotBeABaseURL) {
      return;
    }

    usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
  }

  get port() {
    if (this._url.port === null) {
      return "";
    }

    return usm.serializeInteger(this._url.port);
  }

  set port(v) {
    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
      return;
    }

    if (v === "") {
      this._url.port = null;
    } else {
      usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
    }
  }

  get pathname() {
    if (this._url.cannotBeABaseURL) {
      return this._url.path[0];
    }

    if (this._url.path.length === 0) {
      return "";
    }

    return "/" + this._url.path.join("/");
  }

  set pathname(v) {
    if (this._url.cannotBeABaseURL) {
      return;
    }

    this._url.path = [];
    usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
  }

  get search() {
    if (this._url.query === null || this._url.query === "") {
      return "";
    }

    return "?" + this._url.query;
  }

  set search(v) {
    // TODO: query stuff

    const url = this._url;

    if (v === "") {
      url.query = null;
      return;
    }

    const input = v[0] === "?" ? v.substring(1) : v;
    url.query = "";
    usm.basicURLParse(input, { url, stateOverride: "query" });
  }

  get hash() {
    if (this._url.fragment === null || this._url.fragment === "") {
      return "";
    }

    return "#" + this._url.fragment;
  }

  set hash(v) {
    if (v === "") {
      this._url.fragment = null;
      return;
    }

    const input = v[0] === "#" ? v.substring(1) : v;
    this._url.fragment = "";
    usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
  }

  toJSON() {
    return this.href;
  }
};


/***/ }),

/***/ 3394:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const conversions = __nccwpck_require__(4886);
const utils = __nccwpck_require__(3185);
const Impl = __nccwpck_require__(7537);

const impl = utils.implSymbol;

function URL(url) {
  if (!this || this[impl] || !(this instanceof URL)) {
    throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
  }
  if (arguments.length < 1) {
    throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
  }
  const args = [];
  for (let i = 0; i < arguments.length && i < 2; ++i) {
    args[i] = arguments[i];
  }
  args[0] = conversions["USVString"](args[0]);
  if (args[1] !== undefined) {
  args[1] = conversions["USVString"](args[1]);
  }

  module.exports.setup(this, args);
}

URL.prototype.toJSON = function toJSON() {
  if (!this || !module.exports.is(this)) {
    throw new TypeError("Illegal invocation");
  }
  const args = [];
  for (let i = 0; i < arguments.length && i < 0; ++i) {
    args[i] = arguments[i];
  }
  return this[impl].toJSON.apply(this[impl], args);
};
Object.defineProperty(URL.prototype, "href", {
  get() {
    return this[impl].href;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].href = V;
  },
  enumerable: true,
  configurable: true
});

URL.prototype.toString = function () {
  if (!this || !module.exports.is(this)) {
    throw new TypeError("Illegal invocation");
  }
  return this.href;
};

Object.defineProperty(URL.prototype, "origin", {
  get() {
    return this[impl].origin;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "protocol", {
  get() {
    return this[impl].protocol;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].protocol = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "username", {
  get() {
    return this[impl].username;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].username = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "password", {
  get() {
    return this[impl].password;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].password = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "host", {
  get() {
    return this[impl].host;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].host = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "hostname", {
  get() {
    return this[impl].hostname;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].hostname = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "port", {
  get() {
    return this[impl].port;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].port = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "pathname", {
  get() {
    return this[impl].pathname;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].pathname = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "search", {
  get() {
    return this[impl].search;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].search = V;
  },
  enumerable: true,
  configurable: true
});

Object.defineProperty(URL.prototype, "hash", {
  get() {
    return this[impl].hash;
  },
  set(V) {
    V = conversions["USVString"](V);
    this[impl].hash = V;
  },
  enumerable: true,
  configurable: true
});


module.exports = {
  is(obj) {
    return !!obj && obj[impl] instanceof Impl.implementation;
  },
  create(constructorArgs, privateData) {
    let obj = Object.create(URL.prototype);
    this.setup(obj, constructorArgs, privateData);
    return obj;
  },
  setup(obj, constructorArgs, privateData) {
    if (!privateData) privateData = {};
    privateData.wrapper = obj;

    obj[impl] = new Impl.implementation(constructorArgs, privateData);
    obj[impl][utils.wrapperSymbol] = obj;
  },
  interface: URL,
  expose: {
    Window: { URL: URL },
    Worker: { URL: URL }
  }
};



/***/ }),

/***/ 8665:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


exports.URL = __nccwpck_require__(3394)["interface"];
exports.serializeURL = __nccwpck_require__(2158).serializeURL;
exports.serializeURLOrigin = __nccwpck_require__(2158).serializeURLOrigin;
exports.basicURLParse = __nccwpck_require__(2158).basicURLParse;
exports.setTheUsername = __nccwpck_require__(2158).setTheUsername;
exports.setThePassword = __nccwpck_require__(2158).setThePassword;
exports.serializeHost = __nccwpck_require__(2158).serializeHost;
exports.serializeInteger = __nccwpck_require__(2158).serializeInteger;
exports.parseURL = __nccwpck_require__(2158).parseURL;


/***/ }),

/***/ 2158:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const punycode = __nccwpck_require__(5477);
const tr46 = __nccwpck_require__(4256);

const specialSchemes = {
  ftp: 21,
  file: null,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};

const failure = Symbol("failure");

function countSymbols(str) {
  return punycode.ucs2.decode(str).length;
}

function at(input, idx) {
  const c = input[idx];
  return isNaN(c) ? undefined : String.fromCodePoint(c);
}

function isASCIIDigit(c) {
  return c >= 0x30 && c <= 0x39;
}

function isASCIIAlpha(c) {
  return (c >= 0x41 && c <= 0x5A) || (c >= 0x61 && c <= 0x7A);
}

function isASCIIAlphanumeric(c) {
  return isASCIIAlpha(c) || isASCIIDigit(c);
}

function isASCIIHex(c) {
  return isASCIIDigit(c) || (c >= 0x41 && c <= 0x46) || (c >= 0x61 && c <= 0x66);
}

function isSingleDot(buffer) {
  return buffer === "." || buffer.toLowerCase() === "%2e";
}

function isDoubleDot(buffer) {
  buffer = buffer.toLowerCase();
  return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
}

function isWindowsDriveLetterCodePoints(cp1, cp2) {
  return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
}

function isWindowsDriveLetterString(string) {
  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
}

function isNormalizedWindowsDriveLetterString(string) {
  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
}

function containsForbiddenHostCodePoint(string) {
  return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
}

function containsForbiddenHostCodePointExcludingPercent(string) {
  return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
}

function isSpecialScheme(scheme) {
  return specialSchemes[scheme] !== undefined;
}

function isSpecial(url) {
  return isSpecialScheme(url.scheme);
}

function defaultPort(scheme) {
  return specialSchemes[scheme];
}

function percentEncode(c) {
  let hex = c.toString(16).toUpperCase();
  if (hex.length === 1) {
    hex = "0" + hex;
  }

  return "%" + hex;
}

function utf8PercentEncode(c) {
  const buf = new Buffer(c);

  let str = "";

  for (let i = 0; i < buf.length; ++i) {
    str += percentEncode(buf[i]);
  }

  return str;
}

function utf8PercentDecode(str) {
  const input = new Buffer(str);
  const output = [];
  for (let i = 0; i < input.length; ++i) {
    if (input[i] !== 37) {
      output.push(input[i]);
    } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
      output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
      i += 2;
    } else {
      output.push(input[i]);
    }
  }
  return new Buffer(output).toString();
}

function isC0ControlPercentEncode(c) {
  return c <= 0x1F || c > 0x7E;
}

const extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
function isPathPercentEncode(c) {
  return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
}

const extraUserinfoPercentEncodeSet =
  new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
function isUserinfoPercentEncode(c) {
  return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
}

function percentEncodeChar(c, encodeSetPredicate) {
  const cStr = String.fromCodePoint(c);

  if (encodeSetPredicate(c)) {
    return utf8PercentEncode(cStr);
  }

  return cStr;
}

function parseIPv4Number(input) {
  let R = 10;

  if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
    input = input.substring(2);
    R = 16;
  } else if (input.length >= 2 && input.charAt(0) === "0") {
    input = input.substring(1);
    R = 8;
  }

  if (input === "") {
    return 0;
  }

  const regex = R === 10 ? /[^0-9]/ : (R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/);
  if (regex.test(input)) {
    return failure;
  }

  return parseInt(input, R);
}

function parseIPv4(input) {
  const parts = input.split(".");
  if (parts[parts.length - 1] === "") {
    if (parts.length > 1) {
      parts.pop();
    }
  }

  if (parts.length > 4) {
    return input;
  }

  const numbers = [];
  for (const part of parts) {
    if (part === "") {
      return input;
    }
    const n = parseIPv4Number(part);
    if (n === failure) {
      return input;
    }

    numbers.push(n);
  }

  for (let i = 0; i < numbers.length - 1; ++i) {
    if (numbers[i] > 255) {
      return failure;
    }
  }
  if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
    return failure;
  }

  let ipv4 = numbers.pop();
  let counter = 0;

  for (const n of numbers) {
    ipv4 += n * Math.pow(256, 3 - counter);
    ++counter;
  }

  return ipv4;
}

function serializeIPv4(address) {
  let output = "";
  let n = address;

  for (let i = 1; i <= 4; ++i) {
    output = String(n % 256) + output;
    if (i !== 4) {
      output = "." + output;
    }
    n = Math.floor(n / 256);
  }

  return output;
}

function parseIPv6(input) {
  const address = [0, 0, 0, 0, 0, 0, 0, 0];
  let pieceIndex = 0;
  let compress = null;
  let pointer = 0;

  input = punycode.ucs2.decode(input);

  if (input[pointer] === 58) {
    if (input[pointer + 1] !== 58) {
      return failure;
    }

    pointer += 2;
    ++pieceIndex;
    compress = pieceIndex;
  }

  while (pointer < input.length) {
    if (pieceIndex === 8) {
      return failure;
    }

    if (input[pointer] === 58) {
      if (compress !== null) {
        return failure;
      }
      ++pointer;
      ++pieceIndex;
      compress = pieceIndex;
      continue;
    }

    let value = 0;
    let length = 0;

    while (length < 4 && isASCIIHex(input[pointer])) {
      value = value * 0x10 + parseInt(at(input, pointer), 16);
      ++pointer;
      ++length;
    }

    if (input[pointer] === 46) {
      if (length === 0) {
        return failure;
      }

      pointer -= length;

      if (pieceIndex > 6) {
        return failure;
      }

      let numbersSeen = 0;

      while (input[pointer] !== undefined) {
        let ipv4Piece = null;

        if (numbersSeen > 0) {
          if (input[pointer] === 46 && numbersSeen < 4) {
            ++pointer;
          } else {
            return failure;
          }
        }

        if (!isASCIIDigit(input[pointer])) {
          return failure;
        }

        while (isASCIIDigit(input[pointer])) {
          const number = parseInt(at(input, pointer));
          if (ipv4Piece === null) {
            ipv4Piece = number;
          } else if (ipv4Piece === 0) {
            return failure;
          } else {
            ipv4Piece = ipv4Piece * 10 + number;
          }
          if (ipv4Piece > 255) {
            return failure;
          }
          ++pointer;
        }

        address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;

        ++numbersSeen;

        if (numbersSeen === 2 || numbersSeen === 4) {
          ++pieceIndex;
        }
      }

      if (numbersSeen !== 4) {
        return failure;
      }

      break;
    } else if (input[pointer] === 58) {
      ++pointer;
      if (input[pointer] === undefined) {
        return failure;
      }
    } else if (input[pointer] !== undefined) {
      return failure;
    }

    address[pieceIndex] = value;
    ++pieceIndex;
  }

  if (compress !== null) {
    let swaps = pieceIndex - compress;
    pieceIndex = 7;
    while (pieceIndex !== 0 && swaps > 0) {
      const temp = address[compress + swaps - 1];
      address[compress + swaps - 1] = address[pieceIndex];
      address[pieceIndex] = temp;
      --pieceIndex;
      --swaps;
    }
  } else if (compress === null && pieceIndex !== 8) {
    return failure;
  }

  return address;
}

function serializeIPv6(address) {
  let output = "";
  const seqResult = findLongestZeroSequence(address);
  const compress = seqResult.idx;
  let ignore0 = false;

  for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
    if (ignore0 && address[pieceIndex] === 0) {
      continue;
    } else if (ignore0) {
      ignore0 = false;
    }

    if (compress === pieceIndex) {
      const separator = pieceIndex === 0 ? "::" : ":";
      output += separator;
      ignore0 = true;
      continue;
    }

    output += address[pieceIndex].toString(16);

    if (pieceIndex !== 7) {
      output += ":";
    }
  }

  return output;
}

function parseHost(input, isSpecialArg) {
  if (input[0] === "[") {
    if (input[input.length - 1] !== "]") {
      return failure;
    }

    return parseIPv6(input.substring(1, input.length - 1));
  }

  if (!isSpecialArg) {
    return parseOpaqueHost(input);
  }

  const domain = utf8PercentDecode(input);
  const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
  if (asciiDomain === null) {
    return failure;
  }

  if (containsForbiddenHostCodePoint(asciiDomain)) {
    return failure;
  }

  const ipv4Host = parseIPv4(asciiDomain);
  if (typeof ipv4Host === "number" || ipv4Host === failure) {
    return ipv4Host;
  }

  return asciiDomain;
}

function parseOpaqueHost(input) {
  if (containsForbiddenHostCodePointExcludingPercent(input)) {
    return failure;
  }

  let output = "";
  const decoded = punycode.ucs2.decode(input);
  for (let i = 0; i < decoded.length; ++i) {
    output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
  }
  return output;
}

function findLongestZeroSequence(arr) {
  let maxIdx = null;
  let maxLen = 1; // only find elements > 1
  let currStart = null;
  let currLen = 0;

  for (let i = 0; i < arr.length; ++i) {
    if (arr[i] !== 0) {
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }

      currStart = null;
      currLen = 0;
    } else {
      if (currStart === null) {
        currStart = i;
      }
      ++currLen;
    }
  }

  // if trailing zeros
  if (currLen > maxLen) {
    maxIdx = currStart;
    maxLen = currLen;
  }

  return {
    idx: maxIdx,
    len: maxLen
  };
}

function serializeHost(host) {
  if (typeof host === "number") {
    return serializeIPv4(host);
  }

  // IPv6 serializer
  if (host instanceof Array) {
    return "[" + serializeIPv6(host) + "]";
  }

  return host;
}

function trimControlChars(url) {
  return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
}

function trimTabAndNewline(url) {
  return url.replace(/\u0009|\u000A|\u000D/g, "");
}

function shortenPath(url) {
  const path = url.path;
  if (path.length === 0) {
    return;
  }
  if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
    return;
  }

  path.pop();
}

function includesCredentials(url) {
  return url.username !== "" || url.password !== "";
}

function cannotHaveAUsernamePasswordPort(url) {
  return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
}

function isNormalizedWindowsDriveLetter(string) {
  return /^[A-Za-z]:$/.test(string);
}

function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
  this.pointer = 0;
  this.input = input;
  this.base = base || null;
  this.encodingOverride = encodingOverride || "utf-8";
  this.stateOverride = stateOverride;
  this.url = url;
  this.failure = false;
  this.parseError = false;

  if (!this.url) {
    this.url = {
      scheme: "",
      username: "",
      password: "",
      host: null,
      port: null,
      path: [],
      query: null,
      fragment: null,

      cannotBeABaseURL: false
    };

    const res = trimControlChars(this.input);
    if (res !== this.input) {
      this.parseError = true;
    }
    this.input = res;
  }

  const res = trimTabAndNewline(this.input);
  if (res !== this.input) {
    this.parseError = true;
  }
  this.input = res;

  this.state = stateOverride || "scheme start";

  this.buffer = "";
  this.atFlag = false;
  this.arrFlag = false;
  this.passwordTokenSeenFlag = false;

  this.input = punycode.ucs2.decode(this.input);

  for (; this.pointer <= this.input.length; ++this.pointer) {
    const c = this.input[this.pointer];
    const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);

    // exec state machine
    const ret = this["parse " + this.state](c, cStr);
    if (!ret) {
      break; // terminate algorithm
    } else if (ret === failure) {
      this.failure = true;
      break;
    }
  }
}

URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
  if (isASCIIAlpha(c)) {
    this.buffer += cStr.toLowerCase();
    this.state = "scheme";
  } else if (!this.stateOverride) {
    this.state = "no scheme";
    --this.pointer;
  } else {
    this.parseError = true;
    return failure;
  }

  return true;
};

URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
  if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
    this.buffer += cStr.toLowerCase();
  } else if (c === 58) {
    if (this.stateOverride) {
      if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
        return false;
      }

      if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
        return false;
      }

      if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
        return false;
      }

      if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
        return false;
      }
    }
    this.url.scheme = this.buffer;
    this.buffer = "";
    if (this.stateOverride) {
      return false;
    }
    if (this.url.scheme === "file") {
      if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
        this.parseError = true;
      }
      this.state = "file";
    } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
      this.state = "special relative or authority";
    } else if (isSpecial(this.url)) {
      this.state = "special authority slashes";
    } else if (this.input[this.pointer + 1] === 47) {
      this.state = "path or authority";
      ++this.pointer;
    } else {
      this.url.cannotBeABaseURL = true;
      this.url.path.push("");
      this.state = "cannot-be-a-base-URL path";
    }
  } else if (!this.stateOverride) {
    this.buffer = "";
    this.state = "no scheme";
    this.pointer = -1;
  } else {
    this.parseError = true;
    return failure;
  }

  return true;
};

URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
  if (this.base === null || (this.base.cannotBeABaseURL && c !== 35)) {
    return failure;
  } else if (this.base.cannotBeABaseURL && c === 35) {
    this.url.scheme = this.base.scheme;
    this.url.path = this.base.path.slice();
    this.url.query = this.base.query;
    this.url.fragment = "";
    this.url.cannotBeABaseURL = true;
    this.state = "fragment";
  } else if (this.base.scheme === "file") {
    this.state = "file";
    --this.pointer;
  } else {
    this.state = "relative";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
  if (c === 47 && this.input[this.pointer + 1] === 47) {
    this.state = "special authority ignore slashes";
    ++this.pointer;
  } else {
    this.parseError = true;
    this.state = "relative";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
  if (c === 47) {
    this.state = "authority";
  } else {
    this.state = "path";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
  this.url.scheme = this.base.scheme;
  if (isNaN(c)) {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.url.path = this.base.path.slice();
    this.url.query = this.base.query;
  } else if (c === 47) {
    this.state = "relative slash";
  } else if (c === 63) {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.url.path = this.base.path.slice();
    this.url.query = "";
    this.state = "query";
  } else if (c === 35) {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.url.path = this.base.path.slice();
    this.url.query = this.base.query;
    this.url.fragment = "";
    this.state = "fragment";
  } else if (isSpecial(this.url) && c === 92) {
    this.parseError = true;
    this.state = "relative slash";
  } else {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.url.path = this.base.path.slice(0, this.base.path.length - 1);

    this.state = "path";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
  if (isSpecial(this.url) && (c === 47 || c === 92)) {
    if (c === 92) {
      this.parseError = true;
    }
    this.state = "special authority ignore slashes";
  } else if (c === 47) {
    this.state = "authority";
  } else {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.state = "path";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
  if (c === 47 && this.input[this.pointer + 1] === 47) {
    this.state = "special authority ignore slashes";
    ++this.pointer;
  } else {
    this.parseError = true;
    this.state = "special authority ignore slashes";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
  if (c !== 47 && c !== 92) {
    this.state = "authority";
    --this.pointer;
  } else {
    this.parseError = true;
  }

  return true;
};

URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
  if (c === 64) {
    this.parseError = true;
    if (this.atFlag) {
      this.buffer = "%40" + this.buffer;
    }
    this.atFlag = true;

    // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars
    const len = countSymbols(this.buffer);
    for (let pointer = 0; pointer < len; ++pointer) {
      const codePoint = this.buffer.codePointAt(pointer);

      if (codePoint === 58 && !this.passwordTokenSeenFlag) {
        this.passwordTokenSeenFlag = true;
        continue;
      }
      const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
      if (this.passwordTokenSeenFlag) {
        this.url.password += encodedCodePoints;
      } else {
        this.url.username += encodedCodePoints;
      }
    }
    this.buffer = "";
  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||
             (isSpecial(this.url) && c === 92)) {
    if (this.atFlag && this.buffer === "") {
      this.parseError = true;
      return failure;
    }
    this.pointer -= countSymbols(this.buffer) + 1;
    this.buffer = "";
    this.state = "host";
  } else {
    this.buffer += cStr;
  }

  return true;
};

URLStateMachine.prototype["parse hostname"] =
URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
  if (this.stateOverride && this.url.scheme === "file") {
    --this.pointer;
    this.state = "file host";
  } else if (c === 58 && !this.arrFlag) {
    if (this.buffer === "") {
      this.parseError = true;
      return failure;
    }

    const host = parseHost(this.buffer, isSpecial(this.url));
    if (host === failure) {
      return failure;
    }

    this.url.host = host;
    this.buffer = "";
    this.state = "port";
    if (this.stateOverride === "hostname") {
      return false;
    }
  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||
             (isSpecial(this.url) && c === 92)) {
    --this.pointer;
    if (isSpecial(this.url) && this.buffer === "") {
      this.parseError = true;
      return failure;
    } else if (this.stateOverride && this.buffer === "" &&
               (includesCredentials(this.url) || this.url.port !== null)) {
      this.parseError = true;
      return false;
    }

    const host = parseHost(this.buffer, isSpecial(this.url));
    if (host === failure) {
      return failure;
    }

    this.url.host = host;
    this.buffer = "";
    this.state = "path start";
    if (this.stateOverride) {
      return false;
    }
  } else {
    if (c === 91) {
      this.arrFlag = true;
    } else if (c === 93) {
      this.arrFlag = false;
    }
    this.buffer += cStr;
  }

  return true;
};

URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
  if (isASCIIDigit(c)) {
    this.buffer += cStr;
  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||
             (isSpecial(this.url) && c === 92) ||
             this.stateOverride) {
    if (this.buffer !== "") {
      const port = parseInt(this.buffer);
      if (port > Math.pow(2, 16) - 1) {
        this.parseError = true;
        return failure;
      }
      this.url.port = port === defaultPort(this.url.scheme) ? null : port;
      this.buffer = "";
    }
    if (this.stateOverride) {
      return false;
    }
    this.state = "path start";
    --this.pointer;
  } else {
    this.parseError = true;
    return failure;
  }

  return true;
};

const fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);

URLStateMachine.prototype["parse file"] = function parseFile(c) {
  this.url.scheme = "file";

  if (c === 47 || c === 92) {
    if (c === 92) {
      this.parseError = true;
    }
    this.state = "file slash";
  } else if (this.base !== null && this.base.scheme === "file") {
    if (isNaN(c)) {
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
    } else if (c === 63) {
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = "";
      this.state = "query";
    } else if (c === 35) {
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.state = "fragment";
    } else {
      if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) ||
          (this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
           !fileOtherwiseCodePoints.has(this.input[this.pointer + 2]))) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        shortenPath(this.url);
      } else {
        this.parseError = true;
      }

      this.state = "path";
      --this.pointer;
    }
  } else {
    this.state = "path";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
  if (c === 47 || c === 92) {
    if (c === 92) {
      this.parseError = true;
    }
    this.state = "file host";
  } else {
    if (this.base !== null && this.base.scheme === "file") {
      if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
        this.url.path.push(this.base.path[0]);
      } else {
        this.url.host = this.base.host;
      }
    }
    this.state = "path";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
  if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
    --this.pointer;
    if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
      this.parseError = true;
      this.state = "path";
    } else if (this.buffer === "") {
      this.url.host = "";
      if (this.stateOverride) {
        return false;
      }
      this.state = "path start";
    } else {
      let host = parseHost(this.buffer, isSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      if (host === "localhost") {
        host = "";
      }
      this.url.host = host;

      if (this.stateOverride) {
        return false;
      }

      this.buffer = "";
      this.state = "path start";
    }
  } else {
    this.buffer += cStr;
  }

  return true;
};

URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
  if (isSpecial(this.url)) {
    if (c === 92) {
      this.parseError = true;
    }
    this.state = "path";

    if (c !== 47 && c !== 92) {
      --this.pointer;
    }
  } else if (!this.stateOverride && c === 63) {
    this.url.query = "";
    this.state = "query";
  } else if (!this.stateOverride && c === 35) {
    this.url.fragment = "";
    this.state = "fragment";
  } else if (c !== undefined) {
    this.state = "path";
    if (c !== 47) {
      --this.pointer;
    }
  }

  return true;
};

URLStateMachine.prototype["parse path"] = function parsePath(c) {
  if (isNaN(c) || c === 47 || (isSpecial(this.url) && c === 92) ||
      (!this.stateOverride && (c === 63 || c === 35))) {
    if (isSpecial(this.url) && c === 92) {
      this.parseError = true;
    }

    if (isDoubleDot(this.buffer)) {
      shortenPath(this.url);
      if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
        this.url.path.push("");
      }
    } else if (isSingleDot(this.buffer) && c !== 47 &&
               !(isSpecial(this.url) && c === 92)) {
      this.url.path.push("");
    } else if (!isSingleDot(this.buffer)) {
      if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
        if (this.url.host !== "" && this.url.host !== null) {
          this.parseError = true;
          this.url.host = "";
        }
        this.buffer = this.buffer[0] + ":";
      }
      this.url.path.push(this.buffer);
    }
    this.buffer = "";
    if (this.url.scheme === "file" && (c === undefined || c === 63 || c === 35)) {
      while (this.url.path.length > 1 && this.url.path[0] === "") {
        this.parseError = true;
        this.url.path.shift();
      }
    }
    if (c === 63) {
      this.url.query = "";
      this.state = "query";
    }
    if (c === 35) {
      this.url.fragment = "";
      this.state = "fragment";
    }
  } else {
    // TODO: If c is not a URL code point and not "%", parse error.

    if (c === 37 &&
      (!isASCIIHex(this.input[this.pointer + 1]) ||
        !isASCIIHex(this.input[this.pointer + 2]))) {
      this.parseError = true;
    }

    this.buffer += percentEncodeChar(c, isPathPercentEncode);
  }

  return true;
};

URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
  if (c === 63) {
    this.url.query = "";
    this.state = "query";
  } else if (c === 35) {
    this.url.fragment = "";
    this.state = "fragment";
  } else {
    // TODO: Add: not a URL code point
    if (!isNaN(c) && c !== 37) {
      this.parseError = true;
    }

    if (c === 37 &&
        (!isASCIIHex(this.input[this.pointer + 1]) ||
         !isASCIIHex(this.input[this.pointer + 2]))) {
      this.parseError = true;
    }

    if (!isNaN(c)) {
      this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
    }
  }

  return true;
};

URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
  if (isNaN(c) || (!this.stateOverride && c === 35)) {
    if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
      this.encodingOverride = "utf-8";
    }

    const buffer = new Buffer(this.buffer); // TODO: Use encoding override instead
    for (let i = 0; i < buffer.length; ++i) {
      if (buffer[i] < 0x21 || buffer[i] > 0x7E || buffer[i] === 0x22 || buffer[i] === 0x23 ||
          buffer[i] === 0x3C || buffer[i] === 0x3E) {
        this.url.query += percentEncode(buffer[i]);
      } else {
        this.url.query += String.fromCodePoint(buffer[i]);
      }
    }

    this.buffer = "";
    if (c === 35) {
      this.url.fragment = "";
      this.state = "fragment";
    }
  } else {
    // TODO: If c is not a URL code point and not "%", parse error.
    if (c === 37 &&
      (!isASCIIHex(this.input[this.pointer + 1]) ||
        !isASCIIHex(this.input[this.pointer + 2]))) {
      this.parseError = true;
    }

    this.buffer += cStr;
  }

  return true;
};

URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
  if (isNaN(c)) { // do nothing
  } else if (c === 0x0) {
    this.parseError = true;
  } else {
    // TODO: If c is not a URL code point and not "%", parse error.
    if (c === 37 &&
      (!isASCIIHex(this.input[this.pointer + 1]) ||
        !isASCIIHex(this.input[this.pointer + 2]))) {
      this.parseError = true;
    }

    this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
  }

  return true;
};

function serializeURL(url, excludeFragment) {
  let output = url.scheme + ":";
  if (url.host !== null) {
    output += "//";

    if (url.username !== "" || url.password !== "") {
      output += url.username;
      if (url.password !== "") {
        output += ":" + url.password;
      }
      output += "@";
    }

    output += serializeHost(url.host);

    if (url.port !== null) {
      output += ":" + url.port;
    }
  } else if (url.host === null && url.scheme === "file") {
    output += "//";
  }

  if (url.cannotBeABaseURL) {
    output += url.path[0];
  } else {
    for (const string of url.path) {
      output += "/" + string;
    }
  }

  if (url.query !== null) {
    output += "?" + url.query;
  }

  if (!excludeFragment && url.fragment !== null) {
    output += "#" + url.fragment;
  }

  return output;
}

function serializeOrigin(tuple) {
  let result = tuple.scheme + "://";
  result += serializeHost(tuple.host);

  if (tuple.port !== null) {
    result += ":" + tuple.port;
  }

  return result;
}

module.exports.serializeURL = serializeURL;

module.exports.serializeURLOrigin = function (url) {
  // https://url.spec.whatwg.org/#concept-url-origin
  switch (url.scheme) {
    case "blob":
      try {
        return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
      } catch (e) {
        // serializing an opaque origin returns "null"
        return "null";
      }
    case "ftp":
    case "gopher":
    case "http":
    case "https":
    case "ws":
    case "wss":
      return serializeOrigin({
        scheme: url.scheme,
        host: url.host,
        port: url.port
      });
    case "file":
      // spec says "exercise to the reader", chrome says "file://"
      return "file://";
    default:
      // serializing an opaque origin returns "null"
      return "null";
  }
};

module.exports.basicURLParse = function (input, options) {
  if (options === undefined) {
    options = {};
  }

  const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
  if (usm.failure) {
    return "failure";
  }

  return usm.url;
};

module.exports.setTheUsername = function (url, username) {
  url.username = "";
  const decoded = punycode.ucs2.decode(username);
  for (let i = 0; i < decoded.length; ++i) {
    url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
  }
};

module.exports.setThePassword = function (url, password) {
  url.password = "";
  const decoded = punycode.ucs2.decode(password);
  for (let i = 0; i < decoded.length; ++i) {
    url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
  }
};

module.exports.serializeHost = serializeHost;

module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;

module.exports.serializeInteger = function (integer) {
  return String(integer);
};

module.exports.parseURL = function (input, options) {
  if (options === undefined) {
    options = {};
  }

  // We don't handle blobs, so this just delegates:
  return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
};


/***/ }),

/***/ 3185:
/***/ ((module) => {

"use strict";


module.exports.mixin = function mixin(target, source) {
  const keys = Object.getOwnPropertyNames(source);
  for (let i = 0; i < keys.length; ++i) {
    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
  }
};

module.exports.wrapperSymbol = Symbol("wrapper");
module.exports.implSymbol = Symbol("impl");

module.exports.wrapperForImpl = function (impl) {
  return impl[module.exports.wrapperSymbol];
};

module.exports.implForWrapper = function (wrapper) {
  return wrapper[module.exports.implSymbol];
};



/***/ }),

/***/ 2940:
/***/ ((module) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),

/***/ 8867:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const WebSocket = __nccwpck_require__(1518);

WebSocket.createWebSocketStream = __nccwpck_require__(1658);
WebSocket.Server = __nccwpck_require__(8887);
WebSocket.Receiver = __nccwpck_require__(5066);
WebSocket.Sender = __nccwpck_require__(6947);

module.exports = WebSocket;


/***/ }),

/***/ 9436:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { EMPTY_BUFFER } = __nccwpck_require__(5949);

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) return target.slice(0, offset);

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  const length = buffer.length;
  for (let i = 0; i < length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer(buf) {
  if (buf.byteLength === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer(data) {
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = Buffer.from(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

try {
  const bufferUtil = __nccwpck_require__(1269);
  const bu = bufferUtil.BufferUtil || bufferUtil;

  module.exports = {
    concat,
    mask(source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bu.mask(source, mask, output, offset, length);
    },
    toArrayBuffer,
    toBuffer,
    unmask(buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bu.unmask(buffer, mask);
    }
  };
} catch (e) /* istanbul ignore next */ {
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
}


/***/ }),

/***/ 5949:
/***/ ((module) => {

"use strict";


module.exports = {
  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  EMPTY_BUFFER: Buffer.alloc(0),
  NOOP: () => {}
};


/***/ }),

/***/ 4561:
/***/ ((module) => {

"use strict";


/**
 * Class representing an event.
 *
 * @private
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @param {Object} target A reference to the target to which the event was
   *     dispatched
   */
  constructor(type, target) {
    this.target = target;
    this.type = type;
  }
}

/**
 * Class representing a message event.
 *
 * @extends Event
 * @private
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data
   * @param {WebSocket} target A reference to the target to which the event was
   *     dispatched
   */
  constructor(data, target) {
    super('message', target);

    this.data = data;
  }
}

/**
 * Class representing a close event.
 *
 * @extends Event
 * @private
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {Number} code The status code explaining why the connection is being
   *     closed
   * @param {String} reason A human-readable string explaining why the
   *     connection is closing
   * @param {WebSocket} target A reference to the target to which the event was
   *     dispatched
   */
  constructor(code, reason, target) {
    super('close', target);

    this.wasClean = target._closeFrameReceived && target._closeFrameSent;
    this.reason = reason;
    this.code = code;
  }
}

/**
 * Class representing an open event.
 *
 * @extends Event
 * @private
 */
class OpenEvent extends Event {
  /**
   * Create a new `OpenEvent`.
   *
   * @param {WebSocket} target A reference to the target to which the event was
   *     dispatched
   */
  constructor(target) {
    super('open', target);
  }
}

/**
 * Class representing an error event.
 *
 * @extends Event
 * @private
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {Object} error The error that generated this event
   * @param {WebSocket} target A reference to the target to which the event was
   *     dispatched
   */
  constructor(error, target) {
    super('error', target);

    this.message = error.message;
    this.error = error;
  }
}

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {Function} listener The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean`` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, listener, options) {
    if (typeof listener !== 'function') return;

    function onMessage(data) {
      listener.call(this, new MessageEvent(data, this));
    }

    function onClose(code, message) {
      listener.call(this, new CloseEvent(code, message, this));
    }

    function onError(error) {
      listener.call(this, new ErrorEvent(error, this));
    }

    function onOpen() {
      listener.call(this, new OpenEvent(this));
    }

    const method = options && options.once ? 'once' : 'on';

    if (type === 'message') {
      onMessage._listener = listener;
      this[method](type, onMessage);
    } else if (type === 'close') {
      onClose._listener = listener;
      this[method](type, onClose);
    } else if (type === 'error') {
      onError._listener = listener;
      this[method](type, onError);
    } else if (type === 'open') {
      onOpen._listener = listener;
      this[method](type, onOpen);
    } else {
      this[method](type, listener);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {Function} listener The listener to remove
   * @public
   */
  removeEventListener(type, listener) {
    const listeners = this.listeners(type);

    for (let i = 0; i < listeners.length; i++) {
      if (listeners[i] === listener || listeners[i]._listener === listener) {
        this.removeListener(type, listeners[i]);
      }
    }
  }
};

module.exports = EventTarget;


/***/ }),

/***/ 2035:
/***/ ((module) => {

"use strict";


//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);

  if (header === undefined || header === '') return offers;

  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 /* ' ' */ || code === 0x09 /* '\t' */) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),

/***/ 1356:
/***/ ((module) => {

"use strict";


const kDone = Symbol('kDone');
const kRun = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone]);
    }
  }
}

module.exports = Limiter;


/***/ }),

/***/ 6684:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const zlib = __nccwpck_require__(9796);

const bufferUtil = __nccwpck_require__(9436);
const Limiter = __nccwpck_require__(1356);
const { kStatusCode, NOOP } = __nccwpck_require__(5949);

const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];

        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {Buffer} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      //
      // An `'error'` event is emitted, only on Node.js < 10.0.0, if the
      // `zlib.DeflateRaw` instance is closed while data is being processed.
      // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong
      // time due to an abnormal WebSocket closure.
      //
      this._deflate.on('error', NOOP);
      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) data = data.slice(0, data.length - 4);

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),

/***/ 5066:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { Writable } = __nccwpck_require__(2781);

const PerMessageDeflate = __nccwpck_require__(6684);
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  kStatusCode,
  kWebSocket
} = __nccwpck_require__(5949);
const { concat, toArrayBuffer, unmask } = __nccwpck_require__(9436);
const { isValidStatusCode, isValidUTF8 } = __nccwpck_require__(6279);

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;

/**
 * HyBi Receiver implementation.
 *
 * @extends stream.Writable
 */
class Receiver extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {String} [binaryType=nodebuffer] The type for binary data
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Boolean} [isServer=false] Specifies whether to operate in client or
   *     server mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(binaryType, extensions, isServer, maxPayload) {
    super();

    this._binaryType = binaryType || BINARY_TYPES[0];
    this[kWebSocket] = undefined;
    this._extensions = extensions || {};
    this._isServer = !!isServer;
    this._maxPayload = maxPayload | 0;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._state = GET_INFO;
    this._loop = false;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = buf.slice(n);
      return buf.slice(0, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = buf.slice(n);
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    let err;
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          err = this.getInfo();
          break;
        case GET_PAYLOAD_LENGTH_16:
          err = this.getPayloadLength16();
          break;
        case GET_PAYLOAD_LENGTH_64:
          err = this.getPayloadLength64();
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          err = this.getData(cb);
          break;
        default:
          // `INFLATING`
          this._loop = false;
          return;
      }
    } while (this._loop);

    cb(err);
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getInfo() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      this._loop = false;
      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      this._loop = false;
      return error(RangeError, 'RSV1 must be clear', true, 1002);
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (!this._fragmented) {
        this._loop = false;
        return error(RangeError, 'invalid opcode 0', true, 1002);
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        this._loop = false;
        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        this._loop = false;
        return error(RangeError, 'FIN must be set', true, 1002);
      }

      if (compressed) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002);
      }

      if (this._payloadLength > 0x7d) {
        this._loop = false;
        return error(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002
        );
      }
    } else {
      this._loop = false;
      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        this._loop = false;
        return error(RangeError, 'MASK must be set', true, 1002);
      }
    } else if (this._masked) {
      this._loop = false;
      return error(RangeError, 'MASK must be clear', true, 1002);
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else return this.haveLength();
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength16() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    return this.haveLength();
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength64() {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      this._loop = false;
      return error(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009
      );
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    return this.haveLength();
  }

  /**
   * Payload length has been read.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  haveLength() {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        this._loop = false;
        return error(RangeError, 'Max payload size exceeded', false, 1009);
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);
      if (this._masked) unmask(data, this._mask);
    }

    if (this._opcode > 0x07) return this.controlMessage(data);

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its lenght is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    return this.dataMessage();
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          return cb(
            error(RangeError, 'Max payload size exceeded', false, 1009)
          );
        }

        this._fragments.push(buf);
      }

      const er = this.dataMessage();
      if (er) return cb(er);

      this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @return {(Error|undefined)} A possible error
   * @private
   */
  dataMessage() {
    if (this._fin) {
      const messageLength = this._messageLength;
      const fragments = this._fragments;

      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];

      if (this._opcode === 2) {
        let data;

        if (this._binaryType === 'nodebuffer') {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === 'arraybuffer') {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else {
          data = fragments;
        }

        this.emit('message', data);
      } else {
        const buf = concat(fragments, messageLength);

        if (!isValidUTF8(buf)) {
          this._loop = false;
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('message', buf.toString());
      }
    }

    this._state = GET_INFO;
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data) {
    if (this._opcode === 0x08) {
      this._loop = false;

      if (data.length === 0) {
        this.emit('conclude', 1005, '');
        this.end();
      } else if (data.length === 1) {
        return error(RangeError, 'invalid payload length 1', true, 1002);
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode(code)) {
          return error(RangeError, `invalid status code ${code}`, true, 1002);
        }

        const buf = data.slice(2);

        if (!isValidUTF8(buf)) {
          return error(Error, 'invalid UTF-8 sequence', true, 1007);
        }

        this.emit('conclude', code, buf.toString());
        this.end();
      }
    } else if (this._opcode === 0x09) {
      this.emit('ping', data);
    } else {
      this.emit('pong', data);
    }

    this._state = GET_INFO;
  }
}

module.exports = Receiver;

/**
 * Builds an error object.
 *
 * @param {(Error|RangeError)} ErrorCtor The error constructor
 * @param {String} message The error message
 * @param {Boolean} prefix Specifies whether or not to add a default prefix to
 *     `message`
 * @param {Number} statusCode The status code
 * @return {(Error|RangeError)} The error
 * @private
 */
function error(ErrorCtor, message, prefix, statusCode) {
  const err = new ErrorCtor(
    prefix ? `Invalid WebSocket frame: ${message}` : message
  );

  Error.captureStackTrace(err, error);
  err[kStatusCode] = statusCode;
  return err;
}


/***/ }),

/***/ 6947:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { randomFillSync } = __nccwpck_require__(6113);

const PerMessageDeflate = __nccwpck_require__(6684);
const { EMPTY_BUFFER } = __nccwpck_require__(5949);
const { isValidStatusCode } = __nccwpck_require__(6279);
const { mask: applyMask, toBuffer } = __nccwpck_require__(9436);

const mask = Buffer.alloc(4);

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {net.Socket} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   */
  constructor(socket, extensions) {
    this._extensions = extensions || {};
    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {Buffer} data The data to frame
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {Buffer[]} The framed data as a list of `Buffer` instances
   * @public
   */
  static frame(data, options) {
    const merge = options.mask && options.readOnly;
    let offset = options.mask ? 6 : 2;
    let payloadLength = data.length;

    if (data.length >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (data.length > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(data.length, 2);
    } else if (payloadLength === 127) {
      target.writeUInt32BE(0, 2);
      target.writeUInt32BE(data.length, 6);
    }

    if (!options.mask) return [target, data];

    randomFillSync(mask, 0, 4);

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (merge) {
      applyMask(data, mask, target, offset, data.length);
      return [target];
    }

    applyMask(data, mask, data, 0, data.length);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {String} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || data === '') {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);
      buf.write(data, 2);
    }

    if (this._deflating) {
      this.enqueue([this.doClose, buf, mask, cb]);
    } else {
      this.doClose(buf, mask, cb);
    }
  }

  /**
   * Frames and sends a close message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @private
   */
  doClose(data, mask, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x08,
        mask,
        readOnly: false
      }),
      cb
    );
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data, mask, cb) {
    const buf = toBuffer(data);

    if (buf.length > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    if (this._deflating) {
      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);
    } else {
      this.doPing(buf, mask, toBuffer.readOnly, cb);
    }
  }

  /**
   * Frames and sends a ping message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
   * @param {Function} [cb] Callback
   * @private
   */
  doPing(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x09,
        mask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data, mask, cb) {
    const buf = toBuffer(data);

    if (buf.length > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    if (this._deflating) {
      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);
    } else {
      this.doPong(buf, mask, toBuffer.readOnly, cb);
    }
  }

  /**
   * Frames and sends a pong message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
   * @param {Function} [cb] Callback
   * @private
   */
  doPong(data, mask, readOnly, cb) {
    this.sendFrame(
      Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x0a,
        mask,
        readOnly
      }),
      cb
    );
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data, options, cb) {
    const buf = toBuffer(data);
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    if (this._firstFragment) {
      this._firstFragment = false;
      if (rsv1 && perMessageDeflate) {
        rsv1 = buf.length >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    if (perMessageDeflate) {
      const opts = {
        fin: options.fin,
        rsv1,
        opcode,
        mask: options.mask,
        readOnly: toBuffer.readOnly
      };

      if (this._deflating) {
        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
      } else {
        this.dispatch(buf, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(
        Sender.frame(buf, {
          fin: options.fin,
          rsv1: false,
          opcode,
          mask: options.mask,
          readOnly: toBuffer.readOnly
        }),
        cb
      );
    }
  }

  /**
   * Dispatches a data message.
   *
   * @param {Buffer} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._bufferedBytes += data.length;
    this._deflating = true;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        if (typeof cb === 'function') cb(err);

        for (let i = 0; i < this._queue.length; i++) {
          const callback = this._queue[i][4];

          if (typeof callback === 'function') callback(err);
        }

        return;
      }

      this._bufferedBytes -= data.length;
      this._deflating = false;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[1].length;
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[1].length;
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;


/***/ }),

/***/ 1658:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { Duplex } = __nccwpck_require__(2781);

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {stream.Duplex} The stream.
 * @private
 */
function emitClose(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @param {Error} err The error
 * @private
 */
function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} [options] The options for the `Duplex` constructor
 * @return {stream.Duplex} The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) {
  let resumeOnReceiverDrain = true;

  function receiverOnDrain() {
    if (resumeOnReceiverDrain) ws._socket.resume();
  }

  if (ws.readyState === ws.CONNECTING) {
    ws.once('open', function open() {
      ws._receiver.removeAllListeners('drain');
      ws._receiver.on('drain', receiverOnDrain);
    });
  } else {
    ws._receiver.removeAllListeners('drain');
    ws._receiver.on('drain', receiverOnDrain);
  }

  const duplex = new Duplex({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg) {
    if (!duplex.push(msg)) {
      resumeOnReceiverDrain = false;
      ws._socket.pause();
    }
  });

  ws.once('error', function error(err) {
    if (duplex.destroyed) return;

    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function (err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    let called = false;

    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });

    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    });
    ws.terminate();
  };

  duplex._final = function (callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function () {
    if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {
      resumeOnReceiverDrain = true;
      if (!ws._receiver._writableState.needDrain) ws._socket.resume();
    }
  };

  duplex._write = function (chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;


/***/ }),

/***/ 6279:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
function isValidStatusCode(code) {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
}

/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function _isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0) {
      // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {
      // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0 // Overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {
      // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
        buf[i] > 0xf4 // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

try {
  let isValidUTF8 = __nccwpck_require__(4592);

  /* istanbul ignore if */
  if (typeof isValidUTF8 === 'object') {
    isValidUTF8 = isValidUTF8.Validation.isValidUTF8; // utf-8-validate@<3.0.0
  }

  module.exports = {
    isValidStatusCode,
    isValidUTF8(buf) {
      return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
    }
  };
} catch (e) /* istanbul ignore next */ {
  module.exports = {
    isValidStatusCode,
    isValidUTF8: _isValidUTF8
  };
}


/***/ }),

/***/ 8887:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const EventEmitter = __nccwpck_require__(2361);
const { createHash } = __nccwpck_require__(6113);
const { createServer, STATUS_CODES } = __nccwpck_require__(3685);

const PerMessageDeflate = __nccwpck_require__(6684);
const WebSocket = __nccwpck_require__(1518);
const { format, parse } = __nccwpck_require__(2035);
const { GUID, kWebSocket } = __nccwpck_require__(5949);

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {http.Server} [options.server] A pre-created HTTP/S server to use
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      maxPayload: 100 * 1024 * 1024,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      ...options
    };

    if (options.port == null && !options.server && !options.noServer) {
      throw new TypeError(
        'One of the "port", "server", or "noServer" options must be specified'
      );
    }

    if (options.port != null) {
      this._server = createServer((req, res) => {
        const body = STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      const emitConnection = this.emit.bind(this, 'connection');

      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) this.clients = new Set();
    this.options = options;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Close the server.
   *
   * @param {Function} [cb] Callback
   * @public
   */
  close(cb) {
    if (cb) this.once('close', cb);

    //
    // Terminate all associated clients.
    //
    if (this.clients) {
      for (const client of this.clients) client.terminate();
    }

    const server = this._server;

    if (server) {
      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // Close the http server if it was internally created.
      //
      if (this.options.port != null) {
        server.close(() => this.emit('close'));
        return;
      }
    }

    process.nextTick(emitClose, this);
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key =
      req.headers['sec-websocket-key'] !== undefined
        ? req.headers['sec-websocket-key'].trim()
        : false;
    const version = +req.headers['sec-websocket-version'];
    const extensions = {};

    if (
      req.method !== 'GET' ||
      req.headers.upgrade.toLowerCase() !== 'websocket' ||
      !key ||
      !keyRegex.test(key) ||
      (version !== 8 && version !== 13) ||
      !this.shouldHandle(req)
    ) {
      return abortHandshake(socket, 400);
    }

    if (this.options.perMessageDeflate) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = parse(req.headers['sec-websocket-extensions']);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        return abortHandshake(socket, 400);
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.socket.authorized || req.socket.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(key, extensions, req, socket, head, cb);
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(key, extensions, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Object} extensions The accepted extensions
   * @param {http.IncomingMessage} req The request object
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(key, extensions, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new WebSocket(null);
    let protocol = req.headers['sec-websocket-protocol'];

    if (protocol) {
      protocol = protocol.split(',').map(trim);

      //
      // Optionally call external protocol selection handler.
      //
      if (this.options.handleProtocols) {
        protocol = this.options.handleProtocols(protocol, req);
      } else {
        protocol = protocol[0];
      }

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, this.options.maxPayload);

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => this.clients.delete(ws));
    }

    cb(ws, req);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server.emit('close');
}

/**
 * Handle premature socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {net.Socket} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  if (socket.writable) {
    message = message || STATUS_CODES[code];
    headers = {
      Connection: 'close',
      'Content-Type': 'text/html',
      'Content-Length': Buffer.byteLength(message),
      ...headers
    };

    socket.write(
      `HTTP/1.1 ${code} ${STATUS_CODES[code]}\r\n` +
        Object.keys(headers)
          .map((h) => `${h}: ${headers[h]}`)
          .join('\r\n') +
        '\r\n\r\n' +
        message
    );
  }

  socket.removeListener('error', socketOnError);
  socket.destroy();
}

/**
 * Remove whitespace characters from both ends of a string.
 *
 * @param {String} str The string
 * @return {String} A new string representing `str` stripped of whitespace
 *     characters from both its beginning and end
 * @private
 */
function trim(str) {
  return str.trim();
}


/***/ }),

/***/ 1518:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const EventEmitter = __nccwpck_require__(2361);
const https = __nccwpck_require__(5687);
const http = __nccwpck_require__(3685);
const net = __nccwpck_require__(1808);
const tls = __nccwpck_require__(4404);
const { randomBytes, createHash } = __nccwpck_require__(6113);
const { URL } = __nccwpck_require__(7310);

const PerMessageDeflate = __nccwpck_require__(6684);
const Receiver = __nccwpck_require__(5066);
const Sender = __nccwpck_require__(6947);
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kStatusCode,
  kWebSocket,
  NOOP
} = __nccwpck_require__(5949);
const { addEventListener, removeEventListener } = __nccwpck_require__(4561);
const { format, parse } = __nccwpck_require__(2035);
const { toBuffer } = __nccwpck_require__(9436);

const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const protocolVersions = [8, 13];
const closeTimeout = 30 * 1000;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|url.URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options) {
    super();

    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = '';
    this._closeTimer = null;
    this._extensions = {};
    this._protocol = '';
    this._readyState = WebSocket.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (Array.isArray(protocols)) {
        protocols = protocols.join(', ');
      } else if (typeof protocols === 'object' && protocols !== null) {
        options = protocols;
        protocols = undefined;
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._isServer = true;
    }
  }

  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    return this._socket._writableState.length + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }

  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }

  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {net.Socket} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Number} [maxPayload=0] The maximum allowed message size
   * @private
   */
  setSocket(socket, head, maxPayload) {
    const receiver = new Receiver(
      this.binaryType,
      this._extensions,
      this._isServer,
      maxPayload
    );

    this._sender = new Sender(socket, this._extensions);
    this._receiver = receiver;
    this._socket = socket;

    receiver[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    socket.setTimeout(0);
    socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this._readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this._readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {String} [data] A string explaining why the connection is closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();
      return;
    }

    this._readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;
      if (this._closeFrameReceived) this._socket.end();
    });

    //
    // Specify a timeout for the closing handshake to complete.
    //
    this._closeTimer = setTimeout(
      this._socket.destroy.bind(this._socket),
      closeTimeout
    );
  }

  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    }

    if (this._socket) {
      this._readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

readyStates.forEach((readyState, i) => {
  const descriptor = { enumerable: true, value: i };

  Object.defineProperty(WebSocket.prototype, readyState, descriptor);
  Object.defineProperty(WebSocket, readyState, descriptor);
});

[
  'binaryType',
  'bufferedAmount',
  'extensions',
  'protocol',
  'readyState',
  'url'
].forEach((property) => {
  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    configurable: true,
    enumerable: true,
    /**
     * Return the listener of the event.
     *
     * @return {(Function|undefined)} The event listener or `undefined`
     * @public
     */
    get() {
      const listeners = this.listeners(method);
      for (let i = 0; i < listeners.length; i++) {
        if (listeners[i]._listener) return listeners[i]._listener;
      }

      return undefined;
    },
    /**
     * Add a listener for the event.
     *
     * @param {Function} listener The listener to add
     * @public
     */
    set(listener) {
      const listeners = this.listeners(method);
      for (let i = 0; i < listeners.length; i++) {
        //
        // Remove only the listeners added via `addEventListener`.
        //
        if (listeners[i]._listener) this.removeListener(method, listeners[i]);
      }
      this.addEventListener(method, listener);
    }
  });
});

WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|url.URL)} address The URL to which to connect
 * @param {String} [protocols] The subprotocols
 * @param {Object} [options] Connection options
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    createConnection: undefined,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: undefined,
    host: undefined,
    path: undefined,
    port: undefined
  };

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
    websocket._url = address.href;
  } else {
    parsedUrl = new URL(address);
    websocket._url = address;
  }

  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';

  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
    throw new Error(`Invalid URL: ${websocket.url}`);
  }

  const isSecure =
    parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';
  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const get = isSecure ? https.get : http.get;
  let perMessageDeflate;

  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket',
    ...opts.headers
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols) {
    opts.headers['Sec-WebSocket-Protocol'] = protocols;
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isUnixSocket) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req = (websocket._req = get(opts));

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (req === null || req.aborted) return;

    req = websocket._req = null;
    websocket._readyState = WebSocket.CLOSING;
    websocket.emit('error', err);
    websocket.emitClose();
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      const addr = new URL(location, address);

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the `upgrade`
    // event.
    //
    if (websocket.readyState !== WebSocket.CONNECTING) return;

    req = websocket._req = null;

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    const protList = (protocols || '').split(/, */);
    let protError;

    if (!protocols && serverProt) {
      protError = 'Server sent a subprotocol but none was requested';
    } else if (protocols && !serverProt) {
      protError = 'Server sent no subprotocol';
    } else if (serverProt && !protList.includes(serverProt)) {
      protError = 'Server sent an invalid subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket._protocol = serverProt;

    if (perMessageDeflate) {
      try {
        const extensions = parse(res.headers['sec-websocket-extensions']);

        if (extensions[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          websocket._extensions[PerMessageDeflate.extensionName] =
            perMessageDeflate;
        }
      } catch (err) {
        abortHandshake(
          websocket,
          socket,
          'Invalid Sec-WebSocket-Extensions header'
        );
        return;
      }
    }

    websocket.setSocket(socket, head, opts.maxPayload);
  });
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = net.isIP(options.host) ? '' : options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the
 *     socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket._readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream.abort();

    if (stream.socket && !stream.socket.destroyed) {
      //
      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
      // called after the request completed. See
      // https://github.com/websockets/ws/issues/1869.
      //
      stream.socket.destroy();
    }

    stream.once('abort', websocket.emitClose.bind(websocket));
    websocket.emit('error', err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    cb(err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {String} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);
  websocket._socket.resume();

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  this[kWebSocket]._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);

  websocket._readyState = WebSocket.CLOSING;
  websocket._closeCode = err[kStatusCode];
  websocket.emit('error', err);
  websocket._socket.destroy();
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message
 * @private
 */
function receiverOnMessage(data) {
  this[kWebSocket].emit('message', data);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  websocket.pong(data, !websocket._isServer, NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * The listener of the `net.Socket` `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('end', socketOnEnd);

  websocket._readyState = WebSocket.CLOSING;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk and emitted synchronously in a single
  // `'data'` event.
  //
  websocket._socket.read();
  websocket._receiver.end();

  this.removeListener('data', socketOnData);
  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the `net.Socket` `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the `net.Socket` `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket._readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the `net.Socket` `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket._readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),

/***/ 1269:
/***/ ((module) => {

module.exports = eval("require")("bufferutil");


/***/ }),

/***/ 2877:
/***/ ((module) => {

module.exports = eval("require")("encoding");


/***/ }),

/***/ 2941:
/***/ ((module) => {

module.exports = eval("require")("original-fs");


/***/ }),

/***/ 4592:
/***/ ((module) => {

module.exports = eval("require")("utf-8-validate");


/***/ }),

/***/ 9491:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 4300:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ 2081:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ 6113:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 2361:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 7147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 3685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 5687:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 1808:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 2037:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 1017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 4074:
/***/ ((module) => {

"use strict";
module.exports = require("perf_hooks");

/***/ }),

/***/ 5477:
/***/ ((module) => {

"use strict";
module.exports = require("punycode");

/***/ }),

/***/ 2781:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 4404:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 7310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 3837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 9796:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ 8597:
/***/ ((module) => {

"use strict";
module.exports = {"i8":"6.5.4"};

/***/ }),

/***/ 2020:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[[[0,44],"disallowed_STD3_valid"],[[45,46],"valid"],[[47,47],"disallowed_STD3_valid"],[[48,57],"valid"],[[58,64],"disallowed_STD3_valid"],[[65,65],"mapped",[97]],[[66,66],"mapped",[98]],[[67,67],"mapped",[99]],[[68,68],"mapped",[100]],[[69,69],"mapped",[101]],[[70,70],"mapped",[102]],[[71,71],"mapped",[103]],[[72,72],"mapped",[104]],[[73,73],"mapped",[105]],[[74,74],"mapped",[106]],[[75,75],"mapped",[107]],[[76,76],"mapped",[108]],[[77,77],"mapped",[109]],[[78,78],"mapped",[110]],[[79,79],"mapped",[111]],[[80,80],"mapped",[112]],[[81,81],"mapped",[113]],[[82,82],"mapped",[114]],[[83,83],"mapped",[115]],[[84,84],"mapped",[116]],[[85,85],"mapped",[117]],[[86,86],"mapped",[118]],[[87,87],"mapped",[119]],[[88,88],"mapped",[120]],[[89,89],"mapped",[121]],[[90,90],"mapped",[122]],[[91,96],"disallowed_STD3_valid"],[[97,122],"valid"],[[123,127],"disallowed_STD3_valid"],[[128,159],"disallowed"],[[160,160],"disallowed_STD3_mapped",[32]],[[161,167],"valid",[],"NV8"],[[168,168],"disallowed_STD3_mapped",[32,776]],[[169,169],"valid",[],"NV8"],[[170,170],"mapped",[97]],[[171,172],"valid",[],"NV8"],[[173,173],"ignored"],[[174,174],"valid",[],"NV8"],[[175,175],"disallowed_STD3_mapped",[32,772]],[[176,177],"valid",[],"NV8"],[[178,178],"mapped",[50]],[[179,179],"mapped",[51]],[[180,180],"disallowed_STD3_mapped",[32,769]],[[181,181],"mapped",[956]],[[182,182],"valid",[],"NV8"],[[183,183],"valid"],[[184,184],"disallowed_STD3_mapped",[32,807]],[[185,185],"mapped",[49]],[[186,186],"mapped",[111]],[[187,187],"valid",[],"NV8"],[[188,188],"mapped",[49,8260,52]],[[189,189],"mapped",[49,8260,50]],[[190,190],"mapped",[51,8260,52]],[[191,191],"valid",[],"NV8"],[[192,192],"mapped",[224]],[[193,193],"mapped",[225]],[[194,194],"mapped",[226]],[[195,195],"mapped",[227]],[[196,196],"mapped",[228]],[[197,197],"mapped",[229]],[[198,198],"mapped",[230]],[[199,199],"mapped",[231]],[[200,200],"mapped",[232]],[[201,201],"mapped",[233]],[[202,202],"mapped",[234]],[[203,203],"mapped",[235]],[[204,204],"mapped",[236]],[[205,205],"mapped",[237]],[[206,206],"mapped",[238]],[[207,207],"mapped",[239]],[[208,208],"mapped",[240]],[[209,209],"mapped",[241]],[[210,210],"mapped",[242]],[[211,211],"mapped",[243]],[[212,212],"mapped",[244]],[[213,213],"mapped",[245]],[[214,214],"mapped",[246]],[[215,215],"valid",[],"NV8"],[[216,216],"mapped",[248]],[[217,217],"mapped",[249]],[[218,218],"mapped",[250]],[[219,219],"mapped",[251]],[[220,220],"mapped",[252]],[[221,221],"mapped",[253]],[[222,222],"mapped",[254]],[[223,223],"deviation",[115,115]],[[224,246],"valid"],[[247,247],"valid",[],"NV8"],[[248,255],"valid"],[[256,256],"mapped",[257]],[[257,257],"valid"],[[258,258],"mapped",[259]],[[259,259],"valid"],[[260,260],"mapped",[261]],[[261,261],"valid"],[[262,262],"mapped",[263]],[[263,263],"valid"],[[264,264],"mapped",[265]],[[265,265],"valid"],[[266,266],"mapped",[267]],[[267,267],"valid"],[[268,268],"mapped",[269]],[[269,269],"valid"],[[270,270],"mapped",[271]],[[271,271],"valid"],[[272,272],"mapped",[273]],[[273,273],"valid"],[[274,274],"mapped",[275]],[[275,275],"valid"],[[276,276],"mapped",[277]],[[277,277],"valid"],[[278,278],"mapped",[279]],[[279,279],"valid"],[[280,280],"mapped",[281]],[[281,281],"valid"],[[282,282],"mapped",[283]],[[283,283],"valid"],[[284,284],"mapped",[285]],[[285,285],"valid"],[[286,286],"mapped",[287]],[[287,287],"valid"],[[288,288],"mapped",[289]],[[289,289],"valid"],[[290,290],"mapped",[291]],[[291,291],"valid"],[[292,292],"mapped",[293]],[[293,293],"valid"],[[294,294],"mapped",[295]],[[295,295],"valid"],[[296,296],"mapped",[297]],[[297,297],"valid"],[[298,298],"mapped",[299]],[[299,299],"valid"],[[300,300],"mapped",[301]],[[301,301],"valid"],[[302,302],"mapped",[303]],[[303,303],"valid"],[[304,304],"mapped",[105,775]],[[305,305],"valid"],[[306,307],"mapped",[105,106]],[[308,308],"mapped",[309]],[[309,309],"valid"],[[310,310],"mapped",[311]],[[311,312],"valid"],[[313,313],"mapped",[314]],[[314,314],"valid"],[[315,315],"mapped",[316]],[[316,316],"valid"],[[317,317],"mapped",[318]],[[318,318],"valid"],[[319,320],"mapped",[108,183]],[[321,321],"mapped",[322]],[[322,322],"valid"],[[323,323],"mapped",[324]],[[324,324],"valid"],[[325,325],"mapped",[326]],[[326,326],"valid"],[[327,327],"mapped",[328]],[[328,328],"valid"],[[329,329],"mapped",[700,110]],[[330,330],"mapped",[331]],[[331,331],"valid"],[[332,332],"mapped",[333]],[[333,333],"valid"],[[334,334],"mapped",[335]],[[335,335],"valid"],[[336,336],"mapped",[337]],[[337,337],"valid"],[[338,338],"mapped",[339]],[[339,339],"valid"],[[340,340],"mapped",[341]],[[341,341],"valid"],[[342,342],"mapped",[343]],[[343,343],"valid"],[[344,344],"mapped",[345]],[[345,345],"valid"],[[346,346],"mapped",[347]],[[347,347],"valid"],[[348,348],"mapped",[349]],[[349,349],"valid"],[[350,350],"mapped",[351]],[[351,351],"valid"],[[352,352],"mapped",[353]],[[353,353],"valid"],[[354,354],"mapped",[355]],[[355,355],"valid"],[[356,356],"mapped",[357]],[[357,357],"valid"],[[358,358],"mapped",[359]],[[359,359],"valid"],[[360,360],"mapped",[361]],[[361,361],"valid"],[[362,362],"mapped",[363]],[[363,363],"valid"],[[364,364],"mapped",[365]],[[365,365],"valid"],[[366,366],"mapped",[367]],[[367,367],"valid"],[[368,368],"mapped",[369]],[[369,369],"valid"],[[370,370],"mapped",[371]],[[371,371],"valid"],[[372,372],"mapped",[373]],[[373,373],"valid"],[[374,374],"mapped",[375]],[[375,375],"valid"],[[376,376],"mapped",[255]],[[377,377],"mapped",[378]],[[378,378],"valid"],[[379,379],"mapped",[380]],[[380,380],"valid"],[[381,381],"mapped",[382]],[[382,382],"valid"],[[383,383],"mapped",[115]],[[384,384],"valid"],[[385,385],"mapped",[595]],[[386,386],"mapped",[387]],[[387,387],"valid"],[[388,388],"mapped",[389]],[[389,389],"valid"],[[390,390],"mapped",[596]],[[391,391],"mapped",[392]],[[392,392],"valid"],[[393,393],"mapped",[598]],[[394,394],"mapped",[599]],[[395,395],"mapped",[396]],[[396,397],"valid"],[[398,398],"mapped",[477]],[[399,399],"mapped",[601]],[[400,400],"mapped",[603]],[[401,401],"mapped",[402]],[[402,402],"valid"],[[403,403],"mapped",[608]],[[404,404],"mapped",[611]],[[405,405],"valid"],[[406,406],"mapped",[617]],[[407,407],"mapped",[616]],[[408,408],"mapped",[409]],[[409,411],"valid"],[[412,412],"mapped",[623]],[[413,413],"mapped",[626]],[[414,414],"valid"],[[415,415],"mapped",[629]],[[416,416],"mapped",[417]],[[417,417],"valid"],[[418,418],"mapped",[419]],[[419,419],"valid"],[[420,420],"mapped",[421]],[[421,421],"valid"],[[422,422],"mapped",[640]],[[423,423],"mapped",[424]],[[424,424],"valid"],[[425,425],"mapped",[643]],[[426,427],"valid"],[[428,428],"mapped",[429]],[[429,429],"valid"],[[430,430],"mapped",[648]],[[431,431],"mapped",[432]],[[432,432],"valid"],[[433,433],"mapped",[650]],[[434,434],"mapped",[651]],[[435,435],"mapped",[436]],[[436,436],"valid"],[[437,437],"mapped",[438]],[[438,438],"valid"],[[439,439],"mapped",[658]],[[440,440],"mapped",[441]],[[441,443],"valid"],[[444,444],"mapped",[445]],[[445,451],"valid"],[[452,454],"mapped",[100,382]],[[455,457],"mapped",[108,106]],[[458,460],"mapped",[110,106]],[[461,461],"mapped",[462]],[[462,462],"valid"],[[463,463],"mapped",[464]],[[464,464],"valid"],[[465,465],"mapped",[466]],[[466,466],"valid"],[[467,467],"mapped",[468]],[[468,468],"valid"],[[469,469],"mapped",[470]],[[470,470],"valid"],[[471,471],"mapped",[472]],[[472,472],"valid"],[[473,473],"mapped",[474]],[[474,474],"valid"],[[475,475],"mapped",[476]],[[476,477],"valid"],[[478,478],"mapped",[479]],[[479,479],"valid"],[[480,480],"mapped",[481]],[[481,481],"valid"],[[482,482],"mapped",[483]],[[483,483],"valid"],[[484,484],"mapped",[485]],[[485,485],"valid"],[[486,486],"mapped",[487]],[[487,487],"valid"],[[488,488],"mapped",[489]],[[489,489],"valid"],[[490,490],"mapped",[491]],[[491,491],"valid"],[[492,492],"mapped",[493]],[[493,493],"valid"],[[494,494],"mapped",[495]],[[495,496],"valid"],[[497,499],"mapped",[100,122]],[[500,500],"mapped",[501]],[[501,501],"valid"],[[502,502],"mapped",[405]],[[503,503],"mapped",[447]],[[504,504],"mapped",[505]],[[505,505],"valid"],[[506,506],"mapped",[507]],[[507,507],"valid"],[[508,508],"mapped",[509]],[[509,509],"valid"],[[510,510],"mapped",[511]],[[511,511],"valid"],[[512,512],"mapped",[513]],[[513,513],"valid"],[[514,514],"mapped",[515]],[[515,515],"valid"],[[516,516],"mapped",[517]],[[517,517],"valid"],[[518,518],"mapped",[519]],[[519,519],"valid"],[[520,520],"mapped",[521]],[[521,521],"valid"],[[522,522],"mapped",[523]],[[523,523],"valid"],[[524,524],"mapped",[525]],[[525,525],"valid"],[[526,526],"mapped",[527]],[[527,527],"valid"],[[528,528],"mapped",[529]],[[529,529],"valid"],[[530,530],"mapped",[531]],[[531,531],"valid"],[[532,532],"mapped",[533]],[[533,533],"valid"],[[534,534],"mapped",[535]],[[535,535],"valid"],[[536,536],"mapped",[537]],[[537,537],"valid"],[[538,538],"mapped",[539]],[[539,539],"valid"],[[540,540],"mapped",[541]],[[541,541],"valid"],[[542,542],"mapped",[543]],[[543,543],"valid"],[[544,544],"mapped",[414]],[[545,545],"valid"],[[546,546],"mapped",[547]],[[547,547],"valid"],[[548,548],"mapped",[549]],[[549,549],"valid"],[[550,550],"mapped",[551]],[[551,551],"valid"],[[552,552],"mapped",[553]],[[553,553],"valid"],[[554,554],"mapped",[555]],[[555,555],"valid"],[[556,556],"mapped",[557]],[[557,557],"valid"],[[558,558],"mapped",[559]],[[559,559],"valid"],[[560,560],"mapped",[561]],[[561,561],"valid"],[[562,562],"mapped",[563]],[[563,563],"valid"],[[564,566],"valid"],[[567,569],"valid"],[[570,570],"mapped",[11365]],[[571,571],"mapped",[572]],[[572,572],"valid"],[[573,573],"mapped",[410]],[[574,574],"mapped",[11366]],[[575,576],"valid"],[[577,577],"mapped",[578]],[[578,578],"valid"],[[579,579],"mapped",[384]],[[580,580],"mapped",[649]],[[581,581],"mapped",[652]],[[582,582],"mapped",[583]],[[583,583],"valid"],[[584,584],"mapped",[585]],[[585,585],"valid"],[[586,586],"mapped",[587]],[[587,587],"valid"],[[588,588],"mapped",[589]],[[589,589],"valid"],[[590,590],"mapped",[591]],[[591,591],"valid"],[[592,680],"valid"],[[681,685],"valid"],[[686,687],"valid"],[[688,688],"mapped",[104]],[[689,689],"mapped",[614]],[[690,690],"mapped",[106]],[[691,691],"mapped",[114]],[[692,692],"mapped",[633]],[[693,693],"mapped",[635]],[[694,694],"mapped",[641]],[[695,695],"mapped",[119]],[[696,696],"mapped",[121]],[[697,705],"valid"],[[706,709],"valid",[],"NV8"],[[710,721],"valid"],[[722,727],"valid",[],"NV8"],[[728,728],"disallowed_STD3_mapped",[32,774]],[[729,729],"disallowed_STD3_mapped",[32,775]],[[730,730],"disallowed_STD3_mapped",[32,778]],[[731,731],"disallowed_STD3_mapped",[32,808]],[[732,732],"disallowed_STD3_mapped",[32,771]],[[733,733],"disallowed_STD3_mapped",[32,779]],[[734,734],"valid",[],"NV8"],[[735,735],"valid",[],"NV8"],[[736,736],"mapped",[611]],[[737,737],"mapped",[108]],[[738,738],"mapped",[115]],[[739,739],"mapped",[120]],[[740,740],"mapped",[661]],[[741,745],"valid",[],"NV8"],[[746,747],"valid",[],"NV8"],[[748,748],"valid"],[[749,749],"valid",[],"NV8"],[[750,750],"valid"],[[751,767],"valid",[],"NV8"],[[768,831],"valid"],[[832,832],"mapped",[768]],[[833,833],"mapped",[769]],[[834,834],"valid"],[[835,835],"mapped",[787]],[[836,836],"mapped",[776,769]],[[837,837],"mapped",[953]],[[838,846],"valid"],[[847,847],"ignored"],[[848,855],"valid"],[[856,860],"valid"],[[861,863],"valid"],[[864,865],"valid"],[[866,866],"valid"],[[867,879],"valid"],[[880,880],"mapped",[881]],[[881,881],"valid"],[[882,882],"mapped",[883]],[[883,883],"valid"],[[884,884],"mapped",[697]],[[885,885],"valid"],[[886,886],"mapped",[887]],[[887,887],"valid"],[[888,889],"disallowed"],[[890,890],"disallowed_STD3_mapped",[32,953]],[[891,893],"valid"],[[894,894],"disallowed_STD3_mapped",[59]],[[895,895],"mapped",[1011]],[[896,899],"disallowed"],[[900,900],"disallowed_STD3_mapped",[32,769]],[[901,901],"disallowed_STD3_mapped",[32,776,769]],[[902,902],"mapped",[940]],[[903,903],"mapped",[183]],[[904,904],"mapped",[941]],[[905,905],"mapped",[942]],[[906,906],"mapped",[943]],[[907,907],"disallowed"],[[908,908],"mapped",[972]],[[909,909],"disallowed"],[[910,910],"mapped",[973]],[[911,911],"mapped",[974]],[[912,912],"valid"],[[913,913],"mapped",[945]],[[914,914],"mapped",[946]],[[915,915],"mapped",[947]],[[916,916],"mapped",[948]],[[917,917],"mapped",[949]],[[918,918],"mapped",[950]],[[919,919],"mapped",[951]],[[920,920],"mapped",[952]],[[921,921],"mapped",[953]],[[922,922],"mapped",[954]],[[923,923],"mapped",[955]],[[924,924],"mapped",[956]],[[925,925],"mapped",[957]],[[926,926],"mapped",[958]],[[927,927],"mapped",[959]],[[928,928],"mapped",[960]],[[929,929],"mapped",[961]],[[930,930],"disallowed"],[[931,931],"mapped",[963]],[[932,932],"mapped",[964]],[[933,933],"mapped",[965]],[[934,934],"mapped",[966]],[[935,935],"mapped",[967]],[[936,936],"mapped",[968]],[[937,937],"mapped",[969]],[[938,938],"mapped",[970]],[[939,939],"mapped",[971]],[[940,961],"valid"],[[962,962],"deviation",[963]],[[963,974],"valid"],[[975,975],"mapped",[983]],[[976,976],"mapped",[946]],[[977,977],"mapped",[952]],[[978,978],"mapped",[965]],[[979,979],"mapped",[973]],[[980,980],"mapped",[971]],[[981,981],"mapped",[966]],[[982,982],"mapped",[960]],[[983,983],"valid"],[[984,984],"mapped",[985]],[[985,985],"valid"],[[986,986],"mapped",[987]],[[987,987],"valid"],[[988,988],"mapped",[989]],[[989,989],"valid"],[[990,990],"mapped",[991]],[[991,991],"valid"],[[992,992],"mapped",[993]],[[993,993],"valid"],[[994,994],"mapped",[995]],[[995,995],"valid"],[[996,996],"mapped",[997]],[[997,997],"valid"],[[998,998],"mapped",[999]],[[999,999],"valid"],[[1000,1000],"mapped",[1001]],[[1001,1001],"valid"],[[1002,1002],"mapped",[1003]],[[1003,1003],"valid"],[[1004,1004],"mapped",[1005]],[[1005,1005],"valid"],[[1006,1006],"mapped",[1007]],[[1007,1007],"valid"],[[1008,1008],"mapped",[954]],[[1009,1009],"mapped",[961]],[[1010,1010],"mapped",[963]],[[1011,1011],"valid"],[[1012,1012],"mapped",[952]],[[1013,1013],"mapped",[949]],[[1014,1014],"valid",[],"NV8"],[[1015,1015],"mapped",[1016]],[[1016,1016],"valid"],[[1017,1017],"mapped",[963]],[[1018,1018],"mapped",[1019]],[[1019,1019],"valid"],[[1020,1020],"valid"],[[1021,1021],"mapped",[891]],[[1022,1022],"mapped",[892]],[[1023,1023],"mapped",[893]],[[1024,1024],"mapped",[1104]],[[1025,1025],"mapped",[1105]],[[1026,1026],"mapped",[1106]],[[1027,1027],"mapped",[1107]],[[1028,1028],"mapped",[1108]],[[1029,1029],"mapped",[1109]],[[1030,1030],"mapped",[1110]],[[1031,1031],"mapped",[1111]],[[1032,1032],"mapped",[1112]],[[1033,1033],"mapped",[1113]],[[1034,1034],"mapped",[1114]],[[1035,1035],"mapped",[1115]],[[1036,1036],"mapped",[1116]],[[1037,1037],"mapped",[1117]],[[1038,1038],"mapped",[1118]],[[1039,1039],"mapped",[1119]],[[1040,1040],"mapped",[1072]],[[1041,1041],"mapped",[1073]],[[1042,1042],"mapped",[1074]],[[1043,1043],"mapped",[1075]],[[1044,1044],"mapped",[1076]],[[1045,1045],"mapped",[1077]],[[1046,1046],"mapped",[1078]],[[1047,1047],"mapped",[1079]],[[1048,1048],"mapped",[1080]],[[1049,1049],"mapped",[1081]],[[1050,1050],"mapped",[1082]],[[1051,1051],"mapped",[1083]],[[1052,1052],"mapped",[1084]],[[1053,1053],"mapped",[1085]],[[1054,1054],"mapped",[1086]],[[1055,1055],"mapped",[1087]],[[1056,1056],"mapped",[1088]],[[1057,1057],"mapped",[1089]],[[1058,1058],"mapped",[1090]],[[1059,1059],"mapped",[1091]],[[1060,1060],"mapped",[1092]],[[1061,1061],"mapped",[1093]],[[1062,1062],"mapped",[1094]],[[1063,1063],"mapped",[1095]],[[1064,1064],"mapped",[1096]],[[1065,1065],"mapped",[1097]],[[1066,1066],"mapped",[1098]],[[1067,1067],"mapped",[1099]],[[1068,1068],"mapped",[1100]],[[1069,1069],"mapped",[1101]],[[1070,1070],"mapped",[1102]],[[1071,1071],"mapped",[1103]],[[1072,1103],"valid"],[[1104,1104],"valid"],[[1105,1116],"valid"],[[1117,1117],"valid"],[[1118,1119],"valid"],[[1120,1120],"mapped",[1121]],[[1121,1121],"valid"],[[1122,1122],"mapped",[1123]],[[1123,1123],"valid"],[[1124,1124],"mapped",[1125]],[[1125,1125],"valid"],[[1126,1126],"mapped",[1127]],[[1127,1127],"valid"],[[1128,1128],"mapped",[1129]],[[1129,1129],"valid"],[[1130,1130],"mapped",[1131]],[[1131,1131],"valid"],[[1132,1132],"mapped",[1133]],[[1133,1133],"valid"],[[1134,1134],"mapped",[1135]],[[1135,1135],"valid"],[[1136,1136],"mapped",[1137]],[[1137,1137],"valid"],[[1138,1138],"mapped",[1139]],[[1139,1139],"valid"],[[1140,1140],"mapped",[1141]],[[1141,1141],"valid"],[[1142,1142],"mapped",[1143]],[[1143,1143],"valid"],[[1144,1144],"mapped",[1145]],[[1145,1145],"valid"],[[1146,1146],"mapped",[1147]],[[1147,1147],"valid"],[[1148,1148],"mapped",[1149]],[[1149,1149],"valid"],[[1150,1150],"mapped",[1151]],[[1151,1151],"valid"],[[1152,1152],"mapped",[1153]],[[1153,1153],"valid"],[[1154,1154],"valid",[],"NV8"],[[1155,1158],"valid"],[[1159,1159],"valid"],[[1160,1161],"valid",[],"NV8"],[[1162,1162],"mapped",[1163]],[[1163,1163],"valid"],[[1164,1164],"mapped",[1165]],[[1165,1165],"valid"],[[1166,1166],"mapped",[1167]],[[1167,1167],"valid"],[[1168,1168],"mapped",[1169]],[[1169,1169],"valid"],[[1170,1170],"mapped",[1171]],[[1171,1171],"valid"],[[1172,1172],"mapped",[1173]],[[1173,1173],"valid"],[[1174,1174],"mapped",[1175]],[[1175,1175],"valid"],[[1176,1176],"mapped",[1177]],[[1177,1177],"valid"],[[1178,1178],"mapped",[1179]],[[1179,1179],"valid"],[[1180,1180],"mapped",[1181]],[[1181,1181],"valid"],[[1182,1182],"mapped",[1183]],[[1183,1183],"valid"],[[1184,1184],"mapped",[1185]],[[1185,1185],"valid"],[[1186,1186],"mapped",[1187]],[[1187,1187],"valid"],[[1188,1188],"mapped",[1189]],[[1189,1189],"valid"],[[1190,1190],"mapped",[1191]],[[1191,1191],"valid"],[[1192,1192],"mapped",[1193]],[[1193,1193],"valid"],[[1194,1194],"mapped",[1195]],[[1195,1195],"valid"],[[1196,1196],"mapped",[1197]],[[1197,1197],"valid"],[[1198,1198],"mapped",[1199]],[[1199,1199],"valid"],[[1200,1200],"mapped",[1201]],[[1201,1201],"valid"],[[1202,1202],"mapped",[1203]],[[1203,1203],"valid"],[[1204,1204],"mapped",[1205]],[[1205,1205],"valid"],[[1206,1206],"mapped",[1207]],[[1207,1207],"valid"],[[1208,1208],"mapped",[1209]],[[1209,1209],"valid"],[[1210,1210],"mapped",[1211]],[[1211,1211],"valid"],[[1212,1212],"mapped",[1213]],[[1213,1213],"valid"],[[1214,1214],"mapped",[1215]],[[1215,1215],"valid"],[[1216,1216],"disallowed"],[[1217,1217],"mapped",[1218]],[[1218,1218],"valid"],[[1219,1219],"mapped",[1220]],[[1220,1220],"valid"],[[1221,1221],"mapped",[1222]],[[1222,1222],"valid"],[[1223,1223],"mapped",[1224]],[[1224,1224],"valid"],[[1225,1225],"mapped",[1226]],[[1226,1226],"valid"],[[1227,1227],"mapped",[1228]],[[1228,1228],"valid"],[[1229,1229],"mapped",[1230]],[[1230,1230],"valid"],[[1231,1231],"valid"],[[1232,1232],"mapped",[1233]],[[1233,1233],"valid"],[[1234,1234],"mapped",[1235]],[[1235,1235],"valid"],[[1236,1236],"mapped",[1237]],[[1237,1237],"valid"],[[1238,1238],"mapped",[1239]],[[1239,1239],"valid"],[[1240,1240],"mapped",[1241]],[[1241,1241],"valid"],[[1242,1242],"mapped",[1243]],[[1243,1243],"valid"],[[1244,1244],"mapped",[1245]],[[1245,1245],"valid"],[[1246,1246],"mapped",[1247]],[[1247,1247],"valid"],[[1248,1248],"mapped",[1249]],[[1249,1249],"valid"],[[1250,1250],"mapped",[1251]],[[1251,1251],"valid"],[[1252,1252],"mapped",[1253]],[[1253,1253],"valid"],[[1254,1254],"mapped",[1255]],[[1255,1255],"valid"],[[1256,1256],"mapped",[1257]],[[1257,1257],"valid"],[[1258,1258],"mapped",[1259]],[[1259,1259],"valid"],[[1260,1260],"mapped",[1261]],[[1261,1261],"valid"],[[1262,1262],"mapped",[1263]],[[1263,1263],"valid"],[[1264,1264],"mapped",[1265]],[[1265,1265],"valid"],[[1266,1266],"mapped",[1267]],[[1267,1267],"valid"],[[1268,1268],"mapped",[1269]],[[1269,1269],"valid"],[[1270,1270],"mapped",[1271]],[[1271,1271],"valid"],[[1272,1272],"mapped",[1273]],[[1273,1273],"valid"],[[1274,1274],"mapped",[1275]],[[1275,1275],"valid"],[[1276,1276],"mapped",[1277]],[[1277,1277],"valid"],[[1278,1278],"mapped",[1279]],[[1279,1279],"valid"],[[1280,1280],"mapped",[1281]],[[1281,1281],"valid"],[[1282,1282],"mapped",[1283]],[[1283,1283],"valid"],[[1284,1284],"mapped",[1285]],[[1285,1285],"valid"],[[1286,1286],"mapped",[1287]],[[1287,1287],"valid"],[[1288,1288],"mapped",[1289]],[[1289,1289],"valid"],[[1290,1290],"mapped",[1291]],[[1291,1291],"valid"],[[1292,1292],"mapped",[1293]],[[1293,1293],"valid"],[[1294,1294],"mapped",[1295]],[[1295,1295],"valid"],[[1296,1296],"mapped",[1297]],[[1297,1297],"valid"],[[1298,1298],"mapped",[1299]],[[1299,1299],"valid"],[[1300,1300],"mapped",[1301]],[[1301,1301],"valid"],[[1302,1302],"mapped",[1303]],[[1303,1303],"valid"],[[1304,1304],"mapped",[1305]],[[1305,1305],"valid"],[[1306,1306],"mapped",[1307]],[[1307,1307],"valid"],[[1308,1308],"mapped",[1309]],[[1309,1309],"valid"],[[1310,1310],"mapped",[1311]],[[1311,1311],"valid"],[[1312,1312],"mapped",[1313]],[[1313,1313],"valid"],[[1314,1314],"mapped",[1315]],[[1315,1315],"valid"],[[1316,1316],"mapped",[1317]],[[1317,1317],"valid"],[[1318,1318],"mapped",[1319]],[[1319,1319],"valid"],[[1320,1320],"mapped",[1321]],[[1321,1321],"valid"],[[1322,1322],"mapped",[1323]],[[1323,1323],"valid"],[[1324,1324],"mapped",[1325]],[[1325,1325],"valid"],[[1326,1326],"mapped",[1327]],[[1327,1327],"valid"],[[1328,1328],"disallowed"],[[1329,1329],"mapped",[1377]],[[1330,1330],"mapped",[1378]],[[1331,1331],"mapped",[1379]],[[1332,1332],"mapped",[1380]],[[1333,1333],"mapped",[1381]],[[1334,1334],"mapped",[1382]],[[1335,1335],"mapped",[1383]],[[1336,1336],"mapped",[1384]],[[1337,1337],"mapped",[1385]],[[1338,1338],"mapped",[1386]],[[1339,1339],"mapped",[1387]],[[1340,1340],"mapped",[1388]],[[1341,1341],"mapped",[1389]],[[1342,1342],"mapped",[1390]],[[1343,1343],"mapped",[1391]],[[1344,1344],"mapped",[1392]],[[1345,1345],"mapped",[1393]],[[1346,1346],"mapped",[1394]],[[1347,1347],"mapped",[1395]],[[1348,1348],"mapped",[1396]],[[1349,1349],"mapped",[1397]],[[1350,1350],"mapped",[1398]],[[1351,1351],"mapped",[1399]],[[1352,1352],"mapped",[1400]],[[1353,1353],"mapped",[1401]],[[1354,1354],"mapped",[1402]],[[1355,1355],"mapped",[1403]],[[1356,1356],"mapped",[1404]],[[1357,1357],"mapped",[1405]],[[1358,1358],"mapped",[1406]],[[1359,1359],"mapped",[1407]],[[1360,1360],"mapped",[1408]],[[1361,1361],"mapped",[1409]],[[1362,1362],"mapped",[1410]],[[1363,1363],"mapped",[1411]],[[1364,1364],"mapped",[1412]],[[1365,1365],"mapped",[1413]],[[1366,1366],"mapped",[1414]],[[1367,1368],"disallowed"],[[1369,1369],"valid"],[[1370,1375],"valid",[],"NV8"],[[1376,1376],"disallowed"],[[1377,1414],"valid"],[[1415,1415],"mapped",[1381,1410]],[[1416,1416],"disallowed"],[[1417,1417],"valid",[],"NV8"],[[1418,1418],"valid",[],"NV8"],[[1419,1420],"disallowed"],[[1421,1422],"valid",[],"NV8"],[[1423,1423],"valid",[],"NV8"],[[1424,1424],"disallowed"],[[1425,1441],"valid"],[[1442,1442],"valid"],[[1443,1455],"valid"],[[1456,1465],"valid"],[[1466,1466],"valid"],[[1467,1469],"valid"],[[1470,1470],"valid",[],"NV8"],[[1471,1471],"valid"],[[1472,1472],"valid",[],"NV8"],[[1473,1474],"valid"],[[1475,1475],"valid",[],"NV8"],[[1476,1476],"valid"],[[1477,1477],"valid"],[[1478,1478],"valid",[],"NV8"],[[1479,1479],"valid"],[[1480,1487],"disallowed"],[[1488,1514],"valid"],[[1515,1519],"disallowed"],[[1520,1524],"valid"],[[1525,1535],"disallowed"],[[1536,1539],"disallowed"],[[1540,1540],"disallowed"],[[1541,1541],"disallowed"],[[1542,1546],"valid",[],"NV8"],[[1547,1547],"valid",[],"NV8"],[[1548,1548],"valid",[],"NV8"],[[1549,1551],"valid",[],"NV8"],[[1552,1557],"valid"],[[1558,1562],"valid"],[[1563,1563],"valid",[],"NV8"],[[1564,1564],"disallowed"],[[1565,1565],"disallowed"],[[1566,1566],"valid",[],"NV8"],[[1567,1567],"valid",[],"NV8"],[[1568,1568],"valid"],[[1569,1594],"valid"],[[1595,1599],"valid"],[[1600,1600],"valid",[],"NV8"],[[1601,1618],"valid"],[[1619,1621],"valid"],[[1622,1624],"valid"],[[1625,1630],"valid"],[[1631,1631],"valid"],[[1632,1641],"valid"],[[1642,1645],"valid",[],"NV8"],[[1646,1647],"valid"],[[1648,1652],"valid"],[[1653,1653],"mapped",[1575,1652]],[[1654,1654],"mapped",[1608,1652]],[[1655,1655],"mapped",[1735,1652]],[[1656,1656],"mapped",[1610,1652]],[[1657,1719],"valid"],[[1720,1721],"valid"],[[1722,1726],"valid"],[[1727,1727],"valid"],[[1728,1742],"valid"],[[1743,1743],"valid"],[[1744,1747],"valid"],[[1748,1748],"valid",[],"NV8"],[[1749,1756],"valid"],[[1757,1757],"disallowed"],[[1758,1758],"valid",[],"NV8"],[[1759,1768],"valid"],[[1769,1769],"valid",[],"NV8"],[[1770,1773],"valid"],[[1774,1775],"valid"],[[1776,1785],"valid"],[[1786,1790],"valid"],[[1791,1791],"valid"],[[1792,1805],"valid",[],"NV8"],[[1806,1806],"disallowed"],[[1807,1807],"disallowed"],[[1808,1836],"valid"],[[1837,1839],"valid"],[[1840,1866],"valid"],[[1867,1868],"disallowed"],[[1869,1871],"valid"],[[1872,1901],"valid"],[[1902,1919],"valid"],[[1920,1968],"valid"],[[1969,1969],"valid"],[[1970,1983],"disallowed"],[[1984,2037],"valid"],[[2038,2042],"valid",[],"NV8"],[[2043,2047],"disallowed"],[[2048,2093],"valid"],[[2094,2095],"disallowed"],[[2096,2110],"valid",[],"NV8"],[[2111,2111],"disallowed"],[[2112,2139],"valid"],[[2140,2141],"disallowed"],[[2142,2142],"valid",[],"NV8"],[[2143,2207],"disallowed"],[[2208,2208],"valid"],[[2209,2209],"valid"],[[2210,2220],"valid"],[[2221,2226],"valid"],[[2227,2228],"valid"],[[2229,2274],"disallowed"],[[2275,2275],"valid"],[[2276,2302],"valid"],[[2303,2303],"valid"],[[2304,2304],"valid"],[[2305,2307],"valid"],[[2308,2308],"valid"],[[2309,2361],"valid"],[[2362,2363],"valid"],[[2364,2381],"valid"],[[2382,2382],"valid"],[[2383,2383],"valid"],[[2384,2388],"valid"],[[2389,2389],"valid"],[[2390,2391],"valid"],[[2392,2392],"mapped",[2325,2364]],[[2393,2393],"mapped",[2326,2364]],[[2394,2394],"mapped",[2327,2364]],[[2395,2395],"mapped",[2332,2364]],[[2396,2396],"mapped",[2337,2364]],[[2397,2397],"mapped",[2338,2364]],[[2398,2398],"mapped",[2347,2364]],[[2399,2399],"mapped",[2351,2364]],[[2400,2403],"valid"],[[2404,2405],"valid",[],"NV8"],[[2406,2415],"valid"],[[2416,2416],"valid",[],"NV8"],[[2417,2418],"valid"],[[2419,2423],"valid"],[[2424,2424],"valid"],[[2425,2426],"valid"],[[2427,2428],"valid"],[[2429,2429],"valid"],[[2430,2431],"valid"],[[2432,2432],"valid"],[[2433,2435],"valid"],[[2436,2436],"disallowed"],[[2437,2444],"valid"],[[2445,2446],"disallowed"],[[2447,2448],"valid"],[[2449,2450],"disallowed"],[[2451,2472],"valid"],[[2473,2473],"disallowed"],[[2474,2480],"valid"],[[2481,2481],"disallowed"],[[2482,2482],"valid"],[[2483,2485],"disallowed"],[[2486,2489],"valid"],[[2490,2491],"disallowed"],[[2492,2492],"valid"],[[2493,2493],"valid"],[[2494,2500],"valid"],[[2501,2502],"disallowed"],[[2503,2504],"valid"],[[2505,2506],"disallowed"],[[2507,2509],"valid"],[[2510,2510],"valid"],[[2511,2518],"disallowed"],[[2519,2519],"valid"],[[2520,2523],"disallowed"],[[2524,2524],"mapped",[2465,2492]],[[2525,2525],"mapped",[2466,2492]],[[2526,2526],"disallowed"],[[2527,2527],"mapped",[2479,2492]],[[2528,2531],"valid"],[[2532,2533],"disallowed"],[[2534,2545],"valid"],[[2546,2554],"valid",[],"NV8"],[[2555,2555],"valid",[],"NV8"],[[2556,2560],"disallowed"],[[2561,2561],"valid"],[[2562,2562],"valid"],[[2563,2563],"valid"],[[2564,2564],"disallowed"],[[2565,2570],"valid"],[[2571,2574],"disallowed"],[[2575,2576],"valid"],[[2577,2578],"disallowed"],[[2579,2600],"valid"],[[2601,2601],"disallowed"],[[2602,2608],"valid"],[[2609,2609],"disallowed"],[[2610,2610],"valid"],[[2611,2611],"mapped",[2610,2620]],[[2612,2612],"disallowed"],[[2613,2613],"valid"],[[2614,2614],"mapped",[2616,2620]],[[2615,2615],"disallowed"],[[2616,2617],"valid"],[[2618,2619],"disallowed"],[[2620,2620],"valid"],[[2621,2621],"disallowed"],[[2622,2626],"valid"],[[2627,2630],"disallowed"],[[2631,2632],"valid"],[[2633,2634],"disallowed"],[[2635,2637],"valid"],[[2638,2640],"disallowed"],[[2641,2641],"valid"],[[2642,2648],"disallowed"],[[2649,2649],"mapped",[2582,2620]],[[2650,2650],"mapped",[2583,2620]],[[2651,2651],"mapped",[2588,2620]],[[2652,2652],"valid"],[[2653,2653],"disallowed"],[[2654,2654],"mapped",[2603,2620]],[[2655,2661],"disallowed"],[[2662,2676],"valid"],[[2677,2677],"valid"],[[2678,2688],"disallowed"],[[2689,2691],"valid"],[[2692,2692],"disallowed"],[[2693,2699],"valid"],[[2700,2700],"valid"],[[2701,2701],"valid"],[[2702,2702],"disallowed"],[[2703,2705],"valid"],[[2706,2706],"disallowed"],[[2707,2728],"valid"],[[2729,2729],"disallowed"],[[2730,2736],"valid"],[[2737,2737],"disallowed"],[[2738,2739],"valid"],[[2740,2740],"disallowed"],[[2741,2745],"valid"],[[2746,2747],"disallowed"],[[2748,2757],"valid"],[[2758,2758],"disallowed"],[[2759,2761],"valid"],[[2762,2762],"disallowed"],[[2763,2765],"valid"],[[2766,2767],"disallowed"],[[2768,2768],"valid"],[[2769,2783],"disallowed"],[[2784,2784],"valid"],[[2785,2787],"valid"],[[2788,2789],"disallowed"],[[2790,2799],"valid"],[[2800,2800],"valid",[],"NV8"],[[2801,2801],"valid",[],"NV8"],[[2802,2808],"disallowed"],[[2809,2809],"valid"],[[2810,2816],"disallowed"],[[2817,2819],"valid"],[[2820,2820],"disallowed"],[[2821,2828],"valid"],[[2829,2830],"disallowed"],[[2831,2832],"valid"],[[2833,2834],"disallowed"],[[2835,2856],"valid"],[[2857,2857],"disallowed"],[[2858,2864],"valid"],[[2865,2865],"disallowed"],[[2866,2867],"valid"],[[2868,2868],"disallowed"],[[2869,2869],"valid"],[[2870,2873],"valid"],[[2874,2875],"disallowed"],[[2876,2883],"valid"],[[2884,2884],"valid"],[[2885,2886],"disallowed"],[[2887,2888],"valid"],[[2889,2890],"disallowed"],[[2891,2893],"valid"],[[2894,2901],"disallowed"],[[2902,2903],"valid"],[[2904,2907],"disallowed"],[[2908,2908],"mapped",[2849,2876]],[[2909,2909],"mapped",[2850,2876]],[[2910,2910],"disallowed"],[[2911,2913],"valid"],[[2914,2915],"valid"],[[2916,2917],"disallowed"],[[2918,2927],"valid"],[[2928,2928],"valid",[],"NV8"],[[2929,2929],"valid"],[[2930,2935],"valid",[],"NV8"],[[2936,2945],"disallowed"],[[2946,2947],"valid"],[[2948,2948],"disallowed"],[[2949,2954],"valid"],[[2955,2957],"disallowed"],[[2958,2960],"valid"],[[2961,2961],"disallowed"],[[2962,2965],"valid"],[[2966,2968],"disallowed"],[[2969,2970],"valid"],[[2971,2971],"disallowed"],[[2972,2972],"valid"],[[2973,2973],"disallowed"],[[2974,2975],"valid"],[[2976,2978],"disallowed"],[[2979,2980],"valid"],[[2981,2983],"disallowed"],[[2984,2986],"valid"],[[2987,2989],"disallowed"],[[2990,2997],"valid"],[[2998,2998],"valid"],[[2999,3001],"valid"],[[3002,3005],"disallowed"],[[3006,3010],"valid"],[[3011,3013],"disallowed"],[[3014,3016],"valid"],[[3017,3017],"disallowed"],[[3018,3021],"valid"],[[3022,3023],"disallowed"],[[3024,3024],"valid"],[[3025,3030],"disallowed"],[[3031,3031],"valid"],[[3032,3045],"disallowed"],[[3046,3046],"valid"],[[3047,3055],"valid"],[[3056,3058],"valid",[],"NV8"],[[3059,3066],"valid",[],"NV8"],[[3067,3071],"disallowed"],[[3072,3072],"valid"],[[3073,3075],"valid"],[[3076,3076],"disallowed"],[[3077,3084],"valid"],[[3085,3085],"disallowed"],[[3086,3088],"valid"],[[3089,3089],"disallowed"],[[3090,3112],"valid"],[[3113,3113],"disallowed"],[[3114,3123],"valid"],[[3124,3124],"valid"],[[3125,3129],"valid"],[[3130,3132],"disallowed"],[[3133,3133],"valid"],[[3134,3140],"valid"],[[3141,3141],"disallowed"],[[3142,3144],"valid"],[[3145,3145],"disallowed"],[[3146,3149],"valid"],[[3150,3156],"disallowed"],[[3157,3158],"valid"],[[3159,3159],"disallowed"],[[3160,3161],"valid"],[[3162,3162],"valid"],[[3163,3167],"disallowed"],[[3168,3169],"valid"],[[3170,3171],"valid"],[[3172,3173],"disallowed"],[[3174,3183],"valid"],[[3184,3191],"disallowed"],[[3192,3199],"valid",[],"NV8"],[[3200,3200],"disallowed"],[[3201,3201],"valid"],[[3202,3203],"valid"],[[3204,3204],"disallowed"],[[3205,3212],"valid"],[[3213,3213],"disallowed"],[[3214,3216],"valid"],[[3217,3217],"disallowed"],[[3218,3240],"valid"],[[3241,3241],"disallowed"],[[3242,3251],"valid"],[[3252,3252],"disallowed"],[[3253,3257],"valid"],[[3258,3259],"disallowed"],[[3260,3261],"valid"],[[3262,3268],"valid"],[[3269,3269],"disallowed"],[[3270,3272],"valid"],[[3273,3273],"disallowed"],[[3274,3277],"valid"],[[3278,3284],"disallowed"],[[3285,3286],"valid"],[[3287,3293],"disallowed"],[[3294,3294],"valid"],[[3295,3295],"disallowed"],[[3296,3297],"valid"],[[3298,3299],"valid"],[[3300,3301],"disallowed"],[[3302,3311],"valid"],[[3312,3312],"disallowed"],[[3313,3314],"valid"],[[3315,3328],"disallowed"],[[3329,3329],"valid"],[[3330,3331],"valid"],[[3332,3332],"disallowed"],[[3333,3340],"valid"],[[3341,3341],"disallowed"],[[3342,3344],"valid"],[[3345,3345],"disallowed"],[[3346,3368],"valid"],[[3369,3369],"valid"],[[3370,3385],"valid"],[[3386,3386],"valid"],[[3387,3388],"disallowed"],[[3389,3389],"valid"],[[3390,3395],"valid"],[[3396,3396],"valid"],[[3397,3397],"disallowed"],[[3398,3400],"valid"],[[3401,3401],"disallowed"],[[3402,3405],"valid"],[[3406,3406],"valid"],[[3407,3414],"disallowed"],[[3415,3415],"valid"],[[3416,3422],"disallowed"],[[3423,3423],"valid"],[[3424,3425],"valid"],[[3426,3427],"valid"],[[3428,3429],"disallowed"],[[3430,3439],"valid"],[[3440,3445],"valid",[],"NV8"],[[3446,3448],"disallowed"],[[3449,3449],"valid",[],"NV8"],[[3450,3455],"valid"],[[3456,3457],"disallowed"],[[3458,3459],"valid"],[[3460,3460],"disallowed"],[[3461,3478],"valid"],[[3479,3481],"disallowed"],[[3482,3505],"valid"],[[3506,3506],"disallowed"],[[3507,3515],"valid"],[[3516,3516],"disallowed"],[[3517,3517],"valid"],[[3518,3519],"disallowed"],[[3520,3526],"valid"],[[3527,3529],"disallowed"],[[3530,3530],"valid"],[[3531,3534],"disallowed"],[[3535,3540],"valid"],[[3541,3541],"disallowed"],[[3542,3542],"valid"],[[3543,3543],"disallowed"],[[3544,3551],"valid"],[[3552,3557],"disallowed"],[[3558,3567],"valid"],[[3568,3569],"disallowed"],[[3570,3571],"valid"],[[3572,3572],"valid",[],"NV8"],[[3573,3584],"disallowed"],[[3585,3634],"valid"],[[3635,3635],"mapped",[3661,3634]],[[3636,3642],"valid"],[[3643,3646],"disallowed"],[[3647,3647],"valid",[],"NV8"],[[3648,3662],"valid"],[[3663,3663],"valid",[],"NV8"],[[3664,3673],"valid"],[[3674,3675],"valid",[],"NV8"],[[3676,3712],"disallowed"],[[3713,3714],"valid"],[[3715,3715],"disallowed"],[[3716,3716],"valid"],[[3717,3718],"disallowed"],[[3719,3720],"valid"],[[3721,3721],"disallowed"],[[3722,3722],"valid"],[[3723,3724],"disallowed"],[[3725,3725],"valid"],[[3726,3731],"disallowed"],[[3732,3735],"valid"],[[3736,3736],"disallowed"],[[3737,3743],"valid"],[[3744,3744],"disallowed"],[[3745,3747],"valid"],[[3748,3748],"disallowed"],[[3749,3749],"valid"],[[3750,3750],"disallowed"],[[3751,3751],"valid"],[[3752,3753],"disallowed"],[[3754,3755],"valid"],[[3756,3756],"disallowed"],[[3757,3762],"valid"],[[3763,3763],"mapped",[3789,3762]],[[3764,3769],"valid"],[[3770,3770],"disallowed"],[[3771,3773],"valid"],[[3774,3775],"disallowed"],[[3776,3780],"valid"],[[3781,3781],"disallowed"],[[3782,3782],"valid"],[[3783,3783],"disallowed"],[[3784,3789],"valid"],[[3790,3791],"disallowed"],[[3792,3801],"valid"],[[3802,3803],"disallowed"],[[3804,3804],"mapped",[3755,3737]],[[3805,3805],"mapped",[3755,3745]],[[3806,3807],"valid"],[[3808,3839],"disallowed"],[[3840,3840],"valid"],[[3841,3850],"valid",[],"NV8"],[[3851,3851],"valid"],[[3852,3852],"mapped",[3851]],[[3853,3863],"valid",[],"NV8"],[[3864,3865],"valid"],[[3866,3871],"valid",[],"NV8"],[[3872,3881],"valid"],[[3882,3892],"valid",[],"NV8"],[[3893,3893],"valid"],[[3894,3894],"valid",[],"NV8"],[[3895,3895],"valid"],[[3896,3896],"valid",[],"NV8"],[[3897,3897],"valid"],[[3898,3901],"valid",[],"NV8"],[[3902,3906],"valid"],[[3907,3907],"mapped",[3906,4023]],[[3908,3911],"valid"],[[3912,3912],"disallowed"],[[3913,3916],"valid"],[[3917,3917],"mapped",[3916,4023]],[[3918,3921],"valid"],[[3922,3922],"mapped",[3921,4023]],[[3923,3926],"valid"],[[3927,3927],"mapped",[3926,4023]],[[3928,3931],"valid"],[[3932,3932],"mapped",[3931,4023]],[[3933,3944],"valid"],[[3945,3945],"mapped",[3904,4021]],[[3946,3946],"valid"],[[3947,3948],"valid"],[[3949,3952],"disallowed"],[[3953,3954],"valid"],[[3955,3955],"mapped",[3953,3954]],[[3956,3956],"valid"],[[3957,3957],"mapped",[3953,3956]],[[3958,3958],"mapped",[4018,3968]],[[3959,3959],"mapped",[4018,3953,3968]],[[3960,3960],"mapped",[4019,3968]],[[3961,3961],"mapped",[4019,3953,3968]],[[3962,3968],"valid"],[[3969,3969],"mapped",[3953,3968]],[[3970,3972],"valid"],[[3973,3973],"valid",[],"NV8"],[[3974,3979],"valid"],[[3980,3983],"valid"],[[3984,3986],"valid"],[[3987,3987],"mapped",[3986,4023]],[[3988,3989],"valid"],[[3990,3990],"valid"],[[3991,3991],"valid"],[[3992,3992],"disallowed"],[[3993,3996],"valid"],[[3997,3997],"mapped",[3996,4023]],[[3998,4001],"valid"],[[4002,4002],"mapped",[4001,4023]],[[4003,4006],"valid"],[[4007,4007],"mapped",[4006,4023]],[[4008,4011],"valid"],[[4012,4012],"mapped",[4011,4023]],[[4013,4013],"valid"],[[4014,4016],"valid"],[[4017,4023],"valid"],[[4024,4024],"valid"],[[4025,4025],"mapped",[3984,4021]],[[4026,4028],"valid"],[[4029,4029],"disallowed"],[[4030,4037],"valid",[],"NV8"],[[4038,4038],"valid"],[[4039,4044],"valid",[],"NV8"],[[4045,4045],"disallowed"],[[4046,4046],"valid",[],"NV8"],[[4047,4047],"valid",[],"NV8"],[[4048,4049],"valid",[],"NV8"],[[4050,4052],"valid",[],"NV8"],[[4053,4056],"valid",[],"NV8"],[[4057,4058],"valid",[],"NV8"],[[4059,4095],"disallowed"],[[4096,4129],"valid"],[[4130,4130],"valid"],[[4131,4135],"valid"],[[4136,4136],"valid"],[[4137,4138],"valid"],[[4139,4139],"valid"],[[4140,4146],"valid"],[[4147,4149],"valid"],[[4150,4153],"valid"],[[4154,4159],"valid"],[[4160,4169],"valid"],[[4170,4175],"valid",[],"NV8"],[[4176,4185],"valid"],[[4186,4249],"valid"],[[4250,4253],"valid"],[[4254,4255],"valid",[],"NV8"],[[4256,4293],"disallowed"],[[4294,4294],"disallowed"],[[4295,4295],"mapped",[11559]],[[4296,4300],"disallowed"],[[4301,4301],"mapped",[11565]],[[4302,4303],"disallowed"],[[4304,4342],"valid"],[[4343,4344],"valid"],[[4345,4346],"valid"],[[4347,4347],"valid",[],"NV8"],[[4348,4348],"mapped",[4316]],[[4349,4351],"valid"],[[4352,4441],"valid",[],"NV8"],[[4442,4446],"valid",[],"NV8"],[[4447,4448],"disallowed"],[[4449,4514],"valid",[],"NV8"],[[4515,4519],"valid",[],"NV8"],[[4520,4601],"valid",[],"NV8"],[[4602,4607],"valid",[],"NV8"],[[4608,4614],"valid"],[[4615,4615],"valid"],[[4616,4678],"valid"],[[4679,4679],"valid"],[[4680,4680],"valid"],[[4681,4681],"disallowed"],[[4682,4685],"valid"],[[4686,4687],"disallowed"],[[4688,4694],"valid"],[[4695,4695],"disallowed"],[[4696,4696],"valid"],[[4697,4697],"disallowed"],[[4698,4701],"valid"],[[4702,4703],"disallowed"],[[4704,4742],"valid"],[[4743,4743],"valid"],[[4744,4744],"valid"],[[4745,4745],"disallowed"],[[4746,4749],"valid"],[[4750,4751],"disallowed"],[[4752,4782],"valid"],[[4783,4783],"valid"],[[4784,4784],"valid"],[[4785,4785],"disallowed"],[[4786,4789],"valid"],[[4790,4791],"disallowed"],[[4792,4798],"valid"],[[4799,4799],"disallowed"],[[4800,4800],"valid"],[[4801,4801],"disallowed"],[[4802,4805],"valid"],[[4806,4807],"disallowed"],[[4808,4814],"valid"],[[4815,4815],"valid"],[[4816,4822],"valid"],[[4823,4823],"disallowed"],[[4824,4846],"valid"],[[4847,4847],"valid"],[[4848,4878],"valid"],[[4879,4879],"valid"],[[4880,4880],"valid"],[[4881,4881],"disallowed"],[[4882,4885],"valid"],[[4886,4887],"disallowed"],[[4888,4894],"valid"],[[4895,4895],"valid"],[[4896,4934],"valid"],[[4935,4935],"valid"],[[4936,4954],"valid"],[[4955,4956],"disallowed"],[[4957,4958],"valid"],[[4959,4959],"valid"],[[4960,4960],"valid",[],"NV8"],[[4961,4988],"valid",[],"NV8"],[[4989,4991],"disallowed"],[[4992,5007],"valid"],[[5008,5017],"valid",[],"NV8"],[[5018,5023],"disallowed"],[[5024,5108],"valid"],[[5109,5109],"valid"],[[5110,5111],"disallowed"],[[5112,5112],"mapped",[5104]],[[5113,5113],"mapped",[5105]],[[5114,5114],"mapped",[5106]],[[5115,5115],"mapped",[5107]],[[5116,5116],"mapped",[5108]],[[5117,5117],"mapped",[5109]],[[5118,5119],"disallowed"],[[5120,5120],"valid",[],"NV8"],[[5121,5740],"valid"],[[5741,5742],"valid",[],"NV8"],[[5743,5750],"valid"],[[5751,5759],"valid"],[[5760,5760],"disallowed"],[[5761,5786],"valid"],[[5787,5788],"valid",[],"NV8"],[[5789,5791],"disallowed"],[[5792,5866],"valid"],[[5867,5872],"valid",[],"NV8"],[[5873,5880],"valid"],[[5881,5887],"disallowed"],[[5888,5900],"valid"],[[5901,5901],"disallowed"],[[5902,5908],"valid"],[[5909,5919],"disallowed"],[[5920,5940],"valid"],[[5941,5942],"valid",[],"NV8"],[[5943,5951],"disallowed"],[[5952,5971],"valid"],[[5972,5983],"disallowed"],[[5984,5996],"valid"],[[5997,5997],"disallowed"],[[5998,6000],"valid"],[[6001,6001],"disallowed"],[[6002,6003],"valid"],[[6004,6015],"disallowed"],[[6016,6067],"valid"],[[6068,6069],"disallowed"],[[6070,6099],"valid"],[[6100,6102],"valid",[],"NV8"],[[6103,6103],"valid"],[[6104,6107],"valid",[],"NV8"],[[6108,6108],"valid"],[[6109,6109],"valid"],[[6110,6111],"disallowed"],[[6112,6121],"valid"],[[6122,6127],"disallowed"],[[6128,6137],"valid",[],"NV8"],[[6138,6143],"disallowed"],[[6144,6149],"valid",[],"NV8"],[[6150,6150],"disallowed"],[[6151,6154],"valid",[],"NV8"],[[6155,6157],"ignored"],[[6158,6158],"disallowed"],[[6159,6159],"disallowed"],[[6160,6169],"valid"],[[6170,6175],"disallowed"],[[6176,6263],"valid"],[[6264,6271],"disallowed"],[[6272,6313],"valid"],[[6314,6314],"valid"],[[6315,6319],"disallowed"],[[6320,6389],"valid"],[[6390,6399],"disallowed"],[[6400,6428],"valid"],[[6429,6430],"valid"],[[6431,6431],"disallowed"],[[6432,6443],"valid"],[[6444,6447],"disallowed"],[[6448,6459],"valid"],[[6460,6463],"disallowed"],[[6464,6464],"valid",[],"NV8"],[[6465,6467],"disallowed"],[[6468,6469],"valid",[],"NV8"],[[6470,6509],"valid"],[[6510,6511],"disallowed"],[[6512,6516],"valid"],[[6517,6527],"disallowed"],[[6528,6569],"valid"],[[6570,6571],"valid"],[[6572,6575],"disallowed"],[[6576,6601],"valid"],[[6602,6607],"disallowed"],[[6608,6617],"valid"],[[6618,6618],"valid",[],"XV8"],[[6619,6621],"disallowed"],[[6622,6623],"valid",[],"NV8"],[[6624,6655],"valid",[],"NV8"],[[6656,6683],"valid"],[[6684,6685],"disallowed"],[[6686,6687],"valid",[],"NV8"],[[6688,6750],"valid"],[[6751,6751],"disallowed"],[[6752,6780],"valid"],[[6781,6782],"disallowed"],[[6783,6793],"valid"],[[6794,6799],"disallowed"],[[6800,6809],"valid"],[[6810,6815],"disallowed"],[[6816,6822],"valid",[],"NV8"],[[6823,6823],"valid"],[[6824,6829],"valid",[],"NV8"],[[6830,6831],"disallowed"],[[6832,6845],"valid"],[[6846,6846],"valid",[],"NV8"],[[6847,6911],"disallowed"],[[6912,6987],"valid"],[[6988,6991],"disallowed"],[[6992,7001],"valid"],[[7002,7018],"valid",[],"NV8"],[[7019,7027],"valid"],[[7028,7036],"valid",[],"NV8"],[[7037,7039],"disallowed"],[[7040,7082],"valid"],[[7083,7085],"valid"],[[7086,7097],"valid"],[[7098,7103],"valid"],[[7104,7155],"valid"],[[7156,7163],"disallowed"],[[7164,7167],"valid",[],"NV8"],[[7168,7223],"valid"],[[7224,7226],"disallowed"],[[7227,7231],"valid",[],"NV8"],[[7232,7241],"valid"],[[7242,7244],"disallowed"],[[7245,7293],"valid"],[[7294,7295],"valid",[],"NV8"],[[7296,7359],"disallowed"],[[7360,7367],"valid",[],"NV8"],[[7368,7375],"disallowed"],[[7376,7378],"valid"],[[7379,7379],"valid",[],"NV8"],[[7380,7410],"valid"],[[7411,7414],"valid"],[[7415,7415],"disallowed"],[[7416,7417],"valid"],[[7418,7423],"disallowed"],[[7424,7467],"valid"],[[7468,7468],"mapped",[97]],[[7469,7469],"mapped",[230]],[[7470,7470],"mapped",[98]],[[7471,7471],"valid"],[[7472,7472],"mapped",[100]],[[7473,7473],"mapped",[101]],[[7474,7474],"mapped",[477]],[[7475,7475],"mapped",[103]],[[7476,7476],"mapped",[104]],[[7477,7477],"mapped",[105]],[[7478,7478],"mapped",[106]],[[7479,7479],"mapped",[107]],[[7480,7480],"mapped",[108]],[[7481,7481],"mapped",[109]],[[7482,7482],"mapped",[110]],[[7483,7483],"valid"],[[7484,7484],"mapped",[111]],[[7485,7485],"mapped",[547]],[[7486,7486],"mapped",[112]],[[7487,7487],"mapped",[114]],[[7488,7488],"mapped",[116]],[[7489,7489],"mapped",[117]],[[7490,7490],"mapped",[119]],[[7491,7491],"mapped",[97]],[[7492,7492],"mapped",[592]],[[7493,7493],"mapped",[593]],[[7494,7494],"mapped",[7426]],[[7495,7495],"mapped",[98]],[[7496,7496],"mapped",[100]],[[7497,7497],"mapped",[101]],[[7498,7498],"mapped",[601]],[[7499,7499],"mapped",[603]],[[7500,7500],"mapped",[604]],[[7501,7501],"mapped",[103]],[[7502,7502],"valid"],[[7503,7503],"mapped",[107]],[[7504,7504],"mapped",[109]],[[7505,7505],"mapped",[331]],[[7506,7506],"mapped",[111]],[[7507,7507],"mapped",[596]],[[7508,7508],"mapped",[7446]],[[7509,7509],"mapped",[7447]],[[7510,7510],"mapped",[112]],[[7511,7511],"mapped",[116]],[[7512,7512],"mapped",[117]],[[7513,7513],"mapped",[7453]],[[7514,7514],"mapped",[623]],[[7515,7515],"mapped",[118]],[[7516,7516],"mapped",[7461]],[[7517,7517],"mapped",[946]],[[7518,7518],"mapped",[947]],[[7519,7519],"mapped",[948]],[[7520,7520],"mapped",[966]],[[7521,7521],"mapped",[967]],[[7522,7522],"mapped",[105]],[[7523,7523],"mapped",[114]],[[7524,7524],"mapped",[117]],[[7525,7525],"mapped",[118]],[[7526,7526],"mapped",[946]],[[7527,7527],"mapped",[947]],[[7528,7528],"mapped",[961]],[[7529,7529],"mapped",[966]],[[7530,7530],"mapped",[967]],[[7531,7531],"valid"],[[7532,7543],"valid"],[[7544,7544],"mapped",[1085]],[[7545,7578],"valid"],[[7579,7579],"mapped",[594]],[[7580,7580],"mapped",[99]],[[7581,7581],"mapped",[597]],[[7582,7582],"mapped",[240]],[[7583,7583],"mapped",[604]],[[7584,7584],"mapped",[102]],[[7585,7585],"mapped",[607]],[[7586,7586],"mapped",[609]],[[7587,7587],"mapped",[613]],[[7588,7588],"mapped",[616]],[[7589,7589],"mapped",[617]],[[7590,7590],"mapped",[618]],[[7591,7591],"mapped",[7547]],[[7592,7592],"mapped",[669]],[[7593,7593],"mapped",[621]],[[7594,7594],"mapped",[7557]],[[7595,7595],"mapped",[671]],[[7596,7596],"mapped",[625]],[[7597,7597],"mapped",[624]],[[7598,7598],"mapped",[626]],[[7599,7599],"mapped",[627]],[[7600,7600],"mapped",[628]],[[7601,7601],"mapped",[629]],[[7602,7602],"mapped",[632]],[[7603,7603],"mapped",[642]],[[7604,7604],"mapped",[643]],[[7605,7605],"mapped",[427]],[[7606,7606],"mapped",[649]],[[7607,7607],"mapped",[650]],[[7608,7608],"mapped",[7452]],[[7609,7609],"mapped",[651]],[[7610,7610],"mapped",[652]],[[7611,7611],"mapped",[122]],[[7612,7612],"mapped",[656]],[[7613,7613],"mapped",[657]],[[7614,7614],"mapped",[658]],[[7615,7615],"mapped",[952]],[[7616,7619],"valid"],[[7620,7626],"valid"],[[7627,7654],"valid"],[[7655,7669],"valid"],[[7670,7675],"disallowed"],[[7676,7676],"valid"],[[7677,7677],"valid"],[[7678,7679],"valid"],[[7680,7680],"mapped",[7681]],[[7681,7681],"valid"],[[7682,7682],"mapped",[7683]],[[7683,7683],"valid"],[[7684,7684],"mapped",[7685]],[[7685,7685],"valid"],[[7686,7686],"mapped",[7687]],[[7687,7687],"valid"],[[7688,7688],"mapped",[7689]],[[7689,7689],"valid"],[[7690,7690],"mapped",[7691]],[[7691,7691],"valid"],[[7692,7692],"mapped",[7693]],[[7693,7693],"valid"],[[7694,7694],"mapped",[7695]],[[7695,7695],"valid"],[[7696,7696],"mapped",[7697]],[[7697,7697],"valid"],[[7698,7698],"mapped",[7699]],[[7699,7699],"valid"],[[7700,7700],"mapped",[7701]],[[7701,7701],"valid"],[[7702,7702],"mapped",[7703]],[[7703,7703],"valid"],[[7704,7704],"mapped",[7705]],[[7705,7705],"valid"],[[7706,7706],"mapped",[7707]],[[7707,7707],"valid"],[[7708,7708],"mapped",[7709]],[[7709,7709],"valid"],[[7710,7710],"mapped",[7711]],[[7711,7711],"valid"],[[7712,7712],"mapped",[7713]],[[7713,7713],"valid"],[[7714,7714],"mapped",[7715]],[[7715,7715],"valid"],[[7716,7716],"mapped",[7717]],[[7717,7717],"valid"],[[7718,7718],"mapped",[7719]],[[7719,7719],"valid"],[[7720,7720],"mapped",[7721]],[[7721,7721],"valid"],[[7722,7722],"mapped",[7723]],[[7723,7723],"valid"],[[7724,7724],"mapped",[7725]],[[7725,7725],"valid"],[[7726,7726],"mapped",[7727]],[[7727,7727],"valid"],[[7728,7728],"mapped",[7729]],[[7729,7729],"valid"],[[7730,7730],"mapped",[7731]],[[7731,7731],"valid"],[[7732,7732],"mapped",[7733]],[[7733,7733],"valid"],[[7734,7734],"mapped",[7735]],[[7735,7735],"valid"],[[7736,7736],"mapped",[7737]],[[7737,7737],"valid"],[[7738,7738],"mapped",[7739]],[[7739,7739],"valid"],[[7740,7740],"mapped",[7741]],[[7741,7741],"valid"],[[7742,7742],"mapped",[7743]],[[7743,7743],"valid"],[[7744,7744],"mapped",[7745]],[[7745,7745],"valid"],[[7746,7746],"mapped",[7747]],[[7747,7747],"valid"],[[7748,7748],"mapped",[7749]],[[7749,7749],"valid"],[[7750,7750],"mapped",[7751]],[[7751,7751],"valid"],[[7752,7752],"mapped",[7753]],[[7753,7753],"valid"],[[7754,7754],"mapped",[7755]],[[7755,7755],"valid"],[[7756,7756],"mapped",[7757]],[[7757,7757],"valid"],[[7758,7758],"mapped",[7759]],[[7759,7759],"valid"],[[7760,7760],"mapped",[7761]],[[7761,7761],"valid"],[[7762,7762],"mapped",[7763]],[[7763,7763],"valid"],[[7764,7764],"mapped",[7765]],[[7765,7765],"valid"],[[7766,7766],"mapped",[7767]],[[7767,7767],"valid"],[[7768,7768],"mapped",[7769]],[[7769,7769],"valid"],[[7770,7770],"mapped",[7771]],[[7771,7771],"valid"],[[7772,7772],"mapped",[7773]],[[7773,7773],"valid"],[[7774,7774],"mapped",[7775]],[[7775,7775],"valid"],[[7776,7776],"mapped",[7777]],[[7777,7777],"valid"],[[7778,7778],"mapped",[7779]],[[7779,7779],"valid"],[[7780,7780],"mapped",[7781]],[[7781,7781],"valid"],[[7782,7782],"mapped",[7783]],[[7783,7783],"valid"],[[7784,7784],"mapped",[7785]],[[7785,7785],"valid"],[[7786,7786],"mapped",[7787]],[[7787,7787],"valid"],[[7788,7788],"mapped",[7789]],[[7789,7789],"valid"],[[7790,7790],"mapped",[7791]],[[7791,7791],"valid"],[[7792,7792],"mapped",[7793]],[[7793,7793],"valid"],[[7794,7794],"mapped",[7795]],[[7795,7795],"valid"],[[7796,7796],"mapped",[7797]],[[7797,7797],"valid"],[[7798,7798],"mapped",[7799]],[[7799,7799],"valid"],[[7800,7800],"mapped",[7801]],[[7801,7801],"valid"],[[7802,7802],"mapped",[7803]],[[7803,7803],"valid"],[[7804,7804],"mapped",[7805]],[[7805,7805],"valid"],[[7806,7806],"mapped",[7807]],[[7807,7807],"valid"],[[7808,7808],"mapped",[7809]],[[7809,7809],"valid"],[[7810,7810],"mapped",[7811]],[[7811,7811],"valid"],[[7812,7812],"mapped",[7813]],[[7813,7813],"valid"],[[7814,7814],"mapped",[7815]],[[7815,7815],"valid"],[[7816,7816],"mapped",[7817]],[[7817,7817],"valid"],[[7818,7818],"mapped",[7819]],[[7819,7819],"valid"],[[7820,7820],"mapped",[7821]],[[7821,7821],"valid"],[[7822,7822],"mapped",[7823]],[[7823,7823],"valid"],[[7824,7824],"mapped",[7825]],[[7825,7825],"valid"],[[7826,7826],"mapped",[7827]],[[7827,7827],"valid"],[[7828,7828],"mapped",[7829]],[[7829,7833],"valid"],[[7834,7834],"mapped",[97,702]],[[7835,7835],"mapped",[7777]],[[7836,7837],"valid"],[[7838,7838],"mapped",[115,115]],[[7839,7839],"valid"],[[7840,7840],"mapped",[7841]],[[7841,7841],"valid"],[[7842,7842],"mapped",[7843]],[[7843,7843],"valid"],[[7844,7844],"mapped",[7845]],[[7845,7845],"valid"],[[7846,7846],"mapped",[7847]],[[7847,7847],"valid"],[[7848,7848],"mapped",[7849]],[[7849,7849],"valid"],[[7850,7850],"mapped",[7851]],[[7851,7851],"valid"],[[7852,7852],"mapped",[7853]],[[7853,7853],"valid"],[[7854,7854],"mapped",[7855]],[[7855,7855],"valid"],[[7856,7856],"mapped",[7857]],[[7857,7857],"valid"],[[7858,7858],"mapped",[7859]],[[7859,7859],"valid"],[[7860,7860],"mapped",[7861]],[[7861,7861],"valid"],[[7862,7862],"mapped",[7863]],[[7863,7863],"valid"],[[7864,7864],"mapped",[7865]],[[7865,7865],"valid"],[[7866,7866],"mapped",[7867]],[[7867,7867],"valid"],[[7868,7868],"mapped",[7869]],[[7869,7869],"valid"],[[7870,7870],"mapped",[7871]],[[7871,7871],"valid"],[[7872,7872],"mapped",[7873]],[[7873,7873],"valid"],[[7874,7874],"mapped",[7875]],[[7875,7875],"valid"],[[7876,7876],"mapped",[7877]],[[7877,7877],"valid"],[[7878,7878],"mapped",[7879]],[[7879,7879],"valid"],[[7880,7880],"mapped",[7881]],[[7881,7881],"valid"],[[7882,7882],"mapped",[7883]],[[7883,7883],"valid"],[[7884,7884],"mapped",[7885]],[[7885,7885],"valid"],[[7886,7886],"mapped",[7887]],[[7887,7887],"valid"],[[7888,7888],"mapped",[7889]],[[7889,7889],"valid"],[[7890,7890],"mapped",[7891]],[[7891,7891],"valid"],[[7892,7892],"mapped",[7893]],[[7893,7893],"valid"],[[7894,7894],"mapped",[7895]],[[7895,7895],"valid"],[[7896,7896],"mapped",[7897]],[[7897,7897],"valid"],[[7898,7898],"mapped",[7899]],[[7899,7899],"valid"],[[7900,7900],"mapped",[7901]],[[7901,7901],"valid"],[[7902,7902],"mapped",[7903]],[[7903,7903],"valid"],[[7904,7904],"mapped",[7905]],[[7905,7905],"valid"],[[7906,7906],"mapped",[7907]],[[7907,7907],"valid"],[[7908,7908],"mapped",[7909]],[[7909,7909],"valid"],[[7910,7910],"mapped",[7911]],[[7911,7911],"valid"],[[7912,7912],"mapped",[7913]],[[7913,7913],"valid"],[[7914,7914],"mapped",[7915]],[[7915,7915],"valid"],[[7916,7916],"mapped",[7917]],[[7917,7917],"valid"],[[7918,7918],"mapped",[7919]],[[7919,7919],"valid"],[[7920,7920],"mapped",[7921]],[[7921,7921],"valid"],[[7922,7922],"mapped",[7923]],[[7923,7923],"valid"],[[7924,7924],"mapped",[7925]],[[7925,7925],"valid"],[[7926,7926],"mapped",[7927]],[[7927,7927],"valid"],[[7928,7928],"mapped",[7929]],[[7929,7929],"valid"],[[7930,7930],"mapped",[7931]],[[7931,7931],"valid"],[[7932,7932],"mapped",[7933]],[[7933,7933],"valid"],[[7934,7934],"mapped",[7935]],[[7935,7935],"valid"],[[7936,7943],"valid"],[[7944,7944],"mapped",[7936]],[[7945,7945],"mapped",[7937]],[[7946,7946],"mapped",[7938]],[[7947,7947],"mapped",[7939]],[[7948,7948],"mapped",[7940]],[[7949,7949],"mapped",[7941]],[[7950,7950],"mapped",[7942]],[[7951,7951],"mapped",[7943]],[[7952,7957],"valid"],[[7958,7959],"disallowed"],[[7960,7960],"mapped",[7952]],[[7961,7961],"mapped",[7953]],[[7962,7962],"mapped",[7954]],[[7963,7963],"mapped",[7955]],[[7964,7964],"mapped",[7956]],[[7965,7965],"mapped",[7957]],[[7966,7967],"disallowed"],[[7968,7975],"valid"],[[7976,7976],"mapped",[7968]],[[7977,7977],"mapped",[7969]],[[7978,7978],"mapped",[7970]],[[7979,7979],"mapped",[7971]],[[7980,7980],"mapped",[7972]],[[7981,7981],"mapped",[7973]],[[7982,7982],"mapped",[7974]],[[7983,7983],"mapped",[7975]],[[7984,7991],"valid"],[[7992,7992],"mapped",[7984]],[[7993,7993],"mapped",[7985]],[[7994,7994],"mapped",[7986]],[[7995,7995],"mapped",[7987]],[[7996,7996],"mapped",[7988]],[[7997,7997],"mapped",[7989]],[[7998,7998],"mapped",[7990]],[[7999,7999],"mapped",[7991]],[[8000,8005],"valid"],[[8006,8007],"disallowed"],[[8008,8008],"mapped",[8000]],[[8009,8009],"mapped",[8001]],[[8010,8010],"mapped",[8002]],[[8011,8011],"mapped",[8003]],[[8012,8012],"mapped",[8004]],[[8013,8013],"mapped",[8005]],[[8014,8015],"disallowed"],[[8016,8023],"valid"],[[8024,8024],"disallowed"],[[8025,8025],"mapped",[8017]],[[8026,8026],"disallowed"],[[8027,8027],"mapped",[8019]],[[8028,8028],"disallowed"],[[8029,8029],"mapped",[8021]],[[8030,8030],"disallowed"],[[8031,8031],"mapped",[8023]],[[8032,8039],"valid"],[[8040,8040],"mapped",[8032]],[[8041,8041],"mapped",[8033]],[[8042,8042],"mapped",[8034]],[[8043,8043],"mapped",[8035]],[[8044,8044],"mapped",[8036]],[[8045,8045],"mapped",[8037]],[[8046,8046],"mapped",[8038]],[[8047,8047],"mapped",[8039]],[[8048,8048],"valid"],[[8049,8049],"mapped",[940]],[[8050,8050],"valid"],[[8051,8051],"mapped",[941]],[[8052,8052],"valid"],[[8053,8053],"mapped",[942]],[[8054,8054],"valid"],[[8055,8055],"mapped",[943]],[[8056,8056],"valid"],[[8057,8057],"mapped",[972]],[[8058,8058],"valid"],[[8059,8059],"mapped",[973]],[[8060,8060],"valid"],[[8061,8061],"mapped",[974]],[[8062,8063],"disallowed"],[[8064,8064],"mapped",[7936,953]],[[8065,8065],"mapped",[7937,953]],[[8066,8066],"mapped",[7938,953]],[[8067,8067],"mapped",[7939,953]],[[8068,8068],"mapped",[7940,953]],[[8069,8069],"mapped",[7941,953]],[[8070,8070],"mapped",[7942,953]],[[8071,8071],"mapped",[7943,953]],[[8072,8072],"mapped",[7936,953]],[[8073,8073],"mapped",[7937,953]],[[8074,8074],"mapped",[7938,953]],[[8075,8075],"mapped",[7939,953]],[[8076,8076],"mapped",[7940,953]],[[8077,8077],"mapped",[7941,953]],[[8078,8078],"mapped",[7942,953]],[[8079,8079],"mapped",[7943,953]],[[8080,8080],"mapped",[7968,953]],[[8081,8081],"mapped",[7969,953]],[[8082,8082],"mapped",[7970,953]],[[8083,8083],"mapped",[7971,953]],[[8084,8084],"mapped",[7972,953]],[[8085,8085],"mapped",[7973,953]],[[8086,8086],"mapped",[7974,953]],[[8087,8087],"mapped",[7975,953]],[[8088,8088],"mapped",[7968,953]],[[8089,8089],"mapped",[7969,953]],[[8090,8090],"mapped",[7970,953]],[[8091,8091],"mapped",[7971,953]],[[8092,8092],"mapped",[7972,953]],[[8093,8093],"mapped",[7973,953]],[[8094,8094],"mapped",[7974,953]],[[8095,8095],"mapped",[7975,953]],[[8096,8096],"mapped",[8032,953]],[[8097,8097],"mapped",[8033,953]],[[8098,8098],"mapped",[8034,953]],[[8099,8099],"mapped",[8035,953]],[[8100,8100],"mapped",[8036,953]],[[8101,8101],"mapped",[8037,953]],[[8102,8102],"mapped",[8038,953]],[[8103,8103],"mapped",[8039,953]],[[8104,8104],"mapped",[8032,953]],[[8105,8105],"mapped",[8033,953]],[[8106,8106],"mapped",[8034,953]],[[8107,8107],"mapped",[8035,953]],[[8108,8108],"mapped",[8036,953]],[[8109,8109],"mapped",[8037,953]],[[8110,8110],"mapped",[8038,953]],[[8111,8111],"mapped",[8039,953]],[[8112,8113],"valid"],[[8114,8114],"mapped",[8048,953]],[[8115,8115],"mapped",[945,953]],[[8116,8116],"mapped",[940,953]],[[8117,8117],"disallowed"],[[8118,8118],"valid"],[[8119,8119],"mapped",[8118,953]],[[8120,8120],"mapped",[8112]],[[8121,8121],"mapped",[8113]],[[8122,8122],"mapped",[8048]],[[8123,8123],"mapped",[940]],[[8124,8124],"mapped",[945,953]],[[8125,8125],"disallowed_STD3_mapped",[32,787]],[[8126,8126],"mapped",[953]],[[8127,8127],"disallowed_STD3_mapped",[32,787]],[[8128,8128],"disallowed_STD3_mapped",[32,834]],[[8129,8129],"disallowed_STD3_mapped",[32,776,834]],[[8130,8130],"mapped",[8052,953]],[[8131,8131],"mapped",[951,953]],[[8132,8132],"mapped",[942,953]],[[8133,8133],"disallowed"],[[8134,8134],"valid"],[[8135,8135],"mapped",[8134,953]],[[8136,8136],"mapped",[8050]],[[8137,8137],"mapped",[941]],[[8138,8138],"mapped",[8052]],[[8139,8139],"mapped",[942]],[[8140,8140],"mapped",[951,953]],[[8141,8141],"disallowed_STD3_mapped",[32,787,768]],[[8142,8142],"disallowed_STD3_mapped",[32,787,769]],[[8143,8143],"disallowed_STD3_mapped",[32,787,834]],[[8144,8146],"valid"],[[8147,8147],"mapped",[912]],[[8148,8149],"disallowed"],[[8150,8151],"valid"],[[8152,8152],"mapped",[8144]],[[8153,8153],"mapped",[8145]],[[8154,8154],"mapped",[8054]],[[8155,8155],"mapped",[943]],[[8156,8156],"disallowed"],[[8157,8157],"disallowed_STD3_mapped",[32,788,768]],[[8158,8158],"disallowed_STD3_mapped",[32,788,769]],[[8159,8159],"disallowed_STD3_mapped",[32,788,834]],[[8160,8162],"valid"],[[8163,8163],"mapped",[944]],[[8164,8167],"valid"],[[8168,8168],"mapped",[8160]],[[8169,8169],"mapped",[8161]],[[8170,8170],"mapped",[8058]],[[8171,8171],"mapped",[973]],[[8172,8172],"mapped",[8165]],[[8173,8173],"disallowed_STD3_mapped",[32,776,768]],[[8174,8174],"disallowed_STD3_mapped",[32,776,769]],[[8175,8175],"disallowed_STD3_mapped",[96]],[[8176,8177],"disallowed"],[[8178,8178],"mapped",[8060,953]],[[8179,8179],"mapped",[969,953]],[[8180,8180],"mapped",[974,953]],[[8181,8181],"disallowed"],[[8182,8182],"valid"],[[8183,8183],"mapped",[8182,953]],[[8184,8184],"mapped",[8056]],[[8185,8185],"mapped",[972]],[[8186,8186],"mapped",[8060]],[[8187,8187],"mapped",[974]],[[8188,8188],"mapped",[969,953]],[[8189,8189],"disallowed_STD3_mapped",[32,769]],[[8190,8190],"disallowed_STD3_mapped",[32,788]],[[8191,8191],"disallowed"],[[8192,8202],"disallowed_STD3_mapped",[32]],[[8203,8203],"ignored"],[[8204,8205],"deviation",[]],[[8206,8207],"disallowed"],[[8208,8208],"valid",[],"NV8"],[[8209,8209],"mapped",[8208]],[[8210,8214],"valid",[],"NV8"],[[8215,8215],"disallowed_STD3_mapped",[32,819]],[[8216,8227],"valid",[],"NV8"],[[8228,8230],"disallowed"],[[8231,8231],"valid",[],"NV8"],[[8232,8238],"disallowed"],[[8239,8239],"disallowed_STD3_mapped",[32]],[[8240,8242],"valid",[],"NV8"],[[8243,8243],"mapped",[8242,8242]],[[8244,8244],"mapped",[8242,8242,8242]],[[8245,8245],"valid",[],"NV8"],[[8246,8246],"mapped",[8245,8245]],[[8247,8247],"mapped",[8245,8245,8245]],[[8248,8251],"valid",[],"NV8"],[[8252,8252],"disallowed_STD3_mapped",[33,33]],[[8253,8253],"valid",[],"NV8"],[[8254,8254],"disallowed_STD3_mapped",[32,773]],[[8255,8262],"valid",[],"NV8"],[[8263,8263],"disallowed_STD3_mapped",[63,63]],[[8264,8264],"disallowed_STD3_mapped",[63,33]],[[8265,8265],"disallowed_STD3_mapped",[33,63]],[[8266,8269],"valid",[],"NV8"],[[8270,8274],"valid",[],"NV8"],[[8275,8276],"valid",[],"NV8"],[[8277,8278],"valid",[],"NV8"],[[8279,8279],"mapped",[8242,8242,8242,8242]],[[8280,8286],"valid",[],"NV8"],[[8287,8287],"disallowed_STD3_mapped",[32]],[[8288,8288],"ignored"],[[8289,8291],"disallowed"],[[8292,8292],"ignored"],[[8293,8293],"disallowed"],[[8294,8297],"disallowed"],[[8298,8303],"disallowed"],[[8304,8304],"mapped",[48]],[[8305,8305],"mapped",[105]],[[8306,8307],"disallowed"],[[8308,8308],"mapped",[52]],[[8309,8309],"mapped",[53]],[[8310,8310],"mapped",[54]],[[8311,8311],"mapped",[55]],[[8312,8312],"mapped",[56]],[[8313,8313],"mapped",[57]],[[8314,8314],"disallowed_STD3_mapped",[43]],[[8315,8315],"mapped",[8722]],[[8316,8316],"disallowed_STD3_mapped",[61]],[[8317,8317],"disallowed_STD3_mapped",[40]],[[8318,8318],"disallowed_STD3_mapped",[41]],[[8319,8319],"mapped",[110]],[[8320,8320],"mapped",[48]],[[8321,8321],"mapped",[49]],[[8322,8322],"mapped",[50]],[[8323,8323],"mapped",[51]],[[8324,8324],"mapped",[52]],[[8325,8325],"mapped",[53]],[[8326,8326],"mapped",[54]],[[8327,8327],"mapped",[55]],[[8328,8328],"mapped",[56]],[[8329,8329],"mapped",[57]],[[8330,8330],"disallowed_STD3_mapped",[43]],[[8331,8331],"mapped",[8722]],[[8332,8332],"disallowed_STD3_mapped",[61]],[[8333,8333],"disallowed_STD3_mapped",[40]],[[8334,8334],"disallowed_STD3_mapped",[41]],[[8335,8335],"disallowed"],[[8336,8336],"mapped",[97]],[[8337,8337],"mapped",[101]],[[8338,8338],"mapped",[111]],[[8339,8339],"mapped",[120]],[[8340,8340],"mapped",[601]],[[8341,8341],"mapped",[104]],[[8342,8342],"mapped",[107]],[[8343,8343],"mapped",[108]],[[8344,8344],"mapped",[109]],[[8345,8345],"mapped",[110]],[[8346,8346],"mapped",[112]],[[8347,8347],"mapped",[115]],[[8348,8348],"mapped",[116]],[[8349,8351],"disallowed"],[[8352,8359],"valid",[],"NV8"],[[8360,8360],"mapped",[114,115]],[[8361,8362],"valid",[],"NV8"],[[8363,8363],"valid",[],"NV8"],[[8364,8364],"valid",[],"NV8"],[[8365,8367],"valid",[],"NV8"],[[8368,8369],"valid",[],"NV8"],[[8370,8373],"valid",[],"NV8"],[[8374,8376],"valid",[],"NV8"],[[8377,8377],"valid",[],"NV8"],[[8378,8378],"valid",[],"NV8"],[[8379,8381],"valid",[],"NV8"],[[8382,8382],"valid",[],"NV8"],[[8383,8399],"disallowed"],[[8400,8417],"valid",[],"NV8"],[[8418,8419],"valid",[],"NV8"],[[8420,8426],"valid",[],"NV8"],[[8427,8427],"valid",[],"NV8"],[[8428,8431],"valid",[],"NV8"],[[8432,8432],"valid",[],"NV8"],[[8433,8447],"disallowed"],[[8448,8448],"disallowed_STD3_mapped",[97,47,99]],[[8449,8449],"disallowed_STD3_mapped",[97,47,115]],[[8450,8450],"mapped",[99]],[[8451,8451],"mapped",[176,99]],[[8452,8452],"valid",[],"NV8"],[[8453,8453],"disallowed_STD3_mapped",[99,47,111]],[[8454,8454],"disallowed_STD3_mapped",[99,47,117]],[[8455,8455],"mapped",[603]],[[8456,8456],"valid",[],"NV8"],[[8457,8457],"mapped",[176,102]],[[8458,8458],"mapped",[103]],[[8459,8462],"mapped",[104]],[[8463,8463],"mapped",[295]],[[8464,8465],"mapped",[105]],[[8466,8467],"mapped",[108]],[[8468,8468],"valid",[],"NV8"],[[8469,8469],"mapped",[110]],[[8470,8470],"mapped",[110,111]],[[8471,8472],"valid",[],"NV8"],[[8473,8473],"mapped",[112]],[[8474,8474],"mapped",[113]],[[8475,8477],"mapped",[114]],[[8478,8479],"valid",[],"NV8"],[[8480,8480],"mapped",[115,109]],[[8481,8481],"mapped",[116,101,108]],[[8482,8482],"mapped",[116,109]],[[8483,8483],"valid",[],"NV8"],[[8484,8484],"mapped",[122]],[[8485,8485],"valid",[],"NV8"],[[8486,8486],"mapped",[969]],[[8487,8487],"valid",[],"NV8"],[[8488,8488],"mapped",[122]],[[8489,8489],"valid",[],"NV8"],[[8490,8490],"mapped",[107]],[[8491,8491],"mapped",[229]],[[8492,8492],"mapped",[98]],[[8493,8493],"mapped",[99]],[[8494,8494],"valid",[],"NV8"],[[8495,8496],"mapped",[101]],[[8497,8497],"mapped",[102]],[[8498,8498],"disallowed"],[[8499,8499],"mapped",[109]],[[8500,8500],"mapped",[111]],[[8501,8501],"mapped",[1488]],[[8502,8502],"mapped",[1489]],[[8503,8503],"mapped",[1490]],[[8504,8504],"mapped",[1491]],[[8505,8505],"mapped",[105]],[[8506,8506],"valid",[],"NV8"],[[8507,8507],"mapped",[102,97,120]],[[8508,8508],"mapped",[960]],[[8509,8510],"mapped",[947]],[[8511,8511],"mapped",[960]],[[8512,8512],"mapped",[8721]],[[8513,8516],"valid",[],"NV8"],[[8517,8518],"mapped",[100]],[[8519,8519],"mapped",[101]],[[8520,8520],"mapped",[105]],[[8521,8521],"mapped",[106]],[[8522,8523],"valid",[],"NV8"],[[8524,8524],"valid",[],"NV8"],[[8525,8525],"valid",[],"NV8"],[[8526,8526],"valid"],[[8527,8527],"valid",[],"NV8"],[[8528,8528],"mapped",[49,8260,55]],[[8529,8529],"mapped",[49,8260,57]],[[8530,8530],"mapped",[49,8260,49,48]],[[8531,8531],"mapped",[49,8260,51]],[[8532,8532],"mapped",[50,8260,51]],[[8533,8533],"mapped",[49,8260,53]],[[8534,8534],"mapped",[50,8260,53]],[[8535,8535],"mapped",[51,8260,53]],[[8536,8536],"mapped",[52,8260,53]],[[8537,8537],"mapped",[49,8260,54]],[[8538,8538],"mapped",[53,8260,54]],[[8539,8539],"mapped",[49,8260,56]],[[8540,8540],"mapped",[51,8260,56]],[[8541,8541],"mapped",[53,8260,56]],[[8542,8542],"mapped",[55,8260,56]],[[8543,8543],"mapped",[49,8260]],[[8544,8544],"mapped",[105]],[[8545,8545],"mapped",[105,105]],[[8546,8546],"mapped",[105,105,105]],[[8547,8547],"mapped",[105,118]],[[8548,8548],"mapped",[118]],[[8549,8549],"mapped",[118,105]],[[8550,8550],"mapped",[118,105,105]],[[8551,8551],"mapped",[118,105,105,105]],[[8552,8552],"mapped",[105,120]],[[8553,8553],"mapped",[120]],[[8554,8554],"mapped",[120,105]],[[8555,8555],"mapped",[120,105,105]],[[8556,8556],"mapped",[108]],[[8557,8557],"mapped",[99]],[[8558,8558],"mapped",[100]],[[8559,8559],"mapped",[109]],[[8560,8560],"mapped",[105]],[[8561,8561],"mapped",[105,105]],[[8562,8562],"mapped",[105,105,105]],[[8563,8563],"mapped",[105,118]],[[8564,8564],"mapped",[118]],[[8565,8565],"mapped",[118,105]],[[8566,8566],"mapped",[118,105,105]],[[8567,8567],"mapped",[118,105,105,105]],[[8568,8568],"mapped",[105,120]],[[8569,8569],"mapped",[120]],[[8570,8570],"mapped",[120,105]],[[8571,8571],"mapped",[120,105,105]],[[8572,8572],"mapped",[108]],[[8573,8573],"mapped",[99]],[[8574,8574],"mapped",[100]],[[8575,8575],"mapped",[109]],[[8576,8578],"valid",[],"NV8"],[[8579,8579],"disallowed"],[[8580,8580],"valid"],[[8581,8584],"valid",[],"NV8"],[[8585,8585],"mapped",[48,8260,51]],[[8586,8587],"valid",[],"NV8"],[[8588,8591],"disallowed"],[[8592,8682],"valid",[],"NV8"],[[8683,8691],"valid",[],"NV8"],[[8692,8703],"valid",[],"NV8"],[[8704,8747],"valid",[],"NV8"],[[8748,8748],"mapped",[8747,8747]],[[8749,8749],"mapped",[8747,8747,8747]],[[8750,8750],"valid",[],"NV8"],[[8751,8751],"mapped",[8750,8750]],[[8752,8752],"mapped",[8750,8750,8750]],[[8753,8799],"valid",[],"NV8"],[[8800,8800],"disallowed_STD3_valid"],[[8801,8813],"valid",[],"NV8"],[[8814,8815],"disallowed_STD3_valid"],[[8816,8945],"valid",[],"NV8"],[[8946,8959],"valid",[],"NV8"],[[8960,8960],"valid",[],"NV8"],[[8961,8961],"valid",[],"NV8"],[[8962,9000],"valid",[],"NV8"],[[9001,9001],"mapped",[12296]],[[9002,9002],"mapped",[12297]],[[9003,9082],"valid",[],"NV8"],[[9083,9083],"valid",[],"NV8"],[[9084,9084],"valid",[],"NV8"],[[9085,9114],"valid",[],"NV8"],[[9115,9166],"valid",[],"NV8"],[[9167,9168],"valid",[],"NV8"],[[9169,9179],"valid",[],"NV8"],[[9180,9191],"valid",[],"NV8"],[[9192,9192],"valid",[],"NV8"],[[9193,9203],"valid",[],"NV8"],[[9204,9210],"valid",[],"NV8"],[[9211,9215],"disallowed"],[[9216,9252],"valid",[],"NV8"],[[9253,9254],"valid",[],"NV8"],[[9255,9279],"disallowed"],[[9280,9290],"valid",[],"NV8"],[[9291,9311],"disallowed"],[[9312,9312],"mapped",[49]],[[9313,9313],"mapped",[50]],[[9314,9314],"mapped",[51]],[[9315,9315],"mapped",[52]],[[9316,9316],"mapped",[53]],[[9317,9317],"mapped",[54]],[[9318,9318],"mapped",[55]],[[9319,9319],"mapped",[56]],[[9320,9320],"mapped",[57]],[[9321,9321],"mapped",[49,48]],[[9322,9322],"mapped",[49,49]],[[9323,9323],"mapped",[49,50]],[[9324,9324],"mapped",[49,51]],[[9325,9325],"mapped",[49,52]],[[9326,9326],"mapped",[49,53]],[[9327,9327],"mapped",[49,54]],[[9328,9328],"mapped",[49,55]],[[9329,9329],"mapped",[49,56]],[[9330,9330],"mapped",[49,57]],[[9331,9331],"mapped",[50,48]],[[9332,9332],"disallowed_STD3_mapped",[40,49,41]],[[9333,9333],"disallowed_STD3_mapped",[40,50,41]],[[9334,9334],"disallowed_STD3_mapped",[40,51,41]],[[9335,9335],"disallowed_STD3_mapped",[40,52,41]],[[9336,9336],"disallowed_STD3_mapped",[40,53,41]],[[9337,9337],"disallowed_STD3_mapped",[40,54,41]],[[9338,9338],"disallowed_STD3_mapped",[40,55,41]],[[9339,9339],"disallowed_STD3_mapped",[40,56,41]],[[9340,9340],"disallowed_STD3_mapped",[40,57,41]],[[9341,9341],"disallowed_STD3_mapped",[40,49,48,41]],[[9342,9342],"disallowed_STD3_mapped",[40,49,49,41]],[[9343,9343],"disallowed_STD3_mapped",[40,49,50,41]],[[9344,9344],"disallowed_STD3_mapped",[40,49,51,41]],[[9345,9345],"disallowed_STD3_mapped",[40,49,52,41]],[[9346,9346],"disallowed_STD3_mapped",[40,49,53,41]],[[9347,9347],"disallowed_STD3_mapped",[40,49,54,41]],[[9348,9348],"disallowed_STD3_mapped",[40,49,55,41]],[[9349,9349],"disallowed_STD3_mapped",[40,49,56,41]],[[9350,9350],"disallowed_STD3_mapped",[40,49,57,41]],[[9351,9351],"disallowed_STD3_mapped",[40,50,48,41]],[[9352,9371],"disallowed"],[[9372,9372],"disallowed_STD3_mapped",[40,97,41]],[[9373,9373],"disallowed_STD3_mapped",[40,98,41]],[[9374,9374],"disallowed_STD3_mapped",[40,99,41]],[[9375,9375],"disallowed_STD3_mapped",[40,100,41]],[[9376,9376],"disallowed_STD3_mapped",[40,101,41]],[[9377,9377],"disallowed_STD3_mapped",[40,102,41]],[[9378,9378],"disallowed_STD3_mapped",[40,103,41]],[[9379,9379],"disallowed_STD3_mapped",[40,104,41]],[[9380,9380],"disallowed_STD3_mapped",[40,105,41]],[[9381,9381],"disallowed_STD3_mapped",[40,106,41]],[[9382,9382],"disallowed_STD3_mapped",[40,107,41]],[[9383,9383],"disallowed_STD3_mapped",[40,108,41]],[[9384,9384],"disallowed_STD3_mapped",[40,109,41]],[[9385,9385],"disallowed_STD3_mapped",[40,110,41]],[[9386,9386],"disallowed_STD3_mapped",[40,111,41]],[[9387,9387],"disallowed_STD3_mapped",[40,112,41]],[[9388,9388],"disallowed_STD3_mapped",[40,113,41]],[[9389,9389],"disallowed_STD3_mapped",[40,114,41]],[[9390,9390],"disallowed_STD3_mapped",[40,115,41]],[[9391,9391],"disallowed_STD3_mapped",[40,116,41]],[[9392,9392],"disallowed_STD3_mapped",[40,117,41]],[[9393,9393],"disallowed_STD3_mapped",[40,118,41]],[[9394,9394],"disallowed_STD3_mapped",[40,119,41]],[[9395,9395],"disallowed_STD3_mapped",[40,120,41]],[[9396,9396],"disallowed_STD3_mapped",[40,121,41]],[[9397,9397],"disallowed_STD3_mapped",[40,122,41]],[[9398,9398],"mapped",[97]],[[9399,9399],"mapped",[98]],[[9400,9400],"mapped",[99]],[[9401,9401],"mapped",[100]],[[9402,9402],"mapped",[101]],[[9403,9403],"mapped",[102]],[[9404,9404],"mapped",[103]],[[9405,9405],"mapped",[104]],[[9406,9406],"mapped",[105]],[[9407,9407],"mapped",[106]],[[9408,9408],"mapped",[107]],[[9409,9409],"mapped",[108]],[[9410,9410],"mapped",[109]],[[9411,9411],"mapped",[110]],[[9412,9412],"mapped",[111]],[[9413,9413],"mapped",[112]],[[9414,9414],"mapped",[113]],[[9415,9415],"mapped",[114]],[[9416,9416],"mapped",[115]],[[9417,9417],"mapped",[116]],[[9418,9418],"mapped",[117]],[[9419,9419],"mapped",[118]],[[9420,9420],"mapped",[119]],[[9421,9421],"mapped",[120]],[[9422,9422],"mapped",[121]],[[9423,9423],"mapped",[122]],[[9424,9424],"mapped",[97]],[[9425,9425],"mapped",[98]],[[9426,9426],"mapped",[99]],[[9427,9427],"mapped",[100]],[[9428,9428],"mapped",[101]],[[9429,9429],"mapped",[102]],[[9430,9430],"mapped",[103]],[[9431,9431],"mapped",[104]],[[9432,9432],"mapped",[105]],[[9433,9433],"mapped",[106]],[[9434,9434],"mapped",[107]],[[9435,9435],"mapped",[108]],[[9436,9436],"mapped",[109]],[[9437,9437],"mapped",[110]],[[9438,9438],"mapped",[111]],[[9439,9439],"mapped",[112]],[[9440,9440],"mapped",[113]],[[9441,9441],"mapped",[114]],[[9442,9442],"mapped",[115]],[[9443,9443],"mapped",[116]],[[9444,9444],"mapped",[117]],[[9445,9445],"mapped",[118]],[[9446,9446],"mapped",[119]],[[9447,9447],"mapped",[120]],[[9448,9448],"mapped",[121]],[[9449,9449],"mapped",[122]],[[9450,9450],"mapped",[48]],[[9451,9470],"valid",[],"NV8"],[[9471,9471],"valid",[],"NV8"],[[9472,9621],"valid",[],"NV8"],[[9622,9631],"valid",[],"NV8"],[[9632,9711],"valid",[],"NV8"],[[9712,9719],"valid",[],"NV8"],[[9720,9727],"valid",[],"NV8"],[[9728,9747],"valid",[],"NV8"],[[9748,9749],"valid",[],"NV8"],[[9750,9751],"valid",[],"NV8"],[[9752,9752],"valid",[],"NV8"],[[9753,9753],"valid",[],"NV8"],[[9754,9839],"valid",[],"NV8"],[[9840,9841],"valid",[],"NV8"],[[9842,9853],"valid",[],"NV8"],[[9854,9855],"valid",[],"NV8"],[[9856,9865],"valid",[],"NV8"],[[9866,9873],"valid",[],"NV8"],[[9874,9884],"valid",[],"NV8"],[[9885,9885],"valid",[],"NV8"],[[9886,9887],"valid",[],"NV8"],[[9888,9889],"valid",[],"NV8"],[[9890,9905],"valid",[],"NV8"],[[9906,9906],"valid",[],"NV8"],[[9907,9916],"valid",[],"NV8"],[[9917,9919],"valid",[],"NV8"],[[9920,9923],"valid",[],"NV8"],[[9924,9933],"valid",[],"NV8"],[[9934,9934],"valid",[],"NV8"],[[9935,9953],"valid",[],"NV8"],[[9954,9954],"valid",[],"NV8"],[[9955,9955],"valid",[],"NV8"],[[9956,9959],"valid",[],"NV8"],[[9960,9983],"valid",[],"NV8"],[[9984,9984],"valid",[],"NV8"],[[9985,9988],"valid",[],"NV8"],[[9989,9989],"valid",[],"NV8"],[[9990,9993],"valid",[],"NV8"],[[9994,9995],"valid",[],"NV8"],[[9996,10023],"valid",[],"NV8"],[[10024,10024],"valid",[],"NV8"],[[10025,10059],"valid",[],"NV8"],[[10060,10060],"valid",[],"NV8"],[[10061,10061],"valid",[],"NV8"],[[10062,10062],"valid",[],"NV8"],[[10063,10066],"valid",[],"NV8"],[[10067,10069],"valid",[],"NV8"],[[10070,10070],"valid",[],"NV8"],[[10071,10071],"valid",[],"NV8"],[[10072,10078],"valid",[],"NV8"],[[10079,10080],"valid",[],"NV8"],[[10081,10087],"valid",[],"NV8"],[[10088,10101],"valid",[],"NV8"],[[10102,10132],"valid",[],"NV8"],[[10133,10135],"valid",[],"NV8"],[[10136,10159],"valid",[],"NV8"],[[10160,10160],"valid",[],"NV8"],[[10161,10174],"valid",[],"NV8"],[[10175,10175],"valid",[],"NV8"],[[10176,10182],"valid",[],"NV8"],[[10183,10186],"valid",[],"NV8"],[[10187,10187],"valid",[],"NV8"],[[10188,10188],"valid",[],"NV8"],[[10189,10189],"valid",[],"NV8"],[[10190,10191],"valid",[],"NV8"],[[10192,10219],"valid",[],"NV8"],[[10220,10223],"valid",[],"NV8"],[[10224,10239],"valid",[],"NV8"],[[10240,10495],"valid",[],"NV8"],[[10496,10763],"valid",[],"NV8"],[[10764,10764],"mapped",[8747,8747,8747,8747]],[[10765,10867],"valid",[],"NV8"],[[10868,10868],"disallowed_STD3_mapped",[58,58,61]],[[10869,10869],"disallowed_STD3_mapped",[61,61]],[[10870,10870],"disallowed_STD3_mapped",[61,61,61]],[[10871,10971],"valid",[],"NV8"],[[10972,10972],"mapped",[10973,824]],[[10973,11007],"valid",[],"NV8"],[[11008,11021],"valid",[],"NV8"],[[11022,11027],"valid",[],"NV8"],[[11028,11034],"valid",[],"NV8"],[[11035,11039],"valid",[],"NV8"],[[11040,11043],"valid",[],"NV8"],[[11044,11084],"valid",[],"NV8"],[[11085,11087],"valid",[],"NV8"],[[11088,11092],"valid",[],"NV8"],[[11093,11097],"valid",[],"NV8"],[[11098,11123],"valid",[],"NV8"],[[11124,11125],"disallowed"],[[11126,11157],"valid",[],"NV8"],[[11158,11159],"disallowed"],[[11160,11193],"valid",[],"NV8"],[[11194,11196],"disallowed"],[[11197,11208],"valid",[],"NV8"],[[11209,11209],"disallowed"],[[11210,11217],"valid",[],"NV8"],[[11218,11243],"disallowed"],[[11244,11247],"valid",[],"NV8"],[[11248,11263],"disallowed"],[[11264,11264],"mapped",[11312]],[[11265,11265],"mapped",[11313]],[[11266,11266],"mapped",[11314]],[[11267,11267],"mapped",[11315]],[[11268,11268],"mapped",[11316]],[[11269,11269],"mapped",[11317]],[[11270,11270],"mapped",[11318]],[[11271,11271],"mapped",[11319]],[[11272,11272],"mapped",[11320]],[[11273,11273],"mapped",[11321]],[[11274,11274],"mapped",[11322]],[[11275,11275],"mapped",[11323]],[[11276,11276],"mapped",[11324]],[[11277,11277],"mapped",[11325]],[[11278,11278],"mapped",[11326]],[[11279,11279],"mapped",[11327]],[[11280,11280],"mapped",[11328]],[[11281,11281],"mapped",[11329]],[[11282,11282],"mapped",[11330]],[[11283,11283],"mapped",[11331]],[[11284,11284],"mapped",[11332]],[[11285,11285],"mapped",[11333]],[[11286,11286],"mapped",[11334]],[[11287,11287],"mapped",[11335]],[[11288,11288],"mapped",[11336]],[[11289,11289],"mapped",[11337]],[[11290,11290],"mapped",[11338]],[[11291,11291],"mapped",[11339]],[[11292,11292],"mapped",[11340]],[[11293,11293],"mapped",[11341]],[[11294,11294],"mapped",[11342]],[[11295,11295],"mapped",[11343]],[[11296,11296],"mapped",[11344]],[[11297,11297],"mapped",[11345]],[[11298,11298],"mapped",[11346]],[[11299,11299],"mapped",[11347]],[[11300,11300],"mapped",[11348]],[[11301,11301],"mapped",[11349]],[[11302,11302],"mapped",[11350]],[[11303,11303],"mapped",[11351]],[[11304,11304],"mapped",[11352]],[[11305,11305],"mapped",[11353]],[[11306,11306],"mapped",[11354]],[[11307,11307],"mapped",[11355]],[[11308,11308],"mapped",[11356]],[[11309,11309],"mapped",[11357]],[[11310,11310],"mapped",[11358]],[[11311,11311],"disallowed"],[[11312,11358],"valid"],[[11359,11359],"disallowed"],[[11360,11360],"mapped",[11361]],[[11361,11361],"valid"],[[11362,11362],"mapped",[619]],[[11363,11363],"mapped",[7549]],[[11364,11364],"mapped",[637]],[[11365,11366],"valid"],[[11367,11367],"mapped",[11368]],[[11368,11368],"valid"],[[11369,11369],"mapped",[11370]],[[11370,11370],"valid"],[[11371,11371],"mapped",[11372]],[[11372,11372],"valid"],[[11373,11373],"mapped",[593]],[[11374,11374],"mapped",[625]],[[11375,11375],"mapped",[592]],[[11376,11376],"mapped",[594]],[[11377,11377],"valid"],[[11378,11378],"mapped",[11379]],[[11379,11379],"valid"],[[11380,11380],"valid"],[[11381,11381],"mapped",[11382]],[[11382,11383],"valid"],[[11384,11387],"valid"],[[11388,11388],"mapped",[106]],[[11389,11389],"mapped",[118]],[[11390,11390],"mapped",[575]],[[11391,11391],"mapped",[576]],[[11392,11392],"mapped",[11393]],[[11393,11393],"valid"],[[11394,11394],"mapped",[11395]],[[11395,11395],"valid"],[[11396,11396],"mapped",[11397]],[[11397,11397],"valid"],[[11398,11398],"mapped",[11399]],[[11399,11399],"valid"],[[11400,11400],"mapped",[11401]],[[11401,11401],"valid"],[[11402,11402],"mapped",[11403]],[[11403,11403],"valid"],[[11404,11404],"mapped",[11405]],[[11405,11405],"valid"],[[11406,11406],"mapped",[11407]],[[11407,11407],"valid"],[[11408,11408],"mapped",[11409]],[[11409,11409],"valid"],[[11410,11410],"mapped",[11411]],[[11411,11411],"valid"],[[11412,11412],"mapped",[11413]],[[11413,11413],"valid"],[[11414,11414],"mapped",[11415]],[[11415,11415],"valid"],[[11416,11416],"mapped",[11417]],[[11417,11417],"valid"],[[11418,11418],"mapped",[11419]],[[11419,11419],"valid"],[[11420,11420],"mapped",[11421]],[[11421,11421],"valid"],[[11422,11422],"mapped",[11423]],[[11423,11423],"valid"],[[11424,11424],"mapped",[11425]],[[11425,11425],"valid"],[[11426,11426],"mapped",[11427]],[[11427,11427],"valid"],[[11428,11428],"mapped",[11429]],[[11429,11429],"valid"],[[11430,11430],"mapped",[11431]],[[11431,11431],"valid"],[[11432,11432],"mapped",[11433]],[[11433,11433],"valid"],[[11434,11434],"mapped",[11435]],[[11435,11435],"valid"],[[11436,11436],"mapped",[11437]],[[11437,11437],"valid"],[[11438,11438],"mapped",[11439]],[[11439,11439],"valid"],[[11440,11440],"mapped",[11441]],[[11441,11441],"valid"],[[11442,11442],"mapped",[11443]],[[11443,11443],"valid"],[[11444,11444],"mapped",[11445]],[[11445,11445],"valid"],[[11446,11446],"mapped",[11447]],[[11447,11447],"valid"],[[11448,11448],"mapped",[11449]],[[11449,11449],"valid"],[[11450,11450],"mapped",[11451]],[[11451,11451],"valid"],[[11452,11452],"mapped",[11453]],[[11453,11453],"valid"],[[11454,11454],"mapped",[11455]],[[11455,11455],"valid"],[[11456,11456],"mapped",[11457]],[[11457,11457],"valid"],[[11458,11458],"mapped",[11459]],[[11459,11459],"valid"],[[11460,11460],"mapped",[11461]],[[11461,11461],"valid"],[[11462,11462],"mapped",[11463]],[[11463,11463],"valid"],[[11464,11464],"mapped",[11465]],[[11465,11465],"valid"],[[11466,11466],"mapped",[11467]],[[11467,11467],"valid"],[[11468,11468],"mapped",[11469]],[[11469,11469],"valid"],[[11470,11470],"mapped",[11471]],[[11471,11471],"valid"],[[11472,11472],"mapped",[11473]],[[11473,11473],"valid"],[[11474,11474],"mapped",[11475]],[[11475,11475],"valid"],[[11476,11476],"mapped",[11477]],[[11477,11477],"valid"],[[11478,11478],"mapped",[11479]],[[11479,11479],"valid"],[[11480,11480],"mapped",[11481]],[[11481,11481],"valid"],[[11482,11482],"mapped",[11483]],[[11483,11483],"valid"],[[11484,11484],"mapped",[11485]],[[11485,11485],"valid"],[[11486,11486],"mapped",[11487]],[[11487,11487],"valid"],[[11488,11488],"mapped",[11489]],[[11489,11489],"valid"],[[11490,11490],"mapped",[11491]],[[11491,11492],"valid"],[[11493,11498],"valid",[],"NV8"],[[11499,11499],"mapped",[11500]],[[11500,11500],"valid"],[[11501,11501],"mapped",[11502]],[[11502,11505],"valid"],[[11506,11506],"mapped",[11507]],[[11507,11507],"valid"],[[11508,11512],"disallowed"],[[11513,11519],"valid",[],"NV8"],[[11520,11557],"valid"],[[11558,11558],"disallowed"],[[11559,11559],"valid"],[[11560,11564],"disallowed"],[[11565,11565],"valid"],[[11566,11567],"disallowed"],[[11568,11621],"valid"],[[11622,11623],"valid"],[[11624,11630],"disallowed"],[[11631,11631],"mapped",[11617]],[[11632,11632],"valid",[],"NV8"],[[11633,11646],"disallowed"],[[11647,11647],"valid"],[[11648,11670],"valid"],[[11671,11679],"disallowed"],[[11680,11686],"valid"],[[11687,11687],"disallowed"],[[11688,11694],"valid"],[[11695,11695],"disallowed"],[[11696,11702],"valid"],[[11703,11703],"disallowed"],[[11704,11710],"valid"],[[11711,11711],"disallowed"],[[11712,11718],"valid"],[[11719,11719],"disallowed"],[[11720,11726],"valid"],[[11727,11727],"disallowed"],[[11728,11734],"valid"],[[11735,11735],"disallowed"],[[11736,11742],"valid"],[[11743,11743],"disallowed"],[[11744,11775],"valid"],[[11776,11799],"valid",[],"NV8"],[[11800,11803],"valid",[],"NV8"],[[11804,11805],"valid",[],"NV8"],[[11806,11822],"valid",[],"NV8"],[[11823,11823],"valid"],[[11824,11824],"valid",[],"NV8"],[[11825,11825],"valid",[],"NV8"],[[11826,11835],"valid",[],"NV8"],[[11836,11842],"valid",[],"NV8"],[[11843,11903],"disallowed"],[[11904,11929],"valid",[],"NV8"],[[11930,11930],"disallowed"],[[11931,11934],"valid",[],"NV8"],[[11935,11935],"mapped",[27597]],[[11936,12018],"valid",[],"NV8"],[[12019,12019],"mapped",[40863]],[[12020,12031],"disallowed"],[[12032,12032],"mapped",[19968]],[[12033,12033],"mapped",[20008]],[[12034,12034],"mapped",[20022]],[[12035,12035],"mapped",[20031]],[[12036,12036],"mapped",[20057]],[[12037,12037],"mapped",[20101]],[[12038,12038],"mapped",[20108]],[[12039,12039],"mapped",[20128]],[[12040,12040],"mapped",[20154]],[[12041,12041],"mapped",[20799]],[[12042,12042],"mapped",[20837]],[[12043,12043],"mapped",[20843]],[[12044,12044],"mapped",[20866]],[[12045,12045],"mapped",[20886]],[[12046,12046],"mapped",[20907]],[[12047,12047],"mapped",[20960]],[[12048,12048],"mapped",[20981]],[[12049,12049],"mapped",[20992]],[[12050,12050],"mapped",[21147]],[[12051,12051],"mapped",[21241]],[[12052,12052],"mapped",[21269]],[[12053,12053],"mapped",[21274]],[[12054,12054],"mapped",[21304]],[[12055,12055],"mapped",[21313]],[[12056,12056],"mapped",[21340]],[[12057,12057],"mapped",[21353]],[[12058,12058],"mapped",[21378]],[[12059,12059],"mapped",[21430]],[[12060,12060],"mapped",[21448]],[[12061,12061],"mapped",[21475]],[[12062,12062],"mapped",[22231]],[[12063,12063],"mapped",[22303]],[[12064,12064],"mapped",[22763]],[[12065,12065],"mapped",[22786]],[[12066,12066],"mapped",[22794]],[[12067,12067],"mapped",[22805]],[[12068,12068],"mapped",[22823]],[[12069,12069],"mapped",[22899]],[[12070,12070],"mapped",[23376]],[[12071,12071],"mapped",[23424]],[[12072,12072],"mapped",[23544]],[[12073,12073],"mapped",[23567]],[[12074,12074],"mapped",[23586]],[[12075,12075],"mapped",[23608]],[[12076,12076],"mapped",[23662]],[[12077,12077],"mapped",[23665]],[[12078,12078],"mapped",[24027]],[[12079,12079],"mapped",[24037]],[[12080,12080],"mapped",[24049]],[[12081,12081],"mapped",[24062]],[[12082,12082],"mapped",[24178]],[[12083,12083],"mapped",[24186]],[[12084,12084],"mapped",[24191]],[[12085,12085],"mapped",[24308]],[[12086,12086],"mapped",[24318]],[[12087,12087],"mapped",[24331]],[[12088,12088],"mapped",[24339]],[[12089,12089],"mapped",[24400]],[[12090,12090],"mapped",[24417]],[[12091,12091],"mapped",[24435]],[[12092,12092],"mapped",[24515]],[[12093,12093],"mapped",[25096]],[[12094,12094],"mapped",[25142]],[[12095,12095],"mapped",[25163]],[[12096,12096],"mapped",[25903]],[[12097,12097],"mapped",[25908]],[[12098,12098],"mapped",[25991]],[[12099,12099],"mapped",[26007]],[[12100,12100],"mapped",[26020]],[[12101,12101],"mapped",[26041]],[[12102,12102],"mapped",[26080]],[[12103,12103],"mapped",[26085]],[[12104,12104],"mapped",[26352]],[[12105,12105],"mapped",[26376]],[[12106,12106],"mapped",[26408]],[[12107,12107],"mapped",[27424]],[[12108,12108],"mapped",[27490]],[[12109,12109],"mapped",[27513]],[[12110,12110],"mapped",[27571]],[[12111,12111],"mapped",[27595]],[[12112,12112],"mapped",[27604]],[[12113,12113],"mapped",[27611]],[[12114,12114],"mapped",[27663]],[[12115,12115],"mapped",[27668]],[[12116,12116],"mapped",[27700]],[[12117,12117],"mapped",[28779]],[[12118,12118],"mapped",[29226]],[[12119,12119],"mapped",[29238]],[[12120,12120],"mapped",[29243]],[[12121,12121],"mapped",[29247]],[[12122,12122],"mapped",[29255]],[[12123,12123],"mapped",[29273]],[[12124,12124],"mapped",[29275]],[[12125,12125],"mapped",[29356]],[[12126,12126],"mapped",[29572]],[[12127,12127],"mapped",[29577]],[[12128,12128],"mapped",[29916]],[[12129,12129],"mapped",[29926]],[[12130,12130],"mapped",[29976]],[[12131,12131],"mapped",[29983]],[[12132,12132],"mapped",[29992]],[[12133,12133],"mapped",[30000]],[[12134,12134],"mapped",[30091]],[[12135,12135],"mapped",[30098]],[[12136,12136],"mapped",[30326]],[[12137,12137],"mapped",[30333]],[[12138,12138],"mapped",[30382]],[[12139,12139],"mapped",[30399]],[[12140,12140],"mapped",[30446]],[[12141,12141],"mapped",[30683]],[[12142,12142],"mapped",[30690]],[[12143,12143],"mapped",[30707]],[[12144,12144],"mapped",[31034]],[[12145,12145],"mapped",[31160]],[[12146,12146],"mapped",[31166]],[[12147,12147],"mapped",[31348]],[[12148,12148],"mapped",[31435]],[[12149,12149],"mapped",[31481]],[[12150,12150],"mapped",[31859]],[[12151,12151],"mapped",[31992]],[[12152,12152],"mapped",[32566]],[[12153,12153],"mapped",[32593]],[[12154,12154],"mapped",[32650]],[[12155,12155],"mapped",[32701]],[[12156,12156],"mapped",[32769]],[[12157,12157],"mapped",[32780]],[[12158,12158],"mapped",[32786]],[[12159,12159],"mapped",[32819]],[[12160,12160],"mapped",[32895]],[[12161,12161],"mapped",[32905]],[[12162,12162],"mapped",[33251]],[[12163,12163],"mapped",[33258]],[[12164,12164],"mapped",[33267]],[[12165,12165],"mapped",[33276]],[[12166,12166],"mapped",[33292]],[[12167,12167],"mapped",[33307]],[[12168,12168],"mapped",[33311]],[[12169,12169],"mapped",[33390]],[[12170,12170],"mapped",[33394]],[[12171,12171],"mapped",[33400]],[[12172,12172],"mapped",[34381]],[[12173,12173],"mapped",[34411]],[[12174,12174],"mapped",[34880]],[[12175,12175],"mapped",[34892]],[[12176,12176],"mapped",[34915]],[[12177,12177],"mapped",[35198]],[[12178,12178],"mapped",[35211]],[[12179,12179],"mapped",[35282]],[[12180,12180],"mapped",[35328]],[[12181,12181],"mapped",[35895]],[[12182,12182],"mapped",[35910]],[[12183,12183],"mapped",[35925]],[[12184,12184],"mapped",[35960]],[[12185,12185],"mapped",[35997]],[[12186,12186],"mapped",[36196]],[[12187,12187],"mapped",[36208]],[[12188,12188],"mapped",[36275]],[[12189,12189],"mapped",[36523]],[[12190,12190],"mapped",[36554]],[[12191,12191],"mapped",[36763]],[[12192,12192],"mapped",[36784]],[[12193,12193],"mapped",[36789]],[[12194,12194],"mapped",[37009]],[[12195,12195],"mapped",[37193]],[[12196,12196],"mapped",[37318]],[[12197,12197],"mapped",[37324]],[[12198,12198],"mapped",[37329]],[[12199,12199],"mapped",[38263]],[[12200,12200],"mapped",[38272]],[[12201,12201],"mapped",[38428]],[[12202,12202],"mapped",[38582]],[[12203,12203],"mapped",[38585]],[[12204,12204],"mapped",[38632]],[[12205,12205],"mapped",[38737]],[[12206,12206],"mapped",[38750]],[[12207,12207],"mapped",[38754]],[[12208,12208],"mapped",[38761]],[[12209,12209],"mapped",[38859]],[[12210,12210],"mapped",[38893]],[[12211,12211],"mapped",[38899]],[[12212,12212],"mapped",[38913]],[[12213,12213],"mapped",[39080]],[[12214,12214],"mapped",[39131]],[[12215,12215],"mapped",[39135]],[[12216,12216],"mapped",[39318]],[[12217,12217],"mapped",[39321]],[[12218,12218],"mapped",[39340]],[[12219,12219],"mapped",[39592]],[[12220,12220],"mapped",[39640]],[[12221,12221],"mapped",[39647]],[[12222,12222],"mapped",[39717]],[[12223,12223],"mapped",[39727]],[[12224,12224],"mapped",[39730]],[[12225,12225],"mapped",[39740]],[[12226,12226],"mapped",[39770]],[[12227,12227],"mapped",[40165]],[[12228,12228],"mapped",[40565]],[[12229,12229],"mapped",[40575]],[[12230,12230],"mapped",[40613]],[[12231,12231],"mapped",[40635]],[[12232,12232],"mapped",[40643]],[[12233,12233],"mapped",[40653]],[[12234,12234],"mapped",[40657]],[[12235,12235],"mapped",[40697]],[[12236,12236],"mapped",[40701]],[[12237,12237],"mapped",[40718]],[[12238,12238],"mapped",[40723]],[[12239,12239],"mapped",[40736]],[[12240,12240],"mapped",[40763]],[[12241,12241],"mapped",[40778]],[[12242,12242],"mapped",[40786]],[[12243,12243],"mapped",[40845]],[[12244,12244],"mapped",[40860]],[[12245,12245],"mapped",[40864]],[[12246,12271],"disallowed"],[[12272,12283],"disallowed"],[[12284,12287],"disallowed"],[[12288,12288],"disallowed_STD3_mapped",[32]],[[12289,12289],"valid",[],"NV8"],[[12290,12290],"mapped",[46]],[[12291,12292],"valid",[],"NV8"],[[12293,12295],"valid"],[[12296,12329],"valid",[],"NV8"],[[12330,12333],"valid"],[[12334,12341],"valid",[],"NV8"],[[12342,12342],"mapped",[12306]],[[12343,12343],"valid",[],"NV8"],[[12344,12344],"mapped",[21313]],[[12345,12345],"mapped",[21316]],[[12346,12346],"mapped",[21317]],[[12347,12347],"valid",[],"NV8"],[[12348,12348],"valid"],[[12349,12349],"valid",[],"NV8"],[[12350,12350],"valid",[],"NV8"],[[12351,12351],"valid",[],"NV8"],[[12352,12352],"disallowed"],[[12353,12436],"valid"],[[12437,12438],"valid"],[[12439,12440],"disallowed"],[[12441,12442],"valid"],[[12443,12443],"disallowed_STD3_mapped",[32,12441]],[[12444,12444],"disallowed_STD3_mapped",[32,12442]],[[12445,12446],"valid"],[[12447,12447],"mapped",[12424,12426]],[[12448,12448],"valid",[],"NV8"],[[12449,12542],"valid"],[[12543,12543],"mapped",[12467,12488]],[[12544,12548],"disallowed"],[[12549,12588],"valid"],[[12589,12589],"valid"],[[12590,12592],"disallowed"],[[12593,12593],"mapped",[4352]],[[12594,12594],"mapped",[4353]],[[12595,12595],"mapped",[4522]],[[12596,12596],"mapped",[4354]],[[12597,12597],"mapped",[4524]],[[12598,12598],"mapped",[4525]],[[12599,12599],"mapped",[4355]],[[12600,12600],"mapped",[4356]],[[12601,12601],"mapped",[4357]],[[12602,12602],"mapped",[4528]],[[12603,12603],"mapped",[4529]],[[12604,12604],"mapped",[4530]],[[12605,12605],"mapped",[4531]],[[12606,12606],"mapped",[4532]],[[12607,12607],"mapped",[4533]],[[12608,12608],"mapped",[4378]],[[12609,12609],"mapped",[4358]],[[12610,12610],"mapped",[4359]],[[12611,12611],"mapped",[4360]],[[12612,12612],"mapped",[4385]],[[12613,12613],"mapped",[4361]],[[12614,12614],"mapped",[4362]],[[12615,12615],"mapped",[4363]],[[12616,12616],"mapped",[4364]],[[12617,12617],"mapped",[4365]],[[12618,12618],"mapped",[4366]],[[12619,12619],"mapped",[4367]],[[12620,12620],"mapped",[4368]],[[12621,12621],"mapped",[4369]],[[12622,12622],"mapped",[4370]],[[12623,12623],"mapped",[4449]],[[12624,12624],"mapped",[4450]],[[12625,12625],"mapped",[4451]],[[12626,12626],"mapped",[4452]],[[12627,12627],"mapped",[4453]],[[12628,12628],"mapped",[4454]],[[12629,12629],"mapped",[4455]],[[12630,12630],"mapped",[4456]],[[12631,12631],"mapped",[4457]],[[12632,12632],"mapped",[4458]],[[12633,12633],"mapped",[4459]],[[12634,12634],"mapped",[4460]],[[12635,12635],"mapped",[4461]],[[12636,12636],"mapped",[4462]],[[12637,12637],"mapped",[4463]],[[12638,12638],"mapped",[4464]],[[12639,12639],"mapped",[4465]],[[12640,12640],"mapped",[4466]],[[12641,12641],"mapped",[4467]],[[12642,12642],"mapped",[4468]],[[12643,12643],"mapped",[4469]],[[12644,12644],"disallowed"],[[12645,12645],"mapped",[4372]],[[12646,12646],"mapped",[4373]],[[12647,12647],"mapped",[4551]],[[12648,12648],"mapped",[4552]],[[12649,12649],"mapped",[4556]],[[12650,12650],"mapped",[4558]],[[12651,12651],"mapped",[4563]],[[12652,12652],"mapped",[4567]],[[12653,12653],"mapped",[4569]],[[12654,12654],"mapped",[4380]],[[12655,12655],"mapped",[4573]],[[12656,12656],"mapped",[4575]],[[12657,12657],"mapped",[4381]],[[12658,12658],"mapped",[4382]],[[12659,12659],"mapped",[4384]],[[12660,12660],"mapped",[4386]],[[12661,12661],"mapped",[4387]],[[12662,12662],"mapped",[4391]],[[12663,12663],"mapped",[4393]],[[12664,12664],"mapped",[4395]],[[12665,12665],"mapped",[4396]],[[12666,12666],"mapped",[4397]],[[12667,12667],"mapped",[4398]],[[12668,12668],"mapped",[4399]],[[12669,12669],"mapped",[4402]],[[12670,12670],"mapped",[4406]],[[12671,12671],"mapped",[4416]],[[12672,12672],"mapped",[4423]],[[12673,12673],"mapped",[4428]],[[12674,12674],"mapped",[4593]],[[12675,12675],"mapped",[4594]],[[12676,12676],"mapped",[4439]],[[12677,12677],"mapped",[4440]],[[12678,12678],"mapped",[4441]],[[12679,12679],"mapped",[4484]],[[12680,12680],"mapped",[4485]],[[12681,12681],"mapped",[4488]],[[12682,12682],"mapped",[4497]],[[12683,12683],"mapped",[4498]],[[12684,12684],"mapped",[4500]],[[12685,12685],"mapped",[4510]],[[12686,12686],"mapped",[4513]],[[12687,12687],"disallowed"],[[12688,12689],"valid",[],"NV8"],[[12690,12690],"mapped",[19968]],[[12691,12691],"mapped",[20108]],[[12692,12692],"mapped",[19977]],[[12693,12693],"mapped",[22235]],[[12694,12694],"mapped",[19978]],[[12695,12695],"mapped",[20013]],[[12696,12696],"mapped",[19979]],[[12697,12697],"mapped",[30002]],[[12698,12698],"mapped",[20057]],[[12699,12699],"mapped",[19993]],[[12700,12700],"mapped",[19969]],[[12701,12701],"mapped",[22825]],[[12702,12702],"mapped",[22320]],[[12703,12703],"mapped",[20154]],[[12704,12727],"valid"],[[12728,12730],"valid"],[[12731,12735],"disallowed"],[[12736,12751],"valid",[],"NV8"],[[12752,12771],"valid",[],"NV8"],[[12772,12783],"disallowed"],[[12784,12799],"valid"],[[12800,12800],"disallowed_STD3_mapped",[40,4352,41]],[[12801,12801],"disallowed_STD3_mapped",[40,4354,41]],[[12802,12802],"disallowed_STD3_mapped",[40,4355,41]],[[12803,12803],"disallowed_STD3_mapped",[40,4357,41]],[[12804,12804],"disallowed_STD3_mapped",[40,4358,41]],[[12805,12805],"disallowed_STD3_mapped",[40,4359,41]],[[12806,12806],"disallowed_STD3_mapped",[40,4361,41]],[[12807,12807],"disallowed_STD3_mapped",[40,4363,41]],[[12808,12808],"disallowed_STD3_mapped",[40,4364,41]],[[12809,12809],"disallowed_STD3_mapped",[40,4366,41]],[[12810,12810],"disallowed_STD3_mapped",[40,4367,41]],[[12811,12811],"disallowed_STD3_mapped",[40,4368,41]],[[12812,12812],"disallowed_STD3_mapped",[40,4369,41]],[[12813,12813],"disallowed_STD3_mapped",[40,4370,41]],[[12814,12814],"disallowed_STD3_mapped",[40,44032,41]],[[12815,12815],"disallowed_STD3_mapped",[40,45208,41]],[[12816,12816],"disallowed_STD3_mapped",[40,45796,41]],[[12817,12817],"disallowed_STD3_mapped",[40,46972,41]],[[12818,12818],"disallowed_STD3_mapped",[40,47560,41]],[[12819,12819],"disallowed_STD3_mapped",[40,48148,41]],[[12820,12820],"disallowed_STD3_mapped",[40,49324,41]],[[12821,12821],"disallowed_STD3_mapped",[40,50500,41]],[[12822,12822],"disallowed_STD3_mapped",[40,51088,41]],[[12823,12823],"disallowed_STD3_mapped",[40,52264,41]],[[12824,12824],"disallowed_STD3_mapped",[40,52852,41]],[[12825,12825],"disallowed_STD3_mapped",[40,53440,41]],[[12826,12826],"disallowed_STD3_mapped",[40,54028,41]],[[12827,12827],"disallowed_STD3_mapped",[40,54616,41]],[[12828,12828],"disallowed_STD3_mapped",[40,51452,41]],[[12829,12829],"disallowed_STD3_mapped",[40,50724,51204,41]],[[12830,12830],"disallowed_STD3_mapped",[40,50724,54980,41]],[[12831,12831],"disallowed"],[[12832,12832],"disallowed_STD3_mapped",[40,19968,41]],[[12833,12833],"disallowed_STD3_mapped",[40,20108,41]],[[12834,12834],"disallowed_STD3_mapped",[40,19977,41]],[[12835,12835],"disallowed_STD3_mapped",[40,22235,41]],[[12836,12836],"disallowed_STD3_mapped",[40,20116,41]],[[12837,12837],"disallowed_STD3_mapped",[40,20845,41]],[[12838,12838],"disallowed_STD3_mapped",[40,19971,41]],[[12839,12839],"disallowed_STD3_mapped",[40,20843,41]],[[12840,12840],"disallowed_STD3_mapped",[40,20061,41]],[[12841,12841],"disallowed_STD3_mapped",[40,21313,41]],[[12842,12842],"disallowed_STD3_mapped",[40,26376,41]],[[12843,12843],"disallowed_STD3_mapped",[40,28779,41]],[[12844,12844],"disallowed_STD3_mapped",[40,27700,41]],[[12845,12845],"disallowed_STD3_mapped",[40,26408,41]],[[12846,12846],"disallowed_STD3_mapped",[40,37329,41]],[[12847,12847],"disallowed_STD3_mapped",[40,22303,41]],[[12848,12848],"disallowed_STD3_mapped",[40,26085,41]],[[12849,12849],"disallowed_STD3_mapped",[40,26666,41]],[[12850,12850],"disallowed_STD3_mapped",[40,26377,41]],[[12851,12851],"disallowed_STD3_mapped",[40,31038,41]],[[12852,12852],"disallowed_STD3_mapped",[40,21517,41]],[[12853,12853],"disallowed_STD3_mapped",[40,29305,41]],[[12854,12854],"disallowed_STD3_mapped",[40,36001,41]],[[12855,12855],"disallowed_STD3_mapped",[40,31069,41]],[[12856,12856],"disallowed_STD3_mapped",[40,21172,41]],[[12857,12857],"disallowed_STD3_mapped",[40,20195,41]],[[12858,12858],"disallowed_STD3_mapped",[40,21628,41]],[[12859,12859],"disallowed_STD3_mapped",[40,23398,41]],[[12860,12860],"disallowed_STD3_mapped",[40,30435,41]],[[12861,12861],"disallowed_STD3_mapped",[40,20225,41]],[[12862,12862],"disallowed_STD3_mapped",[40,36039,41]],[[12863,12863],"disallowed_STD3_mapped",[40,21332,41]],[[12864,12864],"disallowed_STD3_mapped",[40,31085,41]],[[12865,12865],"disallowed_STD3_mapped",[40,20241,41]],[[12866,12866],"disallowed_STD3_mapped",[40,33258,41]],[[12867,12867],"disallowed_STD3_mapped",[40,33267,41]],[[12868,12868],"mapped",[21839]],[[12869,12869],"mapped",[24188]],[[12870,12870],"mapped",[25991]],[[12871,12871],"mapped",[31631]],[[12872,12879],"valid",[],"NV8"],[[12880,12880],"mapped",[112,116,101]],[[12881,12881],"mapped",[50,49]],[[12882,12882],"mapped",[50,50]],[[12883,12883],"mapped",[50,51]],[[12884,12884],"mapped",[50,52]],[[12885,12885],"mapped",[50,53]],[[12886,12886],"mapped",[50,54]],[[12887,12887],"mapped",[50,55]],[[12888,12888],"mapped",[50,56]],[[12889,12889],"mapped",[50,57]],[[12890,12890],"mapped",[51,48]],[[12891,12891],"mapped",[51,49]],[[12892,12892],"mapped",[51,50]],[[12893,12893],"mapped",[51,51]],[[12894,12894],"mapped",[51,52]],[[12895,12895],"mapped",[51,53]],[[12896,12896],"mapped",[4352]],[[12897,12897],"mapped",[4354]],[[12898,12898],"mapped",[4355]],[[12899,12899],"mapped",[4357]],[[12900,12900],"mapped",[4358]],[[12901,12901],"mapped",[4359]],[[12902,12902],"mapped",[4361]],[[12903,12903],"mapped",[4363]],[[12904,12904],"mapped",[4364]],[[12905,12905],"mapped",[4366]],[[12906,12906],"mapped",[4367]],[[12907,12907],"mapped",[4368]],[[12908,12908],"mapped",[4369]],[[12909,12909],"mapped",[4370]],[[12910,12910],"mapped",[44032]],[[12911,12911],"mapped",[45208]],[[12912,12912],"mapped",[45796]],[[12913,12913],"mapped",[46972]],[[12914,12914],"mapped",[47560]],[[12915,12915],"mapped",[48148]],[[12916,12916],"mapped",[49324]],[[12917,12917],"mapped",[50500]],[[12918,12918],"mapped",[51088]],[[12919,12919],"mapped",[52264]],[[12920,12920],"mapped",[52852]],[[12921,12921],"mapped",[53440]],[[12922,12922],"mapped",[54028]],[[12923,12923],"mapped",[54616]],[[12924,12924],"mapped",[52280,44256]],[[12925,12925],"mapped",[51452,51032]],[[12926,12926],"mapped",[50864]],[[12927,12927],"valid",[],"NV8"],[[12928,12928],"mapped",[19968]],[[12929,12929],"mapped",[20108]],[[12930,12930],"mapped",[19977]],[[12931,12931],"mapped",[22235]],[[12932,12932],"mapped",[20116]],[[12933,12933],"mapped",[20845]],[[12934,12934],"mapped",[19971]],[[12935,12935],"mapped",[20843]],[[12936,12936],"mapped",[20061]],[[12937,12937],"mapped",[21313]],[[12938,12938],"mapped",[26376]],[[12939,12939],"mapped",[28779]],[[12940,12940],"mapped",[27700]],[[12941,12941],"mapped",[26408]],[[12942,12942],"mapped",[37329]],[[12943,12943],"mapped",[22303]],[[12944,12944],"mapped",[26085]],[[12945,12945],"mapped",[26666]],[[12946,12946],"mapped",[26377]],[[12947,12947],"mapped",[31038]],[[12948,12948],"mapped",[21517]],[[12949,12949],"mapped",[29305]],[[12950,12950],"mapped",[36001]],[[12951,12951],"mapped",[31069]],[[12952,12952],"mapped",[21172]],[[12953,12953],"mapped",[31192]],[[12954,12954],"mapped",[30007]],[[12955,12955],"mapped",[22899]],[[12956,12956],"mapped",[36969]],[[12957,12957],"mapped",[20778]],[[12958,12958],"mapped",[21360]],[[12959,12959],"mapped",[27880]],[[12960,12960],"mapped",[38917]],[[12961,12961],"mapped",[20241]],[[12962,12962],"mapped",[20889]],[[12963,12963],"mapped",[27491]],[[12964,12964],"mapped",[19978]],[[12965,12965],"mapped",[20013]],[[12966,12966],"mapped",[19979]],[[12967,12967],"mapped",[24038]],[[12968,12968],"mapped",[21491]],[[12969,12969],"mapped",[21307]],[[12970,12970],"mapped",[23447]],[[12971,12971],"mapped",[23398]],[[12972,12972],"mapped",[30435]],[[12973,12973],"mapped",[20225]],[[12974,12974],"mapped",[36039]],[[12975,12975],"mapped",[21332]],[[12976,12976],"mapped",[22812]],[[12977,12977],"mapped",[51,54]],[[12978,12978],"mapped",[51,55]],[[12979,12979],"mapped",[51,56]],[[12980,12980],"mapped",[51,57]],[[12981,12981],"mapped",[52,48]],[[12982,12982],"mapped",[52,49]],[[12983,12983],"mapped",[52,50]],[[12984,12984],"mapped",[52,51]],[[12985,12985],"mapped",[52,52]],[[12986,12986],"mapped",[52,53]],[[12987,12987],"mapped",[52,54]],[[12988,12988],"mapped",[52,55]],[[12989,12989],"mapped",[52,56]],[[12990,12990],"mapped",[52,57]],[[12991,12991],"mapped",[53,48]],[[12992,12992],"mapped",[49,26376]],[[12993,12993],"mapped",[50,26376]],[[12994,12994],"mapped",[51,26376]],[[12995,12995],"mapped",[52,26376]],[[12996,12996],"mapped",[53,26376]],[[12997,12997],"mapped",[54,26376]],[[12998,12998],"mapped",[55,26376]],[[12999,12999],"mapped",[56,26376]],[[13000,13000],"mapped",[57,26376]],[[13001,13001],"mapped",[49,48,26376]],[[13002,13002],"mapped",[49,49,26376]],[[13003,13003],"mapped",[49,50,26376]],[[13004,13004],"mapped",[104,103]],[[13005,13005],"mapped",[101,114,103]],[[13006,13006],"mapped",[101,118]],[[13007,13007],"mapped",[108,116,100]],[[13008,13008],"mapped",[12450]],[[13009,13009],"mapped",[12452]],[[13010,13010],"mapped",[12454]],[[13011,13011],"mapped",[12456]],[[13012,13012],"mapped",[12458]],[[13013,13013],"mapped",[12459]],[[13014,13014],"mapped",[12461]],[[13015,13015],"mapped",[12463]],[[13016,13016],"mapped",[12465]],[[13017,13017],"mapped",[12467]],[[13018,13018],"mapped",[12469]],[[13019,13019],"mapped",[12471]],[[13020,13020],"mapped",[12473]],[[13021,13021],"mapped",[12475]],[[13022,13022],"mapped",[12477]],[[13023,13023],"mapped",[12479]],[[13024,13024],"mapped",[12481]],[[13025,13025],"mapped",[12484]],[[13026,13026],"mapped",[12486]],[[13027,13027],"mapped",[12488]],[[13028,13028],"mapped",[12490]],[[13029,13029],"mapped",[12491]],[[13030,13030],"mapped",[12492]],[[13031,13031],"mapped",[12493]],[[13032,13032],"mapped",[12494]],[[13033,13033],"mapped",[12495]],[[13034,13034],"mapped",[12498]],[[13035,13035],"mapped",[12501]],[[13036,13036],"mapped",[12504]],[[13037,13037],"mapped",[12507]],[[13038,13038],"mapped",[12510]],[[13039,13039],"mapped",[12511]],[[13040,13040],"mapped",[12512]],[[13041,13041],"mapped",[12513]],[[13042,13042],"mapped",[12514]],[[13043,13043],"mapped",[12516]],[[13044,13044],"mapped",[12518]],[[13045,13045],"mapped",[12520]],[[13046,13046],"mapped",[12521]],[[13047,13047],"mapped",[12522]],[[13048,13048],"mapped",[12523]],[[13049,13049],"mapped",[12524]],[[13050,13050],"mapped",[12525]],[[13051,13051],"mapped",[12527]],[[13052,13052],"mapped",[12528]],[[13053,13053],"mapped",[12529]],[[13054,13054],"mapped",[12530]],[[13055,13055],"disallowed"],[[13056,13056],"mapped",[12450,12497,12540,12488]],[[13057,13057],"mapped",[12450,12523,12501,12449]],[[13058,13058],"mapped",[12450,12531,12506,12450]],[[13059,13059],"mapped",[12450,12540,12523]],[[13060,13060],"mapped",[12452,12491,12531,12464]],[[13061,13061],"mapped",[12452,12531,12481]],[[13062,13062],"mapped",[12454,12457,12531]],[[13063,13063],"mapped",[12456,12473,12463,12540,12489]],[[13064,13064],"mapped",[12456,12540,12459,12540]],[[13065,13065],"mapped",[12458,12531,12473]],[[13066,13066],"mapped",[12458,12540,12512]],[[13067,13067],"mapped",[12459,12452,12522]],[[13068,13068],"mapped",[12459,12521,12483,12488]],[[13069,13069],"mapped",[12459,12525,12522,12540]],[[13070,13070],"mapped",[12460,12525,12531]],[[13071,13071],"mapped",[12460,12531,12510]],[[13072,13072],"mapped",[12462,12460]],[[13073,13073],"mapped",[12462,12491,12540]],[[13074,13074],"mapped",[12461,12517,12522,12540]],[[13075,13075],"mapped",[12462,12523,12480,12540]],[[13076,13076],"mapped",[12461,12525]],[[13077,13077],"mapped",[12461,12525,12464,12521,12512]],[[13078,13078],"mapped",[12461,12525,12513,12540,12488,12523]],[[13079,13079],"mapped",[12461,12525,12527,12483,12488]],[[13080,13080],"mapped",[12464,12521,12512]],[[13081,13081],"mapped",[12464,12521,12512,12488,12531]],[[13082,13082],"mapped",[12463,12523,12476,12452,12525]],[[13083,13083],"mapped",[12463,12525,12540,12493]],[[13084,13084],"mapped",[12465,12540,12473]],[[13085,13085],"mapped",[12467,12523,12490]],[[13086,13086],"mapped",[12467,12540,12509]],[[13087,13087],"mapped",[12469,12452,12463,12523]],[[13088,13088],"mapped",[12469,12531,12481,12540,12512]],[[13089,13089],"mapped",[12471,12522,12531,12464]],[[13090,13090],"mapped",[12475,12531,12481]],[[13091,13091],"mapped",[12475,12531,12488]],[[13092,13092],"mapped",[12480,12540,12473]],[[13093,13093],"mapped",[12487,12471]],[[13094,13094],"mapped",[12489,12523]],[[13095,13095],"mapped",[12488,12531]],[[13096,13096],"mapped",[12490,12494]],[[13097,13097],"mapped",[12494,12483,12488]],[[13098,13098],"mapped",[12495,12452,12484]],[[13099,13099],"mapped",[12497,12540,12475,12531,12488]],[[13100,13100],"mapped",[12497,12540,12484]],[[13101,13101],"mapped",[12496,12540,12524,12523]],[[13102,13102],"mapped",[12500,12450,12473,12488,12523]],[[13103,13103],"mapped",[12500,12463,12523]],[[13104,13104],"mapped",[12500,12467]],[[13105,13105],"mapped",[12499,12523]],[[13106,13106],"mapped",[12501,12449,12521,12483,12489]],[[13107,13107],"mapped",[12501,12451,12540,12488]],[[13108,13108],"mapped",[12502,12483,12471,12455,12523]],[[13109,13109],"mapped",[12501,12521,12531]],[[13110,13110],"mapped",[12504,12463,12479,12540,12523]],[[13111,13111],"mapped",[12506,12477]],[[13112,13112],"mapped",[12506,12491,12498]],[[13113,13113],"mapped",[12504,12523,12484]],[[13114,13114],"mapped",[12506,12531,12473]],[[13115,13115],"mapped",[12506,12540,12472]],[[13116,13116],"mapped",[12505,12540,12479]],[[13117,13117],"mapped",[12509,12452,12531,12488]],[[13118,13118],"mapped",[12508,12523,12488]],[[13119,13119],"mapped",[12507,12531]],[[13120,13120],"mapped",[12509,12531,12489]],[[13121,13121],"mapped",[12507,12540,12523]],[[13122,13122],"mapped",[12507,12540,12531]],[[13123,13123],"mapped",[12510,12452,12463,12525]],[[13124,13124],"mapped",[12510,12452,12523]],[[13125,13125],"mapped",[12510,12483,12495]],[[13126,13126],"mapped",[12510,12523,12463]],[[13127,13127],"mapped",[12510,12531,12471,12519,12531]],[[13128,13128],"mapped",[12511,12463,12525,12531]],[[13129,13129],"mapped",[12511,12522]],[[13130,13130],"mapped",[12511,12522,12496,12540,12523]],[[13131,13131],"mapped",[12513,12460]],[[13132,13132],"mapped",[12513,12460,12488,12531]],[[13133,13133],"mapped",[12513,12540,12488,12523]],[[13134,13134],"mapped",[12516,12540,12489]],[[13135,13135],"mapped",[12516,12540,12523]],[[13136,13136],"mapped",[12518,12450,12531]],[[13137,13137],"mapped",[12522,12483,12488,12523]],[[13138,13138],"mapped",[12522,12521]],[[13139,13139],"mapped",[12523,12500,12540]],[[13140,13140],"mapped",[12523,12540,12502,12523]],[[13141,13141],"mapped",[12524,12512]],[[13142,13142],"mapped",[12524,12531,12488,12466,12531]],[[13143,13143],"mapped",[12527,12483,12488]],[[13144,13144],"mapped",[48,28857]],[[13145,13145],"mapped",[49,28857]],[[13146,13146],"mapped",[50,28857]],[[13147,13147],"mapped",[51,28857]],[[13148,13148],"mapped",[52,28857]],[[13149,13149],"mapped",[53,28857]],[[13150,13150],"mapped",[54,28857]],[[13151,13151],"mapped",[55,28857]],[[13152,13152],"mapped",[56,28857]],[[13153,13153],"mapped",[57,28857]],[[13154,13154],"mapped",[49,48,28857]],[[13155,13155],"mapped",[49,49,28857]],[[13156,13156],"mapped",[49,50,28857]],[[13157,13157],"mapped",[49,51,28857]],[[13158,13158],"mapped",[49,52,28857]],[[13159,13159],"mapped",[49,53,28857]],[[13160,13160],"mapped",[49,54,28857]],[[13161,13161],"mapped",[49,55,28857]],[[13162,13162],"mapped",[49,56,28857]],[[13163,13163],"mapped",[49,57,28857]],[[13164,13164],"mapped",[50,48,28857]],[[13165,13165],"mapped",[50,49,28857]],[[13166,13166],"mapped",[50,50,28857]],[[13167,13167],"mapped",[50,51,28857]],[[13168,13168],"mapped",[50,52,28857]],[[13169,13169],"mapped",[104,112,97]],[[13170,13170],"mapped",[100,97]],[[13171,13171],"mapped",[97,117]],[[13172,13172],"mapped",[98,97,114]],[[13173,13173],"mapped",[111,118]],[[13174,13174],"mapped",[112,99]],[[13175,13175],"mapped",[100,109]],[[13176,13176],"mapped",[100,109,50]],[[13177,13177],"mapped",[100,109,51]],[[13178,13178],"mapped",[105,117]],[[13179,13179],"mapped",[24179,25104]],[[13180,13180],"mapped",[26157,21644]],[[13181,13181],"mapped",[22823,27491]],[[13182,13182],"mapped",[26126,27835]],[[13183,13183],"mapped",[26666,24335,20250,31038]],[[13184,13184],"mapped",[112,97]],[[13185,13185],"mapped",[110,97]],[[13186,13186],"mapped",[956,97]],[[13187,13187],"mapped",[109,97]],[[13188,13188],"mapped",[107,97]],[[13189,13189],"mapped",[107,98]],[[13190,13190],"mapped",[109,98]],[[13191,13191],"mapped",[103,98]],[[13192,13192],"mapped",[99,97,108]],[[13193,13193],"mapped",[107,99,97,108]],[[13194,13194],"mapped",[112,102]],[[13195,13195],"mapped",[110,102]],[[13196,13196],"mapped",[956,102]],[[13197,13197],"mapped",[956,103]],[[13198,13198],"mapped",[109,103]],[[13199,13199],"mapped",[107,103]],[[13200,13200],"mapped",[104,122]],[[13201,13201],"mapped",[107,104,122]],[[13202,13202],"mapped",[109,104,122]],[[13203,13203],"mapped",[103,104,122]],[[13204,13204],"mapped",[116,104,122]],[[13205,13205],"mapped",[956,108]],[[13206,13206],"mapped",[109,108]],[[13207,13207],"mapped",[100,108]],[[13208,13208],"mapped",[107,108]],[[13209,13209],"mapped",[102,109]],[[13210,13210],"mapped",[110,109]],[[13211,13211],"mapped",[956,109]],[[13212,13212],"mapped",[109,109]],[[13213,13213],"mapped",[99,109]],[[13214,13214],"mapped",[107,109]],[[13215,13215],"mapped",[109,109,50]],[[13216,13216],"mapped",[99,109,50]],[[13217,13217],"mapped",[109,50]],[[13218,13218],"mapped",[107,109,50]],[[13219,13219],"mapped",[109,109,51]],[[13220,13220],"mapped",[99,109,51]],[[13221,13221],"mapped",[109,51]],[[13222,13222],"mapped",[107,109,51]],[[13223,13223],"mapped",[109,8725,115]],[[13224,13224],"mapped",[109,8725,115,50]],[[13225,13225],"mapped",[112,97]],[[13226,13226],"mapped",[107,112,97]],[[13227,13227],"mapped",[109,112,97]],[[13228,13228],"mapped",[103,112,97]],[[13229,13229],"mapped",[114,97,100]],[[13230,13230],"mapped",[114,97,100,8725,115]],[[13231,13231],"mapped",[114,97,100,8725,115,50]],[[13232,13232],"mapped",[112,115]],[[13233,13233],"mapped",[110,115]],[[13234,13234],"mapped",[956,115]],[[13235,13235],"mapped",[109,115]],[[13236,13236],"mapped",[112,118]],[[13237,13237],"mapped",[110,118]],[[13238,13238],"mapped",[956,118]],[[13239,13239],"mapped",[109,118]],[[13240,13240],"mapped",[107,118]],[[13241,13241],"mapped",[109,118]],[[13242,13242],"mapped",[112,119]],[[13243,13243],"mapped",[110,119]],[[13244,13244],"mapped",[956,119]],[[13245,13245],"mapped",[109,119]],[[13246,13246],"mapped",[107,119]],[[13247,13247],"mapped",[109,119]],[[13248,13248],"mapped",[107,969]],[[13249,13249],"mapped",[109,969]],[[13250,13250],"disallowed"],[[13251,13251],"mapped",[98,113]],[[13252,13252],"mapped",[99,99]],[[13253,13253],"mapped",[99,100]],[[13254,13254],"mapped",[99,8725,107,103]],[[13255,13255],"disallowed"],[[13256,13256],"mapped",[100,98]],[[13257,13257],"mapped",[103,121]],[[13258,13258],"mapped",[104,97]],[[13259,13259],"mapped",[104,112]],[[13260,13260],"mapped",[105,110]],[[13261,13261],"mapped",[107,107]],[[13262,13262],"mapped",[107,109]],[[13263,13263],"mapped",[107,116]],[[13264,13264],"mapped",[108,109]],[[13265,13265],"mapped",[108,110]],[[13266,13266],"mapped",[108,111,103]],[[13267,13267],"mapped",[108,120]],[[13268,13268],"mapped",[109,98]],[[13269,13269],"mapped",[109,105,108]],[[13270,13270],"mapped",[109,111,108]],[[13271,13271],"mapped",[112,104]],[[13272,13272],"disallowed"],[[13273,13273],"mapped",[112,112,109]],[[13274,13274],"mapped",[112,114]],[[13275,13275],"mapped",[115,114]],[[13276,13276],"mapped",[115,118]],[[13277,13277],"mapped",[119,98]],[[13278,13278],"mapped",[118,8725,109]],[[13279,13279],"mapped",[97,8725,109]],[[13280,13280],"mapped",[49,26085]],[[13281,13281],"mapped",[50,26085]],[[13282,13282],"mapped",[51,26085]],[[13283,13283],"mapped",[52,26085]],[[13284,13284],"mapped",[53,26085]],[[13285,13285],"mapped",[54,26085]],[[13286,13286],"mapped",[55,26085]],[[13287,13287],"mapped",[56,26085]],[[13288,13288],"mapped",[57,26085]],[[13289,13289],"mapped",[49,48,26085]],[[13290,13290],"mapped",[49,49,26085]],[[13291,13291],"mapped",[49,50,26085]],[[13292,13292],"mapped",[49,51,26085]],[[13293,13293],"mapped",[49,52,26085]],[[13294,13294],"mapped",[49,53,26085]],[[13295,13295],"mapped",[49,54,26085]],[[13296,13296],"mapped",[49,55,26085]],[[13297,13297],"mapped",[49,56,26085]],[[13298,13298],"mapped",[49,57,26085]],[[13299,13299],"mapped",[50,48,26085]],[[13300,13300],"mapped",[50,49,26085]],[[13301,13301],"mapped",[50,50,26085]],[[13302,13302],"mapped",[50,51,26085]],[[13303,13303],"mapped",[50,52,26085]],[[13304,13304],"mapped",[50,53,26085]],[[13305,13305],"mapped",[50,54,26085]],[[13306,13306],"mapped",[50,55,26085]],[[13307,13307],"mapped",[50,56,26085]],[[13308,13308],"mapped",[50,57,26085]],[[13309,13309],"mapped",[51,48,26085]],[[13310,13310],"mapped",[51,49,26085]],[[13311,13311],"mapped",[103,97,108]],[[13312,19893],"valid"],[[19894,19903],"disallowed"],[[19904,19967],"valid",[],"NV8"],[[19968,40869],"valid"],[[40870,40891],"valid"],[[40892,40899],"valid"],[[40900,40907],"valid"],[[40908,40908],"valid"],[[40909,40917],"valid"],[[40918,40959],"disallowed"],[[40960,42124],"valid"],[[42125,42127],"disallowed"],[[42128,42145],"valid",[],"NV8"],[[42146,42147],"valid",[],"NV8"],[[42148,42163],"valid",[],"NV8"],[[42164,42164],"valid",[],"NV8"],[[42165,42176],"valid",[],"NV8"],[[42177,42177],"valid",[],"NV8"],[[42178,42180],"valid",[],"NV8"],[[42181,42181],"valid",[],"NV8"],[[42182,42182],"valid",[],"NV8"],[[42183,42191],"disallowed"],[[42192,42237],"valid"],[[42238,42239],"valid",[],"NV8"],[[42240,42508],"valid"],[[42509,42511],"valid",[],"NV8"],[[42512,42539],"valid"],[[42540,42559],"disallowed"],[[42560,42560],"mapped",[42561]],[[42561,42561],"valid"],[[42562,42562],"mapped",[42563]],[[42563,42563],"valid"],[[42564,42564],"mapped",[42565]],[[42565,42565],"valid"],[[42566,42566],"mapped",[42567]],[[42567,42567],"valid"],[[42568,42568],"mapped",[42569]],[[42569,42569],"valid"],[[42570,42570],"mapped",[42571]],[[42571,42571],"valid"],[[42572,42572],"mapped",[42573]],[[42573,42573],"valid"],[[42574,42574],"mapped",[42575]],[[42575,42575],"valid"],[[42576,42576],"mapped",[42577]],[[42577,42577],"valid"],[[42578,42578],"mapped",[42579]],[[42579,42579],"valid"],[[42580,42580],"mapped",[42581]],[[42581,42581],"valid"],[[42582,42582],"mapped",[42583]],[[42583,42583],"valid"],[[42584,42584],"mapped",[42585]],[[42585,42585],"valid"],[[42586,42586],"mapped",[42587]],[[42587,42587],"valid"],[[42588,42588],"mapped",[42589]],[[42589,42589],"valid"],[[42590,42590],"mapped",[42591]],[[42591,42591],"valid"],[[42592,42592],"mapped",[42593]],[[42593,42593],"valid"],[[42594,42594],"mapped",[42595]],[[42595,42595],"valid"],[[42596,42596],"mapped",[42597]],[[42597,42597],"valid"],[[42598,42598],"mapped",[42599]],[[42599,42599],"valid"],[[42600,42600],"mapped",[42601]],[[42601,42601],"valid"],[[42602,42602],"mapped",[42603]],[[42603,42603],"valid"],[[42604,42604],"mapped",[42605]],[[42605,42607],"valid"],[[42608,42611],"valid",[],"NV8"],[[42612,42619],"valid"],[[42620,42621],"valid"],[[42622,42622],"valid",[],"NV8"],[[42623,42623],"valid"],[[42624,42624],"mapped",[42625]],[[42625,42625],"valid"],[[42626,42626],"mapped",[42627]],[[42627,42627],"valid"],[[42628,42628],"mapped",[42629]],[[42629,42629],"valid"],[[42630,42630],"mapped",[42631]],[[42631,42631],"valid"],[[42632,42632],"mapped",[42633]],[[42633,42633],"valid"],[[42634,42634],"mapped",[42635]],[[42635,42635],"valid"],[[42636,42636],"mapped",[42637]],[[42637,42637],"valid"],[[42638,42638],"mapped",[42639]],[[42639,42639],"valid"],[[42640,42640],"mapped",[42641]],[[42641,42641],"valid"],[[42642,42642],"mapped",[42643]],[[42643,42643],"valid"],[[42644,42644],"mapped",[42645]],[[42645,42645],"valid"],[[42646,42646],"mapped",[42647]],[[42647,42647],"valid"],[[42648,42648],"mapped",[42649]],[[42649,42649],"valid"],[[42650,42650],"mapped",[42651]],[[42651,42651],"valid"],[[42652,42652],"mapped",[1098]],[[42653,42653],"mapped",[1100]],[[42654,42654],"valid"],[[42655,42655],"valid"],[[42656,42725],"valid"],[[42726,42735],"valid",[],"NV8"],[[42736,42737],"valid"],[[42738,42743],"valid",[],"NV8"],[[42744,42751],"disallowed"],[[42752,42774],"valid",[],"NV8"],[[42775,42778],"valid"],[[42779,42783],"valid"],[[42784,42785],"valid",[],"NV8"],[[42786,42786],"mapped",[42787]],[[42787,42787],"valid"],[[42788,42788],"mapped",[42789]],[[42789,42789],"valid"],[[42790,42790],"mapped",[42791]],[[42791,42791],"valid"],[[42792,42792],"mapped",[42793]],[[42793,42793],"valid"],[[42794,42794],"mapped",[42795]],[[42795,42795],"valid"],[[42796,42796],"mapped",[42797]],[[42797,42797],"valid"],[[42798,42798],"mapped",[42799]],[[42799,42801],"valid"],[[42802,42802],"mapped",[42803]],[[42803,42803],"valid"],[[42804,42804],"mapped",[42805]],[[42805,42805],"valid"],[[42806,42806],"mapped",[42807]],[[42807,42807],"valid"],[[42808,42808],"mapped",[42809]],[[42809,42809],"valid"],[[42810,42810],"mapped",[42811]],[[42811,42811],"valid"],[[42812,42812],"mapped",[42813]],[[42813,42813],"valid"],[[42814,42814],"mapped",[42815]],[[42815,42815],"valid"],[[42816,42816],"mapped",[42817]],[[42817,42817],"valid"],[[42818,42818],"mapped",[42819]],[[42819,42819],"valid"],[[42820,42820],"mapped",[42821]],[[42821,42821],"valid"],[[42822,42822],"mapped",[42823]],[[42823,42823],"valid"],[[42824,42824],"mapped",[42825]],[[42825,42825],"valid"],[[42826,42826],"mapped",[42827]],[[42827,42827],"valid"],[[42828,42828],"mapped",[42829]],[[42829,42829],"valid"],[[42830,42830],"mapped",[42831]],[[42831,42831],"valid"],[[42832,42832],"mapped",[42833]],[[42833,42833],"valid"],[[42834,42834],"mapped",[42835]],[[42835,42835],"valid"],[[42836,42836],"mapped",[42837]],[[42837,42837],"valid"],[[42838,42838],"mapped",[42839]],[[42839,42839],"valid"],[[42840,42840],"mapped",[42841]],[[42841,42841],"valid"],[[42842,42842],"mapped",[42843]],[[42843,42843],"valid"],[[42844,42844],"mapped",[42845]],[[42845,42845],"valid"],[[42846,42846],"mapped",[42847]],[[42847,42847],"valid"],[[42848,42848],"mapped",[42849]],[[42849,42849],"valid"],[[42850,42850],"mapped",[42851]],[[42851,42851],"valid"],[[42852,42852],"mapped",[42853]],[[42853,42853],"valid"],[[42854,42854],"mapped",[42855]],[[42855,42855],"valid"],[[42856,42856],"mapped",[42857]],[[42857,42857],"valid"],[[42858,42858],"mapped",[42859]],[[42859,42859],"valid"],[[42860,42860],"mapped",[42861]],[[42861,42861],"valid"],[[42862,42862],"mapped",[42863]],[[42863,42863],"valid"],[[42864,42864],"mapped",[42863]],[[42865,42872],"valid"],[[42873,42873],"mapped",[42874]],[[42874,42874],"valid"],[[42875,42875],"mapped",[42876]],[[42876,42876],"valid"],[[42877,42877],"mapped",[7545]],[[42878,42878],"mapped",[42879]],[[42879,42879],"valid"],[[42880,42880],"mapped",[42881]],[[42881,42881],"valid"],[[42882,42882],"mapped",[42883]],[[42883,42883],"valid"],[[42884,42884],"mapped",[42885]],[[42885,42885],"valid"],[[42886,42886],"mapped",[42887]],[[42887,42888],"valid"],[[42889,42890],"valid",[],"NV8"],[[42891,42891],"mapped",[42892]],[[42892,42892],"valid"],[[42893,42893],"mapped",[613]],[[42894,42894],"valid"],[[42895,42895],"valid"],[[42896,42896],"mapped",[42897]],[[42897,42897],"valid"],[[42898,42898],"mapped",[42899]],[[42899,42899],"valid"],[[42900,42901],"valid"],[[42902,42902],"mapped",[42903]],[[42903,42903],"valid"],[[42904,42904],"mapped",[42905]],[[42905,42905],"valid"],[[42906,42906],"mapped",[42907]],[[42907,42907],"valid"],[[42908,42908],"mapped",[42909]],[[42909,42909],"valid"],[[42910,42910],"mapped",[42911]],[[42911,42911],"valid"],[[42912,42912],"mapped",[42913]],[[42913,42913],"valid"],[[42914,42914],"mapped",[42915]],[[42915,42915],"valid"],[[42916,42916],"mapped",[42917]],[[42917,42917],"valid"],[[42918,42918],"mapped",[42919]],[[42919,42919],"valid"],[[42920,42920],"mapped",[42921]],[[42921,42921],"valid"],[[42922,42922],"mapped",[614]],[[42923,42923],"mapped",[604]],[[42924,42924],"mapped",[609]],[[42925,42925],"mapped",[620]],[[42926,42927],"disallowed"],[[42928,42928],"mapped",[670]],[[42929,42929],"mapped",[647]],[[42930,42930],"mapped",[669]],[[42931,42931],"mapped",[43859]],[[42932,42932],"mapped",[42933]],[[42933,42933],"valid"],[[42934,42934],"mapped",[42935]],[[42935,42935],"valid"],[[42936,42998],"disallowed"],[[42999,42999],"valid"],[[43000,43000],"mapped",[295]],[[43001,43001],"mapped",[339]],[[43002,43002],"valid"],[[43003,43007],"valid"],[[43008,43047],"valid"],[[43048,43051],"valid",[],"NV8"],[[43052,43055],"disallowed"],[[43056,43065],"valid",[],"NV8"],[[43066,43071],"disallowed"],[[43072,43123],"valid"],[[43124,43127],"valid",[],"NV8"],[[43128,43135],"disallowed"],[[43136,43204],"valid"],[[43205,43213],"disallowed"],[[43214,43215],"valid",[],"NV8"],[[43216,43225],"valid"],[[43226,43231],"disallowed"],[[43232,43255],"valid"],[[43256,43258],"valid",[],"NV8"],[[43259,43259],"valid"],[[43260,43260],"valid",[],"NV8"],[[43261,43261],"valid"],[[43262,43263],"disallowed"],[[43264,43309],"valid"],[[43310,43311],"valid",[],"NV8"],[[43312,43347],"valid"],[[43348,43358],"disallowed"],[[43359,43359],"valid",[],"NV8"],[[43360,43388],"valid",[],"NV8"],[[43389,43391],"disallowed"],[[43392,43456],"valid"],[[43457,43469],"valid",[],"NV8"],[[43470,43470],"disallowed"],[[43471,43481],"valid"],[[43482,43485],"disallowed"],[[43486,43487],"valid",[],"NV8"],[[43488,43518],"valid"],[[43519,43519],"disallowed"],[[43520,43574],"valid"],[[43575,43583],"disallowed"],[[43584,43597],"valid"],[[43598,43599],"disallowed"],[[43600,43609],"valid"],[[43610,43611],"disallowed"],[[43612,43615],"valid",[],"NV8"],[[43616,43638],"valid"],[[43639,43641],"valid",[],"NV8"],[[43642,43643],"valid"],[[43644,43647],"valid"],[[43648,43714],"valid"],[[43715,43738],"disallowed"],[[43739,43741],"valid"],[[43742,43743],"valid",[],"NV8"],[[43744,43759],"valid"],[[43760,43761],"valid",[],"NV8"],[[43762,43766],"valid"],[[43767,43776],"disallowed"],[[43777,43782],"valid"],[[43783,43784],"disallowed"],[[43785,43790],"valid"],[[43791,43792],"disallowed"],[[43793,43798],"valid"],[[43799,43807],"disallowed"],[[43808,43814],"valid"],[[43815,43815],"disallowed"],[[43816,43822],"valid"],[[43823,43823],"disallowed"],[[43824,43866],"valid"],[[43867,43867],"valid",[],"NV8"],[[43868,43868],"mapped",[42791]],[[43869,43869],"mapped",[43831]],[[43870,43870],"mapped",[619]],[[43871,43871],"mapped",[43858]],[[43872,43875],"valid"],[[43876,43877],"valid"],[[43878,43887],"disallowed"],[[43888,43888],"mapped",[5024]],[[43889,43889],"mapped",[5025]],[[43890,43890],"mapped",[5026]],[[43891,43891],"mapped",[5027]],[[43892,43892],"mapped",[5028]],[[43893,43893],"mapped",[5029]],[[43894,43894],"mapped",[5030]],[[43895,43895],"mapped",[5031]],[[43896,43896],"mapped",[5032]],[[43897,43897],"mapped",[5033]],[[43898,43898],"mapped",[5034]],[[43899,43899],"mapped",[5035]],[[43900,43900],"mapped",[5036]],[[43901,43901],"mapped",[5037]],[[43902,43902],"mapped",[5038]],[[43903,43903],"mapped",[5039]],[[43904,43904],"mapped",[5040]],[[43905,43905],"mapped",[5041]],[[43906,43906],"mapped",[5042]],[[43907,43907],"mapped",[5043]],[[43908,43908],"mapped",[5044]],[[43909,43909],"mapped",[5045]],[[43910,43910],"mapped",[5046]],[[43911,43911],"mapped",[5047]],[[43912,43912],"mapped",[5048]],[[43913,43913],"mapped",[5049]],[[43914,43914],"mapped",[5050]],[[43915,43915],"mapped",[5051]],[[43916,43916],"mapped",[5052]],[[43917,43917],"mapped",[5053]],[[43918,43918],"mapped",[5054]],[[43919,43919],"mapped",[5055]],[[43920,43920],"mapped",[5056]],[[43921,43921],"mapped",[5057]],[[43922,43922],"mapped",[5058]],[[43923,43923],"mapped",[5059]],[[43924,43924],"mapped",[5060]],[[43925,43925],"mapped",[5061]],[[43926,43926],"mapped",[5062]],[[43927,43927],"mapped",[5063]],[[43928,43928],"mapped",[5064]],[[43929,43929],"mapped",[5065]],[[43930,43930],"mapped",[5066]],[[43931,43931],"mapped",[5067]],[[43932,43932],"mapped",[5068]],[[43933,43933],"mapped",[5069]],[[43934,43934],"mapped",[5070]],[[43935,43935],"mapped",[5071]],[[43936,43936],"mapped",[5072]],[[43937,43937],"mapped",[5073]],[[43938,43938],"mapped",[5074]],[[43939,43939],"mapped",[5075]],[[43940,43940],"mapped",[5076]],[[43941,43941],"mapped",[5077]],[[43942,43942],"mapped",[5078]],[[43943,43943],"mapped",[5079]],[[43944,43944],"mapped",[5080]],[[43945,43945],"mapped",[5081]],[[43946,43946],"mapped",[5082]],[[43947,43947],"mapped",[5083]],[[43948,43948],"mapped",[5084]],[[43949,43949],"mapped",[5085]],[[43950,43950],"mapped",[5086]],[[43951,43951],"mapped",[5087]],[[43952,43952],"mapped",[5088]],[[43953,43953],"mapped",[5089]],[[43954,43954],"mapped",[5090]],[[43955,43955],"mapped",[5091]],[[43956,43956],"mapped",[5092]],[[43957,43957],"mapped",[5093]],[[43958,43958],"mapped",[5094]],[[43959,43959],"mapped",[5095]],[[43960,43960],"mapped",[5096]],[[43961,43961],"mapped",[5097]],[[43962,43962],"mapped",[5098]],[[43963,43963],"mapped",[5099]],[[43964,43964],"mapped",[5100]],[[43965,43965],"mapped",[5101]],[[43966,43966],"mapped",[5102]],[[43967,43967],"mapped",[5103]],[[43968,44010],"valid"],[[44011,44011],"valid",[],"NV8"],[[44012,44013],"valid"],[[44014,44015],"disallowed"],[[44016,44025],"valid"],[[44026,44031],"disallowed"],[[44032,55203],"valid"],[[55204,55215],"disallowed"],[[55216,55238],"valid",[],"NV8"],[[55239,55242],"disallowed"],[[55243,55291],"valid",[],"NV8"],[[55292,55295],"disallowed"],[[55296,57343],"disallowed"],[[57344,63743],"disallowed"],[[63744,63744],"mapped",[35912]],[[63745,63745],"mapped",[26356]],[[63746,63746],"mapped",[36554]],[[63747,63747],"mapped",[36040]],[[63748,63748],"mapped",[28369]],[[63749,63749],"mapped",[20018]],[[63750,63750],"mapped",[21477]],[[63751,63752],"mapped",[40860]],[[63753,63753],"mapped",[22865]],[[63754,63754],"mapped",[37329]],[[63755,63755],"mapped",[21895]],[[63756,63756],"mapped",[22856]],[[63757,63757],"mapped",[25078]],[[63758,63758],"mapped",[30313]],[[63759,63759],"mapped",[32645]],[[63760,63760],"mapped",[34367]],[[63761,63761],"mapped",[34746]],[[63762,63762],"mapped",[35064]],[[63763,63763],"mapped",[37007]],[[63764,63764],"mapped",[27138]],[[63765,63765],"mapped",[27931]],[[63766,63766],"mapped",[28889]],[[63767,63767],"mapped",[29662]],[[63768,63768],"mapped",[33853]],[[63769,63769],"mapped",[37226]],[[63770,63770],"mapped",[39409]],[[63771,63771],"mapped",[20098]],[[63772,63772],"mapped",[21365]],[[63773,63773],"mapped",[27396]],[[63774,63774],"mapped",[29211]],[[63775,63775],"mapped",[34349]],[[63776,63776],"mapped",[40478]],[[63777,63777],"mapped",[23888]],[[63778,63778],"mapped",[28651]],[[63779,63779],"mapped",[34253]],[[63780,63780],"mapped",[35172]],[[63781,63781],"mapped",[25289]],[[63782,63782],"mapped",[33240]],[[63783,63783],"mapped",[34847]],[[63784,63784],"mapped",[24266]],[[63785,63785],"mapped",[26391]],[[63786,63786],"mapped",[28010]],[[63787,63787],"mapped",[29436]],[[63788,63788],"mapped",[37070]],[[63789,63789],"mapped",[20358]],[[63790,63790],"mapped",[20919]],[[63791,63791],"mapped",[21214]],[[63792,63792],"mapped",[25796]],[[63793,63793],"mapped",[27347]],[[63794,63794],"mapped",[29200]],[[63795,63795],"mapped",[30439]],[[63796,63796],"mapped",[32769]],[[63797,63797],"mapped",[34310]],[[63798,63798],"mapped",[34396]],[[63799,63799],"mapped",[36335]],[[63800,63800],"mapped",[38706]],[[63801,63801],"mapped",[39791]],[[63802,63802],"mapped",[40442]],[[63803,63803],"mapped",[30860]],[[63804,63804],"mapped",[31103]],[[63805,63805],"mapped",[32160]],[[63806,63806],"mapped",[33737]],[[63807,63807],"mapped",[37636]],[[63808,63808],"mapped",[40575]],[[63809,63809],"mapped",[35542]],[[63810,63810],"mapped",[22751]],[[63811,63811],"mapped",[24324]],[[63812,63812],"mapped",[31840]],[[63813,63813],"mapped",[32894]],[[63814,63814],"mapped",[29282]],[[63815,63815],"mapped",[30922]],[[63816,63816],"mapped",[36034]],[[63817,63817],"mapped",[38647]],[[63818,63818],"mapped",[22744]],[[63819,63819],"mapped",[23650]],[[63820,63820],"mapped",[27155]],[[63821,63821],"mapped",[28122]],[[63822,63822],"mapped",[28431]],[[63823,63823],"mapped",[32047]],[[63824,63824],"mapped",[32311]],[[63825,63825],"mapped",[38475]],[[63826,63826],"mapped",[21202]],[[63827,63827],"mapped",[32907]],[[63828,63828],"mapped",[20956]],[[63829,63829],"mapped",[20940]],[[63830,63830],"mapped",[31260]],[[63831,63831],"mapped",[32190]],[[63832,63832],"mapped",[33777]],[[63833,63833],"mapped",[38517]],[[63834,63834],"mapped",[35712]],[[63835,63835],"mapped",[25295]],[[63836,63836],"mapped",[27138]],[[63837,63837],"mapped",[35582]],[[63838,63838],"mapped",[20025]],[[63839,63839],"mapped",[23527]],[[63840,63840],"mapped",[24594]],[[63841,63841],"mapped",[29575]],[[63842,63842],"mapped",[30064]],[[63843,63843],"mapped",[21271]],[[63844,63844],"mapped",[30971]],[[63845,63845],"mapped",[20415]],[[63846,63846],"mapped",[24489]],[[63847,63847],"mapped",[19981]],[[63848,63848],"mapped",[27852]],[[63849,63849],"mapped",[25976]],[[63850,63850],"mapped",[32034]],[[63851,63851],"mapped",[21443]],[[63852,63852],"mapped",[22622]],[[63853,63853],"mapped",[30465]],[[63854,63854],"mapped",[33865]],[[63855,63855],"mapped",[35498]],[[63856,63856],"mapped",[27578]],[[63857,63857],"mapped",[36784]],[[63858,63858],"mapped",[27784]],[[63859,63859],"mapped",[25342]],[[63860,63860],"mapped",[33509]],[[63861,63861],"mapped",[25504]],[[63862,63862],"mapped",[30053]],[[63863,63863],"mapped",[20142]],[[63864,63864],"mapped",[20841]],[[63865,63865],"mapped",[20937]],[[63866,63866],"mapped",[26753]],[[63867,63867],"mapped",[31975]],[[63868,63868],"mapped",[33391]],[[63869,63869],"mapped",[35538]],[[63870,63870],"mapped",[37327]],[[63871,63871],"mapped",[21237]],[[63872,63872],"mapped",[21570]],[[63873,63873],"mapped",[22899]],[[63874,63874],"mapped",[24300]],[[63875,63875],"mapped",[26053]],[[63876,63876],"mapped",[28670]],[[63877,63877],"mapped",[31018]],[[63878,63878],"mapped",[38317]],[[63879,63879],"mapped",[39530]],[[63880,63880],"mapped",[40599]],[[63881,63881],"mapped",[40654]],[[63882,63882],"mapped",[21147]],[[63883,63883],"mapped",[26310]],[[63884,63884],"mapped",[27511]],[[63885,63885],"mapped",[36706]],[[63886,63886],"mapped",[24180]],[[63887,63887],"mapped",[24976]],[[63888,63888],"mapped",[25088]],[[63889,63889],"mapped",[25754]],[[63890,63890],"mapped",[28451]],[[63891,63891],"mapped",[29001]],[[63892,63892],"mapped",[29833]],[[63893,63893],"mapped",[31178]],[[63894,63894],"mapped",[32244]],[[63895,63895],"mapped",[32879]],[[63896,63896],"mapped",[36646]],[[63897,63897],"mapped",[34030]],[[63898,63898],"mapped",[36899]],[[63899,63899],"mapped",[37706]],[[63900,63900],"mapped",[21015]],[[63901,63901],"mapped",[21155]],[[63902,63902],"mapped",[21693]],[[63903,63903],"mapped",[28872]],[[63904,63904],"mapped",[35010]],[[63905,63905],"mapped",[35498]],[[63906,63906],"mapped",[24265]],[[63907,63907],"mapped",[24565]],[[63908,63908],"mapped",[25467]],[[63909,63909],"mapped",[27566]],[[63910,63910],"mapped",[31806]],[[63911,63911],"mapped",[29557]],[[63912,63912],"mapped",[20196]],[[63913,63913],"mapped",[22265]],[[63914,63914],"mapped",[23527]],[[63915,63915],"mapped",[23994]],[[63916,63916],"mapped",[24604]],[[63917,63917],"mapped",[29618]],[[63918,63918],"mapped",[29801]],[[63919,63919],"mapped",[32666]],[[63920,63920],"mapped",[32838]],[[63921,63921],"mapped",[37428]],[[63922,63922],"mapped",[38646]],[[63923,63923],"mapped",[38728]],[[63924,63924],"mapped",[38936]],[[63925,63925],"mapped",[20363]],[[63926,63926],"mapped",[31150]],[[63927,63927],"mapped",[37300]],[[63928,63928],"mapped",[38584]],[[63929,63929],"mapped",[24801]],[[63930,63930],"mapped",[20102]],[[63931,63931],"mapped",[20698]],[[63932,63932],"mapped",[23534]],[[63933,63933],"mapped",[23615]],[[63934,63934],"mapped",[26009]],[[63935,63935],"mapped",[27138]],[[63936,63936],"mapped",[29134]],[[63937,63937],"mapped",[30274]],[[63938,63938],"mapped",[34044]],[[63939,63939],"mapped",[36988]],[[63940,63940],"mapped",[40845]],[[63941,63941],"mapped",[26248]],[[63942,63942],"mapped",[38446]],[[63943,63943],"mapped",[21129]],[[63944,63944],"mapped",[26491]],[[63945,63945],"mapped",[26611]],[[63946,63946],"mapped",[27969]],[[63947,63947],"mapped",[28316]],[[63948,63948],"mapped",[29705]],[[63949,63949],"mapped",[30041]],[[63950,63950],"mapped",[30827]],[[63951,63951],"mapped",[32016]],[[63952,63952],"mapped",[39006]],[[63953,63953],"mapped",[20845]],[[63954,63954],"mapped",[25134]],[[63955,63955],"mapped",[38520]],[[63956,63956],"mapped",[20523]],[[63957,63957],"mapped",[23833]],[[63958,63958],"mapped",[28138]],[[63959,63959],"mapped",[36650]],[[63960,63960],"mapped",[24459]],[[63961,63961],"mapped",[24900]],[[63962,63962],"mapped",[26647]],[[63963,63963],"mapped",[29575]],[[63964,63964],"mapped",[38534]],[[63965,63965],"mapped",[21033]],[[63966,63966],"mapped",[21519]],[[63967,63967],"mapped",[23653]],[[63968,63968],"mapped",[26131]],[[63969,63969],"mapped",[26446]],[[63970,63970],"mapped",[26792]],[[63971,63971],"mapped",[27877]],[[63972,63972],"mapped",[29702]],[[63973,63973],"mapped",[30178]],[[63974,63974],"mapped",[32633]],[[63975,63975],"mapped",[35023]],[[63976,63976],"mapped",[35041]],[[63977,63977],"mapped",[37324]],[[63978,63978],"mapped",[38626]],[[63979,63979],"mapped",[21311]],[[63980,63980],"mapped",[28346]],[[63981,63981],"mapped",[21533]],[[63982,63982],"mapped",[29136]],[[63983,63983],"mapped",[29848]],[[63984,63984],"mapped",[34298]],[[63985,63985],"mapped",[38563]],[[63986,63986],"mapped",[40023]],[[63987,63987],"mapped",[40607]],[[63988,63988],"mapped",[26519]],[[63989,63989],"mapped",[28107]],[[63990,63990],"mapped",[33256]],[[63991,63991],"mapped",[31435]],[[63992,63992],"mapped",[31520]],[[63993,63993],"mapped",[31890]],[[63994,63994],"mapped",[29376]],[[63995,63995],"mapped",[28825]],[[63996,63996],"mapped",[35672]],[[63997,63997],"mapped",[20160]],[[63998,63998],"mapped",[33590]],[[63999,63999],"mapped",[21050]],[[64000,64000],"mapped",[20999]],[[64001,64001],"mapped",[24230]],[[64002,64002],"mapped",[25299]],[[64003,64003],"mapped",[31958]],[[64004,64004],"mapped",[23429]],[[64005,64005],"mapped",[27934]],[[64006,64006],"mapped",[26292]],[[64007,64007],"mapped",[36667]],[[64008,64008],"mapped",[34892]],[[64009,64009],"mapped",[38477]],[[64010,64010],"mapped",[35211]],[[64011,64011],"mapped",[24275]],[[64012,64012],"mapped",[20800]],[[64013,64013],"mapped",[21952]],[[64014,64015],"valid"],[[64016,64016],"mapped",[22618]],[[64017,64017],"valid"],[[64018,64018],"mapped",[26228]],[[64019,64020],"valid"],[[64021,64021],"mapped",[20958]],[[64022,64022],"mapped",[29482]],[[64023,64023],"mapped",[30410]],[[64024,64024],"mapped",[31036]],[[64025,64025],"mapped",[31070]],[[64026,64026],"mapped",[31077]],[[64027,64027],"mapped",[31119]],[[64028,64028],"mapped",[38742]],[[64029,64029],"mapped",[31934]],[[64030,64030],"mapped",[32701]],[[64031,64031],"valid"],[[64032,64032],"mapped",[34322]],[[64033,64033],"valid"],[[64034,64034],"mapped",[35576]],[[64035,64036],"valid"],[[64037,64037],"mapped",[36920]],[[64038,64038],"mapped",[37117]],[[64039,64041],"valid"],[[64042,64042],"mapped",[39151]],[[64043,64043],"mapped",[39164]],[[64044,64044],"mapped",[39208]],[[64045,64045],"mapped",[40372]],[[64046,64046],"mapped",[37086]],[[64047,64047],"mapped",[38583]],[[64048,64048],"mapped",[20398]],[[64049,64049],"mapped",[20711]],[[64050,64050],"mapped",[20813]],[[64051,64051],"mapped",[21193]],[[64052,64052],"mapped",[21220]],[[64053,64053],"mapped",[21329]],[[64054,64054],"mapped",[21917]],[[64055,64055],"mapped",[22022]],[[64056,64056],"mapped",[22120]],[[64057,64057],"mapped",[22592]],[[64058,64058],"mapped",[22696]],[[64059,64059],"mapped",[23652]],[[64060,64060],"mapped",[23662]],[[64061,64061],"mapped",[24724]],[[64062,64062],"mapped",[24936]],[[64063,64063],"mapped",[24974]],[[64064,64064],"mapped",[25074]],[[64065,64065],"mapped",[25935]],[[64066,64066],"mapped",[26082]],[[64067,64067],"mapped",[26257]],[[64068,64068],"mapped",[26757]],[[64069,64069],"mapped",[28023]],[[64070,64070],"mapped",[28186]],[[64071,64071],"mapped",[28450]],[[64072,64072],"mapped",[29038]],[[64073,64073],"mapped",[29227]],[[64074,64074],"mapped",[29730]],[[64075,64075],"mapped",[30865]],[[64076,64076],"mapped",[31038]],[[64077,64077],"mapped",[31049]],[[64078,64078],"mapped",[31048]],[[64079,64079],"mapped",[31056]],[[64080,64080],"mapped",[31062]],[[64081,64081],"mapped",[31069]],[[64082,64082],"mapped",[31117]],[[64083,64083],"mapped",[31118]],[[64084,64084],"mapped",[31296]],[[64085,64085],"mapped",[31361]],[[64086,64086],"mapped",[31680]],[[64087,64087],"mapped",[32244]],[[64088,64088],"mapped",[32265]],[[64089,64089],"mapped",[32321]],[[64090,64090],"mapped",[32626]],[[64091,64091],"mapped",[32773]],[[64092,64092],"mapped",[33261]],[[64093,64094],"mapped",[33401]],[[64095,64095],"mapped",[33879]],[[64096,64096],"mapped",[35088]],[[64097,64097],"mapped",[35222]],[[64098,64098],"mapped",[35585]],[[64099,64099],"mapped",[35641]],[[64100,64100],"mapped",[36051]],[[64101,64101],"mapped",[36104]],[[64102,64102],"mapped",[36790]],[[64103,64103],"mapped",[36920]],[[64104,64104],"mapped",[38627]],[[64105,64105],"mapped",[38911]],[[64106,64106],"mapped",[38971]],[[64107,64107],"mapped",[24693]],[[64108,64108],"mapped",[148206]],[[64109,64109],"mapped",[33304]],[[64110,64111],"disallowed"],[[64112,64112],"mapped",[20006]],[[64113,64113],"mapped",[20917]],[[64114,64114],"mapped",[20840]],[[64115,64115],"mapped",[20352]],[[64116,64116],"mapped",[20805]],[[64117,64117],"mapped",[20864]],[[64118,64118],"mapped",[21191]],[[64119,64119],"mapped",[21242]],[[64120,64120],"mapped",[21917]],[[64121,64121],"mapped",[21845]],[[64122,64122],"mapped",[21913]],[[64123,64123],"mapped",[21986]],[[64124,64124],"mapped",[22618]],[[64125,64125],"mapped",[22707]],[[64126,64126],"mapped",[22852]],[[64127,64127],"mapped",[22868]],[[64128,64128],"mapped",[23138]],[[64129,64129],"mapped",[23336]],[[64130,64130],"mapped",[24274]],[[64131,64131],"mapped",[24281]],[[64132,64132],"mapped",[24425]],[[64133,64133],"mapped",[24493]],[[64134,64134],"mapped",[24792]],[[64135,64135],"mapped",[24910]],[[64136,64136],"mapped",[24840]],[[64137,64137],"mapped",[24974]],[[64138,64138],"mapped",[24928]],[[64139,64139],"mapped",[25074]],[[64140,64140],"mapped",[25140]],[[64141,64141],"mapped",[25540]],[[64142,64142],"mapped",[25628]],[[64143,64143],"mapped",[25682]],[[64144,64144],"mapped",[25942]],[[64145,64145],"mapped",[26228]],[[64146,64146],"mapped",[26391]],[[64147,64147],"mapped",[26395]],[[64148,64148],"mapped",[26454]],[[64149,64149],"mapped",[27513]],[[64150,64150],"mapped",[27578]],[[64151,64151],"mapped",[27969]],[[64152,64152],"mapped",[28379]],[[64153,64153],"mapped",[28363]],[[64154,64154],"mapped",[28450]],[[64155,64155],"mapped",[28702]],[[64156,64156],"mapped",[29038]],[[64157,64157],"mapped",[30631]],[[64158,64158],"mapped",[29237]],[[64159,64159],"mapped",[29359]],[[64160,64160],"mapped",[29482]],[[64161,64161],"mapped",[29809]],[[64162,64162],"mapped",[29958]],[[64163,64163],"mapped",[30011]],[[64164,64164],"mapped",[30237]],[[64165,64165],"mapped",[30239]],[[64166,64166],"mapped",[30410]],[[64167,64167],"mapped",[30427]],[[64168,64168],"mapped",[30452]],[[64169,64169],"mapped",[30538]],[[64170,64170],"mapped",[30528]],[[64171,64171],"mapped",[30924]],[[64172,64172],"mapped",[31409]],[[64173,64173],"mapped",[31680]],[[64174,64174],"mapped",[31867]],[[64175,64175],"mapped",[32091]],[[64176,64176],"mapped",[32244]],[[64177,64177],"mapped",[32574]],[[64178,64178],"mapped",[32773]],[[64179,64179],"mapped",[33618]],[[64180,64180],"mapped",[33775]],[[64181,64181],"mapped",[34681]],[[64182,64182],"mapped",[35137]],[[64183,64183],"mapped",[35206]],[[64184,64184],"mapped",[35222]],[[64185,64185],"mapped",[35519]],[[64186,64186],"mapped",[35576]],[[64187,64187],"mapped",[35531]],[[64188,64188],"mapped",[35585]],[[64189,64189],"mapped",[35582]],[[64190,64190],"mapped",[35565]],[[64191,64191],"mapped",[35641]],[[64192,64192],"mapped",[35722]],[[64193,64193],"mapped",[36104]],[[64194,64194],"mapped",[36664]],[[64195,64195],"mapped",[36978]],[[64196,64196],"mapped",[37273]],[[64197,64197],"mapped",[37494]],[[64198,64198],"mapped",[38524]],[[64199,64199],"mapped",[38627]],[[64200,64200],"mapped",[38742]],[[64201,64201],"mapped",[38875]],[[64202,64202],"mapped",[38911]],[[64203,64203],"mapped",[38923]],[[64204,64204],"mapped",[38971]],[[64205,64205],"mapped",[39698]],[[64206,64206],"mapped",[40860]],[[64207,64207],"mapped",[141386]],[[64208,64208],"mapped",[141380]],[[64209,64209],"mapped",[144341]],[[64210,64210],"mapped",[15261]],[[64211,64211],"mapped",[16408]],[[64212,64212],"mapped",[16441]],[[64213,64213],"mapped",[152137]],[[64214,64214],"mapped",[154832]],[[64215,64215],"mapped",[163539]],[[64216,64216],"mapped",[40771]],[[64217,64217],"mapped",[40846]],[[64218,64255],"disallowed"],[[64256,64256],"mapped",[102,102]],[[64257,64257],"mapped",[102,105]],[[64258,64258],"mapped",[102,108]],[[64259,64259],"mapped",[102,102,105]],[[64260,64260],"mapped",[102,102,108]],[[64261,64262],"mapped",[115,116]],[[64263,64274],"disallowed"],[[64275,64275],"mapped",[1396,1398]],[[64276,64276],"mapped",[1396,1381]],[[64277,64277],"mapped",[1396,1387]],[[64278,64278],"mapped",[1406,1398]],[[64279,64279],"mapped",[1396,1389]],[[64280,64284],"disallowed"],[[64285,64285],"mapped",[1497,1460]],[[64286,64286],"valid"],[[64287,64287],"mapped",[1522,1463]],[[64288,64288],"mapped",[1506]],[[64289,64289],"mapped",[1488]],[[64290,64290],"mapped",[1491]],[[64291,64291],"mapped",[1492]],[[64292,64292],"mapped",[1499]],[[64293,64293],"mapped",[1500]],[[64294,64294],"mapped",[1501]],[[64295,64295],"mapped",[1512]],[[64296,64296],"mapped",[1514]],[[64297,64297],"disallowed_STD3_mapped",[43]],[[64298,64298],"mapped",[1513,1473]],[[64299,64299],"mapped",[1513,1474]],[[64300,64300],"mapped",[1513,1468,1473]],[[64301,64301],"mapped",[1513,1468,1474]],[[64302,64302],"mapped",[1488,1463]],[[64303,64303],"mapped",[1488,1464]],[[64304,64304],"mapped",[1488,1468]],[[64305,64305],"mapped",[1489,1468]],[[64306,64306],"mapped",[1490,1468]],[[64307,64307],"mapped",[1491,1468]],[[64308,64308],"mapped",[1492,1468]],[[64309,64309],"mapped",[1493,1468]],[[64310,64310],"mapped",[1494,1468]],[[64311,64311],"disallowed"],[[64312,64312],"mapped",[1496,1468]],[[64313,64313],"mapped",[1497,1468]],[[64314,64314],"mapped",[1498,1468]],[[64315,64315],"mapped",[1499,1468]],[[64316,64316],"mapped",[1500,1468]],[[64317,64317],"disallowed"],[[64318,64318],"mapped",[1502,1468]],[[64319,64319],"disallowed"],[[64320,64320],"mapped",[1504,1468]],[[64321,64321],"mapped",[1505,1468]],[[64322,64322],"disallowed"],[[64323,64323],"mapped",[1507,1468]],[[64324,64324],"mapped",[1508,1468]],[[64325,64325],"disallowed"],[[64326,64326],"mapped",[1510,1468]],[[64327,64327],"mapped",[1511,1468]],[[64328,64328],"mapped",[1512,1468]],[[64329,64329],"mapped",[1513,1468]],[[64330,64330],"mapped",[1514,1468]],[[64331,64331],"mapped",[1493,1465]],[[64332,64332],"mapped",[1489,1471]],[[64333,64333],"mapped",[1499,1471]],[[64334,64334],"mapped",[1508,1471]],[[64335,64335],"mapped",[1488,1500]],[[64336,64337],"mapped",[1649]],[[64338,64341],"mapped",[1659]],[[64342,64345],"mapped",[1662]],[[64346,64349],"mapped",[1664]],[[64350,64353],"mapped",[1658]],[[64354,64357],"mapped",[1663]],[[64358,64361],"mapped",[1657]],[[64362,64365],"mapped",[1700]],[[64366,64369],"mapped",[1702]],[[64370,64373],"mapped",[1668]],[[64374,64377],"mapped",[1667]],[[64378,64381],"mapped",[1670]],[[64382,64385],"mapped",[1671]],[[64386,64387],"mapped",[1677]],[[64388,64389],"mapped",[1676]],[[64390,64391],"mapped",[1678]],[[64392,64393],"mapped",[1672]],[[64394,64395],"mapped",[1688]],[[64396,64397],"mapped",[1681]],[[64398,64401],"mapped",[1705]],[[64402,64405],"mapped",[1711]],[[64406,64409],"mapped",[1715]],[[64410,64413],"mapped",[1713]],[[64414,64415],"mapped",[1722]],[[64416,64419],"mapped",[1723]],[[64420,64421],"mapped",[1728]],[[64422,64425],"mapped",[1729]],[[64426,64429],"mapped",[1726]],[[64430,64431],"mapped",[1746]],[[64432,64433],"mapped",[1747]],[[64434,64449],"valid",[],"NV8"],[[64450,64466],"disallowed"],[[64467,64470],"mapped",[1709]],[[64471,64472],"mapped",[1735]],[[64473,64474],"mapped",[1734]],[[64475,64476],"mapped",[1736]],[[64477,64477],"mapped",[1735,1652]],[[64478,64479],"mapped",[1739]],[[64480,64481],"mapped",[1733]],[[64482,64483],"mapped",[1737]],[[64484,64487],"mapped",[1744]],[[64488,64489],"mapped",[1609]],[[64490,64491],"mapped",[1574,1575]],[[64492,64493],"mapped",[1574,1749]],[[64494,64495],"mapped",[1574,1608]],[[64496,64497],"mapped",[1574,1735]],[[64498,64499],"mapped",[1574,1734]],[[64500,64501],"mapped",[1574,1736]],[[64502,64504],"mapped",[1574,1744]],[[64505,64507],"mapped",[1574,1609]],[[64508,64511],"mapped",[1740]],[[64512,64512],"mapped",[1574,1580]],[[64513,64513],"mapped",[1574,1581]],[[64514,64514],"mapped",[1574,1605]],[[64515,64515],"mapped",[1574,1609]],[[64516,64516],"mapped",[1574,1610]],[[64517,64517],"mapped",[1576,1580]],[[64518,64518],"mapped",[1576,1581]],[[64519,64519],"mapped",[1576,1582]],[[64520,64520],"mapped",[1576,1605]],[[64521,64521],"mapped",[1576,1609]],[[64522,64522],"mapped",[1576,1610]],[[64523,64523],"mapped",[1578,1580]],[[64524,64524],"mapped",[1578,1581]],[[64525,64525],"mapped",[1578,1582]],[[64526,64526],"mapped",[1578,1605]],[[64527,64527],"mapped",[1578,1609]],[[64528,64528],"mapped",[1578,1610]],[[64529,64529],"mapped",[1579,1580]],[[64530,64530],"mapped",[1579,1605]],[[64531,64531],"mapped",[1579,1609]],[[64532,64532],"mapped",[1579,1610]],[[64533,64533],"mapped",[1580,1581]],[[64534,64534],"mapped",[1580,1605]],[[64535,64535],"mapped",[1581,1580]],[[64536,64536],"mapped",[1581,1605]],[[64537,64537],"mapped",[1582,1580]],[[64538,64538],"mapped",[1582,1581]],[[64539,64539],"mapped",[1582,1605]],[[64540,64540],"mapped",[1587,1580]],[[64541,64541],"mapped",[1587,1581]],[[64542,64542],"mapped",[1587,1582]],[[64543,64543],"mapped",[1587,1605]],[[64544,64544],"mapped",[1589,1581]],[[64545,64545],"mapped",[1589,1605]],[[64546,64546],"mapped",[1590,1580]],[[64547,64547],"mapped",[1590,1581]],[[64548,64548],"mapped",[1590,1582]],[[64549,64549],"mapped",[1590,1605]],[[64550,64550],"mapped",[1591,1581]],[[64551,64551],"mapped",[1591,1605]],[[64552,64552],"mapped",[1592,1605]],[[64553,64553],"mapped",[1593,1580]],[[64554,64554],"mapped",[1593,1605]],[[64555,64555],"mapped",[1594,1580]],[[64556,64556],"mapped",[1594,1605]],[[64557,64557],"mapped",[1601,1580]],[[64558,64558],"mapped",[1601,1581]],[[64559,64559],"mapped",[1601,1582]],[[64560,64560],"mapped",[1601,1605]],[[64561,64561],"mapped",[1601,1609]],[[64562,64562],"mapped",[1601,1610]],[[64563,64563],"mapped",[1602,1581]],[[64564,64564],"mapped",[1602,1605]],[[64565,64565],"mapped",[1602,1609]],[[64566,64566],"mapped",[1602,1610]],[[64567,64567],"mapped",[1603,1575]],[[64568,64568],"mapped",[1603,1580]],[[64569,64569],"mapped",[1603,1581]],[[64570,64570],"mapped",[1603,1582]],[[64571,64571],"mapped",[1603,1604]],[[64572,64572],"mapped",[1603,1605]],[[64573,64573],"mapped",[1603,1609]],[[64574,64574],"mapped",[1603,1610]],[[64575,64575],"mapped",[1604,1580]],[[64576,64576],"mapped",[1604,1581]],[[64577,64577],"mapped",[1604,1582]],[[64578,64578],"mapped",[1604,1605]],[[64579,64579],"mapped",[1604,1609]],[[64580,64580],"mapped",[1604,1610]],[[64581,64581],"mapped",[1605,1580]],[[64582,64582],"mapped",[1605,1581]],[[64583,64583],"mapped",[1605,1582]],[[64584,64584],"mapped",[1605,1605]],[[64585,64585],"mapped",[1605,1609]],[[64586,64586],"mapped",[1605,1610]],[[64587,64587],"mapped",[1606,1580]],[[64588,64588],"mapped",[1606,1581]],[[64589,64589],"mapped",[1606,1582]],[[64590,64590],"mapped",[1606,1605]],[[64591,64591],"mapped",[1606,1609]],[[64592,64592],"mapped",[1606,1610]],[[64593,64593],"mapped",[1607,1580]],[[64594,64594],"mapped",[1607,1605]],[[64595,64595],"mapped",[1607,1609]],[[64596,64596],"mapped",[1607,1610]],[[64597,64597],"mapped",[1610,1580]],[[64598,64598],"mapped",[1610,1581]],[[64599,64599],"mapped",[1610,1582]],[[64600,64600],"mapped",[1610,1605]],[[64601,64601],"mapped",[1610,1609]],[[64602,64602],"mapped",[1610,1610]],[[64603,64603],"mapped",[1584,1648]],[[64604,64604],"mapped",[1585,1648]],[[64605,64605],"mapped",[1609,1648]],[[64606,64606],"disallowed_STD3_mapped",[32,1612,1617]],[[64607,64607],"disallowed_STD3_mapped",[32,1613,1617]],[[64608,64608],"disallowed_STD3_mapped",[32,1614,1617]],[[64609,64609],"disallowed_STD3_mapped",[32,1615,1617]],[[64610,64610],"disallowed_STD3_mapped",[32,1616,1617]],[[64611,64611],"disallowed_STD3_mapped",[32,1617,1648]],[[64612,64612],"mapped",[1574,1585]],[[64613,64613],"mapped",[1574,1586]],[[64614,64614],"mapped",[1574,1605]],[[64615,64615],"mapped",[1574,1606]],[[64616,64616],"mapped",[1574,1609]],[[64617,64617],"mapped",[1574,1610]],[[64618,64618],"mapped",[1576,1585]],[[64619,64619],"mapped",[1576,1586]],[[64620,64620],"mapped",[1576,1605]],[[64621,64621],"mapped",[1576,1606]],[[64622,64622],"mapped",[1576,1609]],[[64623,64623],"mapped",[1576,1610]],[[64624,64624],"mapped",[1578,1585]],[[64625,64625],"mapped",[1578,1586]],[[64626,64626],"mapped",[1578,1605]],[[64627,64627],"mapped",[1578,1606]],[[64628,64628],"mapped",[1578,1609]],[[64629,64629],"mapped",[1578,1610]],[[64630,64630],"mapped",[1579,1585]],[[64631,64631],"mapped",[1579,1586]],[[64632,64632],"mapped",[1579,1605]],[[64633,64633],"mapped",[1579,1606]],[[64634,64634],"mapped",[1579,1609]],[[64635,64635],"mapped",[1579,1610]],[[64636,64636],"mapped",[1601,1609]],[[64637,64637],"mapped",[1601,1610]],[[64638,64638],"mapped",[1602,1609]],[[64639,64639],"mapped",[1602,1610]],[[64640,64640],"mapped",[1603,1575]],[[64641,64641],"mapped",[1603,1604]],[[64642,64642],"mapped",[1603,1605]],[[64643,64643],"mapped",[1603,1609]],[[64644,64644],"mapped",[1603,1610]],[[64645,64645],"mapped",[1604,1605]],[[64646,64646],"mapped",[1604,1609]],[[64647,64647],"mapped",[1604,1610]],[[64648,64648],"mapped",[1605,1575]],[[64649,64649],"mapped",[1605,1605]],[[64650,64650],"mapped",[1606,1585]],[[64651,64651],"mapped",[1606,1586]],[[64652,64652],"mapped",[1606,1605]],[[64653,64653],"mapped",[1606,1606]],[[64654,64654],"mapped",[1606,1609]],[[64655,64655],"mapped",[1606,1610]],[[64656,64656],"mapped",[1609,1648]],[[64657,64657],"mapped",[1610,1585]],[[64658,64658],"mapped",[1610,1586]],[[64659,64659],"mapped",[1610,1605]],[[64660,64660],"mapped",[1610,1606]],[[64661,64661],"mapped",[1610,1609]],[[64662,64662],"mapped",[1610,1610]],[[64663,64663],"mapped",[1574,1580]],[[64664,64664],"mapped",[1574,1581]],[[64665,64665],"mapped",[1574,1582]],[[64666,64666],"mapped",[1574,1605]],[[64667,64667],"mapped",[1574,1607]],[[64668,64668],"mapped",[1576,1580]],[[64669,64669],"mapped",[1576,1581]],[[64670,64670],"mapped",[1576,1582]],[[64671,64671],"mapped",[1576,1605]],[[64672,64672],"mapped",[1576,1607]],[[64673,64673],"mapped",[1578,1580]],[[64674,64674],"mapped",[1578,1581]],[[64675,64675],"mapped",[1578,1582]],[[64676,64676],"mapped",[1578,1605]],[[64677,64677],"mapped",[1578,1607]],[[64678,64678],"mapped",[1579,1605]],[[64679,64679],"mapped",[1580,1581]],[[64680,64680],"mapped",[1580,1605]],[[64681,64681],"mapped",[1581,1580]],[[64682,64682],"mapped",[1581,1605]],[[64683,64683],"mapped",[1582,1580]],[[64684,64684],"mapped",[1582,1605]],[[64685,64685],"mapped",[1587,1580]],[[64686,64686],"mapped",[1587,1581]],[[64687,64687],"mapped",[1587,1582]],[[64688,64688],"mapped",[1587,1605]],[[64689,64689],"mapped",[1589,1581]],[[64690,64690],"mapped",[1589,1582]],[[64691,64691],"mapped",[1589,1605]],[[64692,64692],"mapped",[1590,1580]],[[64693,64693],"mapped",[1590,1581]],[[64694,64694],"mapped",[1590,1582]],[[64695,64695],"mapped",[1590,1605]],[[64696,64696],"mapped",[1591,1581]],[[64697,64697],"mapped",[1592,1605]],[[64698,64698],"mapped",[1593,1580]],[[64699,64699],"mapped",[1593,1605]],[[64700,64700],"mapped",[1594,1580]],[[64701,64701],"mapped",[1594,1605]],[[64702,64702],"mapped",[1601,1580]],[[64703,64703],"mapped",[1601,1581]],[[64704,64704],"mapped",[1601,1582]],[[64705,64705],"mapped",[1601,1605]],[[64706,64706],"mapped",[1602,1581]],[[64707,64707],"mapped",[1602,1605]],[[64708,64708],"mapped",[1603,1580]],[[64709,64709],"mapped",[1603,1581]],[[64710,64710],"mapped",[1603,1582]],[[64711,64711],"mapped",[1603,1604]],[[64712,64712],"mapped",[1603,1605]],[[64713,64713],"mapped",[1604,1580]],[[64714,64714],"mapped",[1604,1581]],[[64715,64715],"mapped",[1604,1582]],[[64716,64716],"mapped",[1604,1605]],[[64717,64717],"mapped",[1604,1607]],[[64718,64718],"mapped",[1605,1580]],[[64719,64719],"mapped",[1605,1581]],[[64720,64720],"mapped",[1605,1582]],[[64721,64721],"mapped",[1605,1605]],[[64722,64722],"mapped",[1606,1580]],[[64723,64723],"mapped",[1606,1581]],[[64724,64724],"mapped",[1606,1582]],[[64725,64725],"mapped",[1606,1605]],[[64726,64726],"mapped",[1606,1607]],[[64727,64727],"mapped",[1607,1580]],[[64728,64728],"mapped",[1607,1605]],[[64729,64729],"mapped",[1607,1648]],[[64730,64730],"mapped",[1610,1580]],[[64731,64731],"mapped",[1610,1581]],[[64732,64732],"mapped",[1610,1582]],[[64733,64733],"mapped",[1610,1605]],[[64734,64734],"mapped",[1610,1607]],[[64735,64735],"mapped",[1574,1605]],[[64736,64736],"mapped",[1574,1607]],[[64737,64737],"mapped",[1576,1605]],[[64738,64738],"mapped",[1576,1607]],[[64739,64739],"mapped",[1578,1605]],[[64740,64740],"mapped",[1578,1607]],[[64741,64741],"mapped",[1579,1605]],[[64742,64742],"mapped",[1579,1607]],[[64743,64743],"mapped",[1587,1605]],[[64744,64744],"mapped",[1587,1607]],[[64745,64745],"mapped",[1588,1605]],[[64746,64746],"mapped",[1588,1607]],[[64747,64747],"mapped",[1603,1604]],[[64748,64748],"mapped",[1603,1605]],[[64749,64749],"mapped",[1604,1605]],[[64750,64750],"mapped",[1606,1605]],[[64751,64751],"mapped",[1606,1607]],[[64752,64752],"mapped",[1610,1605]],[[64753,64753],"mapped",[1610,1607]],[[64754,64754],"mapped",[1600,1614,1617]],[[64755,64755],"mapped",[1600,1615,1617]],[[64756,64756],"mapped",[1600,1616,1617]],[[64757,64757],"mapped",[1591,1609]],[[64758,64758],"mapped",[1591,1610]],[[64759,64759],"mapped",[1593,1609]],[[64760,64760],"mapped",[1593,1610]],[[64761,64761],"mapped",[1594,1609]],[[64762,64762],"mapped",[1594,1610]],[[64763,64763],"mapped",[1587,1609]],[[64764,64764],"mapped",[1587,1610]],[[64765,64765],"mapped",[1588,1609]],[[64766,64766],"mapped",[1588,1610]],[[64767,64767],"mapped",[1581,1609]],[[64768,64768],"mapped",[1581,1610]],[[64769,64769],"mapped",[1580,1609]],[[64770,64770],"mapped",[1580,1610]],[[64771,64771],"mapped",[1582,1609]],[[64772,64772],"mapped",[1582,1610]],[[64773,64773],"mapped",[1589,1609]],[[64774,64774],"mapped",[1589,1610]],[[64775,64775],"mapped",[1590,1609]],[[64776,64776],"mapped",[1590,1610]],[[64777,64777],"mapped",[1588,1580]],[[64778,64778],"mapped",[1588,1581]],[[64779,64779],"mapped",[1588,1582]],[[64780,64780],"mapped",[1588,1605]],[[64781,64781],"mapped",[1588,1585]],[[64782,64782],"mapped",[1587,1585]],[[64783,64783],"mapped",[1589,1585]],[[64784,64784],"mapped",[1590,1585]],[[64785,64785],"mapped",[1591,1609]],[[64786,64786],"mapped",[1591,1610]],[[64787,64787],"mapped",[1593,1609]],[[64788,64788],"mapped",[1593,1610]],[[64789,64789],"mapped",[1594,1609]],[[64790,64790],"mapped",[1594,1610]],[[64791,64791],"mapped",[1587,1609]],[[64792,64792],"mapped",[1587,1610]],[[64793,64793],"mapped",[1588,1609]],[[64794,64794],"mapped",[1588,1610]],[[64795,64795],"mapped",[1581,1609]],[[64796,64796],"mapped",[1581,1610]],[[64797,64797],"mapped",[1580,1609]],[[64798,64798],"mapped",[1580,1610]],[[64799,64799],"mapped",[1582,1609]],[[64800,64800],"mapped",[1582,1610]],[[64801,64801],"mapped",[1589,1609]],[[64802,64802],"mapped",[1589,1610]],[[64803,64803],"mapped",[1590,1609]],[[64804,64804],"mapped",[1590,1610]],[[64805,64805],"mapped",[1588,1580]],[[64806,64806],"mapped",[1588,1581]],[[64807,64807],"mapped",[1588,1582]],[[64808,64808],"mapped",[1588,1605]],[[64809,64809],"mapped",[1588,1585]],[[64810,64810],"mapped",[1587,1585]],[[64811,64811],"mapped",[1589,1585]],[[64812,64812],"mapped",[1590,1585]],[[64813,64813],"mapped",[1588,1580]],[[64814,64814],"mapped",[1588,1581]],[[64815,64815],"mapped",[1588,1582]],[[64816,64816],"mapped",[1588,1605]],[[64817,64817],"mapped",[1587,1607]],[[64818,64818],"mapped",[1588,1607]],[[64819,64819],"mapped",[1591,1605]],[[64820,64820],"mapped",[1587,1580]],[[64821,64821],"mapped",[1587,1581]],[[64822,64822],"mapped",[1587,1582]],[[64823,64823],"mapped",[1588,1580]],[[64824,64824],"mapped",[1588,1581]],[[64825,64825],"mapped",[1588,1582]],[[64826,64826],"mapped",[1591,1605]],[[64827,64827],"mapped",[1592,1605]],[[64828,64829],"mapped",[1575,1611]],[[64830,64831],"valid",[],"NV8"],[[64832,64847],"disallowed"],[[64848,64848],"mapped",[1578,1580,1605]],[[64849,64850],"mapped",[1578,1581,1580]],[[64851,64851],"mapped",[1578,1581,1605]],[[64852,64852],"mapped",[1578,1582,1605]],[[64853,64853],"mapped",[1578,1605,1580]],[[64854,64854],"mapped",[1578,1605,1581]],[[64855,64855],"mapped",[1578,1605,1582]],[[64856,64857],"mapped",[1580,1605,1581]],[[64858,64858],"mapped",[1581,1605,1610]],[[64859,64859],"mapped",[1581,1605,1609]],[[64860,64860],"mapped",[1587,1581,1580]],[[64861,64861],"mapped",[1587,1580,1581]],[[64862,64862],"mapped",[1587,1580,1609]],[[64863,64864],"mapped",[1587,1605,1581]],[[64865,64865],"mapped",[1587,1605,1580]],[[64866,64867],"mapped",[1587,1605,1605]],[[64868,64869],"mapped",[1589,1581,1581]],[[64870,64870],"mapped",[1589,1605,1605]],[[64871,64872],"mapped",[1588,1581,1605]],[[64873,64873],"mapped",[1588,1580,1610]],[[64874,64875],"mapped",[1588,1605,1582]],[[64876,64877],"mapped",[1588,1605,1605]],[[64878,64878],"mapped",[1590,1581,1609]],[[64879,64880],"mapped",[1590,1582,1605]],[[64881,64882],"mapped",[1591,1605,1581]],[[64883,64883],"mapped",[1591,1605,1605]],[[64884,64884],"mapped",[1591,1605,1610]],[[64885,64885],"mapped",[1593,1580,1605]],[[64886,64887],"mapped",[1593,1605,1605]],[[64888,64888],"mapped",[1593,1605,1609]],[[64889,64889],"mapped",[1594,1605,1605]],[[64890,64890],"mapped",[1594,1605,1610]],[[64891,64891],"mapped",[1594,1605,1609]],[[64892,64893],"mapped",[1601,1582,1605]],[[64894,64894],"mapped",[1602,1605,1581]],[[64895,64895],"mapped",[1602,1605,1605]],[[64896,64896],"mapped",[1604,1581,1605]],[[64897,64897],"mapped",[1604,1581,1610]],[[64898,64898],"mapped",[1604,1581,1609]],[[64899,64900],"mapped",[1604,1580,1580]],[[64901,64902],"mapped",[1604,1582,1605]],[[64903,64904],"mapped",[1604,1605,1581]],[[64905,64905],"mapped",[1605,1581,1580]],[[64906,64906],"mapped",[1605,1581,1605]],[[64907,64907],"mapped",[1605,1581,1610]],[[64908,64908],"mapped",[1605,1580,1581]],[[64909,64909],"mapped",[1605,1580,1605]],[[64910,64910],"mapped",[1605,1582,1580]],[[64911,64911],"mapped",[1605,1582,1605]],[[64912,64913],"disallowed"],[[64914,64914],"mapped",[1605,1580,1582]],[[64915,64915],"mapped",[1607,1605,1580]],[[64916,64916],"mapped",[1607,1605,1605]],[[64917,64917],"mapped",[1606,1581,1605]],[[64918,64918],"mapped",[1606,1581,1609]],[[64919,64920],"mapped",[1606,1580,1605]],[[64921,64921],"mapped",[1606,1580,1609]],[[64922,64922],"mapped",[1606,1605,1610]],[[64923,64923],"mapped",[1606,1605,1609]],[[64924,64925],"mapped",[1610,1605,1605]],[[64926,64926],"mapped",[1576,1582,1610]],[[64927,64927],"mapped",[1578,1580,1610]],[[64928,64928],"mapped",[1578,1580,1609]],[[64929,64929],"mapped",[1578,1582,1610]],[[64930,64930],"mapped",[1578,1582,1609]],[[64931,64931],"mapped",[1578,1605,1610]],[[64932,64932],"mapped",[1578,1605,1609]],[[64933,64933],"mapped",[1580,1605,1610]],[[64934,64934],"mapped",[1580,1581,1609]],[[64935,64935],"mapped",[1580,1605,1609]],[[64936,64936],"mapped",[1587,1582,1609]],[[64937,64937],"mapped",[1589,1581,1610]],[[64938,64938],"mapped",[1588,1581,1610]],[[64939,64939],"mapped",[1590,1581,1610]],[[64940,64940],"mapped",[1604,1580,1610]],[[64941,64941],"mapped",[1604,1605,1610]],[[64942,64942],"mapped",[1610,1581,1610]],[[64943,64943],"mapped",[1610,1580,1610]],[[64944,64944],"mapped",[1610,1605,1610]],[[64945,64945],"mapped",[1605,1605,1610]],[[64946,64946],"mapped",[1602,1605,1610]],[[64947,64947],"mapped",[1606,1581,1610]],[[64948,64948],"mapped",[1602,1605,1581]],[[64949,64949],"mapped",[1604,1581,1605]],[[64950,64950],"mapped",[1593,1605,1610]],[[64951,64951],"mapped",[1603,1605,1610]],[[64952,64952],"mapped",[1606,1580,1581]],[[64953,64953],"mapped",[1605,1582,1610]],[[64954,64954],"mapped",[1604,1580,1605]],[[64955,64955],"mapped",[1603,1605,1605]],[[64956,64956],"mapped",[1604,1580,1605]],[[64957,64957],"mapped",[1606,1580,1581]],[[64958,64958],"mapped",[1580,1581,1610]],[[64959,64959],"mapped",[1581,1580,1610]],[[64960,64960],"mapped",[1605,1580,1610]],[[64961,64961],"mapped",[1601,1605,1610]],[[64962,64962],"mapped",[1576,1581,1610]],[[64963,64963],"mapped",[1603,1605,1605]],[[64964,64964],"mapped",[1593,1580,1605]],[[64965,64965],"mapped",[1589,1605,1605]],[[64966,64966],"mapped",[1587,1582,1610]],[[64967,64967],"mapped",[1606,1580,1610]],[[64968,64975],"disallowed"],[[64976,65007],"disallowed"],[[65008,65008],"mapped",[1589,1604,1746]],[[65009,65009],"mapped",[1602,1604,1746]],[[65010,65010],"mapped",[1575,1604,1604,1607]],[[65011,65011],"mapped",[1575,1603,1576,1585]],[[65012,65012],"mapped",[1605,1581,1605,1583]],[[65013,65013],"mapped",[1589,1604,1593,1605]],[[65014,65014],"mapped",[1585,1587,1608,1604]],[[65015,65015],"mapped",[1593,1604,1610,1607]],[[65016,65016],"mapped",[1608,1587,1604,1605]],[[65017,65017],"mapped",[1589,1604,1609]],[[65018,65018],"disallowed_STD3_mapped",[1589,1604,1609,32,1575,1604,1604,1607,32,1593,1604,1610,1607,32,1608,1587,1604,1605]],[[65019,65019],"disallowed_STD3_mapped",[1580,1604,32,1580,1604,1575,1604,1607]],[[65020,65020],"mapped",[1585,1740,1575,1604]],[[65021,65021],"valid",[],"NV8"],[[65022,65023],"disallowed"],[[65024,65039],"ignored"],[[65040,65040],"disallowed_STD3_mapped",[44]],[[65041,65041],"mapped",[12289]],[[65042,65042],"disallowed"],[[65043,65043],"disallowed_STD3_mapped",[58]],[[65044,65044],"disallowed_STD3_mapped",[59]],[[65045,65045],"disallowed_STD3_mapped",[33]],[[65046,65046],"disallowed_STD3_mapped",[63]],[[65047,65047],"mapped",[12310]],[[65048,65048],"mapped",[12311]],[[65049,65049],"disallowed"],[[65050,65055],"disallowed"],[[65056,65059],"valid"],[[65060,65062],"valid"],[[65063,65069],"valid"],[[65070,65071],"valid"],[[65072,65072],"disallowed"],[[65073,65073],"mapped",[8212]],[[65074,65074],"mapped",[8211]],[[65075,65076],"disallowed_STD3_mapped",[95]],[[65077,65077],"disallowed_STD3_mapped",[40]],[[65078,65078],"disallowed_STD3_mapped",[41]],[[65079,65079],"disallowed_STD3_mapped",[123]],[[65080,65080],"disallowed_STD3_mapped",[125]],[[65081,65081],"mapped",[12308]],[[65082,65082],"mapped",[12309]],[[65083,65083],"mapped",[12304]],[[65084,65084],"mapped",[12305]],[[65085,65085],"mapped",[12298]],[[65086,65086],"mapped",[12299]],[[65087,65087],"mapped",[12296]],[[65088,65088],"mapped",[12297]],[[65089,65089],"mapped",[12300]],[[65090,65090],"mapped",[12301]],[[65091,65091],"mapped",[12302]],[[65092,65092],"mapped",[12303]],[[65093,65094],"valid",[],"NV8"],[[65095,65095],"disallowed_STD3_mapped",[91]],[[65096,65096],"disallowed_STD3_mapped",[93]],[[65097,65100],"disallowed_STD3_mapped",[32,773]],[[65101,65103],"disallowed_STD3_mapped",[95]],[[65104,65104],"disallowed_STD3_mapped",[44]],[[65105,65105],"mapped",[12289]],[[65106,65106],"disallowed"],[[65107,65107],"disallowed"],[[65108,65108],"disallowed_STD3_mapped",[59]],[[65109,65109],"disallowed_STD3_mapped",[58]],[[65110,65110],"disallowed_STD3_mapped",[63]],[[65111,65111],"disallowed_STD3_mapped",[33]],[[65112,65112],"mapped",[8212]],[[65113,65113],"disallowed_STD3_mapped",[40]],[[65114,65114],"disallowed_STD3_mapped",[41]],[[65115,65115],"disallowed_STD3_mapped",[123]],[[65116,65116],"disallowed_STD3_mapped",[125]],[[65117,65117],"mapped",[12308]],[[65118,65118],"mapped",[12309]],[[65119,65119],"disallowed_STD3_mapped",[35]],[[65120,65120],"disallowed_STD3_mapped",[38]],[[65121,65121],"disallowed_STD3_mapped",[42]],[[65122,65122],"disallowed_STD3_mapped",[43]],[[65123,65123],"mapped",[45]],[[65124,65124],"disallowed_STD3_mapped",[60]],[[65125,65125],"disallowed_STD3_mapped",[62]],[[65126,65126],"disallowed_STD3_mapped",[61]],[[65127,65127],"disallowed"],[[65128,65128],"disallowed_STD3_mapped",[92]],[[65129,65129],"disallowed_STD3_mapped",[36]],[[65130,65130],"disallowed_STD3_mapped",[37]],[[65131,65131],"disallowed_STD3_mapped",[64]],[[65132,65135],"disallowed"],[[65136,65136],"disallowed_STD3_mapped",[32,1611]],[[65137,65137],"mapped",[1600,1611]],[[65138,65138],"disallowed_STD3_mapped",[32,1612]],[[65139,65139],"valid"],[[65140,65140],"disallowed_STD3_mapped",[32,1613]],[[65141,65141],"disallowed"],[[65142,65142],"disallowed_STD3_mapped",[32,1614]],[[65143,65143],"mapped",[1600,1614]],[[65144,65144],"disallowed_STD3_mapped",[32,1615]],[[65145,65145],"mapped",[1600,1615]],[[65146,65146],"disallowed_STD3_mapped",[32,1616]],[[65147,65147],"mapped",[1600,1616]],[[65148,65148],"disallowed_STD3_mapped",[32,1617]],[[65149,65149],"mapped",[1600,1617]],[[65150,65150],"disallowed_STD3_mapped",[32,1618]],[[65151,65151],"mapped",[1600,1618]],[[65152,65152],"mapped",[1569]],[[65153,65154],"mapped",[1570]],[[65155,65156],"mapped",[1571]],[[65157,65158],"mapped",[1572]],[[65159,65160],"mapped",[1573]],[[65161,65164],"mapped",[1574]],[[65165,65166],"mapped",[1575]],[[65167,65170],"mapped",[1576]],[[65171,65172],"mapped",[1577]],[[65173,65176],"mapped",[1578]],[[65177,65180],"mapped",[1579]],[[65181,65184],"mapped",[1580]],[[65185,65188],"mapped",[1581]],[[65189,65192],"mapped",[1582]],[[65193,65194],"mapped",[1583]],[[65195,65196],"mapped",[1584]],[[65197,65198],"mapped",[1585]],[[65199,65200],"mapped",[1586]],[[65201,65204],"mapped",[1587]],[[65205,65208],"mapped",[1588]],[[65209,65212],"mapped",[1589]],[[65213,65216],"mapped",[1590]],[[65217,65220],"mapped",[1591]],[[65221,65224],"mapped",[1592]],[[65225,65228],"mapped",[1593]],[[65229,65232],"mapped",[1594]],[[65233,65236],"mapped",[1601]],[[65237,65240],"mapped",[1602]],[[65241,65244],"mapped",[1603]],[[65245,65248],"mapped",[1604]],[[65249,65252],"mapped",[1605]],[[65253,65256],"mapped",[1606]],[[65257,65260],"mapped",[1607]],[[65261,65262],"mapped",[1608]],[[65263,65264],"mapped",[1609]],[[65265,65268],"mapped",[1610]],[[65269,65270],"mapped",[1604,1570]],[[65271,65272],"mapped",[1604,1571]],[[65273,65274],"mapped",[1604,1573]],[[65275,65276],"mapped",[1604,1575]],[[65277,65278],"disallowed"],[[65279,65279],"ignored"],[[65280,65280],"disallowed"],[[65281,65281],"disallowed_STD3_mapped",[33]],[[65282,65282],"disallowed_STD3_mapped",[34]],[[65283,65283],"disallowed_STD3_mapped",[35]],[[65284,65284],"disallowed_STD3_mapped",[36]],[[65285,65285],"disallowed_STD3_mapped",[37]],[[65286,65286],"disallowed_STD3_mapped",[38]],[[65287,65287],"disallowed_STD3_mapped",[39]],[[65288,65288],"disallowed_STD3_mapped",[40]],[[65289,65289],"disallowed_STD3_mapped",[41]],[[65290,65290],"disallowed_STD3_mapped",[42]],[[65291,65291],"disallowed_STD3_mapped",[43]],[[65292,65292],"disallowed_STD3_mapped",[44]],[[65293,65293],"mapped",[45]],[[65294,65294],"mapped",[46]],[[65295,65295],"disallowed_STD3_mapped",[47]],[[65296,65296],"mapped",[48]],[[65297,65297],"mapped",[49]],[[65298,65298],"mapped",[50]],[[65299,65299],"mapped",[51]],[[65300,65300],"mapped",[52]],[[65301,65301],"mapped",[53]],[[65302,65302],"mapped",[54]],[[65303,65303],"mapped",[55]],[[65304,65304],"mapped",[56]],[[65305,65305],"mapped",[57]],[[65306,65306],"disallowed_STD3_mapped",[58]],[[65307,65307],"disallowed_STD3_mapped",[59]],[[65308,65308],"disallowed_STD3_mapped",[60]],[[65309,65309],"disallowed_STD3_mapped",[61]],[[65310,65310],"disallowed_STD3_mapped",[62]],[[65311,65311],"disallowed_STD3_mapped",[63]],[[65312,65312],"disallowed_STD3_mapped",[64]],[[65313,65313],"mapped",[97]],[[65314,65314],"mapped",[98]],[[65315,65315],"mapped",[99]],[[65316,65316],"mapped",[100]],[[65317,65317],"mapped",[101]],[[65318,65318],"mapped",[102]],[[65319,65319],"mapped",[103]],[[65320,65320],"mapped",[104]],[[65321,65321],"mapped",[105]],[[65322,65322],"mapped",[106]],[[65323,65323],"mapped",[107]],[[65324,65324],"mapped",[108]],[[65325,65325],"mapped",[109]],[[65326,65326],"mapped",[110]],[[65327,65327],"mapped",[111]],[[65328,65328],"mapped",[112]],[[65329,65329],"mapped",[113]],[[65330,65330],"mapped",[114]],[[65331,65331],"mapped",[115]],[[65332,65332],"mapped",[116]],[[65333,65333],"mapped",[117]],[[65334,65334],"mapped",[118]],[[65335,65335],"mapped",[119]],[[65336,65336],"mapped",[120]],[[65337,65337],"mapped",[121]],[[65338,65338],"mapped",[122]],[[65339,65339],"disallowed_STD3_mapped",[91]],[[65340,65340],"disallowed_STD3_mapped",[92]],[[65341,65341],"disallowed_STD3_mapped",[93]],[[65342,65342],"disallowed_STD3_mapped",[94]],[[65343,65343],"disallowed_STD3_mapped",[95]],[[65344,65344],"disallowed_STD3_mapped",[96]],[[65345,65345],"mapped",[97]],[[65346,65346],"mapped",[98]],[[65347,65347],"mapped",[99]],[[65348,65348],"mapped",[100]],[[65349,65349],"mapped",[101]],[[65350,65350],"mapped",[102]],[[65351,65351],"mapped",[103]],[[65352,65352],"mapped",[104]],[[65353,65353],"mapped",[105]],[[65354,65354],"mapped",[106]],[[65355,65355],"mapped",[107]],[[65356,65356],"mapped",[108]],[[65357,65357],"mapped",[109]],[[65358,65358],"mapped",[110]],[[65359,65359],"mapped",[111]],[[65360,65360],"mapped",[112]],[[65361,65361],"mapped",[113]],[[65362,65362],"mapped",[114]],[[65363,65363],"mapped",[115]],[[65364,65364],"mapped",[116]],[[65365,65365],"mapped",[117]],[[65366,65366],"mapped",[118]],[[65367,65367],"mapped",[119]],[[65368,65368],"mapped",[120]],[[65369,65369],"mapped",[121]],[[65370,65370],"mapped",[122]],[[65371,65371],"disallowed_STD3_mapped",[123]],[[65372,65372],"disallowed_STD3_mapped",[124]],[[65373,65373],"disallowed_STD3_mapped",[125]],[[65374,65374],"disallowed_STD3_mapped",[126]],[[65375,65375],"mapped",[10629]],[[65376,65376],"mapped",[10630]],[[65377,65377],"mapped",[46]],[[65378,65378],"mapped",[12300]],[[65379,65379],"mapped",[12301]],[[65380,65380],"mapped",[12289]],[[65381,65381],"mapped",[12539]],[[65382,65382],"mapped",[12530]],[[65383,65383],"mapped",[12449]],[[65384,65384],"mapped",[12451]],[[65385,65385],"mapped",[12453]],[[65386,65386],"mapped",[12455]],[[65387,65387],"mapped",[12457]],[[65388,65388],"mapped",[12515]],[[65389,65389],"mapped",[12517]],[[65390,65390],"mapped",[12519]],[[65391,65391],"mapped",[12483]],[[65392,65392],"mapped",[12540]],[[65393,65393],"mapped",[12450]],[[65394,65394],"mapped",[12452]],[[65395,65395],"mapped",[12454]],[[65396,65396],"mapped",[12456]],[[65397,65397],"mapped",[12458]],[[65398,65398],"mapped",[12459]],[[65399,65399],"mapped",[12461]],[[65400,65400],"mapped",[12463]],[[65401,65401],"mapped",[12465]],[[65402,65402],"mapped",[12467]],[[65403,65403],"mapped",[12469]],[[65404,65404],"mapped",[12471]],[[65405,65405],"mapped",[12473]],[[65406,65406],"mapped",[12475]],[[65407,65407],"mapped",[12477]],[[65408,65408],"mapped",[12479]],[[65409,65409],"mapped",[12481]],[[65410,65410],"mapped",[12484]],[[65411,65411],"mapped",[12486]],[[65412,65412],"mapped",[12488]],[[65413,65413],"mapped",[12490]],[[65414,65414],"mapped",[12491]],[[65415,65415],"mapped",[12492]],[[65416,65416],"mapped",[12493]],[[65417,65417],"mapped",[12494]],[[65418,65418],"mapped",[12495]],[[65419,65419],"mapped",[12498]],[[65420,65420],"mapped",[12501]],[[65421,65421],"mapped",[12504]],[[65422,65422],"mapped",[12507]],[[65423,65423],"mapped",[12510]],[[65424,65424],"mapped",[12511]],[[65425,65425],"mapped",[12512]],[[65426,65426],"mapped",[12513]],[[65427,65427],"mapped",[12514]],[[65428,65428],"mapped",[12516]],[[65429,65429],"mapped",[12518]],[[65430,65430],"mapped",[12520]],[[65431,65431],"mapped",[12521]],[[65432,65432],"mapped",[12522]],[[65433,65433],"mapped",[12523]],[[65434,65434],"mapped",[12524]],[[65435,65435],"mapped",[12525]],[[65436,65436],"mapped",[12527]],[[65437,65437],"mapped",[12531]],[[65438,65438],"mapped",[12441]],[[65439,65439],"mapped",[12442]],[[65440,65440],"disallowed"],[[65441,65441],"mapped",[4352]],[[65442,65442],"mapped",[4353]],[[65443,65443],"mapped",[4522]],[[65444,65444],"mapped",[4354]],[[65445,65445],"mapped",[4524]],[[65446,65446],"mapped",[4525]],[[65447,65447],"mapped",[4355]],[[65448,65448],"mapped",[4356]],[[65449,65449],"mapped",[4357]],[[65450,65450],"mapped",[4528]],[[65451,65451],"mapped",[4529]],[[65452,65452],"mapped",[4530]],[[65453,65453],"mapped",[4531]],[[65454,65454],"mapped",[4532]],[[65455,65455],"mapped",[4533]],[[65456,65456],"mapped",[4378]],[[65457,65457],"mapped",[4358]],[[65458,65458],"mapped",[4359]],[[65459,65459],"mapped",[4360]],[[65460,65460],"mapped",[4385]],[[65461,65461],"mapped",[4361]],[[65462,65462],"mapped",[4362]],[[65463,65463],"mapped",[4363]],[[65464,65464],"mapped",[4364]],[[65465,65465],"mapped",[4365]],[[65466,65466],"mapped",[4366]],[[65467,65467],"mapped",[4367]],[[65468,65468],"mapped",[4368]],[[65469,65469],"mapped",[4369]],[[65470,65470],"mapped",[4370]],[[65471,65473],"disallowed"],[[65474,65474],"mapped",[4449]],[[65475,65475],"mapped",[4450]],[[65476,65476],"mapped",[4451]],[[65477,65477],"mapped",[4452]],[[65478,65478],"mapped",[4453]],[[65479,65479],"mapped",[4454]],[[65480,65481],"disallowed"],[[65482,65482],"mapped",[4455]],[[65483,65483],"mapped",[4456]],[[65484,65484],"mapped",[4457]],[[65485,65485],"mapped",[4458]],[[65486,65486],"mapped",[4459]],[[65487,65487],"mapped",[4460]],[[65488,65489],"disallowed"],[[65490,65490],"mapped",[4461]],[[65491,65491],"mapped",[4462]],[[65492,65492],"mapped",[4463]],[[65493,65493],"mapped",[4464]],[[65494,65494],"mapped",[4465]],[[65495,65495],"mapped",[4466]],[[65496,65497],"disallowed"],[[65498,65498],"mapped",[4467]],[[65499,65499],"mapped",[4468]],[[65500,65500],"mapped",[4469]],[[65501,65503],"disallowed"],[[65504,65504],"mapped",[162]],[[65505,65505],"mapped",[163]],[[65506,65506],"mapped",[172]],[[65507,65507],"disallowed_STD3_mapped",[32,772]],[[65508,65508],"mapped",[166]],[[65509,65509],"mapped",[165]],[[65510,65510],"mapped",[8361]],[[65511,65511],"disallowed"],[[65512,65512],"mapped",[9474]],[[65513,65513],"mapped",[8592]],[[65514,65514],"mapped",[8593]],[[65515,65515],"mapped",[8594]],[[65516,65516],"mapped",[8595]],[[65517,65517],"mapped",[9632]],[[65518,65518],"mapped",[9675]],[[65519,65528],"disallowed"],[[65529,65531],"disallowed"],[[65532,65532],"disallowed"],[[65533,65533],"disallowed"],[[65534,65535],"disallowed"],[[65536,65547],"valid"],[[65548,65548],"disallowed"],[[65549,65574],"valid"],[[65575,65575],"disallowed"],[[65576,65594],"valid"],[[65595,65595],"disallowed"],[[65596,65597],"valid"],[[65598,65598],"disallowed"],[[65599,65613],"valid"],[[65614,65615],"disallowed"],[[65616,65629],"valid"],[[65630,65663],"disallowed"],[[65664,65786],"valid"],[[65787,65791],"disallowed"],[[65792,65794],"valid",[],"NV8"],[[65795,65798],"disallowed"],[[65799,65843],"valid",[],"NV8"],[[65844,65846],"disallowed"],[[65847,65855],"valid",[],"NV8"],[[65856,65930],"valid",[],"NV8"],[[65931,65932],"valid",[],"NV8"],[[65933,65935],"disallowed"],[[65936,65947],"valid",[],"NV8"],[[65948,65951],"disallowed"],[[65952,65952],"valid",[],"NV8"],[[65953,65999],"disallowed"],[[66000,66044],"valid",[],"NV8"],[[66045,66045],"valid"],[[66046,66175],"disallowed"],[[66176,66204],"valid"],[[66205,66207],"disallowed"],[[66208,66256],"valid"],[[66257,66271],"disallowed"],[[66272,66272],"valid"],[[66273,66299],"valid",[],"NV8"],[[66300,66303],"disallowed"],[[66304,66334],"valid"],[[66335,66335],"valid"],[[66336,66339],"valid",[],"NV8"],[[66340,66351],"disallowed"],[[66352,66368],"valid"],[[66369,66369],"valid",[],"NV8"],[[66370,66377],"valid"],[[66378,66378],"valid",[],"NV8"],[[66379,66383],"disallowed"],[[66384,66426],"valid"],[[66427,66431],"disallowed"],[[66432,66461],"valid"],[[66462,66462],"disallowed"],[[66463,66463],"valid",[],"NV8"],[[66464,66499],"valid"],[[66500,66503],"disallowed"],[[66504,66511],"valid"],[[66512,66517],"valid",[],"NV8"],[[66518,66559],"disallowed"],[[66560,66560],"mapped",[66600]],[[66561,66561],"mapped",[66601]],[[66562,66562],"mapped",[66602]],[[66563,66563],"mapped",[66603]],[[66564,66564],"mapped",[66604]],[[66565,66565],"mapped",[66605]],[[66566,66566],"mapped",[66606]],[[66567,66567],"mapped",[66607]],[[66568,66568],"mapped",[66608]],[[66569,66569],"mapped",[66609]],[[66570,66570],"mapped",[66610]],[[66571,66571],"mapped",[66611]],[[66572,66572],"mapped",[66612]],[[66573,66573],"mapped",[66613]],[[66574,66574],"mapped",[66614]],[[66575,66575],"mapped",[66615]],[[66576,66576],"mapped",[66616]],[[66577,66577],"mapped",[66617]],[[66578,66578],"mapped",[66618]],[[66579,66579],"mapped",[66619]],[[66580,66580],"mapped",[66620]],[[66581,66581],"mapped",[66621]],[[66582,66582],"mapped",[66622]],[[66583,66583],"mapped",[66623]],[[66584,66584],"mapped",[66624]],[[66585,66585],"mapped",[66625]],[[66586,66586],"mapped",[66626]],[[66587,66587],"mapped",[66627]],[[66588,66588],"mapped",[66628]],[[66589,66589],"mapped",[66629]],[[66590,66590],"mapped",[66630]],[[66591,66591],"mapped",[66631]],[[66592,66592],"mapped",[66632]],[[66593,66593],"mapped",[66633]],[[66594,66594],"mapped",[66634]],[[66595,66595],"mapped",[66635]],[[66596,66596],"mapped",[66636]],[[66597,66597],"mapped",[66637]],[[66598,66598],"mapped",[66638]],[[66599,66599],"mapped",[66639]],[[66600,66637],"valid"],[[66638,66717],"valid"],[[66718,66719],"disallowed"],[[66720,66729],"valid"],[[66730,66815],"disallowed"],[[66816,66855],"valid"],[[66856,66863],"disallowed"],[[66864,66915],"valid"],[[66916,66926],"disallowed"],[[66927,66927],"valid",[],"NV8"],[[66928,67071],"disallowed"],[[67072,67382],"valid"],[[67383,67391],"disallowed"],[[67392,67413],"valid"],[[67414,67423],"disallowed"],[[67424,67431],"valid"],[[67432,67583],"disallowed"],[[67584,67589],"valid"],[[67590,67591],"disallowed"],[[67592,67592],"valid"],[[67593,67593],"disallowed"],[[67594,67637],"valid"],[[67638,67638],"disallowed"],[[67639,67640],"valid"],[[67641,67643],"disallowed"],[[67644,67644],"valid"],[[67645,67646],"disallowed"],[[67647,67647],"valid"],[[67648,67669],"valid"],[[67670,67670],"disallowed"],[[67671,67679],"valid",[],"NV8"],[[67680,67702],"valid"],[[67703,67711],"valid",[],"NV8"],[[67712,67742],"valid"],[[67743,67750],"disallowed"],[[67751,67759],"valid",[],"NV8"],[[67760,67807],"disallowed"],[[67808,67826],"valid"],[[67827,67827],"disallowed"],[[67828,67829],"valid"],[[67830,67834],"disallowed"],[[67835,67839],"valid",[],"NV8"],[[67840,67861],"valid"],[[67862,67865],"valid",[],"NV8"],[[67866,67867],"valid",[],"NV8"],[[67868,67870],"disallowed"],[[67871,67871],"valid",[],"NV8"],[[67872,67897],"valid"],[[67898,67902],"disallowed"],[[67903,67903],"valid",[],"NV8"],[[67904,67967],"disallowed"],[[67968,68023],"valid"],[[68024,68027],"disallowed"],[[68028,68029],"valid",[],"NV8"],[[68030,68031],"valid"],[[68032,68047],"valid",[],"NV8"],[[68048,68049],"disallowed"],[[68050,68095],"valid",[],"NV8"],[[68096,68099],"valid"],[[68100,68100],"disallowed"],[[68101,68102],"valid"],[[68103,68107],"disallowed"],[[68108,68115],"valid"],[[68116,68116],"disallowed"],[[68117,68119],"valid"],[[68120,68120],"disallowed"],[[68121,68147],"valid"],[[68148,68151],"disallowed"],[[68152,68154],"valid"],[[68155,68158],"disallowed"],[[68159,68159],"valid"],[[68160,68167],"valid",[],"NV8"],[[68168,68175],"disallowed"],[[68176,68184],"valid",[],"NV8"],[[68185,68191],"disallowed"],[[68192,68220],"valid"],[[68221,68223],"valid",[],"NV8"],[[68224,68252],"valid"],[[68253,68255],"valid",[],"NV8"],[[68256,68287],"disallowed"],[[68288,68295],"valid"],[[68296,68296],"valid",[],"NV8"],[[68297,68326],"valid"],[[68327,68330],"disallowed"],[[68331,68342],"valid",[],"NV8"],[[68343,68351],"disallowed"],[[68352,68405],"valid"],[[68406,68408],"disallowed"],[[68409,68415],"valid",[],"NV8"],[[68416,68437],"valid"],[[68438,68439],"disallowed"],[[68440,68447],"valid",[],"NV8"],[[68448,68466],"valid"],[[68467,68471],"disallowed"],[[68472,68479],"valid",[],"NV8"],[[68480,68497],"valid"],[[68498,68504],"disallowed"],[[68505,68508],"valid",[],"NV8"],[[68509,68520],"disallowed"],[[68521,68527],"valid",[],"NV8"],[[68528,68607],"disallowed"],[[68608,68680],"valid"],[[68681,68735],"disallowed"],[[68736,68736],"mapped",[68800]],[[68737,68737],"mapped",[68801]],[[68738,68738],"mapped",[68802]],[[68739,68739],"mapped",[68803]],[[68740,68740],"mapped",[68804]],[[68741,68741],"mapped",[68805]],[[68742,68742],"mapped",[68806]],[[68743,68743],"mapped",[68807]],[[68744,68744],"mapped",[68808]],[[68745,68745],"mapped",[68809]],[[68746,68746],"mapped",[68810]],[[68747,68747],"mapped",[68811]],[[68748,68748],"mapped",[68812]],[[68749,68749],"mapped",[68813]],[[68750,68750],"mapped",[68814]],[[68751,68751],"mapped",[68815]],[[68752,68752],"mapped",[68816]],[[68753,68753],"mapped",[68817]],[[68754,68754],"mapped",[68818]],[[68755,68755],"mapped",[68819]],[[68756,68756],"mapped",[68820]],[[68757,68757],"mapped",[68821]],[[68758,68758],"mapped",[68822]],[[68759,68759],"mapped",[68823]],[[68760,68760],"mapped",[68824]],[[68761,68761],"mapped",[68825]],[[68762,68762],"mapped",[68826]],[[68763,68763],"mapped",[68827]],[[68764,68764],"mapped",[68828]],[[68765,68765],"mapped",[68829]],[[68766,68766],"mapped",[68830]],[[68767,68767],"mapped",[68831]],[[68768,68768],"mapped",[68832]],[[68769,68769],"mapped",[68833]],[[68770,68770],"mapped",[68834]],[[68771,68771],"mapped",[68835]],[[68772,68772],"mapped",[68836]],[[68773,68773],"mapped",[68837]],[[68774,68774],"mapped",[68838]],[[68775,68775],"mapped",[68839]],[[68776,68776],"mapped",[68840]],[[68777,68777],"mapped",[68841]],[[68778,68778],"mapped",[68842]],[[68779,68779],"mapped",[68843]],[[68780,68780],"mapped",[68844]],[[68781,68781],"mapped",[68845]],[[68782,68782],"mapped",[68846]],[[68783,68783],"mapped",[68847]],[[68784,68784],"mapped",[68848]],[[68785,68785],"mapped",[68849]],[[68786,68786],"mapped",[68850]],[[68787,68799],"disallowed"],[[68800,68850],"valid"],[[68851,68857],"disallowed"],[[68858,68863],"valid",[],"NV8"],[[68864,69215],"disallowed"],[[69216,69246],"valid",[],"NV8"],[[69247,69631],"disallowed"],[[69632,69702],"valid"],[[69703,69709],"valid",[],"NV8"],[[69710,69713],"disallowed"],[[69714,69733],"valid",[],"NV8"],[[69734,69743],"valid"],[[69744,69758],"disallowed"],[[69759,69759],"valid"],[[69760,69818],"valid"],[[69819,69820],"valid",[],"NV8"],[[69821,69821],"disallowed"],[[69822,69825],"valid",[],"NV8"],[[69826,69839],"disallowed"],[[69840,69864],"valid"],[[69865,69871],"disallowed"],[[69872,69881],"valid"],[[69882,69887],"disallowed"],[[69888,69940],"valid"],[[69941,69941],"disallowed"],[[69942,69951],"valid"],[[69952,69955],"valid",[],"NV8"],[[69956,69967],"disallowed"],[[69968,70003],"valid"],[[70004,70005],"valid",[],"NV8"],[[70006,70006],"valid"],[[70007,70015],"disallowed"],[[70016,70084],"valid"],[[70085,70088],"valid",[],"NV8"],[[70089,70089],"valid",[],"NV8"],[[70090,70092],"valid"],[[70093,70093],"valid",[],"NV8"],[[70094,70095],"disallowed"],[[70096,70105],"valid"],[[70106,70106],"valid"],[[70107,70107],"valid",[],"NV8"],[[70108,70108],"valid"],[[70109,70111],"valid",[],"NV8"],[[70112,70112],"disallowed"],[[70113,70132],"valid",[],"NV8"],[[70133,70143],"disallowed"],[[70144,70161],"valid"],[[70162,70162],"disallowed"],[[70163,70199],"valid"],[[70200,70205],"valid",[],"NV8"],[[70206,70271],"disallowed"],[[70272,70278],"valid"],[[70279,70279],"disallowed"],[[70280,70280],"valid"],[[70281,70281],"disallowed"],[[70282,70285],"valid"],[[70286,70286],"disallowed"],[[70287,70301],"valid"],[[70302,70302],"disallowed"],[[70303,70312],"valid"],[[70313,70313],"valid",[],"NV8"],[[70314,70319],"disallowed"],[[70320,70378],"valid"],[[70379,70383],"disallowed"],[[70384,70393],"valid"],[[70394,70399],"disallowed"],[[70400,70400],"valid"],[[70401,70403],"valid"],[[70404,70404],"disallowed"],[[70405,70412],"valid"],[[70413,70414],"disallowed"],[[70415,70416],"valid"],[[70417,70418],"disallowed"],[[70419,70440],"valid"],[[70441,70441],"disallowed"],[[70442,70448],"valid"],[[70449,70449],"disallowed"],[[70450,70451],"valid"],[[70452,70452],"disallowed"],[[70453,70457],"valid"],[[70458,70459],"disallowed"],[[70460,70468],"valid"],[[70469,70470],"disallowed"],[[70471,70472],"valid"],[[70473,70474],"disallowed"],[[70475,70477],"valid"],[[70478,70479],"disallowed"],[[70480,70480],"valid"],[[70481,70486],"disallowed"],[[70487,70487],"valid"],[[70488,70492],"disallowed"],[[70493,70499],"valid"],[[70500,70501],"disallowed"],[[70502,70508],"valid"],[[70509,70511],"disallowed"],[[70512,70516],"valid"],[[70517,70783],"disallowed"],[[70784,70853],"valid"],[[70854,70854],"valid",[],"NV8"],[[70855,70855],"valid"],[[70856,70863],"disallowed"],[[70864,70873],"valid"],[[70874,71039],"disallowed"],[[71040,71093],"valid"],[[71094,71095],"disallowed"],[[71096,71104],"valid"],[[71105,71113],"valid",[],"NV8"],[[71114,71127],"valid",[],"NV8"],[[71128,71133],"valid"],[[71134,71167],"disallowed"],[[71168,71232],"valid"],[[71233,71235],"valid",[],"NV8"],[[71236,71236],"valid"],[[71237,71247],"disallowed"],[[71248,71257],"valid"],[[71258,71295],"disallowed"],[[71296,71351],"valid"],[[71352,71359],"disallowed"],[[71360,71369],"valid"],[[71370,71423],"disallowed"],[[71424,71449],"valid"],[[71450,71452],"disallowed"],[[71453,71467],"valid"],[[71468,71471],"disallowed"],[[71472,71481],"valid"],[[71482,71487],"valid",[],"NV8"],[[71488,71839],"disallowed"],[[71840,71840],"mapped",[71872]],[[71841,71841],"mapped",[71873]],[[71842,71842],"mapped",[71874]],[[71843,71843],"mapped",[71875]],[[71844,71844],"mapped",[71876]],[[71845,71845],"mapped",[71877]],[[71846,71846],"mapped",[71878]],[[71847,71847],"mapped",[71879]],[[71848,71848],"mapped",[71880]],[[71849,71849],"mapped",[71881]],[[71850,71850],"mapped",[71882]],[[71851,71851],"mapped",[71883]],[[71852,71852],"mapped",[71884]],[[71853,71853],"mapped",[71885]],[[71854,71854],"mapped",[71886]],[[71855,71855],"mapped",[71887]],[[71856,71856],"mapped",[71888]],[[71857,71857],"mapped",[71889]],[[71858,71858],"mapped",[71890]],[[71859,71859],"mapped",[71891]],[[71860,71860],"mapped",[71892]],[[71861,71861],"mapped",[71893]],[[71862,71862],"mapped",[71894]],[[71863,71863],"mapped",[71895]],[[71864,71864],"mapped",[71896]],[[71865,71865],"mapped",[71897]],[[71866,71866],"mapped",[71898]],[[71867,71867],"mapped",[71899]],[[71868,71868],"mapped",[71900]],[[71869,71869],"mapped",[71901]],[[71870,71870],"mapped",[71902]],[[71871,71871],"mapped",[71903]],[[71872,71913],"valid"],[[71914,71922],"valid",[],"NV8"],[[71923,71934],"disallowed"],[[71935,71935],"valid"],[[71936,72383],"disallowed"],[[72384,72440],"valid"],[[72441,73727],"disallowed"],[[73728,74606],"valid"],[[74607,74648],"valid"],[[74649,74649],"valid"],[[74650,74751],"disallowed"],[[74752,74850],"valid",[],"NV8"],[[74851,74862],"valid",[],"NV8"],[[74863,74863],"disallowed"],[[74864,74867],"valid",[],"NV8"],[[74868,74868],"valid",[],"NV8"],[[74869,74879],"disallowed"],[[74880,75075],"valid"],[[75076,77823],"disallowed"],[[77824,78894],"valid"],[[78895,82943],"disallowed"],[[82944,83526],"valid"],[[83527,92159],"disallowed"],[[92160,92728],"valid"],[[92729,92735],"disallowed"],[[92736,92766],"valid"],[[92767,92767],"disallowed"],[[92768,92777],"valid"],[[92778,92781],"disallowed"],[[92782,92783],"valid",[],"NV8"],[[92784,92879],"disallowed"],[[92880,92909],"valid"],[[92910,92911],"disallowed"],[[92912,92916],"valid"],[[92917,92917],"valid",[],"NV8"],[[92918,92927],"disallowed"],[[92928,92982],"valid"],[[92983,92991],"valid",[],"NV8"],[[92992,92995],"valid"],[[92996,92997],"valid",[],"NV8"],[[92998,93007],"disallowed"],[[93008,93017],"valid"],[[93018,93018],"disallowed"],[[93019,93025],"valid",[],"NV8"],[[93026,93026],"disallowed"],[[93027,93047],"valid"],[[93048,93052],"disallowed"],[[93053,93071],"valid"],[[93072,93951],"disallowed"],[[93952,94020],"valid"],[[94021,94031],"disallowed"],[[94032,94078],"valid"],[[94079,94094],"disallowed"],[[94095,94111],"valid"],[[94112,110591],"disallowed"],[[110592,110593],"valid"],[[110594,113663],"disallowed"],[[113664,113770],"valid"],[[113771,113775],"disallowed"],[[113776,113788],"valid"],[[113789,113791],"disallowed"],[[113792,113800],"valid"],[[113801,113807],"disallowed"],[[113808,113817],"valid"],[[113818,113819],"disallowed"],[[113820,113820],"valid",[],"NV8"],[[113821,113822],"valid"],[[113823,113823],"valid",[],"NV8"],[[113824,113827],"ignored"],[[113828,118783],"disallowed"],[[118784,119029],"valid",[],"NV8"],[[119030,119039],"disallowed"],[[119040,119078],"valid",[],"NV8"],[[119079,119080],"disallowed"],[[119081,119081],"valid",[],"NV8"],[[119082,119133],"valid",[],"NV8"],[[119134,119134],"mapped",[119127,119141]],[[119135,119135],"mapped",[119128,119141]],[[119136,119136],"mapped",[119128,119141,119150]],[[119137,119137],"mapped",[119128,119141,119151]],[[119138,119138],"mapped",[119128,119141,119152]],[[119139,119139],"mapped",[119128,119141,119153]],[[119140,119140],"mapped",[119128,119141,119154]],[[119141,119154],"valid",[],"NV8"],[[119155,119162],"disallowed"],[[119163,119226],"valid",[],"NV8"],[[119227,119227],"mapped",[119225,119141]],[[119228,119228],"mapped",[119226,119141]],[[119229,119229],"mapped",[119225,119141,119150]],[[119230,119230],"mapped",[119226,119141,119150]],[[119231,119231],"mapped",[119225,119141,119151]],[[119232,119232],"mapped",[119226,119141,119151]],[[119233,119261],"valid",[],"NV8"],[[119262,119272],"valid",[],"NV8"],[[119273,119295],"disallowed"],[[119296,119365],"valid",[],"NV8"],[[119366,119551],"disallowed"],[[119552,119638],"valid",[],"NV8"],[[119639,119647],"disallowed"],[[119648,119665],"valid",[],"NV8"],[[119666,119807],"disallowed"],[[119808,119808],"mapped",[97]],[[119809,119809],"mapped",[98]],[[119810,119810],"mapped",[99]],[[119811,119811],"mapped",[100]],[[119812,119812],"mapped",[101]],[[119813,119813],"mapped",[102]],[[119814,119814],"mapped",[103]],[[119815,119815],"mapped",[104]],[[119816,119816],"mapped",[105]],[[119817,119817],"mapped",[106]],[[119818,119818],"mapped",[107]],[[119819,119819],"mapped",[108]],[[119820,119820],"mapped",[109]],[[119821,119821],"mapped",[110]],[[119822,119822],"mapped",[111]],[[119823,119823],"mapped",[112]],[[119824,119824],"mapped",[113]],[[119825,119825],"mapped",[114]],[[119826,119826],"mapped",[115]],[[119827,119827],"mapped",[116]],[[119828,119828],"mapped",[117]],[[119829,119829],"mapped",[118]],[[119830,119830],"mapped",[119]],[[119831,119831],"mapped",[120]],[[119832,119832],"mapped",[121]],[[119833,119833],"mapped",[122]],[[119834,119834],"mapped",[97]],[[119835,119835],"mapped",[98]],[[119836,119836],"mapped",[99]],[[119837,119837],"mapped",[100]],[[119838,119838],"mapped",[101]],[[119839,119839],"mapped",[102]],[[119840,119840],"mapped",[103]],[[119841,119841],"mapped",[104]],[[119842,119842],"mapped",[105]],[[119843,119843],"mapped",[106]],[[119844,119844],"mapped",[107]],[[119845,119845],"mapped",[108]],[[119846,119846],"mapped",[109]],[[119847,119847],"mapped",[110]],[[119848,119848],"mapped",[111]],[[119849,119849],"mapped",[112]],[[119850,119850],"mapped",[113]],[[119851,119851],"mapped",[114]],[[119852,119852],"mapped",[115]],[[119853,119853],"mapped",[116]],[[119854,119854],"mapped",[117]],[[119855,119855],"mapped",[118]],[[119856,119856],"mapped",[119]],[[119857,119857],"mapped",[120]],[[119858,119858],"mapped",[121]],[[119859,119859],"mapped",[122]],[[119860,119860],"mapped",[97]],[[119861,119861],"mapped",[98]],[[119862,119862],"mapped",[99]],[[119863,119863],"mapped",[100]],[[119864,119864],"mapped",[101]],[[119865,119865],"mapped",[102]],[[119866,119866],"mapped",[103]],[[119867,119867],"mapped",[104]],[[119868,119868],"mapped",[105]],[[119869,119869],"mapped",[106]],[[119870,119870],"mapped",[107]],[[119871,119871],"mapped",[108]],[[119872,119872],"mapped",[109]],[[119873,119873],"mapped",[110]],[[119874,119874],"mapped",[111]],[[119875,119875],"mapped",[112]],[[119876,119876],"mapped",[113]],[[119877,119877],"mapped",[114]],[[119878,119878],"mapped",[115]],[[119879,119879],"mapped",[116]],[[119880,119880],"mapped",[117]],[[119881,119881],"mapped",[118]],[[119882,119882],"mapped",[119]],[[119883,119883],"mapped",[120]],[[119884,119884],"mapped",[121]],[[119885,119885],"mapped",[122]],[[119886,119886],"mapped",[97]],[[119887,119887],"mapped",[98]],[[119888,119888],"mapped",[99]],[[119889,119889],"mapped",[100]],[[119890,119890],"mapped",[101]],[[119891,119891],"mapped",[102]],[[119892,119892],"mapped",[103]],[[119893,119893],"disallowed"],[[119894,119894],"mapped",[105]],[[119895,119895],"mapped",[106]],[[119896,119896],"mapped",[107]],[[119897,119897],"mapped",[108]],[[119898,119898],"mapped",[109]],[[119899,119899],"mapped",[110]],[[119900,119900],"mapped",[111]],[[119901,119901],"mapped",[112]],[[119902,119902],"mapped",[113]],[[119903,119903],"mapped",[114]],[[119904,119904],"mapped",[115]],[[119905,119905],"mapped",[116]],[[119906,119906],"mapped",[117]],[[119907,119907],"mapped",[118]],[[119908,119908],"mapped",[119]],[[119909,119909],"mapped",[120]],[[119910,119910],"mapped",[121]],[[119911,119911],"mapped",[122]],[[119912,119912],"mapped",[97]],[[119913,119913],"mapped",[98]],[[119914,119914],"mapped",[99]],[[119915,119915],"mapped",[100]],[[119916,119916],"mapped",[101]],[[119917,119917],"mapped",[102]],[[119918,119918],"mapped",[103]],[[119919,119919],"mapped",[104]],[[119920,119920],"mapped",[105]],[[119921,119921],"mapped",[106]],[[119922,119922],"mapped",[107]],[[119923,119923],"mapped",[108]],[[119924,119924],"mapped",[109]],[[119925,119925],"mapped",[110]],[[119926,119926],"mapped",[111]],[[119927,119927],"mapped",[112]],[[119928,119928],"mapped",[113]],[[119929,119929],"mapped",[114]],[[119930,119930],"mapped",[115]],[[119931,119931],"mapped",[116]],[[119932,119932],"mapped",[117]],[[119933,119933],"mapped",[118]],[[119934,119934],"mapped",[119]],[[119935,119935],"mapped",[120]],[[119936,119936],"mapped",[121]],[[119937,119937],"mapped",[122]],[[119938,119938],"mapped",[97]],[[119939,119939],"mapped",[98]],[[119940,119940],"mapped",[99]],[[119941,119941],"mapped",[100]],[[119942,119942],"mapped",[101]],[[119943,119943],"mapped",[102]],[[119944,119944],"mapped",[103]],[[119945,119945],"mapped",[104]],[[119946,119946],"mapped",[105]],[[119947,119947],"mapped",[106]],[[119948,119948],"mapped",[107]],[[119949,119949],"mapped",[108]],[[119950,119950],"mapped",[109]],[[119951,119951],"mapped",[110]],[[119952,119952],"mapped",[111]],[[119953,119953],"mapped",[112]],[[119954,119954],"mapped",[113]],[[119955,119955],"mapped",[114]],[[119956,119956],"mapped",[115]],[[119957,119957],"mapped",[116]],[[119958,119958],"mapped",[117]],[[119959,119959],"mapped",[118]],[[119960,119960],"mapped",[119]],[[119961,119961],"mapped",[120]],[[119962,119962],"mapped",[121]],[[119963,119963],"mapped",[122]],[[119964,119964],"mapped",[97]],[[119965,119965],"disallowed"],[[119966,119966],"mapped",[99]],[[119967,119967],"mapped",[100]],[[119968,119969],"disallowed"],[[119970,119970],"mapped",[103]],[[119971,119972],"disallowed"],[[119973,119973],"mapped",[106]],[[119974,119974],"mapped",[107]],[[119975,119976],"disallowed"],[[119977,119977],"mapped",[110]],[[119978,119978],"mapped",[111]],[[119979,119979],"mapped",[112]],[[119980,119980],"mapped",[113]],[[119981,119981],"disallowed"],[[119982,119982],"mapped",[115]],[[119983,119983],"mapped",[116]],[[119984,119984],"mapped",[117]],[[119985,119985],"mapped",[118]],[[119986,119986],"mapped",[119]],[[119987,119987],"mapped",[120]],[[119988,119988],"mapped",[121]],[[119989,119989],"mapped",[122]],[[119990,119990],"mapped",[97]],[[119991,119991],"mapped",[98]],[[119992,119992],"mapped",[99]],[[119993,119993],"mapped",[100]],[[119994,119994],"disallowed"],[[119995,119995],"mapped",[102]],[[119996,119996],"disallowed"],[[119997,119997],"mapped",[104]],[[119998,119998],"mapped",[105]],[[119999,119999],"mapped",[106]],[[120000,120000],"mapped",[107]],[[120001,120001],"mapped",[108]],[[120002,120002],"mapped",[109]],[[120003,120003],"mapped",[110]],[[120004,120004],"disallowed"],[[120005,120005],"mapped",[112]],[[120006,120006],"mapped",[113]],[[120007,120007],"mapped",[114]],[[120008,120008],"mapped",[115]],[[120009,120009],"mapped",[116]],[[120010,120010],"mapped",[117]],[[120011,120011],"mapped",[118]],[[120012,120012],"mapped",[119]],[[120013,120013],"mapped",[120]],[[120014,120014],"mapped",[121]],[[120015,120015],"mapped",[122]],[[120016,120016],"mapped",[97]],[[120017,120017],"mapped",[98]],[[120018,120018],"mapped",[99]],[[120019,120019],"mapped",[100]],[[120020,120020],"mapped",[101]],[[120021,120021],"mapped",[102]],[[120022,120022],"mapped",[103]],[[120023,120023],"mapped",[104]],[[120024,120024],"mapped",[105]],[[120025,120025],"mapped",[106]],[[120026,120026],"mapped",[107]],[[120027,120027],"mapped",[108]],[[120028,120028],"mapped",[109]],[[120029,120029],"mapped",[110]],[[120030,120030],"mapped",[111]],[[120031,120031],"mapped",[112]],[[120032,120032],"mapped",[113]],[[120033,120033],"mapped",[114]],[[120034,120034],"mapped",[115]],[[120035,120035],"mapped",[116]],[[120036,120036],"mapped",[117]],[[120037,120037],"mapped",[118]],[[120038,120038],"mapped",[119]],[[120039,120039],"mapped",[120]],[[120040,120040],"mapped",[121]],[[120041,120041],"mapped",[122]],[[120042,120042],"mapped",[97]],[[120043,120043],"mapped",[98]],[[120044,120044],"mapped",[99]],[[120045,120045],"mapped",[100]],[[120046,120046],"mapped",[101]],[[120047,120047],"mapped",[102]],[[120048,120048],"mapped",[103]],[[120049,120049],"mapped",[104]],[[120050,120050],"mapped",[105]],[[120051,120051],"mapped",[106]],[[120052,120052],"mapped",[107]],[[120053,120053],"mapped",[108]],[[120054,120054],"mapped",[109]],[[120055,120055],"mapped",[110]],[[120056,120056],"mapped",[111]],[[120057,120057],"mapped",[112]],[[120058,120058],"mapped",[113]],[[120059,120059],"mapped",[114]],[[120060,120060],"mapped",[115]],[[120061,120061],"mapped",[116]],[[120062,120062],"mapped",[117]],[[120063,120063],"mapped",[118]],[[120064,120064],"mapped",[119]],[[120065,120065],"mapped",[120]],[[120066,120066],"mapped",[121]],[[120067,120067],"mapped",[122]],[[120068,120068],"mapped",[97]],[[120069,120069],"mapped",[98]],[[120070,120070],"disallowed"],[[120071,120071],"mapped",[100]],[[120072,120072],"mapped",[101]],[[120073,120073],"mapped",[102]],[[120074,120074],"mapped",[103]],[[120075,120076],"disallowed"],[[120077,120077],"mapped",[106]],[[120078,120078],"mapped",[107]],[[120079,120079],"mapped",[108]],[[120080,120080],"mapped",[109]],[[120081,120081],"mapped",[110]],[[120082,120082],"mapped",[111]],[[120083,120083],"mapped",[112]],[[120084,120084],"mapped",[113]],[[120085,120085],"disallowed"],[[120086,120086],"mapped",[115]],[[120087,120087],"mapped",[116]],[[120088,120088],"mapped",[117]],[[120089,120089],"mapped",[118]],[[120090,120090],"mapped",[119]],[[120091,120091],"mapped",[120]],[[120092,120092],"mapped",[121]],[[120093,120093],"disallowed"],[[120094,120094],"mapped",[97]],[[120095,120095],"mapped",[98]],[[120096,120096],"mapped",[99]],[[120097,120097],"mapped",[100]],[[120098,120098],"mapped",[101]],[[120099,120099],"mapped",[102]],[[120100,120100],"mapped",[103]],[[120101,120101],"mapped",[104]],[[120102,120102],"mapped",[105]],[[120103,120103],"mapped",[106]],[[120104,120104],"mapped",[107]],[[120105,120105],"mapped",[108]],[[120106,120106],"mapped",[109]],[[120107,120107],"mapped",[110]],[[120108,120108],"mapped",[111]],[[120109,120109],"mapped",[112]],[[120110,120110],"mapped",[113]],[[120111,120111],"mapped",[114]],[[120112,120112],"mapped",[115]],[[120113,120113],"mapped",[116]],[[120114,120114],"mapped",[117]],[[120115,120115],"mapped",[118]],[[120116,120116],"mapped",[119]],[[120117,120117],"mapped",[120]],[[120118,120118],"mapped",[121]],[[120119,120119],"mapped",[122]],[[120120,120120],"mapped",[97]],[[120121,120121],"mapped",[98]],[[120122,120122],"disallowed"],[[120123,120123],"mapped",[100]],[[120124,120124],"mapped",[101]],[[120125,120125],"mapped",[102]],[[120126,120126],"mapped",[103]],[[120127,120127],"disallowed"],[[120128,120128],"mapped",[105]],[[120129,120129],"mapped",[106]],[[120130,120130],"mapped",[107]],[[120131,120131],"mapped",[108]],[[120132,120132],"mapped",[109]],[[120133,120133],"disallowed"],[[120134,120134],"mapped",[111]],[[120135,120137],"disallowed"],[[120138,120138],"mapped",[115]],[[120139,120139],"mapped",[116]],[[120140,120140],"mapped",[117]],[[120141,120141],"mapped",[118]],[[120142,120142],"mapped",[119]],[[120143,120143],"mapped",[120]],[[120144,120144],"mapped",[121]],[[120145,120145],"disallowed"],[[120146,120146],"mapped",[97]],[[120147,120147],"mapped",[98]],[[120148,120148],"mapped",[99]],[[120149,120149],"mapped",[100]],[[120150,120150],"mapped",[101]],[[120151,120151],"mapped",[102]],[[120152,120152],"mapped",[103]],[[120153,120153],"mapped",[104]],[[120154,120154],"mapped",[105]],[[120155,120155],"mapped",[106]],[[120156,120156],"mapped",[107]],[[120157,120157],"mapped",[108]],[[120158,120158],"mapped",[109]],[[120159,120159],"mapped",[110]],[[120160,120160],"mapped",[111]],[[120161,120161],"mapped",[112]],[[120162,120162],"mapped",[113]],[[120163,120163],"mapped",[114]],[[120164,120164],"mapped",[115]],[[120165,120165],"mapped",[116]],[[120166,120166],"mapped",[117]],[[120167,120167],"mapped",[118]],[[120168,120168],"mapped",[119]],[[120169,120169],"mapped",[120]],[[120170,120170],"mapped",[121]],[[120171,120171],"mapped",[122]],[[120172,120172],"mapped",[97]],[[120173,120173],"mapped",[98]],[[120174,120174],"mapped",[99]],[[120175,120175],"mapped",[100]],[[120176,120176],"mapped",[101]],[[120177,120177],"mapped",[102]],[[120178,120178],"mapped",[103]],[[120179,120179],"mapped",[104]],[[120180,120180],"mapped",[105]],[[120181,120181],"mapped",[106]],[[120182,120182],"mapped",[107]],[[120183,120183],"mapped",[108]],[[120184,120184],"mapped",[109]],[[120185,120185],"mapped",[110]],[[120186,120186],"mapped",[111]],[[120187,120187],"mapped",[112]],[[120188,120188],"mapped",[113]],[[120189,120189],"mapped",[114]],[[120190,120190],"mapped",[115]],[[120191,120191],"mapped",[116]],[[120192,120192],"mapped",[117]],[[120193,120193],"mapped",[118]],[[120194,120194],"mapped",[119]],[[120195,120195],"mapped",[120]],[[120196,120196],"mapped",[121]],[[120197,120197],"mapped",[122]],[[120198,120198],"mapped",[97]],[[120199,120199],"mapped",[98]],[[120200,120200],"mapped",[99]],[[120201,120201],"mapped",[100]],[[120202,120202],"mapped",[101]],[[120203,120203],"mapped",[102]],[[120204,120204],"mapped",[103]],[[120205,120205],"mapped",[104]],[[120206,120206],"mapped",[105]],[[120207,120207],"mapped",[106]],[[120208,120208],"mapped",[107]],[[120209,120209],"mapped",[108]],[[120210,120210],"mapped",[109]],[[120211,120211],"mapped",[110]],[[120212,120212],"mapped",[111]],[[120213,120213],"mapped",[112]],[[120214,120214],"mapped",[113]],[[120215,120215],"mapped",[114]],[[120216,120216],"mapped",[115]],[[120217,120217],"mapped",[116]],[[120218,120218],"mapped",[117]],[[120219,120219],"mapped",[118]],[[120220,120220],"mapped",[119]],[[120221,120221],"mapped",[120]],[[120222,120222],"mapped",[121]],[[120223,120223],"mapped",[122]],[[120224,120224],"mapped",[97]],[[120225,120225],"mapped",[98]],[[120226,120226],"mapped",[99]],[[120227,120227],"mapped",[100]],[[120228,120228],"mapped",[101]],[[120229,120229],"mapped",[102]],[[120230,120230],"mapped",[103]],[[120231,120231],"mapped",[104]],[[120232,120232],"mapped",[105]],[[120233,120233],"mapped",[106]],[[120234,120234],"mapped",[107]],[[120235,120235],"mapped",[108]],[[120236,120236],"mapped",[109]],[[120237,120237],"mapped",[110]],[[120238,120238],"mapped",[111]],[[120239,120239],"mapped",[112]],[[120240,120240],"mapped",[113]],[[120241,120241],"mapped",[114]],[[120242,120242],"mapped",[115]],[[120243,120243],"mapped",[116]],[[120244,120244],"mapped",[117]],[[120245,120245],"mapped",[118]],[[120246,120246],"mapped",[119]],[[120247,120247],"mapped",[120]],[[120248,120248],"mapped",[121]],[[120249,120249],"mapped",[122]],[[120250,120250],"mapped",[97]],[[120251,120251],"mapped",[98]],[[120252,120252],"mapped",[99]],[[120253,120253],"mapped",[100]],[[120254,120254],"mapped",[101]],[[120255,120255],"mapped",[102]],[[120256,120256],"mapped",[103]],[[120257,120257],"mapped",[104]],[[120258,120258],"mapped",[105]],[[120259,120259],"mapped",[106]],[[120260,120260],"mapped",[107]],[[120261,120261],"mapped",[108]],[[120262,120262],"mapped",[109]],[[120263,120263],"mapped",[110]],[[120264,120264],"mapped",[111]],[[120265,120265],"mapped",[112]],[[120266,120266],"mapped",[113]],[[120267,120267],"mapped",[114]],[[120268,120268],"mapped",[115]],[[120269,120269],"mapped",[116]],[[120270,120270],"mapped",[117]],[[120271,120271],"mapped",[118]],[[120272,120272],"mapped",[119]],[[120273,120273],"mapped",[120]],[[120274,120274],"mapped",[121]],[[120275,120275],"mapped",[122]],[[120276,120276],"mapped",[97]],[[120277,120277],"mapped",[98]],[[120278,120278],"mapped",[99]],[[120279,120279],"mapped",[100]],[[120280,120280],"mapped",[101]],[[120281,120281],"mapped",[102]],[[120282,120282],"mapped",[103]],[[120283,120283],"mapped",[104]],[[120284,120284],"mapped",[105]],[[120285,120285],"mapped",[106]],[[120286,120286],"mapped",[107]],[[120287,120287],"mapped",[108]],[[120288,120288],"mapped",[109]],[[120289,120289],"mapped",[110]],[[120290,120290],"mapped",[111]],[[120291,120291],"mapped",[112]],[[120292,120292],"mapped",[113]],[[120293,120293],"mapped",[114]],[[120294,120294],"mapped",[115]],[[120295,120295],"mapped",[116]],[[120296,120296],"mapped",[117]],[[120297,120297],"mapped",[118]],[[120298,120298],"mapped",[119]],[[120299,120299],"mapped",[120]],[[120300,120300],"mapped",[121]],[[120301,120301],"mapped",[122]],[[120302,120302],"mapped",[97]],[[120303,120303],"mapped",[98]],[[120304,120304],"mapped",[99]],[[120305,120305],"mapped",[100]],[[120306,120306],"mapped",[101]],[[120307,120307],"mapped",[102]],[[120308,120308],"mapped",[103]],[[120309,120309],"mapped",[104]],[[120310,120310],"mapped",[105]],[[120311,120311],"mapped",[106]],[[120312,120312],"mapped",[107]],[[120313,120313],"mapped",[108]],[[120314,120314],"mapped",[109]],[[120315,120315],"mapped",[110]],[[120316,120316],"mapped",[111]],[[120317,120317],"mapped",[112]],[[120318,120318],"mapped",[113]],[[120319,120319],"mapped",[114]],[[120320,120320],"mapped",[115]],[[120321,120321],"mapped",[116]],[[120322,120322],"mapped",[117]],[[120323,120323],"mapped",[118]],[[120324,120324],"mapped",[119]],[[120325,120325],"mapped",[120]],[[120326,120326],"mapped",[121]],[[120327,120327],"mapped",[122]],[[120328,120328],"mapped",[97]],[[120329,120329],"mapped",[98]],[[120330,120330],"mapped",[99]],[[120331,120331],"mapped",[100]],[[120332,120332],"mapped",[101]],[[120333,120333],"mapped",[102]],[[120334,120334],"mapped",[103]],[[120335,120335],"mapped",[104]],[[120336,120336],"mapped",[105]],[[120337,120337],"mapped",[106]],[[120338,120338],"mapped",[107]],[[120339,120339],"mapped",[108]],[[120340,120340],"mapped",[109]],[[120341,120341],"mapped",[110]],[[120342,120342],"mapped",[111]],[[120343,120343],"mapped",[112]],[[120344,120344],"mapped",[113]],[[120345,120345],"mapped",[114]],[[120346,120346],"mapped",[115]],[[120347,120347],"mapped",[116]],[[120348,120348],"mapped",[117]],[[120349,120349],"mapped",[118]],[[120350,120350],"mapped",[119]],[[120351,120351],"mapped",[120]],[[120352,120352],"mapped",[121]],[[120353,120353],"mapped",[122]],[[120354,120354],"mapped",[97]],[[120355,120355],"mapped",[98]],[[120356,120356],"mapped",[99]],[[120357,120357],"mapped",[100]],[[120358,120358],"mapped",[101]],[[120359,120359],"mapped",[102]],[[120360,120360],"mapped",[103]],[[120361,120361],"mapped",[104]],[[120362,120362],"mapped",[105]],[[120363,120363],"mapped",[106]],[[120364,120364],"mapped",[107]],[[120365,120365],"mapped",[108]],[[120366,120366],"mapped",[109]],[[120367,120367],"mapped",[110]],[[120368,120368],"mapped",[111]],[[120369,120369],"mapped",[112]],[[120370,120370],"mapped",[113]],[[120371,120371],"mapped",[114]],[[120372,120372],"mapped",[115]],[[120373,120373],"mapped",[116]],[[120374,120374],"mapped",[117]],[[120375,120375],"mapped",[118]],[[120376,120376],"mapped",[119]],[[120377,120377],"mapped",[120]],[[120378,120378],"mapped",[121]],[[120379,120379],"mapped",[122]],[[120380,120380],"mapped",[97]],[[120381,120381],"mapped",[98]],[[120382,120382],"mapped",[99]],[[120383,120383],"mapped",[100]],[[120384,120384],"mapped",[101]],[[120385,120385],"mapped",[102]],[[120386,120386],"mapped",[103]],[[120387,120387],"mapped",[104]],[[120388,120388],"mapped",[105]],[[120389,120389],"mapped",[106]],[[120390,120390],"mapped",[107]],[[120391,120391],"mapped",[108]],[[120392,120392],"mapped",[109]],[[120393,120393],"mapped",[110]],[[120394,120394],"mapped",[111]],[[120395,120395],"mapped",[112]],[[120396,120396],"mapped",[113]],[[120397,120397],"mapped",[114]],[[120398,120398],"mapped",[115]],[[120399,120399],"mapped",[116]],[[120400,120400],"mapped",[117]],[[120401,120401],"mapped",[118]],[[120402,120402],"mapped",[119]],[[120403,120403],"mapped",[120]],[[120404,120404],"mapped",[121]],[[120405,120405],"mapped",[122]],[[120406,120406],"mapped",[97]],[[120407,120407],"mapped",[98]],[[120408,120408],"mapped",[99]],[[120409,120409],"mapped",[100]],[[120410,120410],"mapped",[101]],[[120411,120411],"mapped",[102]],[[120412,120412],"mapped",[103]],[[120413,120413],"mapped",[104]],[[120414,120414],"mapped",[105]],[[120415,120415],"mapped",[106]],[[120416,120416],"mapped",[107]],[[120417,120417],"mapped",[108]],[[120418,120418],"mapped",[109]],[[120419,120419],"mapped",[110]],[[120420,120420],"mapped",[111]],[[120421,120421],"mapped",[112]],[[120422,120422],"mapped",[113]],[[120423,120423],"mapped",[114]],[[120424,120424],"mapped",[115]],[[120425,120425],"mapped",[116]],[[120426,120426],"mapped",[117]],[[120427,120427],"mapped",[118]],[[120428,120428],"mapped",[119]],[[120429,120429],"mapped",[120]],[[120430,120430],"mapped",[121]],[[120431,120431],"mapped",[122]],[[120432,120432],"mapped",[97]],[[120433,120433],"mapped",[98]],[[120434,120434],"mapped",[99]],[[120435,120435],"mapped",[100]],[[120436,120436],"mapped",[101]],[[120437,120437],"mapped",[102]],[[120438,120438],"mapped",[103]],[[120439,120439],"mapped",[104]],[[120440,120440],"mapped",[105]],[[120441,120441],"mapped",[106]],[[120442,120442],"mapped",[107]],[[120443,120443],"mapped",[108]],[[120444,120444],"mapped",[109]],[[120445,120445],"mapped",[110]],[[120446,120446],"mapped",[111]],[[120447,120447],"mapped",[112]],[[120448,120448],"mapped",[113]],[[120449,120449],"mapped",[114]],[[120450,120450],"mapped",[115]],[[120451,120451],"mapped",[116]],[[120452,120452],"mapped",[117]],[[120453,120453],"mapped",[118]],[[120454,120454],"mapped",[119]],[[120455,120455],"mapped",[120]],[[120456,120456],"mapped",[121]],[[120457,120457],"mapped",[122]],[[120458,120458],"mapped",[97]],[[120459,120459],"mapped",[98]],[[120460,120460],"mapped",[99]],[[120461,120461],"mapped",[100]],[[120462,120462],"mapped",[101]],[[120463,120463],"mapped",[102]],[[120464,120464],"mapped",[103]],[[120465,120465],"mapped",[104]],[[120466,120466],"mapped",[105]],[[120467,120467],"mapped",[106]],[[120468,120468],"mapped",[107]],[[120469,120469],"mapped",[108]],[[120470,120470],"mapped",[109]],[[120471,120471],"mapped",[110]],[[120472,120472],"mapped",[111]],[[120473,120473],"mapped",[112]],[[120474,120474],"mapped",[113]],[[120475,120475],"mapped",[114]],[[120476,120476],"mapped",[115]],[[120477,120477],"mapped",[116]],[[120478,120478],"mapped",[117]],[[120479,120479],"mapped",[118]],[[120480,120480],"mapped",[119]],[[120481,120481],"mapped",[120]],[[120482,120482],"mapped",[121]],[[120483,120483],"mapped",[122]],[[120484,120484],"mapped",[305]],[[120485,120485],"mapped",[567]],[[120486,120487],"disallowed"],[[120488,120488],"mapped",[945]],[[120489,120489],"mapped",[946]],[[120490,120490],"mapped",[947]],[[120491,120491],"mapped",[948]],[[120492,120492],"mapped",[949]],[[120493,120493],"mapped",[950]],[[120494,120494],"mapped",[951]],[[120495,120495],"mapped",[952]],[[120496,120496],"mapped",[953]],[[120497,120497],"mapped",[954]],[[120498,120498],"mapped",[955]],[[120499,120499],"mapped",[956]],[[120500,120500],"mapped",[957]],[[120501,120501],"mapped",[958]],[[120502,120502],"mapped",[959]],[[120503,120503],"mapped",[960]],[[120504,120504],"mapped",[961]],[[120505,120505],"mapped",[952]],[[120506,120506],"mapped",[963]],[[120507,120507],"mapped",[964]],[[120508,120508],"mapped",[965]],[[120509,120509],"mapped",[966]],[[120510,120510],"mapped",[967]],[[120511,120511],"mapped",[968]],[[120512,120512],"mapped",[969]],[[120513,120513],"mapped",[8711]],[[120514,120514],"mapped",[945]],[[120515,120515],"mapped",[946]],[[120516,120516],"mapped",[947]],[[120517,120517],"mapped",[948]],[[120518,120518],"mapped",[949]],[[120519,120519],"mapped",[950]],[[120520,120520],"mapped",[951]],[[120521,120521],"mapped",[952]],[[120522,120522],"mapped",[953]],[[120523,120523],"mapped",[954]],[[120524,120524],"mapped",[955]],[[120525,120525],"mapped",[956]],[[120526,120526],"mapped",[957]],[[120527,120527],"mapped",[958]],[[120528,120528],"mapped",[959]],[[120529,120529],"mapped",[960]],[[120530,120530],"mapped",[961]],[[120531,120532],"mapped",[963]],[[120533,120533],"mapped",[964]],[[120534,120534],"mapped",[965]],[[120535,120535],"mapped",[966]],[[120536,120536],"mapped",[967]],[[120537,120537],"mapped",[968]],[[120538,120538],"mapped",[969]],[[120539,120539],"mapped",[8706]],[[120540,120540],"mapped",[949]],[[120541,120541],"mapped",[952]],[[120542,120542],"mapped",[954]],[[120543,120543],"mapped",[966]],[[120544,120544],"mapped",[961]],[[120545,120545],"mapped",[960]],[[120546,120546],"mapped",[945]],[[120547,120547],"mapped",[946]],[[120548,120548],"mapped",[947]],[[120549,120549],"mapped",[948]],[[120550,120550],"mapped",[949]],[[120551,120551],"mapped",[950]],[[120552,120552],"mapped",[951]],[[120553,120553],"mapped",[952]],[[120554,120554],"mapped",[953]],[[120555,120555],"mapped",[954]],[[120556,120556],"mapped",[955]],[[120557,120557],"mapped",[956]],[[120558,120558],"mapped",[957]],[[120559,120559],"mapped",[958]],[[120560,120560],"mapped",[959]],[[120561,120561],"mapped",[960]],[[120562,120562],"mapped",[961]],[[120563,120563],"mapped",[952]],[[120564,120564],"mapped",[963]],[[120565,120565],"mapped",[964]],[[120566,120566],"mapped",[965]],[[120567,120567],"mapped",[966]],[[120568,120568],"mapped",[967]],[[120569,120569],"mapped",[968]],[[120570,120570],"mapped",[969]],[[120571,120571],"mapped",[8711]],[[120572,120572],"mapped",[945]],[[120573,120573],"mapped",[946]],[[120574,120574],"mapped",[947]],[[120575,120575],"mapped",[948]],[[120576,120576],"mapped",[949]],[[120577,120577],"mapped",[950]],[[120578,120578],"mapped",[951]],[[120579,120579],"mapped",[952]],[[120580,120580],"mapped",[953]],[[120581,120581],"mapped",[954]],[[120582,120582],"mapped",[955]],[[120583,120583],"mapped",[956]],[[120584,120584],"mapped",[957]],[[120585,120585],"mapped",[958]],[[120586,120586],"mapped",[959]],[[120587,120587],"mapped",[960]],[[120588,120588],"mapped",[961]],[[120589,120590],"mapped",[963]],[[120591,120591],"mapped",[964]],[[120592,120592],"mapped",[965]],[[120593,120593],"mapped",[966]],[[120594,120594],"mapped",[967]],[[120595,120595],"mapped",[968]],[[120596,120596],"mapped",[969]],[[120597,120597],"mapped",[8706]],[[120598,120598],"mapped",[949]],[[120599,120599],"mapped",[952]],[[120600,120600],"mapped",[954]],[[120601,120601],"mapped",[966]],[[120602,120602],"mapped",[961]],[[120603,120603],"mapped",[960]],[[120604,120604],"mapped",[945]],[[120605,120605],"mapped",[946]],[[120606,120606],"mapped",[947]],[[120607,120607],"mapped",[948]],[[120608,120608],"mapped",[949]],[[120609,120609],"mapped",[950]],[[120610,120610],"mapped",[951]],[[120611,120611],"mapped",[952]],[[120612,120612],"mapped",[953]],[[120613,120613],"mapped",[954]],[[120614,120614],"mapped",[955]],[[120615,120615],"mapped",[956]],[[120616,120616],"mapped",[957]],[[120617,120617],"mapped",[958]],[[120618,120618],"mapped",[959]],[[120619,120619],"mapped",[960]],[[120620,120620],"mapped",[961]],[[120621,120621],"mapped",[952]],[[120622,120622],"mapped",[963]],[[120623,120623],"mapped",[964]],[[120624,120624],"mapped",[965]],[[120625,120625],"mapped",[966]],[[120626,120626],"mapped",[967]],[[120627,120627],"mapped",[968]],[[120628,120628],"mapped",[969]],[[120629,120629],"mapped",[8711]],[[120630,120630],"mapped",[945]],[[120631,120631],"mapped",[946]],[[120632,120632],"mapped",[947]],[[120633,120633],"mapped",[948]],[[120634,120634],"mapped",[949]],[[120635,120635],"mapped",[950]],[[120636,120636],"mapped",[951]],[[120637,120637],"mapped",[952]],[[120638,120638],"mapped",[953]],[[120639,120639],"mapped",[954]],[[120640,120640],"mapped",[955]],[[120641,120641],"mapped",[956]],[[120642,120642],"mapped",[957]],[[120643,120643],"mapped",[958]],[[120644,120644],"mapped",[959]],[[120645,120645],"mapped",[960]],[[120646,120646],"mapped",[961]],[[120647,120648],"mapped",[963]],[[120649,120649],"mapped",[964]],[[120650,120650],"mapped",[965]],[[120651,120651],"mapped",[966]],[[120652,120652],"mapped",[967]],[[120653,120653],"mapped",[968]],[[120654,120654],"mapped",[969]],[[120655,120655],"mapped",[8706]],[[120656,120656],"mapped",[949]],[[120657,120657],"mapped",[952]],[[120658,120658],"mapped",[954]],[[120659,120659],"mapped",[966]],[[120660,120660],"mapped",[961]],[[120661,120661],"mapped",[960]],[[120662,120662],"mapped",[945]],[[120663,120663],"mapped",[946]],[[120664,120664],"mapped",[947]],[[120665,120665],"mapped",[948]],[[120666,120666],"mapped",[949]],[[120667,120667],"mapped",[950]],[[120668,120668],"mapped",[951]],[[120669,120669],"mapped",[952]],[[120670,120670],"mapped",[953]],[[120671,120671],"mapped",[954]],[[120672,120672],"mapped",[955]],[[120673,120673],"mapped",[956]],[[120674,120674],"mapped",[957]],[[120675,120675],"mapped",[958]],[[120676,120676],"mapped",[959]],[[120677,120677],"mapped",[960]],[[120678,120678],"mapped",[961]],[[120679,120679],"mapped",[952]],[[120680,120680],"mapped",[963]],[[120681,120681],"mapped",[964]],[[120682,120682],"mapped",[965]],[[120683,120683],"mapped",[966]],[[120684,120684],"mapped",[967]],[[120685,120685],"mapped",[968]],[[120686,120686],"mapped",[969]],[[120687,120687],"mapped",[8711]],[[120688,120688],"mapped",[945]],[[120689,120689],"mapped",[946]],[[120690,120690],"mapped",[947]],[[120691,120691],"mapped",[948]],[[120692,120692],"mapped",[949]],[[120693,120693],"mapped",[950]],[[120694,120694],"mapped",[951]],[[120695,120695],"mapped",[952]],[[120696,120696],"mapped",[953]],[[120697,120697],"mapped",[954]],[[120698,120698],"mapped",[955]],[[120699,120699],"mapped",[956]],[[120700,120700],"mapped",[957]],[[120701,120701],"mapped",[958]],[[120702,120702],"mapped",[959]],[[120703,120703],"mapped",[960]],[[120704,120704],"mapped",[961]],[[120705,120706],"mapped",[963]],[[120707,120707],"mapped",[964]],[[120708,120708],"mapped",[965]],[[120709,120709],"mapped",[966]],[[120710,120710],"mapped",[967]],[[120711,120711],"mapped",[968]],[[120712,120712],"mapped",[969]],[[120713,120713],"mapped",[8706]],[[120714,120714],"mapped",[949]],[[120715,120715],"mapped",[952]],[[120716,120716],"mapped",[954]],[[120717,120717],"mapped",[966]],[[120718,120718],"mapped",[961]],[[120719,120719],"mapped",[960]],[[120720,120720],"mapped",[945]],[[120721,120721],"mapped",[946]],[[120722,120722],"mapped",[947]],[[120723,120723],"mapped",[948]],[[120724,120724],"mapped",[949]],[[120725,120725],"mapped",[950]],[[120726,120726],"mapped",[951]],[[120727,120727],"mapped",[952]],[[120728,120728],"mapped",[953]],[[120729,120729],"mapped",[954]],[[120730,120730],"mapped",[955]],[[120731,120731],"mapped",[956]],[[120732,120732],"mapped",[957]],[[120733,120733],"mapped",[958]],[[120734,120734],"mapped",[959]],[[120735,120735],"mapped",[960]],[[120736,120736],"mapped",[961]],[[120737,120737],"mapped",[952]],[[120738,120738],"mapped",[963]],[[120739,120739],"mapped",[964]],[[120740,120740],"mapped",[965]],[[120741,120741],"mapped",[966]],[[120742,120742],"mapped",[967]],[[120743,120743],"mapped",[968]],[[120744,120744],"mapped",[969]],[[120745,120745],"mapped",[8711]],[[120746,120746],"mapped",[945]],[[120747,120747],"mapped",[946]],[[120748,120748],"mapped",[947]],[[120749,120749],"mapped",[948]],[[120750,120750],"mapped",[949]],[[120751,120751],"mapped",[950]],[[120752,120752],"mapped",[951]],[[120753,120753],"mapped",[952]],[[120754,120754],"mapped",[953]],[[120755,120755],"mapped",[954]],[[120756,120756],"mapped",[955]],[[120757,120757],"mapped",[956]],[[120758,120758],"mapped",[957]],[[120759,120759],"mapped",[958]],[[120760,120760],"mapped",[959]],[[120761,120761],"mapped",[960]],[[120762,120762],"mapped",[961]],[[120763,120764],"mapped",[963]],[[120765,120765],"mapped",[964]],[[120766,120766],"mapped",[965]],[[120767,120767],"mapped",[966]],[[120768,120768],"mapped",[967]],[[120769,120769],"mapped",[968]],[[120770,120770],"mapped",[969]],[[120771,120771],"mapped",[8706]],[[120772,120772],"mapped",[949]],[[120773,120773],"mapped",[952]],[[120774,120774],"mapped",[954]],[[120775,120775],"mapped",[966]],[[120776,120776],"mapped",[961]],[[120777,120777],"mapped",[960]],[[120778,120779],"mapped",[989]],[[120780,120781],"disallowed"],[[120782,120782],"mapped",[48]],[[120783,120783],"mapped",[49]],[[120784,120784],"mapped",[50]],[[120785,120785],"mapped",[51]],[[120786,120786],"mapped",[52]],[[120787,120787],"mapped",[53]],[[120788,120788],"mapped",[54]],[[120789,120789],"mapped",[55]],[[120790,120790],"mapped",[56]],[[120791,120791],"mapped",[57]],[[120792,120792],"mapped",[48]],[[120793,120793],"mapped",[49]],[[120794,120794],"mapped",[50]],[[120795,120795],"mapped",[51]],[[120796,120796],"mapped",[52]],[[120797,120797],"mapped",[53]],[[120798,120798],"mapped",[54]],[[120799,120799],"mapped",[55]],[[120800,120800],"mapped",[56]],[[120801,120801],"mapped",[57]],[[120802,120802],"mapped",[48]],[[120803,120803],"mapped",[49]],[[120804,120804],"mapped",[50]],[[120805,120805],"mapped",[51]],[[120806,120806],"mapped",[52]],[[120807,120807],"mapped",[53]],[[120808,120808],"mapped",[54]],[[120809,120809],"mapped",[55]],[[120810,120810],"mapped",[56]],[[120811,120811],"mapped",[57]],[[120812,120812],"mapped",[48]],[[120813,120813],"mapped",[49]],[[120814,120814],"mapped",[50]],[[120815,120815],"mapped",[51]],[[120816,120816],"mapped",[52]],[[120817,120817],"mapped",[53]],[[120818,120818],"mapped",[54]],[[120819,120819],"mapped",[55]],[[120820,120820],"mapped",[56]],[[120821,120821],"mapped",[57]],[[120822,120822],"mapped",[48]],[[120823,120823],"mapped",[49]],[[120824,120824],"mapped",[50]],[[120825,120825],"mapped",[51]],[[120826,120826],"mapped",[52]],[[120827,120827],"mapped",[53]],[[120828,120828],"mapped",[54]],[[120829,120829],"mapped",[55]],[[120830,120830],"mapped",[56]],[[120831,120831],"mapped",[57]],[[120832,121343],"valid",[],"NV8"],[[121344,121398],"valid"],[[121399,121402],"valid",[],"NV8"],[[121403,121452],"valid"],[[121453,121460],"valid",[],"NV8"],[[121461,121461],"valid"],[[121462,121475],"valid",[],"NV8"],[[121476,121476],"valid"],[[121477,121483],"valid",[],"NV8"],[[121484,121498],"disallowed"],[[121499,121503],"valid"],[[121504,121504],"disallowed"],[[121505,121519],"valid"],[[121520,124927],"disallowed"],[[124928,125124],"valid"],[[125125,125126],"disallowed"],[[125127,125135],"valid",[],"NV8"],[[125136,125142],"valid"],[[125143,126463],"disallowed"],[[126464,126464],"mapped",[1575]],[[126465,126465],"mapped",[1576]],[[126466,126466],"mapped",[1580]],[[126467,126467],"mapped",[1583]],[[126468,126468],"disallowed"],[[126469,126469],"mapped",[1608]],[[126470,126470],"mapped",[1586]],[[126471,126471],"mapped",[1581]],[[126472,126472],"mapped",[1591]],[[126473,126473],"mapped",[1610]],[[126474,126474],"mapped",[1603]],[[126475,126475],"mapped",[1604]],[[126476,126476],"mapped",[1605]],[[126477,126477],"mapped",[1606]],[[126478,126478],"mapped",[1587]],[[126479,126479],"mapped",[1593]],[[126480,126480],"mapped",[1601]],[[126481,126481],"mapped",[1589]],[[126482,126482],"mapped",[1602]],[[126483,126483],"mapped",[1585]],[[126484,126484],"mapped",[1588]],[[126485,126485],"mapped",[1578]],[[126486,126486],"mapped",[1579]],[[126487,126487],"mapped",[1582]],[[126488,126488],"mapped",[1584]],[[126489,126489],"mapped",[1590]],[[126490,126490],"mapped",[1592]],[[126491,126491],"mapped",[1594]],[[126492,126492],"mapped",[1646]],[[126493,126493],"mapped",[1722]],[[126494,126494],"mapped",[1697]],[[126495,126495],"mapped",[1647]],[[126496,126496],"disallowed"],[[126497,126497],"mapped",[1576]],[[126498,126498],"mapped",[1580]],[[126499,126499],"disallowed"],[[126500,126500],"mapped",[1607]],[[126501,126502],"disallowed"],[[126503,126503],"mapped",[1581]],[[126504,126504],"disallowed"],[[126505,126505],"mapped",[1610]],[[126506,126506],"mapped",[1603]],[[126507,126507],"mapped",[1604]],[[126508,126508],"mapped",[1605]],[[126509,126509],"mapped",[1606]],[[126510,126510],"mapped",[1587]],[[126511,126511],"mapped",[1593]],[[126512,126512],"mapped",[1601]],[[126513,126513],"mapped",[1589]],[[126514,126514],"mapped",[1602]],[[126515,126515],"disallowed"],[[126516,126516],"mapped",[1588]],[[126517,126517],"mapped",[1578]],[[126518,126518],"mapped",[1579]],[[126519,126519],"mapped",[1582]],[[126520,126520],"disallowed"],[[126521,126521],"mapped",[1590]],[[126522,126522],"disallowed"],[[126523,126523],"mapped",[1594]],[[126524,126529],"disallowed"],[[126530,126530],"mapped",[1580]],[[126531,126534],"disallowed"],[[126535,126535],"mapped",[1581]],[[126536,126536],"disallowed"],[[126537,126537],"mapped",[1610]],[[126538,126538],"disallowed"],[[126539,126539],"mapped",[1604]],[[126540,126540],"disallowed"],[[126541,126541],"mapped",[1606]],[[126542,126542],"mapped",[1587]],[[126543,126543],"mapped",[1593]],[[126544,126544],"disallowed"],[[126545,126545],"mapped",[1589]],[[126546,126546],"mapped",[1602]],[[126547,126547],"disallowed"],[[126548,126548],"mapped",[1588]],[[126549,126550],"disallowed"],[[126551,126551],"mapped",[1582]],[[126552,126552],"disallowed"],[[126553,126553],"mapped",[1590]],[[126554,126554],"disallowed"],[[126555,126555],"mapped",[1594]],[[126556,126556],"disallowed"],[[126557,126557],"mapped",[1722]],[[126558,126558],"disallowed"],[[126559,126559],"mapped",[1647]],[[126560,126560],"disallowed"],[[126561,126561],"mapped",[1576]],[[126562,126562],"mapped",[1580]],[[126563,126563],"disallowed"],[[126564,126564],"mapped",[1607]],[[126565,126566],"disallowed"],[[126567,126567],"mapped",[1581]],[[126568,126568],"mapped",[1591]],[[126569,126569],"mapped",[1610]],[[126570,126570],"mapped",[1603]],[[126571,126571],"disallowed"],[[126572,126572],"mapped",[1605]],[[126573,126573],"mapped",[1606]],[[126574,126574],"mapped",[1587]],[[126575,126575],"mapped",[1593]],[[126576,126576],"mapped",[1601]],[[126577,126577],"mapped",[1589]],[[126578,126578],"mapped",[1602]],[[126579,126579],"disallowed"],[[126580,126580],"mapped",[1588]],[[126581,126581],"mapped",[1578]],[[126582,126582],"mapped",[1579]],[[126583,126583],"mapped",[1582]],[[126584,126584],"disallowed"],[[126585,126585],"mapped",[1590]],[[126586,126586],"mapped",[1592]],[[126587,126587],"mapped",[1594]],[[126588,126588],"mapped",[1646]],[[126589,126589],"disallowed"],[[126590,126590],"mapped",[1697]],[[126591,126591],"disallowed"],[[126592,126592],"mapped",[1575]],[[126593,126593],"mapped",[1576]],[[126594,126594],"mapped",[1580]],[[126595,126595],"mapped",[1583]],[[126596,126596],"mapped",[1607]],[[126597,126597],"mapped",[1608]],[[126598,126598],"mapped",[1586]],[[126599,126599],"mapped",[1581]],[[126600,126600],"mapped",[1591]],[[126601,126601],"mapped",[1610]],[[126602,126602],"disallowed"],[[126603,126603],"mapped",[1604]],[[126604,126604],"mapped",[1605]],[[126605,126605],"mapped",[1606]],[[126606,126606],"mapped",[1587]],[[126607,126607],"mapped",[1593]],[[126608,126608],"mapped",[1601]],[[126609,126609],"mapped",[1589]],[[126610,126610],"mapped",[1602]],[[126611,126611],"mapped",[1585]],[[126612,126612],"mapped",[1588]],[[126613,126613],"mapped",[1578]],[[126614,126614],"mapped",[1579]],[[126615,126615],"mapped",[1582]],[[126616,126616],"mapped",[1584]],[[126617,126617],"mapped",[1590]],[[126618,126618],"mapped",[1592]],[[126619,126619],"mapped",[1594]],[[126620,126624],"disallowed"],[[126625,126625],"mapped",[1576]],[[126626,126626],"mapped",[1580]],[[126627,126627],"mapped",[1583]],[[126628,126628],"disallowed"],[[126629,126629],"mapped",[1608]],[[126630,126630],"mapped",[1586]],[[126631,126631],"mapped",[1581]],[[126632,126632],"mapped",[1591]],[[126633,126633],"mapped",[1610]],[[126634,126634],"disallowed"],[[126635,126635],"mapped",[1604]],[[126636,126636],"mapped",[1605]],[[126637,126637],"mapped",[1606]],[[126638,126638],"mapped",[1587]],[[126639,126639],"mapped",[1593]],[[126640,126640],"mapped",[1601]],[[126641,126641],"mapped",[1589]],[[126642,126642],"mapped",[1602]],[[126643,126643],"mapped",[1585]],[[126644,126644],"mapped",[1588]],[[126645,126645],"mapped",[1578]],[[126646,126646],"mapped",[1579]],[[126647,126647],"mapped",[1582]],[[126648,126648],"mapped",[1584]],[[126649,126649],"mapped",[1590]],[[126650,126650],"mapped",[1592]],[[126651,126651],"mapped",[1594]],[[126652,126703],"disallowed"],[[126704,126705],"valid",[],"NV8"],[[126706,126975],"disallowed"],[[126976,127019],"valid",[],"NV8"],[[127020,127023],"disallowed"],[[127024,127123],"valid",[],"NV8"],[[127124,127135],"disallowed"],[[127136,127150],"valid",[],"NV8"],[[127151,127152],"disallowed"],[[127153,127166],"valid",[],"NV8"],[[127167,127167],"valid",[],"NV8"],[[127168,127168],"disallowed"],[[127169,127183],"valid",[],"NV8"],[[127184,127184],"disallowed"],[[127185,127199],"valid",[],"NV8"],[[127200,127221],"valid",[],"NV8"],[[127222,127231],"disallowed"],[[127232,127232],"disallowed"],[[127233,127233],"disallowed_STD3_mapped",[48,44]],[[127234,127234],"disallowed_STD3_mapped",[49,44]],[[127235,127235],"disallowed_STD3_mapped",[50,44]],[[127236,127236],"disallowed_STD3_mapped",[51,44]],[[127237,127237],"disallowed_STD3_mapped",[52,44]],[[127238,127238],"disallowed_STD3_mapped",[53,44]],[[127239,127239],"disallowed_STD3_mapped",[54,44]],[[127240,127240],"disallowed_STD3_mapped",[55,44]],[[127241,127241],"disallowed_STD3_mapped",[56,44]],[[127242,127242],"disallowed_STD3_mapped",[57,44]],[[127243,127244],"valid",[],"NV8"],[[127245,127247],"disallowed"],[[127248,127248],"disallowed_STD3_mapped",[40,97,41]],[[127249,127249],"disallowed_STD3_mapped",[40,98,41]],[[127250,127250],"disallowed_STD3_mapped",[40,99,41]],[[127251,127251],"disallowed_STD3_mapped",[40,100,41]],[[127252,127252],"disallowed_STD3_mapped",[40,101,41]],[[127253,127253],"disallowed_STD3_mapped",[40,102,41]],[[127254,127254],"disallowed_STD3_mapped",[40,103,41]],[[127255,127255],"disallowed_STD3_mapped",[40,104,41]],[[127256,127256],"disallowed_STD3_mapped",[40,105,41]],[[127257,127257],"disallowed_STD3_mapped",[40,106,41]],[[127258,127258],"disallowed_STD3_mapped",[40,107,41]],[[127259,127259],"disallowed_STD3_mapped",[40,108,41]],[[127260,127260],"disallowed_STD3_mapped",[40,109,41]],[[127261,127261],"disallowed_STD3_mapped",[40,110,41]],[[127262,127262],"disallowed_STD3_mapped",[40,111,41]],[[127263,127263],"disallowed_STD3_mapped",[40,112,41]],[[127264,127264],"disallowed_STD3_mapped",[40,113,41]],[[127265,127265],"disallowed_STD3_mapped",[40,114,41]],[[127266,127266],"disallowed_STD3_mapped",[40,115,41]],[[127267,127267],"disallowed_STD3_mapped",[40,116,41]],[[127268,127268],"disallowed_STD3_mapped",[40,117,41]],[[127269,127269],"disallowed_STD3_mapped",[40,118,41]],[[127270,127270],"disallowed_STD3_mapped",[40,119,41]],[[127271,127271],"disallowed_STD3_mapped",[40,120,41]],[[127272,127272],"disallowed_STD3_mapped",[40,121,41]],[[127273,127273],"disallowed_STD3_mapped",[40,122,41]],[[127274,127274],"mapped",[12308,115,12309]],[[127275,127275],"mapped",[99]],[[127276,127276],"mapped",[114]],[[127277,127277],"mapped",[99,100]],[[127278,127278],"mapped",[119,122]],[[127279,127279],"disallowed"],[[127280,127280],"mapped",[97]],[[127281,127281],"mapped",[98]],[[127282,127282],"mapped",[99]],[[127283,127283],"mapped",[100]],[[127284,127284],"mapped",[101]],[[127285,127285],"mapped",[102]],[[127286,127286],"mapped",[103]],[[127287,127287],"mapped",[104]],[[127288,127288],"mapped",[105]],[[127289,127289],"mapped",[106]],[[127290,127290],"mapped",[107]],[[127291,127291],"mapped",[108]],[[127292,127292],"mapped",[109]],[[127293,127293],"mapped",[110]],[[127294,127294],"mapped",[111]],[[127295,127295],"mapped",[112]],[[127296,127296],"mapped",[113]],[[127297,127297],"mapped",[114]],[[127298,127298],"mapped",[115]],[[127299,127299],"mapped",[116]],[[127300,127300],"mapped",[117]],[[127301,127301],"mapped",[118]],[[127302,127302],"mapped",[119]],[[127303,127303],"mapped",[120]],[[127304,127304],"mapped",[121]],[[127305,127305],"mapped",[122]],[[127306,127306],"mapped",[104,118]],[[127307,127307],"mapped",[109,118]],[[127308,127308],"mapped",[115,100]],[[127309,127309],"mapped",[115,115]],[[127310,127310],"mapped",[112,112,118]],[[127311,127311],"mapped",[119,99]],[[127312,127318],"valid",[],"NV8"],[[127319,127319],"valid",[],"NV8"],[[127320,127326],"valid",[],"NV8"],[[127327,127327],"valid",[],"NV8"],[[127328,127337],"valid",[],"NV8"],[[127338,127338],"mapped",[109,99]],[[127339,127339],"mapped",[109,100]],[[127340,127343],"disallowed"],[[127344,127352],"valid",[],"NV8"],[[127353,127353],"valid",[],"NV8"],[[127354,127354],"valid",[],"NV8"],[[127355,127356],"valid",[],"NV8"],[[127357,127358],"valid",[],"NV8"],[[127359,127359],"valid",[],"NV8"],[[127360,127369],"valid",[],"NV8"],[[127370,127373],"valid",[],"NV8"],[[127374,127375],"valid",[],"NV8"],[[127376,127376],"mapped",[100,106]],[[127377,127386],"valid",[],"NV8"],[[127387,127461],"disallowed"],[[127462,127487],"valid",[],"NV8"],[[127488,127488],"mapped",[12411,12363]],[[127489,127489],"mapped",[12467,12467]],[[127490,127490],"mapped",[12469]],[[127491,127503],"disallowed"],[[127504,127504],"mapped",[25163]],[[127505,127505],"mapped",[23383]],[[127506,127506],"mapped",[21452]],[[127507,127507],"mapped",[12487]],[[127508,127508],"mapped",[20108]],[[127509,127509],"mapped",[22810]],[[127510,127510],"mapped",[35299]],[[127511,127511],"mapped",[22825]],[[127512,127512],"mapped",[20132]],[[127513,127513],"mapped",[26144]],[[127514,127514],"mapped",[28961]],[[127515,127515],"mapped",[26009]],[[127516,127516],"mapped",[21069]],[[127517,127517],"mapped",[24460]],[[127518,127518],"mapped",[20877]],[[127519,127519],"mapped",[26032]],[[127520,127520],"mapped",[21021]],[[127521,127521],"mapped",[32066]],[[127522,127522],"mapped",[29983]],[[127523,127523],"mapped",[36009]],[[127524,127524],"mapped",[22768]],[[127525,127525],"mapped",[21561]],[[127526,127526],"mapped",[28436]],[[127527,127527],"mapped",[25237]],[[127528,127528],"mapped",[25429]],[[127529,127529],"mapped",[19968]],[[127530,127530],"mapped",[19977]],[[127531,127531],"mapped",[36938]],[[127532,127532],"mapped",[24038]],[[127533,127533],"mapped",[20013]],[[127534,127534],"mapped",[21491]],[[127535,127535],"mapped",[25351]],[[127536,127536],"mapped",[36208]],[[127537,127537],"mapped",[25171]],[[127538,127538],"mapped",[31105]],[[127539,127539],"mapped",[31354]],[[127540,127540],"mapped",[21512]],[[127541,127541],"mapped",[28288]],[[127542,127542],"mapped",[26377]],[[127543,127543],"mapped",[26376]],[[127544,127544],"mapped",[30003]],[[127545,127545],"mapped",[21106]],[[127546,127546],"mapped",[21942]],[[127547,127551],"disallowed"],[[127552,127552],"mapped",[12308,26412,12309]],[[127553,127553],"mapped",[12308,19977,12309]],[[127554,127554],"mapped",[12308,20108,12309]],[[127555,127555],"mapped",[12308,23433,12309]],[[127556,127556],"mapped",[12308,28857,12309]],[[127557,127557],"mapped",[12308,25171,12309]],[[127558,127558],"mapped",[12308,30423,12309]],[[127559,127559],"mapped",[12308,21213,12309]],[[127560,127560],"mapped",[12308,25943,12309]],[[127561,127567],"disallowed"],[[127568,127568],"mapped",[24471]],[[127569,127569],"mapped",[21487]],[[127570,127743],"disallowed"],[[127744,127776],"valid",[],"NV8"],[[127777,127788],"valid",[],"NV8"],[[127789,127791],"valid",[],"NV8"],[[127792,127797],"valid",[],"NV8"],[[127798,127798],"valid",[],"NV8"],[[127799,127868],"valid",[],"NV8"],[[127869,127869],"valid",[],"NV8"],[[127870,127871],"valid",[],"NV8"],[[127872,127891],"valid",[],"NV8"],[[127892,127903],"valid",[],"NV8"],[[127904,127940],"valid",[],"NV8"],[[127941,127941],"valid",[],"NV8"],[[127942,127946],"valid",[],"NV8"],[[127947,127950],"valid",[],"NV8"],[[127951,127955],"valid",[],"NV8"],[[127956,127967],"valid",[],"NV8"],[[127968,127984],"valid",[],"NV8"],[[127985,127991],"valid",[],"NV8"],[[127992,127999],"valid",[],"NV8"],[[128000,128062],"valid",[],"NV8"],[[128063,128063],"valid",[],"NV8"],[[128064,128064],"valid",[],"NV8"],[[128065,128065],"valid",[],"NV8"],[[128066,128247],"valid",[],"NV8"],[[128248,128248],"valid",[],"NV8"],[[128249,128252],"valid",[],"NV8"],[[128253,128254],"valid",[],"NV8"],[[128255,128255],"valid",[],"NV8"],[[128256,128317],"valid",[],"NV8"],[[128318,128319],"valid",[],"NV8"],[[128320,128323],"valid",[],"NV8"],[[128324,128330],"valid",[],"NV8"],[[128331,128335],"valid",[],"NV8"],[[128336,128359],"valid",[],"NV8"],[[128360,128377],"valid",[],"NV8"],[[128378,128378],"disallowed"],[[128379,128419],"valid",[],"NV8"],[[128420,128420],"disallowed"],[[128421,128506],"valid",[],"NV8"],[[128507,128511],"valid",[],"NV8"],[[128512,128512],"valid",[],"NV8"],[[128513,128528],"valid",[],"NV8"],[[128529,128529],"valid",[],"NV8"],[[128530,128532],"valid",[],"NV8"],[[128533,128533],"valid",[],"NV8"],[[128534,128534],"valid",[],"NV8"],[[128535,128535],"valid",[],"NV8"],[[128536,128536],"valid",[],"NV8"],[[128537,128537],"valid",[],"NV8"],[[128538,128538],"valid",[],"NV8"],[[128539,128539],"valid",[],"NV8"],[[128540,128542],"valid",[],"NV8"],[[128543,128543],"valid",[],"NV8"],[[128544,128549],"valid",[],"NV8"],[[128550,128551],"valid",[],"NV8"],[[128552,128555],"valid",[],"NV8"],[[128556,128556],"valid",[],"NV8"],[[128557,128557],"valid",[],"NV8"],[[128558,128559],"valid",[],"NV8"],[[128560,128563],"valid",[],"NV8"],[[128564,128564],"valid",[],"NV8"],[[128565,128576],"valid",[],"NV8"],[[128577,128578],"valid",[],"NV8"],[[128579,128580],"valid",[],"NV8"],[[128581,128591],"valid",[],"NV8"],[[128592,128639],"valid",[],"NV8"],[[128640,128709],"valid",[],"NV8"],[[128710,128719],"valid",[],"NV8"],[[128720,128720],"valid",[],"NV8"],[[128721,128735],"disallowed"],[[128736,128748],"valid",[],"NV8"],[[128749,128751],"disallowed"],[[128752,128755],"valid",[],"NV8"],[[128756,128767],"disallowed"],[[128768,128883],"valid",[],"NV8"],[[128884,128895],"disallowed"],[[128896,128980],"valid",[],"NV8"],[[128981,129023],"disallowed"],[[129024,129035],"valid",[],"NV8"],[[129036,129039],"disallowed"],[[129040,129095],"valid",[],"NV8"],[[129096,129103],"disallowed"],[[129104,129113],"valid",[],"NV8"],[[129114,129119],"disallowed"],[[129120,129159],"valid",[],"NV8"],[[129160,129167],"disallowed"],[[129168,129197],"valid",[],"NV8"],[[129198,129295],"disallowed"],[[129296,129304],"valid",[],"NV8"],[[129305,129407],"disallowed"],[[129408,129412],"valid",[],"NV8"],[[129413,129471],"disallowed"],[[129472,129472],"valid",[],"NV8"],[[129473,131069],"disallowed"],[[131070,131071],"disallowed"],[[131072,173782],"valid"],[[173783,173823],"disallowed"],[[173824,177972],"valid"],[[177973,177983],"disallowed"],[[177984,178205],"valid"],[[178206,178207],"disallowed"],[[178208,183969],"valid"],[[183970,194559],"disallowed"],[[194560,194560],"mapped",[20029]],[[194561,194561],"mapped",[20024]],[[194562,194562],"mapped",[20033]],[[194563,194563],"mapped",[131362]],[[194564,194564],"mapped",[20320]],[[194565,194565],"mapped",[20398]],[[194566,194566],"mapped",[20411]],[[194567,194567],"mapped",[20482]],[[194568,194568],"mapped",[20602]],[[194569,194569],"mapped",[20633]],[[194570,194570],"mapped",[20711]],[[194571,194571],"mapped",[20687]],[[194572,194572],"mapped",[13470]],[[194573,194573],"mapped",[132666]],[[194574,194574],"mapped",[20813]],[[194575,194575],"mapped",[20820]],[[194576,194576],"mapped",[20836]],[[194577,194577],"mapped",[20855]],[[194578,194578],"mapped",[132380]],[[194579,194579],"mapped",[13497]],[[194580,194580],"mapped",[20839]],[[194581,194581],"mapped",[20877]],[[194582,194582],"mapped",[132427]],[[194583,194583],"mapped",[20887]],[[194584,194584],"mapped",[20900]],[[194585,194585],"mapped",[20172]],[[194586,194586],"mapped",[20908]],[[194587,194587],"mapped",[20917]],[[194588,194588],"mapped",[168415]],[[194589,194589],"mapped",[20981]],[[194590,194590],"mapped",[20995]],[[194591,194591],"mapped",[13535]],[[194592,194592],"mapped",[21051]],[[194593,194593],"mapped",[21062]],[[194594,194594],"mapped",[21106]],[[194595,194595],"mapped",[21111]],[[194596,194596],"mapped",[13589]],[[194597,194597],"mapped",[21191]],[[194598,194598],"mapped",[21193]],[[194599,194599],"mapped",[21220]],[[194600,194600],"mapped",[21242]],[[194601,194601],"mapped",[21253]],[[194602,194602],"mapped",[21254]],[[194603,194603],"mapped",[21271]],[[194604,194604],"mapped",[21321]],[[194605,194605],"mapped",[21329]],[[194606,194606],"mapped",[21338]],[[194607,194607],"mapped",[21363]],[[194608,194608],"mapped",[21373]],[[194609,194611],"mapped",[21375]],[[194612,194612],"mapped",[133676]],[[194613,194613],"mapped",[28784]],[[194614,194614],"mapped",[21450]],[[194615,194615],"mapped",[21471]],[[194616,194616],"mapped",[133987]],[[194617,194617],"mapped",[21483]],[[194618,194618],"mapped",[21489]],[[194619,194619],"mapped",[21510]],[[194620,194620],"mapped",[21662]],[[194621,194621],"mapped",[21560]],[[194622,194622],"mapped",[21576]],[[194623,194623],"mapped",[21608]],[[194624,194624],"mapped",[21666]],[[194625,194625],"mapped",[21750]],[[194626,194626],"mapped",[21776]],[[194627,194627],"mapped",[21843]],[[194628,194628],"mapped",[21859]],[[194629,194630],"mapped",[21892]],[[194631,194631],"mapped",[21913]],[[194632,194632],"mapped",[21931]],[[194633,194633],"mapped",[21939]],[[194634,194634],"mapped",[21954]],[[194635,194635],"mapped",[22294]],[[194636,194636],"mapped",[22022]],[[194637,194637],"mapped",[22295]],[[194638,194638],"mapped",[22097]],[[194639,194639],"mapped",[22132]],[[194640,194640],"mapped",[20999]],[[194641,194641],"mapped",[22766]],[[194642,194642],"mapped",[22478]],[[194643,194643],"mapped",[22516]],[[194644,194644],"mapped",[22541]],[[194645,194645],"mapped",[22411]],[[194646,194646],"mapped",[22578]],[[194647,194647],"mapped",[22577]],[[194648,194648],"mapped",[22700]],[[194649,194649],"mapped",[136420]],[[194650,194650],"mapped",[22770]],[[194651,194651],"mapped",[22775]],[[194652,194652],"mapped",[22790]],[[194653,194653],"mapped",[22810]],[[194654,194654],"mapped",[22818]],[[194655,194655],"mapped",[22882]],[[194656,194656],"mapped",[136872]],[[194657,194657],"mapped",[136938]],[[194658,194658],"mapped",[23020]],[[194659,194659],"mapped",[23067]],[[194660,194660],"mapped",[23079]],[[194661,194661],"mapped",[23000]],[[194662,194662],"mapped",[23142]],[[194663,194663],"mapped",[14062]],[[194664,194664],"disallowed"],[[194665,194665],"mapped",[23304]],[[194666,194667],"mapped",[23358]],[[194668,194668],"mapped",[137672]],[[194669,194669],"mapped",[23491]],[[194670,194670],"mapped",[23512]],[[194671,194671],"mapped",[23527]],[[194672,194672],"mapped",[23539]],[[194673,194673],"mapped",[138008]],[[194674,194674],"mapped",[23551]],[[194675,194675],"mapped",[23558]],[[194676,194676],"disallowed"],[[194677,194677],"mapped",[23586]],[[194678,194678],"mapped",[14209]],[[194679,194679],"mapped",[23648]],[[194680,194680],"mapped",[23662]],[[194681,194681],"mapped",[23744]],[[194682,194682],"mapped",[23693]],[[194683,194683],"mapped",[138724]],[[194684,194684],"mapped",[23875]],[[194685,194685],"mapped",[138726]],[[194686,194686],"mapped",[23918]],[[194687,194687],"mapped",[23915]],[[194688,194688],"mapped",[23932]],[[194689,194689],"mapped",[24033]],[[194690,194690],"mapped",[24034]],[[194691,194691],"mapped",[14383]],[[194692,194692],"mapped",[24061]],[[194693,194693],"mapped",[24104]],[[194694,194694],"mapped",[24125]],[[194695,194695],"mapped",[24169]],[[194696,194696],"mapped",[14434]],[[194697,194697],"mapped",[139651]],[[194698,194698],"mapped",[14460]],[[194699,194699],"mapped",[24240]],[[194700,194700],"mapped",[24243]],[[194701,194701],"mapped",[24246]],[[194702,194702],"mapped",[24266]],[[194703,194703],"mapped",[172946]],[[194704,194704],"mapped",[24318]],[[194705,194706],"mapped",[140081]],[[194707,194707],"mapped",[33281]],[[194708,194709],"mapped",[24354]],[[194710,194710],"mapped",[14535]],[[194711,194711],"mapped",[144056]],[[194712,194712],"mapped",[156122]],[[194713,194713],"mapped",[24418]],[[194714,194714],"mapped",[24427]],[[194715,194715],"mapped",[14563]],[[194716,194716],"mapped",[24474]],[[194717,194717],"mapped",[24525]],[[194718,194718],"mapped",[24535]],[[194719,194719],"mapped",[24569]],[[194720,194720],"mapped",[24705]],[[194721,194721],"mapped",[14650]],[[194722,194722],"mapped",[14620]],[[194723,194723],"mapped",[24724]],[[194724,194724],"mapped",[141012]],[[194725,194725],"mapped",[24775]],[[194726,194726],"mapped",[24904]],[[194727,194727],"mapped",[24908]],[[194728,194728],"mapped",[24910]],[[194729,194729],"mapped",[24908]],[[194730,194730],"mapped",[24954]],[[194731,194731],"mapped",[24974]],[[194732,194732],"mapped",[25010]],[[194733,194733],"mapped",[24996]],[[194734,194734],"mapped",[25007]],[[194735,194735],"mapped",[25054]],[[194736,194736],"mapped",[25074]],[[194737,194737],"mapped",[25078]],[[194738,194738],"mapped",[25104]],[[194739,194739],"mapped",[25115]],[[194740,194740],"mapped",[25181]],[[194741,194741],"mapped",[25265]],[[194742,194742],"mapped",[25300]],[[194743,194743],"mapped",[25424]],[[194744,194744],"mapped",[142092]],[[194745,194745],"mapped",[25405]],[[194746,194746],"mapped",[25340]],[[194747,194747],"mapped",[25448]],[[194748,194748],"mapped",[25475]],[[194749,194749],"mapped",[25572]],[[194750,194750],"mapped",[142321]],[[194751,194751],"mapped",[25634]],[[194752,194752],"mapped",[25541]],[[194753,194753],"mapped",[25513]],[[194754,194754],"mapped",[14894]],[[194755,194755],"mapped",[25705]],[[194756,194756],"mapped",[25726]],[[194757,194757],"mapped",[25757]],[[194758,194758],"mapped",[25719]],[[194759,194759],"mapped",[14956]],[[194760,194760],"mapped",[25935]],[[194761,194761],"mapped",[25964]],[[194762,194762],"mapped",[143370]],[[194763,194763],"mapped",[26083]],[[194764,194764],"mapped",[26360]],[[194765,194765],"mapped",[26185]],[[194766,194766],"mapped",[15129]],[[194767,194767],"mapped",[26257]],[[194768,194768],"mapped",[15112]],[[194769,194769],"mapped",[15076]],[[194770,194770],"mapped",[20882]],[[194771,194771],"mapped",[20885]],[[194772,194772],"mapped",[26368]],[[194773,194773],"mapped",[26268]],[[194774,194774],"mapped",[32941]],[[194775,194775],"mapped",[17369]],[[194776,194776],"mapped",[26391]],[[194777,194777],"mapped",[26395]],[[194778,194778],"mapped",[26401]],[[194779,194779],"mapped",[26462]],[[194780,194780],"mapped",[26451]],[[194781,194781],"mapped",[144323]],[[194782,194782],"mapped",[15177]],[[194783,194783],"mapped",[26618]],[[194784,194784],"mapped",[26501]],[[194785,194785],"mapped",[26706]],[[194786,194786],"mapped",[26757]],[[194787,194787],"mapped",[144493]],[[194788,194788],"mapped",[26766]],[[194789,194789],"mapped",[26655]],[[194790,194790],"mapped",[26900]],[[194791,194791],"mapped",[15261]],[[194792,194792],"mapped",[26946]],[[194793,194793],"mapped",[27043]],[[194794,194794],"mapped",[27114]],[[194795,194795],"mapped",[27304]],[[194796,194796],"mapped",[145059]],[[194797,194797],"mapped",[27355]],[[194798,194798],"mapped",[15384]],[[194799,194799],"mapped",[27425]],[[194800,194800],"mapped",[145575]],[[194801,194801],"mapped",[27476]],[[194802,194802],"mapped",[15438]],[[194803,194803],"mapped",[27506]],[[194804,194804],"mapped",[27551]],[[194805,194805],"mapped",[27578]],[[194806,194806],"mapped",[27579]],[[194807,194807],"mapped",[146061]],[[194808,194808],"mapped",[138507]],[[194809,194809],"mapped",[146170]],[[194810,194810],"mapped",[27726]],[[194811,194811],"mapped",[146620]],[[194812,194812],"mapped",[27839]],[[194813,194813],"mapped",[27853]],[[194814,194814],"mapped",[27751]],[[194815,194815],"mapped",[27926]],[[194816,194816],"mapped",[27966]],[[194817,194817],"mapped",[28023]],[[194818,194818],"mapped",[27969]],[[194819,194819],"mapped",[28009]],[[194820,194820],"mapped",[28024]],[[194821,194821],"mapped",[28037]],[[194822,194822],"mapped",[146718]],[[194823,194823],"mapped",[27956]],[[194824,194824],"mapped",[28207]],[[194825,194825],"mapped",[28270]],[[194826,194826],"mapped",[15667]],[[194827,194827],"mapped",[28363]],[[194828,194828],"mapped",[28359]],[[194829,194829],"mapped",[147153]],[[194830,194830],"mapped",[28153]],[[194831,194831],"mapped",[28526]],[[194832,194832],"mapped",[147294]],[[194833,194833],"mapped",[147342]],[[194834,194834],"mapped",[28614]],[[194835,194835],"mapped",[28729]],[[194836,194836],"mapped",[28702]],[[194837,194837],"mapped",[28699]],[[194838,194838],"mapped",[15766]],[[194839,194839],"mapped",[28746]],[[194840,194840],"mapped",[28797]],[[194841,194841],"mapped",[28791]],[[194842,194842],"mapped",[28845]],[[194843,194843],"mapped",[132389]],[[194844,194844],"mapped",[28997]],[[194845,194845],"mapped",[148067]],[[194846,194846],"mapped",[29084]],[[194847,194847],"disallowed"],[[194848,194848],"mapped",[29224]],[[194849,194849],"mapped",[29237]],[[194850,194850],"mapped",[29264]],[[194851,194851],"mapped",[149000]],[[194852,194852],"mapped",[29312]],[[194853,194853],"mapped",[29333]],[[194854,194854],"mapped",[149301]],[[194855,194855],"mapped",[149524]],[[194856,194856],"mapped",[29562]],[[194857,194857],"mapped",[29579]],[[194858,194858],"mapped",[16044]],[[194859,194859],"mapped",[29605]],[[194860,194861],"mapped",[16056]],[[194862,194862],"mapped",[29767]],[[194863,194863],"mapped",[29788]],[[194864,194864],"mapped",[29809]],[[194865,194865],"mapped",[29829]],[[194866,194866],"mapped",[29898]],[[194867,194867],"mapped",[16155]],[[194868,194868],"mapped",[29988]],[[194869,194869],"mapped",[150582]],[[194870,194870],"mapped",[30014]],[[194871,194871],"mapped",[150674]],[[194872,194872],"mapped",[30064]],[[194873,194873],"mapped",[139679]],[[194874,194874],"mapped",[30224]],[[194875,194875],"mapped",[151457]],[[194876,194876],"mapped",[151480]],[[194877,194877],"mapped",[151620]],[[194878,194878],"mapped",[16380]],[[194879,194879],"mapped",[16392]],[[194880,194880],"mapped",[30452]],[[194881,194881],"mapped",[151795]],[[194882,194882],"mapped",[151794]],[[194883,194883],"mapped",[151833]],[[194884,194884],"mapped",[151859]],[[194885,194885],"mapped",[30494]],[[194886,194887],"mapped",[30495]],[[194888,194888],"mapped",[30538]],[[194889,194889],"mapped",[16441]],[[194890,194890],"mapped",[30603]],[[194891,194891],"mapped",[16454]],[[194892,194892],"mapped",[16534]],[[194893,194893],"mapped",[152605]],[[194894,194894],"mapped",[30798]],[[194895,194895],"mapped",[30860]],[[194896,194896],"mapped",[30924]],[[194897,194897],"mapped",[16611]],[[194898,194898],"mapped",[153126]],[[194899,194899],"mapped",[31062]],[[194900,194900],"mapped",[153242]],[[194901,194901],"mapped",[153285]],[[194902,194902],"mapped",[31119]],[[194903,194903],"mapped",[31211]],[[194904,194904],"mapped",[16687]],[[194905,194905],"mapped",[31296]],[[194906,194906],"mapped",[31306]],[[194907,194907],"mapped",[31311]],[[194908,194908],"mapped",[153980]],[[194909,194910],"mapped",[154279]],[[194911,194911],"disallowed"],[[194912,194912],"mapped",[16898]],[[194913,194913],"mapped",[154539]],[[194914,194914],"mapped",[31686]],[[194915,194915],"mapped",[31689]],[[194916,194916],"mapped",[16935]],[[194917,194917],"mapped",[154752]],[[194918,194918],"mapped",[31954]],[[194919,194919],"mapped",[17056]],[[194920,194920],"mapped",[31976]],[[194921,194921],"mapped",[31971]],[[194922,194922],"mapped",[32000]],[[194923,194923],"mapped",[155526]],[[194924,194924],"mapped",[32099]],[[194925,194925],"mapped",[17153]],[[194926,194926],"mapped",[32199]],[[194927,194927],"mapped",[32258]],[[194928,194928],"mapped",[32325]],[[194929,194929],"mapped",[17204]],[[194930,194930],"mapped",[156200]],[[194931,194931],"mapped",[156231]],[[194932,194932],"mapped",[17241]],[[194933,194933],"mapped",[156377]],[[194934,194934],"mapped",[32634]],[[194935,194935],"mapped",[156478]],[[194936,194936],"mapped",[32661]],[[194937,194937],"mapped",[32762]],[[194938,194938],"mapped",[32773]],[[194939,194939],"mapped",[156890]],[[194940,194940],"mapped",[156963]],[[194941,194941],"mapped",[32864]],[[194942,194942],"mapped",[157096]],[[194943,194943],"mapped",[32880]],[[194944,194944],"mapped",[144223]],[[194945,194945],"mapped",[17365]],[[194946,194946],"mapped",[32946]],[[194947,194947],"mapped",[33027]],[[194948,194948],"mapped",[17419]],[[194949,194949],"mapped",[33086]],[[194950,194950],"mapped",[23221]],[[194951,194951],"mapped",[157607]],[[194952,194952],"mapped",[157621]],[[194953,194953],"mapped",[144275]],[[194954,194954],"mapped",[144284]],[[194955,194955],"mapped",[33281]],[[194956,194956],"mapped",[33284]],[[194957,194957],"mapped",[36766]],[[194958,194958],"mapped",[17515]],[[194959,194959],"mapped",[33425]],[[194960,194960],"mapped",[33419]],[[194961,194961],"mapped",[33437]],[[194962,194962],"mapped",[21171]],[[194963,194963],"mapped",[33457]],[[194964,194964],"mapped",[33459]],[[194965,194965],"mapped",[33469]],[[194966,194966],"mapped",[33510]],[[194967,194967],"mapped",[158524]],[[194968,194968],"mapped",[33509]],[[194969,194969],"mapped",[33565]],[[194970,194970],"mapped",[33635]],[[194971,194971],"mapped",[33709]],[[194972,194972],"mapped",[33571]],[[194973,194973],"mapped",[33725]],[[194974,194974],"mapped",[33767]],[[194975,194975],"mapped",[33879]],[[194976,194976],"mapped",[33619]],[[194977,194977],"mapped",[33738]],[[194978,194978],"mapped",[33740]],[[194979,194979],"mapped",[33756]],[[194980,194980],"mapped",[158774]],[[194981,194981],"mapped",[159083]],[[194982,194982],"mapped",[158933]],[[194983,194983],"mapped",[17707]],[[194984,194984],"mapped",[34033]],[[194985,194985],"mapped",[34035]],[[194986,194986],"mapped",[34070]],[[194987,194987],"mapped",[160714]],[[194988,194988],"mapped",[34148]],[[194989,194989],"mapped",[159532]],[[194990,194990],"mapped",[17757]],[[194991,194991],"mapped",[17761]],[[194992,194992],"mapped",[159665]],[[194993,194993],"mapped",[159954]],[[194994,194994],"mapped",[17771]],[[194995,194995],"mapped",[34384]],[[194996,194996],"mapped",[34396]],[[194997,194997],"mapped",[34407]],[[194998,194998],"mapped",[34409]],[[194999,194999],"mapped",[34473]],[[195000,195000],"mapped",[34440]],[[195001,195001],"mapped",[34574]],[[195002,195002],"mapped",[34530]],[[195003,195003],"mapped",[34681]],[[195004,195004],"mapped",[34600]],[[195005,195005],"mapped",[34667]],[[195006,195006],"mapped",[34694]],[[195007,195007],"disallowed"],[[195008,195008],"mapped",[34785]],[[195009,195009],"mapped",[34817]],[[195010,195010],"mapped",[17913]],[[195011,195011],"mapped",[34912]],[[195012,195012],"mapped",[34915]],[[195013,195013],"mapped",[161383]],[[195014,195014],"mapped",[35031]],[[195015,195015],"mapped",[35038]],[[195016,195016],"mapped",[17973]],[[195017,195017],"mapped",[35066]],[[195018,195018],"mapped",[13499]],[[195019,195019],"mapped",[161966]],[[195020,195020],"mapped",[162150]],[[195021,195021],"mapped",[18110]],[[195022,195022],"mapped",[18119]],[[195023,195023],"mapped",[35488]],[[195024,195024],"mapped",[35565]],[[195025,195025],"mapped",[35722]],[[195026,195026],"mapped",[35925]],[[195027,195027],"mapped",[162984]],[[195028,195028],"mapped",[36011]],[[195029,195029],"mapped",[36033]],[[195030,195030],"mapped",[36123]],[[195031,195031],"mapped",[36215]],[[195032,195032],"mapped",[163631]],[[195033,195033],"mapped",[133124]],[[195034,195034],"mapped",[36299]],[[195035,195035],"mapped",[36284]],[[195036,195036],"mapped",[36336]],[[195037,195037],"mapped",[133342]],[[195038,195038],"mapped",[36564]],[[195039,195039],"mapped",[36664]],[[195040,195040],"mapped",[165330]],[[195041,195041],"mapped",[165357]],[[195042,195042],"mapped",[37012]],[[195043,195043],"mapped",[37105]],[[195044,195044],"mapped",[37137]],[[195045,195045],"mapped",[165678]],[[195046,195046],"mapped",[37147]],[[195047,195047],"mapped",[37432]],[[195048,195048],"mapped",[37591]],[[195049,195049],"mapped",[37592]],[[195050,195050],"mapped",[37500]],[[195051,195051],"mapped",[37881]],[[195052,195052],"mapped",[37909]],[[195053,195053],"mapped",[166906]],[[195054,195054],"mapped",[38283]],[[195055,195055],"mapped",[18837]],[[195056,195056],"mapped",[38327]],[[195057,195057],"mapped",[167287]],[[195058,195058],"mapped",[18918]],[[195059,195059],"mapped",[38595]],[[195060,195060],"mapped",[23986]],[[195061,195061],"mapped",[38691]],[[195062,195062],"mapped",[168261]],[[195063,195063],"mapped",[168474]],[[195064,195064],"mapped",[19054]],[[195065,195065],"mapped",[19062]],[[195066,195066],"mapped",[38880]],[[195067,195067],"mapped",[168970]],[[195068,195068],"mapped",[19122]],[[195069,195069],"mapped",[169110]],[[195070,195071],"mapped",[38923]],[[195072,195072],"mapped",[38953]],[[195073,195073],"mapped",[169398]],[[195074,195074],"mapped",[39138]],[[195075,195075],"mapped",[19251]],[[195076,195076],"mapped",[39209]],[[195077,195077],"mapped",[39335]],[[195078,195078],"mapped",[39362]],[[195079,195079],"mapped",[39422]],[[195080,195080],"mapped",[19406]],[[195081,195081],"mapped",[170800]],[[195082,195082],"mapped",[39698]],[[195083,195083],"mapped",[40000]],[[195084,195084],"mapped",[40189]],[[195085,195085],"mapped",[19662]],[[195086,195086],"mapped",[19693]],[[195087,195087],"mapped",[40295]],[[195088,195088],"mapped",[172238]],[[195089,195089],"mapped",[19704]],[[195090,195090],"mapped",[172293]],[[195091,195091],"mapped",[172558]],[[195092,195092],"mapped",[172689]],[[195093,195093],"mapped",[40635]],[[195094,195094],"mapped",[19798]],[[195095,195095],"mapped",[40697]],[[195096,195096],"mapped",[40702]],[[195097,195097],"mapped",[40709]],[[195098,195098],"mapped",[40719]],[[195099,195099],"mapped",[40726]],[[195100,195100],"mapped",[40763]],[[195101,195101],"mapped",[173568]],[[195102,196605],"disallowed"],[[196606,196607],"disallowed"],[[196608,262141],"disallowed"],[[262142,262143],"disallowed"],[[262144,327677],"disallowed"],[[327678,327679],"disallowed"],[[327680,393213],"disallowed"],[[393214,393215],"disallowed"],[[393216,458749],"disallowed"],[[458750,458751],"disallowed"],[[458752,524285],"disallowed"],[[524286,524287],"disallowed"],[[524288,589821],"disallowed"],[[589822,589823],"disallowed"],[[589824,655357],"disallowed"],[[655358,655359],"disallowed"],[[655360,720893],"disallowed"],[[720894,720895],"disallowed"],[[720896,786429],"disallowed"],[[786430,786431],"disallowed"],[[786432,851965],"disallowed"],[[851966,851967],"disallowed"],[[851968,917501],"disallowed"],[[917502,917503],"disallowed"],[[917504,917504],"disallowed"],[[917505,917505],"disallowed"],[[917506,917535],"disallowed"],[[917536,917631],"disallowed"],[[917632,917759],"disallowed"],[[917760,917999],"ignored"],[[918000,983037],"disallowed"],[[983038,983039],"disallowed"],[[983040,1048573],"disallowed"],[[1048574,1048575],"disallowed"],[[1048576,1114109],"disallowed"],[[1114110,1114111],"disallowed"]]');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__nccwpck_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __nccwpck_require__(4822);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=index.js.map